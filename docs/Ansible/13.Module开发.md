# 13.Module 开发

官方开发文档

- http://docs.ansible.com/ansible/dev_guide/index.html

非常推荐大家看看 官方文档

> 环境

本次所用的环境

- ansible 2.9.6.0

- os Centos 7.7 X64

- 虚拟环境：python 2.7.5 and 3.6.8

## 1.Module 开发说明

### 1.1 模块介绍

模块(也称为 task 插件或 library 插件)是可以从命令行或 playbook 任务中使用的独立单元。Ansible 通常在远程目标节点上执行每个模块，并收集返回值。

可以使用下列命令执行模块

```sh
ansible webservers -m service -a "name=httpd state=started"
ansible webservers -m ping
ansible webservers -m command -a "/sbin/reboot -t now"
```

每个模块都支持采用参数。 几乎所有模块都采用 key = value 参数，以空格分隔。 一些模块不带任何参数，而 command/shell 模块仅采用要运行命令的字符串。

在 playbook 中使用模块

```yaml
- name: reboot the servers
  action: command /sbin/reboot -t now

- name: reboot the servers
  command: /sbin/reboot -t now

- name: restart webserver
  service:
    name: httpd
    state: restarted
```

获取模块的帮助信息

```sh
ansible-doc yum
```

获取可用的模块列表

```sh
ansible-doc -l
```

更多命令介绍见[ansible-doc](https://ansible.leops.cn/basic/Ansible-command/#ansible-doc)

### 1.2 开发模块前提

官方是否有提供的类似功能模块？ 可从下面两个连接确定官方提供的模块，以免重复造轮子

- 官方已发布的模块 http://docs.ansible.com/ansible/modules.html

- 官方正在开发的模块 https://github.com/ansible/ansible/labels/module

你需要开发一个 action 插件么？ action 插件是在 ansible 主机上运行，而不是在目标主机上运行的。

对于类似 file/copy/template 功能的模块，在模块执行前需要在 ansible 主机上做一些操作的。

明确几点

- 模块是传送到目标主机上运行的。
- 模块的返回值必须是 json dumps 的字符串。

> 模块的通用返回值见[模块返回值](https://ansible.leops.cn/dev/modules/module-return/)

### 1.3 本地添加模块

Ansible 自动将在某些目录中找到的所有可执行文件作为模块加载，因此您可以在以下任意位置创建或添加本地模块：

使用环境变量 ANSIBLE_LIBRARY 定义的目录列表，使用逗号分隔。

```sh
~/.ansible/plugins/modules/
/usr/share/ansible/plugins/modules/
```

针对于 playbook 使用

- 保存在 playbook 当前目录 library 目录中的文件

针对于 role 使用

- 保存在 role 目录下 library 目录中的文件

也可以在配置文件中指定模块目录
Ansible 会在几个地方查找它的模块——首先它会查找 config 文件(`/etc/ansible/ansible.cfg`)中 library 键指定的位置，然后它会查找使用命令行中的`--module-path`参数指定的位置，然后它会在与 playbook 相同的目录中查找包含模块的 library 目录，最后它会在 library 目录中查找可能设置的任何角色。

```sh
[defaults]
library        = /usr/share/my_modules/
module_utils   = /usr/share/my_module_utils/
```

### 1.4 模块工具

Ansible 提供了许多模块实用程序，它们提供了在开发自己的模块时可以使用的辅助功能。
basic.py 模块为程序提供访问 Ansible 库的主要入口点，所有 Ansible 模块必须至少从 basic.py 导入：

```python
from ansible.module_utils.basic import *
```

### 1.5 开发环境

```sh
$ sudo apt-get update
$ sudo apt-get install python-pip python-dev build-essential
$ git clone https://github.com/ansible/ansible.git
$ cd ansible
$ python -m virtualenv moduledev
New python executable in /home/james/ansible/moduledev/bin/python
Installing setuptools, pip, wheel...done.
```

### 1.6 模块返回值

#### 通用返回值

所有模块通用的返回值

| 名称         | 类型 | 说明                                                                          |
| :----------- | :--- | ----------------------------------------------------------------------------- |
| backup_file  | str  | 对于一些 modules 使用了 backup 变量，返回备份的文件路径                       |
| changed      | bool | 表示任务是否必须进行更改。                                                    |
| failed       | bool | 表示任务是否失败。                                                            |
| invocation   | dict | 有关如何调用模块的信息。                                                      |
| msg          | str  | 存储通用消息的字符串                                                          |
| rc           | int  | 命令行程序的返回码                                                            |
| results      | dict | 如果该键存在，则表示该任务存在循环，并且它包含每个项目的模块“results”的列表。 |
| skipped      | bool | 表示该任务是否被跳过                                                          |
| stderr       | str  | 命令行程序的错误输出                                                          |
| stderr_lines | list | 它将 stderr 字符串按行分割存储在列表中                                        |
| stdout       | str  | 命令行程序的标准输出                                                          |
| stdout_lines | list | 它将 stdout 字符串按行分割存储在列表中                                        |

#### 内部使用

这些值是 ansible 内部定义的,模块可以使用，但不能用作注册变量。

| 名称          | 类型 | 说明                                                                                      |
| :------------ | :--- | ----------------------------------------------------------------------------------------- |
| ansible_facts | dict | 该 key 应包含一个字典，附加到分配给主机的 fact。 这些可以直接访问，不需要使用注册的变量。 |
| exception     | dict | 该 key 包含由模块中的异常引起的追溯信息。 它只能以高度详细程度显示（-vvv）。              |
| warnings      | list | 此键包含将显示给用户的字符串列表。                                                        |
| deprecations  | dict | 返回 msg 和 version 的字典列表                                                            |

## 2.工具类

Ansible 提供了许多模块实用类，或代码片段来帮助你在 Python 中快速构建 ansible 模块。
这些模块工具类默认存放在 `/usr/lib/python2.7/site-packages/ansible/module_utils/` 中，basic.py 模块类是 ansible 模块的主要入口，常见的工具类是 AnsibleModule。

### 2.1 AnsibleModule

想要使用此功能，使用`from ansible.module_utils.basic import AnsibleModule`命令导入即可。

```python
class ansible.module_utils.basic.AnsibleModule(argument_spec, bypass_checks=False, no_log=False, check_invalid_arguments=None, mutually_exclusive=None, required_together=None, required_one_of=None, add_file_common_args=False, supports_check_mode=False, required_if=None, required_by=None)
```

使用此功能，可以在 Python 中快速构建 ansible 模块的通用代码(尽管您可以用任何可以返回 JSON 的东西来编写模块)。

```sh
add_path_info(kwargs)                           # 对于文件结果，请在返回路径中添加有关文件路径的统计信息，以补充有关文件的信息。
atomic_move(src, dest, unsafe_writes=False)     # 原子性的移动文件
backup_local(fn)                                # 对指定文件进行带日期标记的备份，成功或失败时返回True或False
boolean(arg)                                    # 将参数转换为布尔值
digest_from_file(filename, algorithm)           # 返回本地文件的十六进制摘要以获取由名称指定的digest_method；如果文件不存在，则返回None。
exit_json( **kwargs )                           # 以json数据的形式从模块返回
fail_json( **kwargs )                           # 以json数据的形式从模块返回，并带有错误信息。
run_command(args, check_rc=False, close_fds=True, executable=None, data=None, binary_data=False, path_prefix=None, cwd=None, use_unsafe_shell=False, prompt_regex=None, environ_update=None, umask=None, encoding='utf-8', errors='surrogate_or_strict', expand_user_and_vars=True, pass_fds=None, before_communicate_callback=None)                # 执行一个命令,返回rc、stdout和stderr。
get_bin_path(arg, required=False, opt_dirs=None) # 查找系统中的可执行文件的路径。
is_executable(path)                              # 判断给定的路径是否可执行
is_special_selinux_path(path)               # 如果给定的路径位于NFS或其他特殊的fs挂载点上，则返回一个包含(True, selinux上下文)的元组，否则返回将为(False, None)。
load_file_common_arguments(params)          # 封装了file模块的常见选项,以便可以多次利用。
md5(filename) 使用digest_from_file()        # 返回本地文件的MD5摘要
preserved_copy(src, dest)                   # 复制一个文件,保留所有权限
sha1(filename)                              # 使用digest_from_file()返回本地文件的SHA1摘要。
sha256(filename)                            # 使用digest_from_file()返回本地文件的SHA256摘要。
```

更多内容见 basic 文件：`/usr/lib/python2.7/site-packages/ansible/module_utils/basic.py`

最常用的方法:

- run_command：此方法用于启动外部命令并检索返回代码、stdout 的输出以及 stderr 的输出。

- exit_json：此方法用于在模块成功完成时向 Ansible 返回数据。

- fail_json：此方法用于向 Ansible 发出失败信号，附带错误消息和返回代码。

### 2.2 asic

想要使用此功能，使用`import ansible.module_utils.basic`命令导入即可。

```sh
ansible.module_utils.basic.AnsibleFallbackNotFound 异常
ansible.module_utils.basic.env_fallback(*args, **kwargs) 从环境中加载值
ansible.module_utils.basic.heuristic_log_sanitize( data, no_log_values=None ) 从日志消息中删除类似密码的字符串
ansible.module_utils.basic.remove_values( value, no_log_strings) 从 value 中删除 no_log_strings 字符串中的字符串
```

更多内容见 basic 文件：/usr/lib/python2.7/site-packages/ansible/module_utils/basic.py

### 2.3 module 工具类的命名和查找

通常，您从名称或位置就可以知道模块工具类的功能。

```sh
lib/ansible/module_utils/urls.py 包含用于解析URL的共享代码
lib/ansible/module_utils/storage/emc/ 包含与EMC相关的共享代码
lib/ansible/modules/storage/emc/ 包含与EMC相关的模块
```

自定义的模块程序遵循此模式，可以很方便的查找和使用。

### 2.4 其他工具类

```sh
api.py - Supports generic API modules
basic.py - General definitions and helper utilities for Ansible modules
common/dict_transformations.py - Helper functions for dictionary transformations
common/file.py - Helper functions for working with files
common/text/ - Helper functions for converting and formatting text.
common/parameters.py - Helper functions for dealing with module parameters
common/sys_info.py - Functions for getting distribution and platform information
common/validation.py - Helper functions for validating module parameters against a module argument spec
facts/ - Directory of utilities for modules that return facts. See PR 23012 for more information
ismount.py - Single helper function that fixes os.path.ismount
json_utils.py - Utilities for filtering unrelated output around module JSON output, like leading and trailing lines
known_hosts.py - utilities for working with known_hosts file
network/common/config.py - Configuration utility functions for use by networking modules
network/common/netconf.py - Definitions and helper functions for modules that use Netconf transport
network/common/parsing.py - Definitions and helper functions for Network modules
network/common/network.py - Functions for running commands on networking devices
network/common/utils.py - Defines commands and comparison operators and other utilises for use in networking modules
powershell/ - Directory of definitions and helper functions for Windows PowerShell modules
pycompat24.py - Exception workaround for Python 2.4
service.py - Utilities to enable modules to work with Linux services (placeholder, not in use)
shell.py - Functions to allow modules to create shells and work with shell commands
six/__init__.py - Bundled copy of the Six Python library to aid in writing code compatible with both Python 2 and Python 3
splitter.py - String splitting and manipulation utilities for working with Jinja2 templates
urls.py - Utilities for working with http and https requests
```

## 3.自定义模块示例

### 3.1 Bash 模块

#### set_hosts 模块

##### 需求

修改本地 hosts 文件，来添加自定义的解析，要求传入两个参数，分别为 host 和 domain 表示要设置的 ip 地址和主机名称

模块使用以下参数。

| 参数   | 说明                      |
| ------ | ------------------------- |
| host   | IP 地址                   |
| domain | 域名解析                  |
| state  | present 创建，absent 删除 |

##### 编写 module

`set_hosts.sh`

```sh
#!/bin/bash

function exit_json() {
    if [ -n "$2" ] ; then
        json_structure="
            {
                \"changed\": $1,
                $2
            }
        "
    else
        json_structure="
            {
                \"changed\": $1
            }
        "
    fi
    echo $json_structure
    exit 0
}

function fail_json() {
    json_structure="
        {
            \"failed\": "true",
            \"msg\": \"$1\"
        }
    "
    echo $json_structure
    exit 1
}
# 函数用于验证是否为合法的 IPv4 地址
is_valid_ip() {
    local ip=$1
    # 正则表达式：匹配有效的 IPv4 地址
    local ip_regex='^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'

    if [[ $ip =~ $ip_regex ]]; then
        return 0
    else
        return 1
    fi
}

# 检查是否已经存在行，并给出返回码
_check_line() {
    local host=$1
    local domain=$2
    grep -Eo "$host\s+$domain" /etc/hosts >/dev/null
    return $?
}

main() {
    # arg parse
    arg_flag=0
    for arg in $(cat $1) ; do
        echo $arg | grep -E ',|\[|\]' > /dev/null 2>&1
        if [ $? -eq 0 ] ; then
            arg2="$arg2$arg"
            arg_flag=1
            continue
        fi

        if [ $arg_flag -eq 0 ] ; then
            key=`echo $arg | cut -d '=' -f 1`
            value=`echo $arg | cut -d '=' -f 2`
            declare "module_arg_$key=$value"
            arg_flag=0
        else
            key=`echo $arg2 | cut -d '=' -f 1`
            value=`echo $arg2 | cut -d '=' -f 2`
            declare "module_arg_$key=$value"
            arg_flag=0
        fi
    done

    # parameters
    host=$module_arg_host
    domain=$module_arg_domain
    state=$module_arg_state

   if [ "$state" == "present" -a -n "$host" -a -n "$domain" ] ; then
     is_valid_ip "$host"
     if [ $? -eq 0 ]; then
        _check_line $host $domain && \
          exit_json "false" || \
          echo "$host $domain" >> /etc/hosts; exit_json "true" "\"add\": \"$host  $domain\""
      else
        fail_json "Error: Invalid IP address $host"
        exit 1
     fi
   fi

   if [ "$state" == "absent" -a -n "$host" -a -n "$domain" ] ; then
      _check_line $host $domain
      res=$?
      if [[ $res -eq 0 ]];then
        sed -Ei "/$host\s+$domain/d" /etc/hosts
        exit_json "true" "\"Delete\" :\"$host $domain\""
      else
        exit_json "false"
      fi
   fi

   fail_json "Required parameters include: hosts, domain, state"
}

# 执行函数
main $1
```

##### playbook 测试

test_set_hosts.yml

```yml
---
- name: setting hosts playbook
  hosts: localhost
  gather_facts: no
  tasks:
    - set_hosts:
        host: 127.0.0.1
        domain: www.example.com
        state: present
```

通过 shell,python,go 等来实现 ansible 的自定义模块

- https://mp.weixin.qq.com/s/mjxudLudPsRCDsMOEkjiqg

#### touch 模块

Ansible 是由 python 语言开发的，但其支持的模块可以是任何语言，只要模块代码可以在远程执行即可。比如 bash 脚本需要 bash 解释器执行。

使用 bash 语言开发 module

##### 需求

功能实现

创建一个文件。

##### 编写 module

```sh
# cd /etc/ansible/library/
# cat touch.sh

#!/bin/sh

ANSIBLE_METADATA="{'metadata_version': '1.0',
          'status': ['preview'],
          'supported_by': 'community'}"

DOCUMENTATION="
---
module: touch
short_description: Touch a file on the remote host
version_added: '2.9'
description:
  - The touch module touch a file on the remote host.
options:
  file:
    description:
      - Path to a file on the remote host
    required: true
author:
  - 'Lework'
"

EXAMPLES="
# Example from Ansible Playbooks
- name: touch file
  touch:
    file: /tmp/foo
"

RETURN="
path:
    description: Path to a file on the remote host
    type: string
    returned: success
    sample: "/path/to/file.name"
"

args_file=$1

[ ! -f "$args_file" ] && echo -n '{"failed": true, "msg": "missing required arguments: file"}' && exit 1
args_result=$(cat $args_file | gawk -F'file=' '{print $2}' | gawk -F' ' '{print $1}')

[ ! -n "$args_result" ] && echo -n "{\"failed\": true, \"msg\": \"file () is absent, cannot continue\", \"file\": \"$args_result\"}" && exit 1

touch $args_result && echo -n "{\"changed\": true, \"rc\": $?,\"file\": \"$args_result\"}" || echo -n "{\"failed\": true, \"rc\": $?, \"file\": \"$args_result\"}"
exit $?
```

返回值一定是 json dumps 的字符串。

##### 本地测试

ansible 的参数都会被写入一个名为 args 的文件，代码中的$1 变量就是这个文件的路径，读取这个文件的内容，就能获取 file 参数的值。

```sh
# cat args
file=/tmp/foo

# sh touch.sh args
{"changed": true, "rc": 0,"file": "/tmp/foo"}
```

##### playbook 测试

执行 playbook

```yaml
# cat test_touch.yml
---
- name: test remote_copy module
  hosts: localhost
  gather_facts: false

  tasks:
    - name: touch file
      touch: file=/tmp/foo
      vars:
        ansible_sh_interpreter: /bin/sh
```

> ansible_sh_interpreter 指定执行模块的可执行文件

执行结果

```sh
# ansible-playbook test_touch.yml

PLAY [test remote_copy module] *****************************************************************************************

TASK [touch file] *****************************************************************************************
changed: [localhost]

PLAY RECAP *****************************************************************************************
localhost             : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

##### 执行 ad-hoc

```sh
# ansible 192.168.77.130 -M /etc/ansible/library/ -m touch -a "file=/tmp/a" -e "ansible_sh_interpreter=/bin/sh"
192.168.77.130 | CHANGED => {
    "changed": true,
    "file": "/tmp/a",
    "rc": 0
}
```

#### dir 模块

##### 需求

创建或删除目录。

模块使用以下参数。

| 参数  | 说明                      |
| ----- | ------------------------- |
| name  | 目录名                    |
| path  | 创建目录的路径            |
| state | present 创建，absent 删除 |

##### 编写 module

```sh
#!/bin/bash
#
# This code is ansible module example using bash.

function exit_json() {
    if [ -n "$2" ] ; then
        json_structure="
            {
                \"changed\": $1,
                $2
            }
        "
    else
        json_structure="
            {
                \"changed\": $1
            }
        "
    fi
    echo $json_structure
    exit 0
}

function fail_json() {
    json_structure="
        {
            \"failed\": "true",
            \"msg\": \"$1\"
        }
    "
    echo $json_structure
    exit 1
}

function main() {
    # arg parse
    arg_flag=0
    for arg in $(cat $1) ; do
        echo $arg | grep -E ',|\[|\]' > /dev/null 2>&1
        if [ $? -eq 0 ] ; then
            arg2="$arg2$arg"
            arg_flag=1
            continue
        fi

        if [ $arg_flag -eq 0 ] ; then
            key=`echo $arg | cut -d '=' -f 1`
            value=`echo $arg | cut -d '=' -f 2`
            declare "module_arg_$key=$value"
            arg_flag=0
        else
            key=`echo $arg2 | cut -d '=' -f 1`
            value=`echo $arg2 | cut -d '=' -f 2`
            declare "module_arg_$key=$value"
            arg_flag=0
        fi
    done

    # parameters
    name=$module_arg_name
    path=$module_arg_path
    state=$module_arg_state

    # When state is present
    if [ $state == "present" -a -n "$name" -a -n "$path" ] ; then
        if [ -d $path ] ; then
            if [ -d "$path/$name" ] ; then
                exit_json "false"
            else
                result=`mkdir "$path/$name" 2>&1`
                if [ -n "$result" ] ; then
                    fail_json "`echo -n $result`"
                else
                    exit_json "true" "\"directory_path\": \"$path/$name\""
                fi
            fi
        else
            fail_json "Error: not found $module_arg_path"
        fi
    fi

    # When state is absent
    if [ $state == "absent" -a -n "$name" -a -n "$path" ] ; then
        if [ -d "$path/$name" ] ; then
            rm -rf "$path/$name" 2>&1 > /dev/null
            if [ -d "$path/$name" ] ; then
                fail_json "Error: failed delete folder $path/$name"
            fi
            exit_json "true" "\"directory_path\": \"$path/$name\""
        else
            exit_json "false"
        fi
    fi

    fail_json "Required parameters include: name, path, state"
}

main $1
```

##### ansible 配置

在 /etc/ansible/ansible.cfg 中指定模块目录

```sh
[defaults]
library = /etc/ansible/library/
```

##### 执行 ad-hoc

```sh
# ansible localhost -m dir -a "name=test path=/tmp state=present"
localhost | CHANGED => {
    "changed": true,
    "directory_path": "/tmp/test"
}

# file /tmp/test
/tmp/test: directory

# ansible localhost -m dir -a "name=test path=/tmp state=absent"
localhost | CHANGED => {
    "changed": true,
    "directory_path": "/tmp/test"
}

# file /tmp/test
/tmp/test: cannot open (No such file or directory)
```

##### 执行 playbook

```yaml
---
- name: Directory operation playbook
  hosts: localhost
  gather_facts: no
  tasks:
    - dir:
        name: test
        path: /tmp
        state: present
    - dir:
        name: test2
        path: /tmp
        state: absent
```

执行结果

```sh
# ansible-playbook test_dir.yml
PLAY [Directory operation playbook] *******************************************************************************************************************

TASK [dir] ********************************************************************************************************************************************
changed: [localhost]

TASK [dir] ********************************************************************************************************************************************
ok: [localhost]

PLAY RECAP ********************************************************************************************************************************************
localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0


# file /tmp/test
/tmp/test: directory
# file /tmp/test2
/tmp/test2: cannot open (No such file or directory)
```

#### docker_facts 模块

##### 需求

只返回 facts 数据的模块

功能实现
获取远程主机的 docker 信息，并将其注册到 facts 数据中。

##### 编写 module

file: library/docker_facts.sh

```sh
#!/bin/bash

ANSIBLE_METADATA="{'metadata_version': '1.0',
          'status': ['preview'],
          'supported_by': 'community'}"

DOCUMENTATION="
---
module: docker_facts
short_description: Get docker facts data
version_added: '2.9'
description:
  - Get docker facts data on remote host.
author:
  - 'Lework'
"
EXAMPLES="
# Example from Ansible Playbooks
- name: get docker facts
  docker_facts:
"

RETURN="
ansible_facts:
    description: docker facts
    type: dict
    returned: always
"

set -e

cat <<EOF
{
    "ansible_facts": {
        "docker_server_version": "$(docker version -f '{{.Server.Version}}')",
        "docker_client_version": "$(docker version -f '{{.Client.Version}}')",
        "docker_info": $(curl -s --unix-socket /var/run/docker.sock http://:/info),
        "docker_version": $(curl -s --unix-socket /var/run/docker.sock http://:/version),
        "docker_containers": $(curl -s --unix-socket /var/run/docker.sock http://:/containers/json?all=true),
        "docker_images": $(curl -s --unix-socket /var/run/docker.sock http://:/images/json)
    },
    "changed": false
}
EOF

exit 0
```

##### 执行 playbook

本地运行测试

```sh
# chmod +x library/docker_facts.sh
# ./library/docker_facts.sh
{
    "ansible_facts": {
        "docker_server_version": "18.09.6",
        "docker_client_version": "18.09.6",
        "docker_info": .......,
        "docker_version": ....,
        "docker_containers": .....,
        "docker_images": .......,
    },
    "changed": false
}
```

以 json 格式输出 docker 信息。

ansible 运行

```sh
# ansible localhost -M /etc/ansible/library -m docker_facts
localhost | SUCCESS => {
    "ansible_facts": {
        "docker_client_version": "18.09.6",
        "docker_containers": [
# ....
}
```

playbook 运行

playbook 内容 `test_docker_facts.yml`

```yaml
---
- hosts: localhost
  gather_facts: no
  tasks:
    - name: get docker facts
      docker_facts:
    - name: show facts
      debug: var=ansible_facts.docker_version
```

playbook 运行

```sh
# ansible-playbook test_docker_facts.yml

PLAY [localhost] *********************************************************************************************************************

TASK [get docker facts] **************************************************************************************************************
ok: [localhost]

TASK [show facts] ********************************************************************************************************************
ok: [localhost] => {
    "ansible_facts.docker_version": {
        "ApiVersion": "1.39",
        "Arch": "amd64",
        "BuildTime": "2019-05-04T02:02:43.000000000+00:00",
        "Components": [
            {
                "Details": {
                    "ApiVersion": "1.39",
                    "Arch": "amd64",
                    "BuildTime": "2019-05-04T02:02:43.000000000+00:00",
                    "Experimental": "false",
                    "GitCommit": "481bc77",
                    "GoVersion": "go1.10.8",
                    "KernelVersion": "5.1.11-1.el7.elrepo.x86_64",
                    "MinAPIVersion": "1.12",
                    "Os": "linux"
                },
                "Name": "Engine",
                "Version": "18.09.6"
            }
        ],
        "GitCommit": "481bc77",
        "GoVersion": "go1.10.8",
        "KernelVersion": "5.1.11-1.el7.elrepo.x86_64",
        "MinAPIVersion": "1.12",
        "Os": "linux",
        "Platform": {
            "Name": "Docker Engine - Community"
        },
        "Version": "18.09.6"
    }
}

PLAY RECAP ***************************************************************************************************************************
localhost                  : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

参考文献：

- https://ansible.leops.cn/dev/modules/module-docker-facts/

#### chkuptime 模块

##### 需求

简单地检查目标机器的正常运行时间，并按照任何 Ansible 模块所需的格式返回输出

##### 编写 module

`library/chkuptime`

```sh
#!/bin/bash

# The module checks for system uptime of the target machine.
# The module takes in 'detailed' bool argument from the user
# It returns a JSON output since an Ansible module should
# output a Valid JSON.

source $1

if [ -f "/proc/uptime" ]; then
    uptime=`cat /proc/uptime`
    uptime=${uptime%%.*}
    days=$(( uptime/60/60/24 ))
    hours=$(( uptime/60/60%24 ))
    if [ $detailed ]; then
        minutes=$(( uptime/60%60 ))
        seconds=$(( uptime%60 ))
        uptime="$days days, $hours hours, $minutes minutes, $seconds seconds"
    else
        uptime="$days days, $hours hours"
    fi
else
    uptime=""
fi

echo -e "{\"uptime\":\""$uptime"\"}"
```

在 Ansible play 中唯一需要更改的是在调用模块时传递一个 Bool 类型的 detailed 参数,通过设置 detailed 标志为 true,来加载运行时间包括了分钟和秒

##### 执行 playbook

Ansible Play (`uptime_arg.yml`)

```yaml
---
- hosts: remote
  user: rdas

  tasks:
    - name: Check uptime
      action: chkuptime detailed=true
      register: uptime

    - debug: var=uptime
```

参考文献：https://fldop2.flygon.net/#/docs/ext-asb/ext-asb_2

### 3.2 Python 模块

#### myshell 模块

`library/myshell.py`

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Site    :
# @File    : myshell.py
# @Software: PyCharm
# @Desc    : python file
# @license : Copyright(C), Your Company

# 兼容 Python 2 和 Python 3
from __future__ import (absolute_import, division, print_function)

# 使文件中定义的所有类成为新式类，无需显式继承自 object.
__metaclass__ = type
from ansible.module_utils.basic import AnsibleModule
import commands


def main():
    """
    run shell
    """
    changed = False
    module = AnsibleModule(
                argument_spec = dict(
                 cmd = dict(type='str', required=True),
                ),
    )
    cmd = module.params['cmd']

    code,output = commands.getstatusoutput(cmd)
    if code == 0:
        # 按照ansible 的返回格式定义返回内容,stdout为标准输出,changed代表系统有没有东西被变更,rc=0代表执行成功
        result = dict(stdout=output,changed=changed,rc=0)
        # 使用ansible规则的module实例下的exit_json返回正常内容
        module.exit_json(**result)
    else:
        # 当调用失败返回错误信息的时候,数据字典只要传递msg信息就可了,然后调用module实例的fail_json方法给返回
        result = dict(msg=output,rc=code)
        module.fail_json(**result)


if __name__ == '__main__':

    main()
```

执行一个正确的命令

```sh
ansible -i inventory/devlop linux-node1 -m myshell -a cmd='pwd'
linux-node1 | SUCCESS => {
    "changed": false,
    "rc": 0,
    "stdout": "/home/niu",
    "stdout_lines": [
        "/home/niu"
    ]
}

ansible -i inventory/devlop linux-node1 -m myshell -a cmd='pws'
linux-node1 | FAILED! => {
    "changed": false,
    "msg": "sh: pws: command not found",
    "rc": 32512
}
```

参数解释

argument_spec 支持的参数

例子：

```sh
module = AnsibleModule(
    argument_spec = dict{
        name = dict(type='str', required=True),
        cwd = dict(type='str', required=False),
        shell = dict(type='bool', default=True),
    }
)
```

#### pids 模块

```python
#!/usr/bin/python
# Copyright: (c) 2019, Saranya Sridharan
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

ANSIBLE_METADATA = {'metadata_version': '1.1',
                    'status': ['preview'],
                    'supported_by': 'community'}

DOCUMENTATION = '''
module: pids
version_added: 2.8
description: "Retrieves a list of PIDs of given process name in Ansible controller/controlled machines.Returns an empty list if no process in that name exists."
short_description: "Retrieves process IDs list if the process is running otherwise return empty list"
author:
  - Saranya Sridharan (@saranyasridharan)
requirements:
  - psutil(python module)
options:
  name:
    description: the name of the process you want to get PID for.
    required: true
    type: str
'''

EXAMPLES = '''
# Pass the process name
- name: Getting process IDs of the process
  pids:
      name: python
  register: pids_of_python

- name: Printing the process IDs obtained
  debug:
    msg: "PIDS of python:{{pids_of_python.pids|join(',')}}"
'''

RETURN = '''
pids:
  description: Process IDs of the given process
  returned: list of none, one, or more process IDs
  type: list
  sample: [100,200]
'''

from ansible.module_utils.basic import AnsibleModule
try:
    import psutil
    HAS_PSUTIL = True
except ImportError:
    HAS_PSUTIL = False


def get_pid(name):
    return [p.info['pid'] for p in psutil.process_iter(attrs=['pid', 'name']) if p.info and p.info.get('name', None) and p.info['name'].lower() == name.lower()]


def main():
    module = AnsibleModule(
        argument_spec=dict(
            name=dict(required=True, type="str"),
        ),
        supports_check_mode=True,
    )
    if not HAS_PSUTIL:
        module.fail_json(msg="Missing required 'psutil' python module. Try installing it with: pip install psutil")
    name = module.params["name"]
    response = dict(pids=get_pid(name))
    module.exit_json(**response)


if __name__ == '__main__':
    main()
```

参考文献：

- https://cloud.tencent.com/developer/article/2013890

#### check_user 模块

##### 版本 v1

我们需要在 Ansible 顶级目录的 `library` 文件夹中创建`check_user.py`文件。

```python
#!/usr/bin/env python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import pwd
import sys
import shlex
import json

def main():
    # Parsing argument file
    args = {}
    args_file = sys.argv[1]
    args_data = file(args_file).read()
    arguments = shlex.split(args_data)
    for arg in arguments:
        if '=' in arg:
            (key, value) = arg.split('=')
            args[key] = value
    user = args['user']

    # Check if user exists
    try:
        pwd.getpwnam(user)
        success = True
        ret_msg = 'User %s exists' % user
    except KeyError:
        success = False
        ret_msg = 'User %s does not exists' % user

    # Error handling and JSON return
    if success:
        print json.dumps({
            'msg': ret_msg
        })
        sys.exit(0)
    else:
        print json.dumps({
            'failed': True,
            'msg': ret_msg
        })
        sys.exit(1)

main()
```

`check_user.yaml`

```yaml
---
- hosts: localhost
  connection: local
  vars:
    user_ok: root
    user_ko: this_user_does_not_exists
  tasks:
    - name: "Check if user {{ user_ok }} exists"
      check_user:
        user: "{{ user_ok }}"
    - name: "Check if user {{ user_ko }} exists"
      check_user:
        user: "{{ user_ko }}"
```

测试 playbooks

```sh
# ansible-playbook check_user.yaml
```

##### 版本 v2 python2 版

我们需要在 Ansible 顶级目录的 `library` 文件夹中创建`check_user_py2.py`文件。

```python
#!/usr/bin/env python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import pwd
from ansible.module_utils.basic import AnsibleModule


def main():
    #  Ansible 通过提供一个AnsibleModule类来简化这个过程，该类自行处理所有处理并为我们提供最终参数。
    # required=True参数意味着该参数是必需的，如果未传递该参数，则执行将失败。 默认值required为False，这将允许用户跳过该参数。
    # 然后，您可以通过在module.params字典上调用module.params上的get方法来访问参数的值。
    # 远程主机上检查用户的逻辑将保持不变，但错误处理和返回方面将如下更改：
    # Parsing argument file
    module = AnsibleModule(
        argument_spec = dict(
            user = dict(required=True)
        )
    )
    user = module.params.get('user')

    # Check if user exists
    try:
        pwd.getpwnam(user)
        success = True
        ret_msg = 'User %s exists' % user
    except KeyError:
        success = False
        ret_msg = 'User %s does not exists' % user

    # Ansible 通过exit_json和fail_json方法提供了更快和更短的处理成功和失败的方法，分别。
    # 您可以直接将消息传递给这些方法，Ansible 将处理剩余的部分。 您还可以将其他变量传递给这些方法，并且 Ansible 将这些变量打印到stdout。
    # Error handling and JSON return
    if success:
        module.exit_json(msg=ret_msg)
    else:
        module.fail_json(msg=ret_msg)

if __name__ == "__main__":
    main()
```

`check_user_py2.yaml`

```yaml
---
- hosts: localhost
  connection: local
  vars:
    user_ok: root
    user_ko: this_user_does_not_exists
  tasks:
    - name: "Check if user {{ user_ok }} exists"
      check_user_py2:
        user: "{{ user_ok }}"
    - name: "Check if user {{ user_ko }} exists"
      check_user_py2:
        user: "{{ user_ko }}"
```

测试 playbooks

```sh
# ansible-playbook check_user_py2.yaml
```

##### 版本 v2 python3 版

我们需要在 Ansible 顶级目录的 `library` 文件夹中创建`check_user_py3.py`文件。

```python
#!/usr/bin/env python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import pwd
from ansible.module_utils.basic import AnsibleModule

class User:
    def __init__(self, user):
        self.user = user

    # Check if user exists
    def check_if_user_exists(self):
        try:
            user = pwd.getpwnam(self.user)
            success = True
            ret_msg = 'User %s exists' % self.user
        except KeyError:
            success = False
            ret_msg = 'User %s does not exists' % self.user
        return success, ret_msg

def main():
    # Parsing argument file
    module = AnsibleModule(
        argument_spec = dict(
            user = dict(required=True)
        )
    )
    user = module.params.get('user')

    chkusr = User(user)
    success, ret_msg = chkusr.check_if_user_exists()

    # Error handling and JSON return
    if success:
        module.exit_json(msg=ret_msg)
    else:
        module.fail_json(msg=ret_msg)

if __name__ == "__main__":
    main()
```

#### check_user_id 模块

`check_user_id.py`

```python
#!/usr/bin/env python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
import pwd
from ansible.module_utils.basic import AnsibleModule

class CheckUser:
    def __init__(self, user):
        self.user = user

    # Check if user exists
    def check_user(self):
        uid = ''
        gid = ''
        try:
            user = pwd.getpwnam(self.user)
            success = True
            ret_msg = 'User %s exists' % self.user
            uid = user.pw_uid
            gid = user.pw_gid
        except KeyError:
            success = False
            ret_msg = 'User %s does not exists' % self.user
        return success, ret_msg, uid, gid

def main():
    # Parsing argument file
    module = AnsibleModule(
        argument_spec = dict(
            user = dict(required=True)
        )
    )
    user = module.params.get('user')

    chkusr = CheckUser(user)
    success, ret_msg, uid, gid = chkusr.check_user()

    # Error handling and JSON return
    if success:
        module.exit_json(msg=ret_msg, uid=uid, gid=gid)
    else:
        module.fail_json(msg=ret_msg)

if __name__ == "__main__":
    main()
```

`check_user_id.yaml`

```yaml
---
- hosts: localhost
  vars:
    user: root
  tasks:
    - name: "Retrive {{ user }} data if it exists"
      check_user_id:
        user: "{{ user }}"
      register: user_data
    - name: "Print user {{ user }} data"
      debug:
        msg: "{{ user_data }}"
```

测试 playbooks

```sh
ansible-playbook check_user_id.yaml
```

#### get_process_ports 模块

用 Python 实现根据进程名称查询进程的端口号的功能

`get_process_ports.py`

```python
#!/usr/bin/python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
from ansible.module_utils.basic import AnsibleModule
import subprocess

def get_process_ports(process_name):
    try:
        # 使用 lsof 命令查询指定进程名称的端口号
        # command = 'netstat -tunlp l grep %s l awk \'ffprint $4}}\'| awk -f: \'ffprint $NF}}\'l sort -u'% process name
        command = f'lsof -i -n -P | grep LISTEN |  grep %s  | awk \'{{print $9}}\' | awk -F: \'{{print $NF}}\' | sort -u' % process name
        ports = subprocess.check_output(command, shell=True, universal_newlines=True)
        ports = ports.strip().split('\n')
        return ports
    except Exception as e:
        return str(e)

def main():
    module_args = dict(
        process_name=dict(type='str', required=True)
    )

    result = dict(
        changed=False,
        ports=[],
        error=''
    )

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

    process_name = module.params['process_name']

    # 查询进程端口号
    ports = get_process_ports(process_name)

    if isinstance(ports, list):
        result['ports'] = ports
        module.exit_json(**result)
    else:
        result['error'] = str(ports)
        module.fail_json(msg=f"Failed to get ports for process '{process_name}': {ports}", **result)

if __name__ == '__main__':
    main()
```

使用示例

```yaml
---
- name: Query process ports example
  hosts: localhost
  tasks:
    - name: Get ports for process 'sshd'
      get_process_ports:
        process_name: sshd
      register: process_ports

    - debug:
        var: process_ports
```

在这个示例中，我们调用了自定义模块 `get_process_ports` 并指定了要查询的进程名称为 sshd。

模块将返回包含端口号的 JSON 结果，我们将其注册到 process_ports 变量中，并使用 debug 模块来输出结果。

#### remote_ping 模块

实现一个远程 ping 模块

`remote_ping`

```python
#!/usr/bin/python env
# coding:utf-8
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

def can_reach(module,host):
    ping_path =  module.get_bin_path('ping', required=True)
    args = [ping_path, '-c 4 -i 0.1',host]
    (rc,stdout,stderr) = module.run_command(args)

    return rc == 0


def main():
    module = AnsibleModule(
        argument_spec=dict(
            host = dict(required=True,type='str'),
        ),
        supports_check_mode=True,
    )

    if module.check_mode:
        module.exit_json(changed=False)

    host = module.params['host']

    if can_reach(module,host):
        module.exit_json(changed=True)
    else:
        msg = 'Could not reach %s' %(host)
        module.fail_json(msg=msg)

from ansible.module_utils.basic import *

if __name__ == '__main__':
    main()
```

编写 yaml 文件使用模块

```yml
---
- name: test remote_ping module
  hosts: webserver01
  gather_facts: false

  tasks:
    - name: do a remote host
      remote_ping: host=172.20.1.100
```

#### remote_filecopy 模块

##### 版本 v1

`remote_filecopy.py`

```python
#!/usr/bin/python
#

# Copyright: (c) 2024, Jesse Keating <hjl@example.org>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

ANSIBLE_METADATA = {'metadata_version': '1.1',
                    'status': ['preview'],
                    'supported_by': 'community'}

DOCUMENTATION = '''
---
module: remote_filecopy
version_added: "2.9"
short_description: Copy a file on the remote host
description:
  - The remote_copy module copies a file on the remote host from a given source to a provided destination.
options:
  source:
    description:
      - Path to a file on the source file on the remote host
    required: True
  dest:
    description:
      - Path to the destination on the remote host for the copy
    required: True
author:
- Jesse Keating (@omgjlk)
'''
EXAMPLES = '''
   # Example from Ansible Playbooks
   - name: backup a config file
     remote_copy:
       source: /etc/herp/derp.conf
       dest: /root/herp-derp.conf.bak
'''

RETURN = '''
source:
  description: source file used for the copy
  returned: success
  type: str
  sample: "/path/to/file.name"
dest:
  description: destination of the copy
  returned: success
  type: str
  sample: "/path/to/destination.file"
gid:
  description: group ID of destination target
  returned: success
  type: int
  sample: 502
group:
  description: group name of destination target
  returned: success
  type: str
  sample: "users"
uid:
  description: owner ID of destination target
  returned: success
  type: int
  sample: 502
owner:
  description: owner name of destination target
  returned: success
  type: str
  sample: "fred"
mode:
  description: permissions of the destination target
  returned: success
  type: int
  sample: 0644
size:
  description: size of destination target
  returned: success
  type: int
  sample: 20
state:
  description: state of destination target
  returned: success
  type: str
  sample: "file"
'''
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type
import shutil

def main():
    module = AnsibleModule(
        argument_spec = dict(
            source=dict(required=True, type='str'),
            dest=dict(required=True, type='str')
        ),
    )
    try:
       shutil.copy(module.params['source'], module.params['dest'])
    except:
       module.fail_json(msg="Failed to copy file")

    module.exit_json(changed=True)

from ansible.module_utils.basic import *
if __name__ == '__main__':
    main()
```

测试 playbook

`test_copyfilev1.yml`

```yml
---
- name: Playbook to test custom module
  hosts: all

  tasks:
    - name: Test the custom module
      remote_filecopy:
        source: /tmp/foo.txt
        dest: /tmp/bar.txt
      register: testresult

    - name: Print the test result data
      debug:
        var: testresult
```

为了清晰起见，你的最终目录结构应该如下所示：

```sh
testplaybook
├── hosts
├── library
│   └── remote_filecopy.py
└── test_copyfilev1.yml

$ ansible-playbook -i hosts test_copyfilev1.yml
```

##### 版本 v2

`better_remote_filecopy.py`

```python
ANSIBLE_METADATA = {'metadata_version': '1.1',
                    'status': ['preview'],
                    'supported_by': 'community'}

DOCUMENTATION = '''
---
module: remote_filecopy
version_added: "2.9"
short_description: Copy a file on the remote host
description:
  - The remote_copy module copies a file on the remote host from a given source to a provided destination.
options:
  source:
    description:
      - Path to a file on the source file on the remote host
    required: True
  dest:
    description:
      - Path to the destination on the remote host for the copy
    required: True
author:
- Jesse Keating (@omgjlk)
'''
EXAMPLES = '''
   # Example from Ansible Playbooks
   - name: backup a config file
     remote_copy:
       source: /etc/herp/derp.conf
       dest: /root/herp-derp.conf.bak
'''
RETURN = '''
source:
  description: source file used for the copy
  returned: success
  type: str
  sample: "/path/to/file.name"
dest:
  description: destination of the copy
  returned: success
  type: str
  sample: "/path/to/destination.file"
gid:
  description: group ID of destination target
  returned: success
  type: int
  sample: 502
group:
  description: group name of destination target
  returned: success
  type: str
  sample: "users"
uid:
  description: owner ID of destination target
  returned: success
  type: int
  sample: 502
owner:
  description: owner name of destination target
  returned: success
  type: str
  sample: "fred"
mode:
  description: permissions of the destination target
  returned: success
  type: int
  sample: 0644
size:
  description: size of destination target
  returned: success
  type: int
  sample: 20
state:
  description: state of destination target
  returned: success
  type: str
  sample: "file"
'''
import shutil

def main():
    module = AnsibleModule(
        argument_spec = dict(
            source=dict(required=True, type='str'),
            dest=dict(required=True, type='str')
        ),
    )
    try:
        shutil.copy(module.params['source'], module.params['dest'])
    except:
        module.fail_json(msg="Failed to copy file")

    module.exit_json(changed=True)

from ansible.module_utils.basic import *
if __name__ == '__main__':
    main()
```

测试 playbook

`test_copyfilev2.yml`

```yml
---
- name: Playbook to test custom module
  hosts: all

  tasks:
    - name: Test the custom module
      better_remote_filecopy:
        source: /tmp/foo.txt
        dest: /tmp/bar.txt.bak
      register: testresult

    - name: Print the test result data
      debug:
        var: testresult
```

为了清晰起见，你的最终目录结构应该如下所示：

```sh
testplaybook
├── hosts
├── library
│   └── better_remote_filecopy.py
└── test_copyfilev2.yml

$ ansible-playbook -i hosts test_copyfilev2.yml
```

参考文献

- https://fldop2.flygon.net/#/docs/prac-asb/prac-asb_07

#### remote_copy 模块

`remote_copy.py`

```python
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright: (c) 2020, lework
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

ANSIBLE_METADATA = {'metadata_version': '1.0',
            'status': ['preview'],
                'supported_by': 'community'}

DOCUMENTATION = '''
---
module: remote_copy
short_description: Copy a file on the remote host
version_added: "2.9"
description:
  - The remote_copy module copies a file on the remote host from a given source to a provided destination.
options:
  source:
    description:
      - Path to a file on the source file on the remote host
    required: true
  dest:
    description:
      - Path to the destination on the remote host for the copy
    required: true
author:
  - "Lework"
'''

EXAMPLES = '''
# Example from Ansible Playbooks
- name: backup a config file
  remote_copy:
    source: /tmp/foo
    dest: /tmp/bar
'''

RETURN = '''
source:
    description: Path to a file on the source file on the remote host
    type: str
    returned: success
    sample: "/path/to/file.name"
dest:
    description: Path to the destination on the remote host for the copy
    type: string
    returned: success
    sample: "/path/to/destination.file"
'''

import os
import shutil
from ansible.module_utils.basic import AnsibleModule

def main():
    module_args = dict(
            source=dict(required=True, type='str'),
            dest=dict(required=True, type='str')
    )

    result = dict(
        changed=False,
        source='',
        dest=''
    )

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

    if module.check_mode:
       module.exit_json(**result)

    if not os.path.isfile(module.params['source']):
        module.fail_json(msg='The '+ module.params['source'] +' file was not found', **result)

    try:
        shutil.copy(module.params['source'], module.params['dest'])
    except Exception as e:
        module.fail_json(msg=e, **result)

    result['source'] = module.params['source']
    result['dest'] = module.params['dest']

    if os.path.isfile(module.params['dest']):
        result['changed'] = True

    remote_facts = {'rc_source': module.params['source'], 'rc_dest': module.params['dest'] }
    result['ansible_facts'] = remote_facts

    module.exit_json(**result)

if __name__ == '__main__':
    main()
```

#### set_hosts 模块

通过 python 来实现时，ansible 提供了已经封装好的类 AnsibleModule，通过实例化这个类，可以将所需的参数传入进去，同时输出执行结果时也提供了 module.exit_json 和 module.fail_json 的方法

```python
#!/usr/bin/env python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.common.text.converters import to_native


def add_lines(module, host, domain):
    option_file = "/etc/hosts"
    option_content = host + " " + domain
    with open(option_file, "r+") as f:
        contents = f.read()

        if option_content in contents:
            module.exit_json(changed=False, stdout="%s 已存在，无需添加" % option_content)
        else:
            f.write("%s\n" % option_content)
            module.exit_json(changed=True, stdout="%s 已添加" % option_content)
    return


def main():
    module = AnsibleModule(
        argument_spec=dict(
            host=dict(type="str", required=True),
            domain=dict(type="str", required=True),
        )
    )
    host = module.params["host"]
    domain = module.params["domain"]

    try:
        add_lines(module, host, domain)
    except Exception as e:
        module.fail_json(msg="Exception error: %s" % to_native(e))


if __name__ == "__main__":
    main()
```

参考文献

https://www.cnblogs.com/dogfei/p/17311919.html

#### huawei switch 模块

https://ansible.leops.cn/dev/modules/huawei-switch/

#### wechat 模块

https://ansible.leops.cn/dev/modules/module-wechat/

#### 编写 facts 模块

- https://hellogitlab.com/CM/ansible/facts_module

### 3.3 Golang 模块

#### hello 模块

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
)

// Response 返回值
type Response struct {
	Changed bool   `json:"changed"`
	Fail    bool   `json:"fail"`
	Msg     string `json:"msg"`
	RC      int    `json:"rc"`
}

func main() {
	var args = os.Args[:]
	var response Response
	if len(args) != 2 {
		response.Fail = true
		response.Msg = "失败"
		response.Changed = false
	}
	contents, err := readJSON(args[1])
	if err != nil {
		response.Msg = err.Error()
		response.Fail = true
		response.Changed = false

	} else {
		var m = make(map[string]string)
		json.Unmarshal([]byte(contents), &m)
		response.Msg = " Hello " + m["name"]
		response.Fail = false
		response.Changed = false
	}

	buffer, _ := json.Marshal(response)
	fmt.Println(string(buffer))
}

func readJSON(f string) (string, error) {
	fh, err := os.Open(f)
	if err != nil {
		return "", err
	}
	contents, err := ioutil.ReadAll(fh)
	return string(contents), err
}
```

```yaml
---
- name:
  hosts: huanggai
  remote_user: deploy
  tasks:
    - name: Hello World版本的playbook
      hello:
        name: "{{ item }}"
      with_items: ["licong", caobo]
```

#### set_hosts 模块

在使用 golang 编写模块时，需要先编译成二进制文件

`library/set_hosts.go` 编译后 `library/set_hosts` 位置

set_hosts.go

```go
package main

import (
 "bufio"
 "bytes"
 "encoding/json"
 "fmt"
 "io"
 "io/ioutil"
 "os"
 "strings"
)

type ModuleResult struct {
 Changed bool   `json:"changed"`
 Fail    bool   `json:"fail"`
 Msg     string `json:"msg"`
 RC      int    `json:"rc"`
}

// 定义要传入的参数
type AllArgs struct {
 Domain string `json:"domain"`
 Host   string `json:"host"`
}

func addLines(host, domain string) (string, error) {
 filename := "/etc/hosts"
 content := host + " " + domain
 data, err := ioutil.ReadFile(filename)
 if err != nil {
  return "", err
 }
 isExist := false

 scanner := bufio.NewScanner(bytes.NewReader(data))

 for scanner.Scan() {
  line := scanner.Text()
  if strings.Contains(line, content) {
   isExist = true
   return "已存在，无需添加", nil
  }
 }
 if !isExist {
  f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
  if err != nil {
   return "未知错误", err
  }
  defer f.Close()
  if _, err := f.WriteString(content + "\n"); err != nil {
   return "write error", err
  }
 }
 return "write sucess", nil
}

func outPut(module ModuleResult, status int) {
 module.RC = status
 var out io.Writer
 if status == 0 {
  out = os.Stdout
 } else {
  out = os.Stderr
 }
 contents, _ := json.Marshal(module)
 fmt.Fprint(out, string(contents))
 os.Exit(status)
}

func parseArg(module ModuleResult, f string) (args AllArgs) {
 fobj, err := os.Open(f)
 if err != nil {
  module.Changed = false
  module.Fail = true
  module.Msg = ""
  outPut(module, 2)
 }

 defer fobj.Close()

 content, err := ioutil.ReadAll(fobj)

 if err != nil {
  module.Changed = false
  module.Fail = true
  module.Msg = ""
  outPut(module, 2)
 }

 err = json.Unmarshal(content, &args)
 if err != nil {
  module.Changed = false
  module.Fail = true
  module.Msg = ""
  outPut(module, 2)
 }
 return
}

func main() {
 module := ModuleResult{}
 var argfile = os.Args[1]
 var parsearg = parseArg(module, argfile)
 host := parsearg.Host
 domain := parsearg.Domain

 res, err := addLines(host, domain)
 if err != nil {
  module.Changed = false
  module.Fail = true
  module.Msg = "添加失败 " + err.Error()
  outPut(module, 2)
 }
 module.Changed = true
 module.Fail = false
 module.Msg = res
 outPut(module, 0)
}
```

注意在使用 go 语言编写自定义模块时，不可以使用打印，例如使用 fmt.Pringln 来打印一些值，这种会造成执行中断，因为这会误导 ansible，以为该模块已经执行完成，因为 ansible 会捕获标准输出。

```yaml
---
- hosts: aliyun
  remote_user: root
  tasks:
    - name: 设置hosts
      set_hosts:
        host: 3.3.3.3
        domain: www.hello.com
      sudo: yes
```

#### write 模块

在使用 golang 编写模块时，需要先编译成二进制文件

`library/write.go` 编译后 `library/write` 位置

```go
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"
)

// Response 返回值
type Response struct {
	Changed bool   `json:"changed"`
	Fail    bool   `json:"fail"`
	Msg     string `json:"msg"`
	RC      int    `json:"rc"`
}

func readJSON(f string) (string, error) {
	fh, err := os.Open(f)
	if err != nil {
		return "", err
	}
	contents, err := ioutil.ReadAll(fh)
	return string(contents), err
}

func main() {
	var f = os.Args[1]
	res := Response{}
	ff, err := os.Open(f)
	if err != nil {
		res.Changed = false
		res.Fail = true
		res.Msg = "打开参数文件" + err.Error()
		returnJSON(res, 2)
	}
	contents, err := ioutil.ReadAll(ff)
	if err != nil {
		res.Changed = false
		res.Fail = true
		res.Msg = "读取参数文件失败" + err.Error()
		returnJSON(res, 2)
	}
	var m = make(map[string]interface{})
	err = json.Unmarshal(contents, &m)
	if err != nil {
		res.Changed = false
		res.Fail = true
		res.Msg = "解析map出错" + err.Error()
		returnJSON(res, 2)
	}
	var path = m["path"]
	pathstring, _ := path.(string)
	fh, err := os.Create(pathstring)
	if err != nil {
		res.Changed = false
		res.Fail = true
		res.Msg = string(contents)
		returnJSON(res, 2)
	}
	defer fh.Close()
	var content = m["content"]
	contentstring, _ := content.(string)
	fh.Write([]byte(contentstring))
	res.Changed = true
	res.Fail = false
	res.Msg = "success"
	returnJSON(res, 0)
}

func returnJSON(res Response, status int) {
	res.RC = status
	var out io.Writer
	if status == 0 {
		out = os.Stdout
	} else {
		out = os.Stderr
	}
	contents, _ := json.Marshal(res)
	fmt.Fprint(out, string(contents))
	os.Exit(status)
}
```

```yaml
---
- name: 写入文件到服务器
  hosts: aliyun
  remote_user: root
  tasks:
    - name: 写文件
      write:
        path: /root/hello.txt
        content: Hello World
      sudo: yes
```

## 4.模块调试

### 本地调试

使用官方提供的脚本在本地运行模块。

```sh
# 根据ansible版本下载对应的脚本
wget https://raw.githubusercontent.com/ansible/ansible/devel/hacking/test-module.py
```

使下列命令运行 module

```sh
# python test-module.py -m /usr/lib/python2.7/site-packages/ansible/modules/system/ping.py
* including generated source, if any, saving to: /root/.ansible_module_generated
* ansiballz module detected; extracted module source to: /root/debug_dir
***********************************
RAW OUTPUT

{"invocation": {"module_args": {"data": "pong"}}, "ping": "pong"}


***********************************
PARSED OUTPUT
{
    "invocation": {
        "module_args": {
            "data": "pong"
        }
    },
    "ping": "pong"
}

# python test-module.py -m /usr/lib/python2.7/site-packages/ansible/modules/commands/command.py -a "/bin/sleep 3"
* including generated source, if any, saving to: /root/.ansible_module_generated
* ansiballz module detected; extracted module source to: /root/debug_dir
***********************************
RAW OUTPUT

{"changed": true, "end": "2020-04-08 23:48:57.125895", "stdout": "", "cmd": ["/bin/sleep", "3"], "rc": 0, "start": "2020-04-08 23:48:54.048553", "stderr": "", "delta": "0:00:03.077342", "invocation": {"module_args": {"creates": null, "executable": null, "_uses_shell": false, "strip_empty_ends": true, "_raw_params": "/bin/sleep 3", "removes": null, "argv": null, "warn": true, "chdir": null, "stdin_add_newline": true, "stdin": null}}}


***********************************
PARSED OUTPUT
{
    "changed": true,
    "cmd": [
        "/bin/sleep",
        "3"
    ],
    "delta": "0:00:03.077342",
    "end": "2020-04-08 23:48:57.125895",
    "invocation": {
        "module_args": {
            "_raw_params": "/bin/sleep 3",
            "_uses_shell": false,
            "argv": null,
            "chdir": null,
            "creates": null,
            "executable": null,
            "removes": null,
            "stdin": null,
            "stdin_add_newline": true,
            "strip_empty_ends": true,
            "warn": true
        }
    },
    "rc": 0,
    "start": "2020-04-08 23:48:54.048553",
    "stderr": "",
    "stdout": ""
}
```

test-module.py 使用参数

```sh
# python test-module.py --help
Usage: test-module.py -[options] (-h for help)

Options:
  -h, --help            show this help message and exit
  -m MODULE_PATH, --module-path=MODULE_PATH
                        REQUIRED: full path of module source to execute
  -a MODULE_ARGS, --args=MODULE_ARGS
                        module argument string
  -D DEBUGGER, --debugger=DEBUGGER
                        path to python debugger (e.g. /usr/bin/pdb)
  -I INTERPRETER_TYPE=INTERPRETER_PATH, --interpreter=INTERPRETER_TYPE=INTERPRETER_PATH
                        path to interpreter to use for this module (e.g.
                        ansible_python_interpreter=/usr/bin/python)
  -c, --check           run the module in check mode
  -n, --noexecute       do not run the resulting module
  -o FILENAME, --output=FILENAME
                        Filename for resulting module
```

#### 测试自己的模块

正如您所看到的，您可以通过创建非常简单的行动手册来运行它们来测试您的模块。为此，我们需要克隆 Ansible 官方存储库(如果您还没有这样做的话):

```sh
git clone git://github.com/ansible/ansible.git --recursive
```

接下来，生成一个环境文件，如下所示:

```sh
source ansible/hacking/env-setup
```

我们现在可以使用 test-module 实用程序通过传递文件名作为命令行参数来运行脚本:

```sh
ansible/hacking/test-module -m library/check_user_id.py -a "user=root"
```

结果将类似于以下输出:

```sh
* including generated source, if any, saving to: /home/fale/.ansible_module_generated
* ansiballz module detected; extracted module source to: /home/fale/debug_dir
***********************************
RAW OUTPUT

{"msg": "User root exists", "invocation": {"module_args": {"user": "root"}}, "gid": 0, "uid": 0, "changed": false}

***********************************
PARSED OUTPUT
{
    "changed": false,
    "gid": 0,
    "invocation": {
        "module_args": {
            "user": "root"
        }
    },
    "msg": "User root exists",
    "uid": 0
}
```

### 远程调试

在前面的介绍中，我们知道 modules 是在远程主机上执行的，调试模块那就需要在远程主机上执行，ansible 默认在执行完 modules，会自动清理在远程主机上的临时文件。

使用 ANSIBLE_KEEP_REMOTE_FILES=1 环境变量 ，可以保留 ansible 在远程主机的执行文件，从而在远程主机上调试模块。

```sh
# ANSIBLE_KEEP_REMOTE_FILES=1 ansible localhost -m ping -a 'data=debugging_session' -vvv
sing module file /usr/lib/python2.6/site-packages/ansible/modules/core/system/ping.py
<localhost> ESTABLISH LOCAL CONNECTION FOR USER: root
<localhost> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo ~/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932 `" && echo ansible-tmp-1489477306.61-275734926719932="` echo ~/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932 `" ) && sleep 0'
<localhost> PUT /tmp/tmpv4EenK TO /root/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932/ping.py
<localhost> EXEC /bin/sh -c 'chmod u+x /root/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932/ /root/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932/ping.py && sleep 0'
<localhost> EXEC /bin/sh -c '/usr/bin/python /root/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932/ping.py && sleep 0'
localhost | SUCCESS => {
    "changed": false,
    "invocation": {
        "module_args": {
            "data": "debugging_session"
        },
        "module_name": "ping"
    },
    "ping": "debugging_session"
}
```

模块文件是由 base64 编码的字符串文件，可使用 explode 将字符串转换成可执行的 python 文件

```sh
$ python /root/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932/ping.py explode
Module expanded into:
/root/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932/debug_dir
```

查看 debug_dir 目录

```sh
$ tree  /root/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932/debug_dir/
/root/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932/debug_dir/
├── ansible
│   ├── __init__.py
│   └── module_utils
│       ├── basic.py
│       ├── __init__.py
│       ├── pycompat24.py
│       ├── six.py
│       └── _text.py
├── ansible_module_ping.py
└── args
```

- ansible_module_ping.py 是模块本身的代码。
- args 文件包含一个 JSON 字符串。 该字符串是一个包含模块参数和其他变量的字典。
- ansible 目录包含由 ansible_module_ping 模块使用的 ansible.module_utils 的代码文件。

修改了 debug_dir 文件中的代码之后，需要使用 execute 执行代码

```sh
$ python /root/.ansible/tmp/ansible-tmp-1489477306.61-275734926719932/ping.py execute
{"invocation": {"module_args": {"data": "debugging_session"}}, "changed": false, "ping": "debugging_session"}
```

## 5.Module 的帮助文档

https://ansible.leops.cn/dev/modules/module-doc/

## 6.模块架构

https://ansible.leops.cn/dev/modules/module-architecture/#aaction-plugins

## 7.开发优秀模块的技巧和惯例

- https://docs.ansible.org.cn/ansible/latest/dev_guide/developing_modules_best_practices.html#developing-modules-best-practices

## 与社区分享模块

- 1.fork 官方 Ansible 存储库的 devel 分支。官方 Ansible 源代码存储库的 URL 是 github.com/ansible/ansible.git

- 2.创建所需的拉取请求（也称为 PRs），以便您可以将您的新模块与上游的 Ansible 项目合并：

```sh
$ git clone https://github.com/danieloh30/ansible.git
$ cp ~/ansible-development/moduledev/remote_filecopy.py ./lib/ansible/modules/files/
$ git add lib/ansible/modules/files/remote_filecopy.py
$ git commit -m 'Added tested version of remote_filecopy.py for pull request creation'
$ git push
```

- 3.在您的网络浏览器中返回 GitHub，并导航到 Pull Requests 页面。点击 New pull request 按钮。

- 4.一旦您成功提交了您的 PR，您应该能够导航到官方 Ansible 源代码存储库的 PR 列表，并在那里找到您的 PR。

- 5.等待您的 PR 审查

您可以像我们之前演示的那样，将模块代码添加到本地的 `library/` 目录中，以便您的拉取请求被处理的速度不会妨碍您使用 Ansible 的工作。

## 参考文献

成就感源于创造：自己动手写 Ansible 模块

- https://junmajinlong.github.io/ansible/16_write_ansible_module/index.html

创建自定义模块

- https://github.com/apachecn/apachecn-devops-zh-pt2/blob/master/docs/learn-ansible-27/07.md

- https://www.cnblogs.com/dogfei/p/17311919.html

- https://fldop2.flygon.net/#/docs/ext-asb/ext-asb_2

- https://fldop2.flygon.net/#/docs/ext-asb/ext-asb_3

[介绍用 golang 编写 Ansible 插件](https://github.com/hellojukay/ansible)

Ansible 模块开发-自定义模块

- https://www.cnblogs.com/biglittleant/p/12857484.html

常用模块搜索

- https://runebook.dev/zh/docs/ansible/-index-

## ansible 模块扩展

- https://github.com/ansible/ansible-modules-extras/tree/devel
