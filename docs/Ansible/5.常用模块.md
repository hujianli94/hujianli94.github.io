# 5.常用模块

## Ansible 常用模块介绍

Ansible 常用模块有很多，包括云计算、命令行、包管理、系统服务、用户管理等，可以通过[官方网站](https://docs.ansible.com/ansible/latest/module_plugin_guide/index.html)

参考：https://blog.gmem.cc/ansible-study-note

查看相应的模块，也可以在命令行下通过`ansible-doc -l`命令查看模块，或者通过`ansible-doc -s`模块名查看具体某个模块的使用方法。

```sh
# pip show ansible
Name: ansible
Version: 2.9.27
Summary: Radically simple IT automation
Home-page: https://ansible.com/
Author: Ansible, Inc.
Author-email: info@ansible.com
License: GPLv3+
Location: /usr/local/lib/python3.8/dist-packages
Requires: cryptography, jinja2, PyYAML
Required-by:
```

pip 安装的 ansible 模块安装在

`/usr/local/lib/python3.8/dist-packages/ansible/modules`

示例

```shell
# 获取所有系统模块
ansible-doc -l
ansible-doc --list
ansible-doc -s yum
ansible-doc yum
```

官网的介绍比较详细，建议查看官网介绍。“ansible-doc -l”命令部分显示结果如下所示：

```shell
.....
purestorage.flashblade.purefb_s3user                                                     Create or delete FlashBlade Object Store account users
purestorage.flashblade.purefb_smtp                                                       Configure SMTP for Pure Storage FlashBlade
purestorage.flashblade.purefb_snap                                                       Manage filesystem snapshots on Pure Storage FlashBlades
purestorage.flashblade.purefb_snmp_agent                                                 Configure the FlashBlade SNMP Agent
purestorage.flashblade.purefb_snmp_mgr                                                   Configure FlashBlade SNMP Managers
purestorage.flashblade.purefb_subnet                                                     Manage network subnets in a Pure Storage FlashBlade
purestorage.flashblade.purefb_syslog                                                     Configure Pure Storage FlashBlade syslog settings
purestorage.flashblade.purefb_target                                                     Manage remote S3-capable targets for a FlashBlade
purestorage.flashblade.purefb_timeout                                                    Configure Pure Storage FlashBlade GUI idle timeout
purestorage.flashblade.purefb_user                                                       Modify FlashBlade local user account password
purestorage.flashblade.purefb_userpolicy                                                 Manage FlashBlade Object Store User Access Policies
purestorage.flashblade.purefb_virtualhost                                                Manage FlashBlade Object Store Virtual Hosts
raw                                                                                      Executes a low-down and dirty command
reboot                                                                                   Reboot a machine
replace                                                                                  Replace all instances of a particular string in a file using a back-referenced regular expression
rpm_key                                                                                  Adds or removes a gpg key from the rpm db
script                                                                                   Runs a local script on a remote node after transferring it
sensu.sensu_go.ad_auth_provider                                                          Manage Sensu AD authent
.....
```

### ansible.builtin

在 Ansible 中，ansible.builtin 是一个特殊的关键字，用于指示 Ansible 使用其内置的核心模块。

推荐一款 vscode 插件 Ansible Core Snippets

ansible.builtin collection

```sh
ansible.builtin.add_host : add_host Add a host (and alternatively a group) to the ansible-playbook in-memory inventory
ansible.builtin.apt : apt Manages apt-packages
ansible.builtin.apt_key : apt_key Add or remove an apt key
ansible.builtin.apt_repository : apt_repository Add and remove APT repositories
ansible.builtin.assemble : assemble Assemble configuration files from fragments
ansible.builtin.assert : assert Asserts given expressions are true
ansible.builtin.async_status : async_status Obtain status of asynchronous task
ansible.builtin.blockinfile : blockinfile Insert/update/remove a text block surrounded by marker lines
ansible.builtin.command : command Execute commands on targets
ansible.builtin.copy : copy Copy files to remote locations
ansible.builtin.cron : cron Manage cron.d and crontab entries
ansible.builtin.debconf : debconf Configure a .deb package
ansible.builtin.debug : debug Print statements during execution
ansible.builtin.dnf : dnf Manages packages with the I(dnf) package manager
ansible.builtin.dpkg_selections : dpkg_selections Dpkg package selection selections
ansible.builtin.expect : expect Executes a command and responds to prompts
ansible.builtin.fail : fail Fail with custom message
ansible.builtin.fetch : fetch Fetch files from remote nodes
ansible.builtin.file : file Manage files and file properties
ansible.builtin.find : find Return a list of files based on specific criteria
ansible.builtin.setup : setup Gathers facts about remote hosts
ansible.builtin.get_url : get_url Downloads files from HTTP, HTTPS, or FTP to node
ansible.builtin.getent : getent A wrapper to the unix getent utility
ansible.builtin.git : git Deploy software (or files) from git checkouts
ansible.builtin.group : group Add or remove groups
ansible.builtin.group_by : group_by Create Ansible groups based on facts
ansible.builtin.hostname : hostname Manage hostname
ansible.builtin.import_playbook : import_playbook Import a playbook
ansible.builtin.import_role : import_role Import a role into a play
ansible.builtin.import_tasks : import_tasks Import a task list
ansible.builtin.include_role : include_role Load and execute a role
ansible.builtin.include_tasks : include_tasks Dynamically include a task list
ansible.builtin.include_vars : include_vars Load variables from files, dynamically within a task
ansible.builtin.iptables : iptables Modify iptables rules
ansible.builtin.known_hosts : known_hosts Add or remove a host from the C(known_hosts) file
ansible.builtin.lineinfile : lineinfile Manage lines in text files
ansible.builtin.meta : meta Execute Ansible 'actions'
ansible.builtin.package : package Generic OS package manager
ansible.builtin.package_facts : package_facts Package information as facts
ansible.builtin.pause : pause Pause playbook execution
ansible.builtin.ping : ping Try to connect to host, verify a usable python and return C(pong) on success
ansible.builtin.pip : pip Manages Python library dependencies
ansible.builtin.raw : raw Executes a low-down and dirty command
ansible.builtin.reboot : reboot Reboot a machine
ansible.builtin.replace : replace Replace all instances of a particular string in a file using a back-referenced regular expression
ansible.builtin.rpm_key : rpm_key Adds or removes a gpg key from the rpm db
ansible.builtin.script : script Runs a local script on a remote node after transferring it
ansible.builtin.service : service Manage services
ansible.builtin.service_facts : service_facts Return service state information as fact data
ansible.builtin.set_fact : set_fact Set host variable(s) and fact(s).
ansible.builtin.set_stats : set_stats Define and display stats for the current ansible run
ansible.builtin.shell : shell Execute shell commands on targets
ansible.builtin.slurp : slurp Slurps a file from remote nodes
ansible.builtin.stat : stat Retrieve file or file system status
ansible.builtin.subversion : subversion Deploys a subversion repository
ansible.builtin.systemd_service : systemd_service Manage systemd units
ansible.builtin.sysvinit : sysvinit Manage SysV services.
ansible.builtin.tempfile : tempfile Creates temporary files and directories
ansible.builtin.template : template Template a file out to a target host
ansible.builtin.unarchive : unarchive Unpacks an archive after (optionally) copying it from the local machine
ansible.builtin.uri : uri Interacts with webservices
ansible.builtin.user : user Manage user accounts
ansible.builtin.validate_argument_spec : validate_argument_spec Validate role argument specs.
ansible.builtin.wait_for : wait_for Waits for a condition before continuing
ansible.builtin.wait_for_connection : wait_for_connection Waits until remote system is reachable/usable
ansible.builtin.yum : yum Manages packages with the I(yum) package manager
ansible.builtin.yum_repository : yum_repository Add or remove YUM repositories
```

1.Playbooks 和 Roles 中的任务定义：

```yaml
- name: Ensure nginx is installed
  ansible.builtin.yum:
    name: nginx
    state: present
  become: yes
```

2.模块调用：

```sh
ansible all -m ansible.builtin.shell -a 'echo hello'
```

3.动态生成变量：

```yaml
- name: Get disk usage
  ansible.builtin.shell:
    cmd: df -h /
  register: disk_usage

- debug:
    msg: "Disk usage: {{ disk_usage.stdout }}"
```

## 运维常用模块示例

下面介绍运维工作中经常用到的几个模块，其他模块不再逐一介绍，建议大家参考官文档。

- local_action 模块
- ping 模块
- debug 模块
- copy 模块
- fetch 模块
- authorized_key 模块
- synchronize 模块
- template 模块
- file 模块
- user 模块
- yum 模块
- apt 模块
- package 模块
- apt_key 模块
- apt_repository 模块
- yum_repository 模块
- service 模块
- shell 模块
- command 模块
- git 模块
- set_fact 模块
- systemd 模块
- modprobe 模块
- setup 模块
- group 模块
- script 模块
- get_url 模块
- cron 模块
- lineinfile 模块
- replace 模块

Ansible 命令行调用模块的语法格式如下所示：

```shell

ansible 操作目标 -m 模块名 -a 模块参数
```

### ping

ping 模块，其可用于检测与被控端机器的连通性，命令如下：

测试一个节点有没有配置好，执行检查：

- 能不能 SSH 登陆
- python 版本是否满足需求

> 没有参数

```shell
ansible all -m ping
```

### debug

打印调试信息，类似于 echo。支持变量替换

```sh
ansible -m debug -a "var=hostvars[inventory_hostname]"
```

```yaml
---
- hosts: k8s
  tasks:
    - name: test
      debug:
        msg: "{{ inventory_hostname }} has gateway {{ ansible_default_ipv4.gateway }}"
        # 也可以打印变量
        var: hostvars[inventory_hostname]["ansible_default_ipv4"]["gateway"]
```

### local_action

当你想委托一个任务在本地机器上运行时，local_action 模块很有用。你可以用 Ansible 模块或者 shell 命令来使用它。

```yaml
- name: Run a local command
  hosts: all
  tasks:
    - name: Backup a file from the remote server to the local machine
      copy:
        src: /path/to/remote/file
        dest: /path/to/local/backup
      register: backup_result

    - name: Log the backup result on the local machine
      local_action:
        module: command
        args: echo "Backup result: {{ backup_result }}"
```

参考文献

https://juejin.cn/post/7122350498732048397

### setup

(1)功能

setup 模块来收集主机的系统信息，这些 facts 信息可以直接以变量的形式使用，但是如果主机较多，会影响执行速度，可以使用 gather_facts: no 来禁止 Ansible 收集 facts 信息

`ansible-doc -s setup`

默认情况下，playbook 的第一个任务就是 Facts 信息，显示的结果如下:

```shell
PLAY [192.168.77.130] ******************************************
TASK [Gathering Facts] ****************************************************************
ok: [192.168.77.130]
TASK [test] ****************************************************
changed: [192.168.77.130]
```

如果要关闭 playbook 的这一操作，就需要为 play 添加 gather_facts 关键字

```yml
# 关闭关闭自动采集Facts
- hosts: whatever
  gather_facts: no
```

(2) 举例

```shell
# 查看已经安装的东西
ansible all  -m setup

# 查看所有节点的ansible_python的版本
ansible all  -m  setup -a 'filter=ansible_python_version'
```

### copy

(1)功能

Ansible 中的 copy 模块用于实现文件复制和批量下发文件，src 来定义本地源文件路径，使用 dest 定义被管理主机文件路径，使用 content 定义信息内容来生成目标文件

该模块可实现 Ansible 主机向客户端传送文件的功能，文件的变化是通过 md5 值来判断的，大家需要记住应提前关闭客户端机器的 SELinux。

`ansible-doc -s copy`

(2) 举例

```shell
src: # 源文件  指定拷贝文件的本地路径  (如果有/ 则拷贝目录内容,比拷贝目录本身)
dest: # 指定目标路径
mode: # 设置权限
  backup: # 备份源文件
  content: # 代替src  指定本机文件内容,生成目标主机文件
```

```shell
# 进行复制dest=/tmp/test.txt"
ansible webserver -m copy -a "content='test content\nxxx' dest=/tmp/test.txt"


# 进行查看
ansible webserver  -a "cat /tmp/test.txt"



ansible webservers -m copy -a "src=/home/test.sh dest=/tmp/ owner=root group=root mode=0755"
ansible dbservers -m copy -a 'src=/etc/fstab dest=/tmp/fstab.ansible owner=root mode=640'

#将“Hello Ansible Hi Ansible”写入管理主机的/tmp/test.ansible文件中
ansible dbservers -m copy -a 'content="Hello Ansible Hi Ansible" dest=/tmp/test.ansible'

# 拷贝是设置权限，force强制覆盖，默认。 backup参考，拷贝覆盖前进行备份
ansible webserver -m copy -a "src=/usr/local/src/test.py dest=/tmp/owner=root group=root mode=0755 force=yes"

ansible web -m copy -a "src=/mine/ntp.conf dest=/etc/ntp.conf owner=root group=root mode=644 backup=yes force=yes"
```

```yaml
- name: copy demo within a remote host
  copy:
    src: /srv/myfiles/foo.conf
    dest: /etc/foo.conf
    owner: foo
    group: foo
    mode: 0644
    # 备份被替换的文件
    backup: yes

- name: copy file from within a remote host
  copy:
    src: /usr/local/script.py
    dest: /home/user1/script.py
    remote_src: yes
    owner: user1
    group: developers
    mode: 0755
```

### fetch

从远程主机获取文件到管理节点，但是不支持目录操作

该模块的工作原理与 ansible.builtin.copy 类似，但方向相反。
它用于从远程计算机获取文件并将它们本地存储在按主机名组织的文件树中。
如果 dest 中已存在的文件与 src 不同，则它们将被覆盖。
Windows 目标也支持此模块。

```sh
ansible all -m fetch -a "src=/etc/yum.repos.d/epel.repo dest=/usr/local/src"
```

```yaml
- name: Store file into /tmp/fetched/host.example.com/tmp/somefile
  ansible.builtin.fetch:
    src: /tmp/somefile
    dest: /tmp/fetched

- name: Specifying a path directly
  ansible.builtin.fetch:
    src: /tmp/somefile
    dest: /tmp/prefix-{{ inventory_hostname }}
    flat: yes

- name: Specifying a destination path
  ansible.builtin.fetch:
    src: /tmp/uniquefile
    dest: /tmp/special/
    flat: yes

- name: Storing in a path relative to the playbook
  ansible.builtin.fetch:
    src: /tmp/uniquefile
    dest: special/prefix-{{ inventory_hostname }}
    flat: yes
```

### authorized_key

用来配置密钥实现免密登录:

ansible 所在的主控机生成密钥后，如何把公钥上传到受控端？

当然可以用 ssh-copy-id 命令逐台手动处理，如果受控端机器数量不多当然没问题，

但如果机器数量较多，有几十几百台时，手动处理的效率就成为问题。

authorized_key 模块就用来把公钥上传到各台服务器实现免密登录

authorized_key 的使用例子:

生成密钥:

```sh
ssh-keygen -t rsa
```

在`hosts`中增加一个段：

```sh
[ils]
121.122.123.87:12888 ansible_ssh_user=webop ansible_ssh_pass="weboppass"
121.122.123.88:12888 ansible_ssh_user=webop ansible_ssh_pass="weboppass"
121.122.123.89:12888 ansible_ssh_user=webop ansible_ssh_pass="weboppass"
```

修改 ansible 的配置文件:

```sh
# vi /etc/ansible/ansible.cfg
# 把这一行的注释去掉:
# 用来禁止ssh的指纹key字串检查
host_key_checking = False
```

```sh
[root@centos8 ~]# ansible ils -m authorized_key -a "user=webop state=present key='{{ lookup('file', '/home/liuhongdi/.ssh/id_rsa.pub') }}'"
# 121.122.123.87 | CHANGED => {

# 手动测试一下：看ssh到目标服务器是否还需要输入密码？

[root@centos8 ~]# ssh -p 12888 webop@121.122.123.87
```

playbook 示例

```yaml
- hosts: test
  gather_facts: false

tasks:
  # 初始化rsync模块的ssh免登录key
  - name: add authorized_keys
    authorized_key:
      user: "{{ ansible_user_id }}"
      key: "{{ lookup('file', '/home/jenkins/.ssh/id_rsa.pub') }}"
      state: present
      exclusive: no


  - name: deliver authorized_keys
    authorized_key:
      user: root
      key: "{{ lookup('file', '/etc/ansible/roles/authorized_keys') }}" # 从本地authorized_keys文件读取公钥内容
      state: present
      exclusive: no
```

设置一个新的授权密钥：

```yaml
- name: add a new authorise SSH key to the user install
  authorized_key:
    user: install
    state: present
    key: "{{ lookup('file', '/home/install/.ssh/id_rsa.pub') }}"
```

### synchronize

(1)功能

由于 synchronize 模块会调用 rsync 命令，因此首先要记得提前安装好 rsync 软件包，不然执行的时候会出现`"msg":"[Errno2]No such file or directory'"`这种报错信息。

`ansible-doc -s synchronize`

功能与优势:
Synchronize 模块支持双向同步，可以推送（push）从控制节点到远程主机，或者拉取（pull）从远程主机到控制节点。
该模块具有高度的灵活性，允许用户指定源路径（src）和目标路径（dest），以满足不同的同步需求。
支持使用 delegate_to 参数进行间接同步，即通过一个中间主机来同步数据到另一台主机。

同步当前机器上的目录到远程节点：

(2)举例

synchronize 模块用于将 Ansible 机器的指定目录推送(push)到客户机器的指定目录下，命令如下：

```shell
ansible 192.168.1.206 -m synchronize -a "src=/usr/local/src/ dest=/usr/local/ src/delete=yes compress=yes
```

其中，delete=-yes 用来实现使两边的内容一样(即以 push 方式为主)，实现效果与`rsync-delete`一样，
如果是客户端不存在的文件或目录则增补，如果存在着不同的文件或目录则删除，以保证两边内容一致。

compress=yes 用于开启压缩，默认为开启。

另外，由于 synchronize 模块调用的是 rsync 命令，因此如果路径使用“/”来结尾，则只复制目录里的内容，如果没有使用“/”来结尾，则包含目录在内的整个内容全部都要复
制过去(源目标目录作为目的目录的一个子目录存在)。

同步本地文件到远程主机

```sh
ansible <inventory_group> -m synchronize -a "src=/path/to/local/file dest=/path/on/remote/file mode=push"
```

同步远程文件到本地

```sh
ansible <inventory_group> -m synchronize -a "src=/path/on/remote/file dest=/path/to/local/file mode=pull"
```

```yaml
---
- name: Synchronize files or directories
  hosts: all
  tasks:
    - name: Synchronize directory from local to remote
      synchronize:
        src: /path/to/local/directory
        dest: /path/to/remote/directory
        mode: push

    - name: Synchronize directory from remote to local
      synchronize:
        src: /path/to/remote/directory
        dest: /path/to/local/directory
        mode: pull
```

示例代码

```yaml

- hosts: all
  tasks:
    # 在 Playbook 中，可以定义同步任务，使用 synchronize 模块来实现文件或目录的推送（push）或拉取（pull）操作。默认是push
    - name: Synchronize configuration file (push)
      synchronize:
        src: /path/to/local/config
        dest: /path/to/remote/config
        # mode: push

    - name: Synchronization using rsync protocol on delegate host (pull)
      ansible.posix.synchronize:
        mode: pull
        src: rsync://somehost.com/path/
        dest: /some/absolute/path/
      delegate_to: delegate.host


    # 设置同步操作的超时时间
    - name: Synchronize with custom rsync timeout
      synchronize:
        src: /path/to/local/large/config/
        dest: /path/to/remote/config/
        rsync_opts: "--timeout=300"

    # 启用压缩的配置文件同步
    - name: Synchronize configuration files with compression
      synchronize:
        src: /path/to/local/config/
        dest: /path/to/remote/config/
        compress: yes

    # 保持文件权限和所有权
    - name: Synchronize configuration files with preserved permissions and ownership
      synchronize:
        src: /path/to/local/config.file
        dest: /path/to/remote/config.file
        archive: yes

    # 使用delegate_to在远程主机间同步
    - name:  Synchronization using rsync protocol on delegate host (push)
      ansible.posix.synchronize:
        src: /some/absolute/path/
        dest: rsync://somehost.com/path/
      delegate_to: delegate.host

    # 同步两个路径，其中一个在本地控制节点上
    - name: Synchronization of two paths both on the control machine
      ansible.posix.synchronize:
        src: some/relative/path
        dest: /some/absolute/path
      delegate_to: localhost

    # 初始化rsync模块的ssh免登录key
    - name: add authorized_keys
      authorized_key:
          user: "{{ ansible_user_id }}"
          key: "{{ lookup('file', '/home/jenkins/.ssh/id_rsa.pub') }}"
          state: present
          exclusive: no

    # 使用rsync模块将Nginx配置文件同步到目标机器
    - name: check rsync_opts rsync dir
      synchronize:
          src: "{{ work }}/"
          dest: "{{ confdir }}"
          delete: yes
          copy_links: yes
          private_key: "/home/jenkins/.ssh/id_rsa"
          rsync_opts: "{{ rsync_opts }}"
        register: rsync_result

    # 输出rsync的执行详情
    - debug: msg="{{ rsync_result.stdout_lines }}"


# 该特定命令被授予目标上的 su 权限
- name: Synchronize using an alternate rsync command
  ansible.posix.synchronize:
    src: some/relative/path
    dest: /some/absolute/path
    rsync_path: su -c rsync

# 源目录中的示例 .rsync-filter 文件
# - var # 排除最后一部分为 'var' 的任何路径
# - /var # 排除从源目录开始的任何以 'var' 开头的路径
# + /var/conf # 包含 /var/conf，即使它之前已被排除
- name: Synchronize passing in extra rsync options
  ansible.posix.synchronize:
    src: /tmp/helloworld
    dest: /var/www/helloworld
    rsync_opts:
      - "--no-motd"
      - "--exclude=.git"

# 硬链接文件（如果它们没有改变）
- name: Use hardlinks when synchronizing filesystems
  ansible.posix.synchronize:
    src: /tmp/path_a/foo.txt
    dest: /tmp/path_b/foo.txt
    link_dest: /tmp/path_a/

# 指定要在远程主机和本地主机上使用的 rsync 二进制文件
- hosts: groupofhosts
  vars:
    ansible_rsync_path: /usr/gnu/bin/rsync

  tasks:
    - name: copy /tmp/localpath/ to remote location /tmp/remotepath
      ansible.posix.synchronize:
        src: /tmp/localpath/
        dest: /tmp/remotepath
        rsync_path: /usr/gnu/bin/rsync


# 定期同步任务
- hosts: all
  tasks:
    - name: Schedule periodic synchronization
      cron:
        name: Periodic config sync
        job: "ansible-playbook sync.yml"
        minute: "0"
        hour: "2"
```

更多参考：

- https://www.oryoy.com/news/ansible-pei-zhi-wen-jian-tong-bu.html

### template

从当前的机器上复制文件到远程节点上，并进行变量替换。变量使用 {{ }}包围。示例：

```yaml
- template:
    src: etc/ssh/sshd_config.j2
    dest: /etc/ssh/sshd_config.j2
    owner: root
    group: root
    mode: "0600"
    # 校验拷贝的文件是否有效
    validate: /usr/sbin/sshd -t %s
    backup: yes
```

### file

(1)功能

Ansible 中使用 file 模块来设置文件属性，path 指定文件路径，sec 指定源文件路径，使用 name 或 dest 来替换创建文件的符号链接

`ansible-doc -s file`

(2)举例

```shell
# 更改文件的用户及权限
ansible web -m file -a "dest=/tmp/a.txt mode=600 owner=user group=user"


# 创建目录，类似mkdir -p
ansible web -m file -a "dest=/tmp/test mode=755 owner=user group=user state=directory"


# 删除文件或者目录
ansible web -m file -a "dest=/tmp/test state=absent"


# 创建软连接，并设置所属用户和用户组
ansible web -m file -a  "src=/file/to/link/to dest=/path/to/symlink owner=user group=user state=link"


# touch 一个文件并添加用户读写权限，用户组去除写执行权限，其他组减去读写执行权限
ansible web -m file -a  "path=/etc/foo.conf state=touch mode='u+rw,g-wx,o-rwx'"


ansible webserver -m file -a 'path=/app/test.txt state=touch'       #创建文件
ansible webserver -m file -a "path=/data/testdir state=directory"   #创建目录
ansible webserver -m file -a "path=/root/test.sh owner=wang mode=755"  #设置权限755
ansible webserver -m file -a 'src=/data/testfile dest=/data/testfile-link state=link' #创建软链接
```

```yaml
# 修改文件模式
- file:
    path: /etc/foo.conf
    owner: foo
    group: foo
    mode: 0644
    mode: "u=rw,g=r,o=r"
    mode: "u+rw,g-wx,o-rwx"

# 创建软链接
- file:
    src: /file/to/link/to
    dest: /path/to/symlink
    owner: foo
    group: foo
    state: link

# 创建新文件
- file:
    path: /etc/foo.conf
    state: touch
    mode: "u=rw,g=r,o=r"

# 创建目录
- file:
    path: /etc/some_directory
    state: directory
    mode: 0755

# 文件模块基本上是管理一切与文件和文件夹组织有关的工具，包括创建、删除、符号链接创建、权限和所有权。
- name: create a file with some specific acl
  file:
    path: /usr/local/script.py
    state: touch
    owner: user1
    group: developers
    mode: 0755

- name: change acl of a file
  acl:
    path: /usr/local/script.py
    entity: user2
    permission: w
    state: present
```

### user

(1)功能

Ansible 中的 user 模块用于创建新用户和更改、删除已存在的用户。其中 name 选项用来这么创建的用户名称。

增、删、改 Linux 远程节点的用户账户，并为其设置账户的属性。示例：

远程主机系统用户管理。

`ansible-doc -s user`

(2)示例

```shell
#创建用户
ansible dbservers -m user -a 'name="user1"'

#该场景中我们可以掌握如下技能点。
# 1）groups设定：groups=用户组1，用户组2……
# 2）增量添加属组：append=yes
# 3）表明属组状态为新建：state=present

ansible db -m user -a "name=dba shell=/bin/bash groups=admins,dbagroup append=yes home=/home/dba/ state=present"

#设置系统用户tom的密码为redhat123。
ansible db -m user -a "name=tom shell=/bin/bash password=to46pW3GOukvA update_password=always"

#删除用户
ansible dbservers -m user -a 'name="user1" state=absent'
ansible db -m user -a "name=dba state=absent remove=yes"



######## windows 用户管理 ###########

#新增用户stanley，密码为magedu@123，属组为Administrators。
ansible windows -m win_user -a "name=stanley passwd=magedu@123 group=Administrators"

######## 应用层用户管理 ####################

#新增MySQL用户stanley，设置登录密码为magedu@bj，对zabbix.*表有ALL权限
ansible db -m mysql_user -a 'login_host=localhost login_password=magedu login_user=root name=stanley password=magedu@bj priv=zabbix.*:ALL state=present'
```

```yaml
# 创建账户
- user:
    name: johnd
    comment: "John Doe"
    uid: 1040
    group: admin
# 删除账户
- user:
    name: johnd
    state: absent
    remove: yes

# 修改属性
- user:
    name: jsmith
    #创建SSH 私钥
    generate_ssh_key: yes
    ssh_key_bits: 2048
    ssh_key_file: .ssh/id_rsa

- user:
    name: james18
    shell: /bin/zsh
    groups: developers
    # 设置账户过期时间
    expires: 1422403387
```

### group

(1)功能

Ansible 中的 group 模块用于对用户组进行管理

`ansible-doc -s group`

（2）例子

```shell
# 创建mysql组，将mysql用户添加到mysql组中
ansible dbservers -m group -a 'name=mysql gid=306 system=yes'
ansible dbservers -m user -a 'name=mysql uid=306 system=yes group=mysql'

# 创建一个组名为test gid为2018的组
ansible webserver -m group -a gid=2018 name='test'

# 查看创建的组
ansible webserver -m shell -a 'cat /etc/group|grep test'

```

注意这里使用了 shell 模块，没有使用默认的 command 模块，

ansible 的默认模块 command，它不会通过 shell 进行处理，所以像`$HOME`和像`“<”，“>”，“|”，“;”`和`“＆”`将不工作。

### yum

Ansible 中的 yum 模块负责在被管理的主机数安装与卸载软件包，前提是在每个节点配置自己的 YUM 仓库，name 指定要安装的软件包

带上软件包的版本号，state 指定安装软件包的状态，present、latest 用来表示安装，absent 表示卸载

`ansible-doc -s yum`

(1) 功能

用来管理 Redhat 系（RHEL，CentOS，Fedora 21-）的 Linux 上的安装包。示例：

(2) 例子

```shell
# 安装zsh软件包
ansible dbservers -m yum -a 'name=zsh'

# 卸载zsh软件包
ansible dbservers -m yum -a 'name=zsh,state=absent'

ansible webservers -m yum -a "name=curl state=latest"

#Redis安装命令：
ansible db-m yum -a "name=redis state=present"。

#Redis安装检查：
ansible db-m command -a "redis-cli--version"。

# 安装MariaDB-server
ansible db -m yum -a "name=MariaDB-server state=present"

# #安装MySQL-python和python-setuptools依赖包。
ansible app -m yum -a "name=MySQL-python state=present"
ansible app -m yum -a "name=python-setuptools state=present"
```

```yaml
- name: 安装最新版本的包，已经安装则替换老版本
    yum:
      name: httpd
      state: latest

- name: 安传个指定版本
    yum:
      name: httpd-2.2.29-1.4.amzn1
      state: present

- name: 删除软件包
    yum:
      name: httpd
      state: absent
- name: 从本地目录安装
  yum:
    name: /usr/local/src/nginx-release-centos-6-0.el6.ngx.noarch.rpm
    state: present
```

### apt

用来管理 Debain 系 Linux 上的软件包。示例：

```shell
# 更新仓库缓存，并安装"curl"
ansible webservers -m apt -a "name=curl update_cache=yes"

## 安装
ansible webservers -m apt -a "pkg=curl state=present"

# 安装最新得"curl"
ansible all -m apt -a "name=curl state=latest"

## 删除
ansible webservers -m apt -a "pkg=curl state=absent"
```

```yaml
- name: 更新仓库缓存并安装软件包foo
  apt:
    name: foo
    update_cache: yes

- name: 安装软件包但是不启动
  apt: name=apache2 state=present
  environment:
    RUNLEVLEL: 1
    http_proxy: http://10.0.0.1:8088
- name: 移除软件包
  apt: name=foo state=absent

- name: 安装指定版本的软件包
  apt:
    name: foo=1.00
    state: present

- name: 更新所有软件包到最新版本
  apt:
    upgrade: dist

- name: 仅仅执行apt-get update
  apt:
    update_cache: yes

- name: 安装Deb包
  apt:
    deb: /tmp/mypackage.deb

- name: 安装foo包的build依赖
  apt:
    pkg: foo
    state: build-dep

- name: 移除无用依赖包
  apt:
    autoremove: yes

- name: 安装多个软件包
  apt: name={{item}} state=installed
  with_items:
    - kubelet
    - kubectl
```

### package

通用的包管理器，使用底层的操作系统包管理器来安装、删除、升级软件包

```yaml
# 确保软件包安装
- name: Install ntpdate
  package:
    name: ntpdate
    state: present

# 确保软件包移除
- name: Remove the apache package
  package:
    name: "{{ apache }}"
    state: absent

# 确保软件包是最新版本
- name: Install the latest version of Apache and MariaDB
  package:
    name:
      - httpd
      - mariadb-server
    state: latest
```

### apt_key

添加或者删除 APT key。示例：

```yaml
- name: 从Key服务器添加一个Key
  apt_key:
    keyserver: keyserver.ubuntu.com
    id: 36A1D7869245C8950F966E92D8576A8BA88D21E9

- name: 从URL添加Key
  apt_key:
    url: https://ftp-master.debian.org/keys/archive-key-6.0.asc
    state: present
```

### apt_repository

管理 APT 仓库。示例：

```yaml
- name: Add an Apt signing key, will not download if present
  # 添加指定的仓库到系统源列表
  - apt_repository:
      repo: deb http://archive.canonical.com/ubuntu hardy partner
      state: present

  # 添加指定的仓库到系统源列表，存放在指定的文件中
  - apt_repository:
      repo: deb http://dl.google.com/linux/chrome/deb/ stable main
      state: present
      filename: google-chrome

  # 移除指定的仓库
  - apt_repository:
      repo: deb http://archive.canonical.com/ubuntu hardy partner
      state: absent

  # 从PPA安装仓库
  - apt_repository:
      repo: ppa:nginx/stable
```

### yum_repository

在基于 RPM 的 Linux 发行版中添加或删除 YUM 存储库。

```yaml
# 添加Nginx yum安装源
- name: add repo
  yum_repository:
    name: nginx
    description: nginx repo
    baseurl: http://nginx.org/packages/centos/7/$basearch/
    gpgcheck: no
    enabled: 1

- name: Add repository
  yum_repository:
    name: epel
    description: EPEL YUM repo
    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/
```

### service

(1) 功能
管理远程节点上的服务。示例：

`ansible-doc -s service`

在 Ansible 中使用 service 模块来控制管理服务器的运行状态，enable 表示是否开机自启动， 值为 true 或者 false，

使用 name 来定义服务名称使用 state 指定服务状态，取值为 started、stoped、restarted

(2) 示例

```shell
ansible webservers -m service -a "name=nginx state=stopped"
ansible webservers -m service -a "name=nginx state=restarted"
ansible webservers -m service -a "name=nginx state=reloaded"

#安装httpd服务
ansible webservers -m yum -a "name=httpd state=latest"

#查看httpd服务的状态
ansible dbservers -a 'service httpd status'
#查看http服务开机启动状态
ansible dbservers -a 'chkconfig httpd status'

#设置httpd服务为开机自启动
ansible dbservers -m service -a 'enable=ture name=httpd state=started'

ansible webservers -m service -a "name=nginx state=stopped"
ansible webservers -m service -a "name=nginx state=restarted"
ansible webservers -m service -a "name=nginx state=reloaded"
```

```yaml
# 开服务
- service:
    name: httpd
    state: started
# 关服务
- service:
    name: httpd
    state: stopped
# 重起服务
- service:
    name: httpd
    state: restarted
# 重载服务
- service:
    name: httpd
    state: reloaded
# 设置开机启动
- service:
    name: httpd
    enabled: yes
```

### command

重启服务器

```shell
ansible servers -a "reboot"
```

不指定-m 模块时，将使用 ansible 的默认模块 command，它不会通过 shell 进行处理，所以像$HOME 和像`“<”，“>”，“|”，“;”`和`“＆”`将不工作

默认情况下，Ansible 使用 5 个并发进程。 如果你要扩大并发，使用-f 10 参数指定数量即可。

```shell
ansible servers -a "reboot" -f 10
```

默认情况下，Ansible 连接远端用户是当前用户，使用-u 参数可以修改

```shell
ansible servers -a "reboot" -f 10 -u root
```

如果运行用户没有权限执行，使用--become 可以提升权限,默认是 sudo 方式

```shell
ansible servers -a "reboot" -f 10 -u root --become
ansible servers -a "reboot" -f 10 -u test --become --become-method sudo --become-user root --ask-become-pass
```

- `--become-method` 指定提升方式
- `--become-user` 指定提升用户
- `--ask-become-pass` 告知提升密码

我们将运行一个命令，然后收集其输出以供以后使用：

```yaml
- name: run a simple command
  command: cat ~/raw.txt
  register: rawtxt

- debug: var=rawtxt.stdout
```

### shell

通过/bin/sh 在远程节点上执行命令，支持$HOME 和”<”, “>”, “|”, “;” and “&”。示例：

(1) 功能

command 模块作为 Ansible 的默认模块，可以运行被控端机器权限范围内的所有 shell 命令，前面已多次提到，这里不再重复。

而 shell 模块用于执行被控端机器的 Shell 脚本文件，与另一个模块 raw 的功能类似，并且支持管道符。

`ansible-doc -s shell`

(2) 示例

获取 web 组里得 eth0 接口信息

```shell
ansible web -m shell -a "ifconfig eth0|grep addr"
```

```yaml
- name: test $home
  shell: echo "Test" > ~/tmp/test

# 多行命令
- hosts: k8s
  tasks:
    - name: Pull images
      shell: |
        docker pull $IMAGE_REPO/kube-apiserver-amd64:v1.10.2
        docker pull $IMAGE_REPO/kube-scheduler-amd64:v1.10.2
      args:
        # 指定工作目录
        chdir: somedir/
        # 指定使用的脚本解析器
        executable: /bin/bash

    # 您可以使用 shell 运行其他可执行文件来执行内联操作
    - name: Run expect to wait for a successful PXE boot via out-of-band CIMC
      ansible.builtin.shell: |
        set timeout 300
        spawn ssh admin@{{ cimc_host }}

        expect "password:"
        send "{{ cimc_password }}\n"

        expect "\n{{ cimc_name }}"
        send "connect host\n"

        expect "pxeboot.n12"
        send "\n"

        exit 0
      args:
        executable: /usr/bin/expect
      delegate_to: localhost

    # 它不仅允许您运行命令，还可以运行 shell 脚本，并允许您指定工作目录和要执行命令行的 bash 的位置。
    - name: run a simple shell script
      shell: ./shell_script.sh >> ~/shell.txt
      args:
        chdir: /usr/local/
        creates: ~/shell.txt
        executable: /bin/csh
```

### raw

如果说远程主机没有 python 模块时，可以使用 raw 模块执行命令

```shell
ansible web -m raw -a "ifconfig eth0|grep addr"
```

### git

下载 Git 仓库的内容到指定位置：

```sh
ansible webservers -m git -a "repo=git://foo.example.org/repo.git dest=/srv/myapp version=HEAD"
```

```yaml
- name: clone Ansible from github
  git:
    repo: https://github.com/ansible/ansible.git
    dest: /usr/local/ansible
    clone: yes
    update: yes
```

### scritp

(1) 功能
script 模块用于在远程被控端主机执行本地 Ansible 机器中的 Shell 脚本文件，相当于"scp+shell"的组合命令。

(2) 示例

```shell
# 执行脚本
ansible all -m script -a '/root/time.sh'

ansible webserver -m script -a 'data/test.sh'

ansible webserver -m script -a "/root/print_hello.sh"
```

```yaml
- name: "使版本目录保持五个版本历史"
  script: chdir=/release/{{project}} keepfive.sh

- name: "执行自由脚本"
  script: chdir=/release/{{project}} free.sh
  tags: deploy

# 该模块支持运行其他类型的脚本，例如 Python、Perl 或 Ruby。看一下以下示例 playbook
- name: execute a script on a remote host
  script: ./shell_script.py –some-argumets "42"
  args:
    creates: ~/shell.txt
    executable: python
```

### set_fact

使用该模块，可以设置 per-host 的变量（事实）。

这些变量可以被当前 ansible-playbook 调用的、后续的 play 使用

如果设置 cacheable 为 yes，则记录在缓存中，允许后续 playbook 调用使用

```yaml
- name: "设置多个变量，用空格分隔"
  set_fact: one_fact="something" other_fact="{{ local_var }}"

- name: "另外一种多变量设置风格"
  set_fact:
    one_fact: something
    other_fact: "{{ local_var * 2 }}"
    another_fact: "{{ some_registered_var.results | map(attribute='ansible_facts.some_fact') | list }}"

- name: "允许缓存变量"
  set_fact:
    one_fact: something
    other_fact: "{{ local_var * 2 }}"
    cacheable: yes
```

以下示例显示了如何使用 set_fact 来配置 MySQL 服务器，使其具有大约机器上可用总内存的一半的 InnoDB 缓冲区大小：

```yaml
---
- name: Configure MySQL
  hosts: mysqlservers
  tasks:
    - name: install MySql
      yum:
        name: mysql-server
        state: installed

    - name: Calculate InnoDB buffer pool size
      set_fact: innodb_buffer_pool_size_mb="{{ansible_memtotal_mb/2}}"

    - name: Configure MySQL
      template:
        src: templates/my.cnf.j2
        dest: /etc/my.cnf
        owner: root
        group: root
        mode: 0644
      notify: restart mysql

    - name: Start MySQL
      service:
        name: mysqld
        state: started
        enabled: yes

  handlers:
    - name: restart mysql
      service:
        name: mysqld
        state: restarted
```

然后模板只需要获取 `innodb_buffer_pool_size` 的值并将其放入配置中。

这意味着我们可以在缓冲池应该是内存的五分之一或八分之一的地方重复使用相同的模板，并简单地更改那些主机的 playbook。在这种情况下，模板将看起来像以下代码片段：

`my.cnf.j2`

```
# {{ ansible_managed }}
[mysqld]
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
# Settings user and group are ignored when systemd is used.
# If we need to run mysqld under a different user or group,
# customize our systemd unit file for mysqld according to the
# instructions in http://fedoraproject.org/wiki/Systemd

# Configure the buffer pool
innodb_buffer_pool_size = {{ innodb_buffer_pool_size_mb|default(128) }}M

[mysqld_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
```

### get_url

(1) 功能

实现在远程主机下载指定 URL 到本地，支持 sha256sum 文件校验

从 HTTP、HTTPS 或 FTP 下载文件到远程服务器。远程服务器必须能够直接访问远程资源。

(2) 例子

```shell
#范例1：下载互联网的软件至本地
[root@manger ~]# ansible webservers -m get_url -a "url=https://mirrors.aliyun.com/xx.rpm dest=/tmp"


# 范例2：下载互联网文件并进行 md5 校验
[root@manger ~]# ansible webservers -m get_url -a "url=http,https dest=/opt checksum=md5:76eb3af80ffd"


ansible webservers -m get_url -a "url=http://www.baidu.com dest=/tmp/index.html mode=0440 force=yes"
```

```yaml
- name: Download file with check (sha256)
  get_url:
    url: http://example.com/path/file.conf
    dest: /etc/foo.conf
    checksum: sha256:b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c

- name: Download file with check (md5)
  get_url:
    url: http://example.com/path/file.conf
    dest: /etc/foo.conf
    checksum: md5:66dffb5228a211e61d6d7ef4a86f5758

- name: Download file with checksum url (sha256)
  get_url:
    url: http://example.com/path/file.conf
    dest: /etc/foo.conf
    checksum: sha256:http://example.com/path/sha256sum.txt

- name: Download file from a file path
  get_url:
    url: file:///tmp/afile.txt
    dest: /tmp/afilecopy.txt

- name: download an ansible archive to remote hosts
  get_url:
    url: https://github.com/ansible/ansible/archive/v2.6.1.tar.gz
    dest: /usr/local/ansible_v2.6.1.tar.gz
    mode: 0777
```

### systemd

功能：管理服务启动与停止，与 service 模块用法一致；

```sh
# 范例1：启动 Httpd 服务
ansible webservers -m service -a "name=httpd state=started"

# 范例2：重载 Httpd 服务
ansible webservers -m service -a "name=httpd state=reloaded"

# 范例3：重启 Httpd 服务
ansible webservers -m service -a "name=httpd state=restarted"

# 范例4：停止 Httpd 服务
ansible webservers -m service -a "name=httpd state=stopped"

#范例5：启动 Httpd 服务，并加入开机自启
 ansible webservers -m service -a "name=httpd state=started enabled=yes"
```

```yaml
# 确保服务启动
- name: Make sure a service is running
  systemd:
    state: started
    name: httpd

# 确保服务停止
- name: Stop service cron on debian, if running
  systemd:
    name: cron
    state: stopped

# 发起daemon-reload并重启服务
- name: Restart service cron on centos, in all cases, also issue daemon-reload to pick up config changes
  systemd:
    state: restarted
    daemon_reload: yes
    name: crond

# 重新载入服务
- name: Reload service httpd, in all cases
  systemd:
    name: httpd
    state: reloaded

# 启用服务
- name: Enable service httpd and ensure it is not masked
  systemd:
    name: httpd
    enabled: yes
    # 被mask的Systemd单元无法启动
    masked: no

# 重新载入配置
- name: Just force systemd to reread configs (2.4 and above)
  systemd:
    daemon_reload: yes
```

### modprobe

加载或卸载内核模块：

```yaml
- name: ensure kernel modules
  modprobe:
    name: "{{ item }}"
    # absent 表示卸载
    state: present
  with_items:
    - "br_netfilter"
```

### PyPI

这是我们的第一个语言软件包管理器，可能是最著名的。它管理 Python 软件包和库。它具有各种选项，以满足与 Python 库相关的各种不同要求。
要运行此模块，我们需要确保 PyPI 已安装在远程主机上。

以下示例 playbook 将显示其中一些：

```yaml
- name: install a python library from the default repo
  pip:
    name: numpy
    version: 0.3

- name: install a python library from a github
  pip:
    name: https://github.com/jakubroztocil/httpie/archive/master.tar.gz
```

### cron

(1)功能

Ansible 中的 cron 模块用于定义任务计划，其中有两种状态，(state):present 表示添加(省略状态时默认使用),absent 表示移除。

`ansible-doc -s cron`

(2) 例子

```shell

# cron模块，顾名思义就是创建计划任务，可以定义webserver组被控端机器每天凌晨1点过1分ntpdate自动对时，命令如下所示：
ansible webserver -m cron -a '"name=ntpdate time every day" minute="1" hour="1" job="/sbin/ntpdate ntp.api.bz >> /dev/null"'

ansible all -m cron -a "name='test a job' user=root job='/bin/sh /server/scripts/test.sh' minute=* hour=* day=* month=* weekday=*"


#添加计划任务
ansible dbservers -m cron -a 'minute="*/10" job="/bin/echo hello" name="test cron job"'
192.168.1.108 | CHANGED => {
    "changed": true,
    "envs": [],
    "jobs": [
        "test cron job"
    ]

#查看crontab计划任务
ansible dbservers -a 'crontab -l'
192.168.1.108 | CHANGED | rc=0 >>
#Ansible: test cron job
*/10 * * * * /bin/echo hello

#移除计划任务
ansible dbservers -m cron -a 'minute="*/10" job="/bin/echo hello" name="test cron job" state=absent'
```

我们将创建一个 cron job，确保共享文件夹内容具有正确的权限：

```yaml
  - name: setup a cron job
    cron:
        name: "shared folder permission enforcer"
        hour: 0
        minute: 0
        day: *
        job: "chmod -R 777 /media/shared"
        state: present
```

### filesystem

此模块在处理虚拟化基础设施时非常方便，但也可以用于裸金属设置。
在远程主机上必须已经存在一个磁盘，然后才能使用此模块进行管理。

在虚拟环境中，Ansible 或其他管理工具允许您自动将磁盘添加到主机，然后使用此模块进行管理。

以下是使用此模块格式化磁盘的 playbook 示例：

```yaml
- name: create a filesystem from a newly added disk
  filesystem:
    fstype: ext4
    dev: /dev/sdc1
```

### mount

功能：管理被控端设备挂载；

环境准备：将 ansible 作为 nfs 服务端， 172.16.1.7、172.16.1.8 作为 nfs 客户端挂载；

```sh
# ansible localhost -m yum -a 'name=nfs-utils state=present'
# ansible localhost -m file -a 'path=/ops state=directory'
# ansible localhost -m copy -a 'content="/ops 172.16.1.0/24(rw,sync)" dest=/etc/exports'
# ansible localhost -m service -a "name=nfs state=restarted"
```

```sh
# 范例1：挂载 nfs 至本地的 /opt 目录，并实现开机自动挂载
ansible webservers -m mount -a "src=172.16.1.61:/ops path=/opt fstype=nfs opts=defaults state=mounted"

# 范例2：临时卸载 nfs 的挂载，但不清理 /etc/fstab
ansible webservers -m mount -a "src=172.16.1.61:/ops path=/opt fstype=nfs opts=defaults state=unmounted"

# 范例3：永久卸载 nfs 挂载，同时清理 /etc/fstab
ansible webservers -m mount -a "src=172.16.1.61:/ops path=/opt fstype=nfs opts=defaults state=absent"
```

```yaml
#设备挂载模块
- name: mount the recently added volume to the system
  mount:
    path: /media/disk1
    fstype: ext4
    boot: yes
    state: mounted
    src: /dev/sdc1

# 删除一个分区
- name: remove a no longer needed partition
  mount:
    device: /dev/sdc
    number: 1
    state: absent
```

### hostname

功能：管理被控端主机名称；

```sh
# 范例：设置主机名称为 ansible-hostname
ansible localhost -m hostname -a 'name=ansible-hostname'
```

### archive

功能：打包与压缩；

```sh
# 范例：将 /var/log 目录压缩为 tar 格式，并存储至 /opt 目录下；
ansible localhost -m archive -a 'path=/var/log dest=/opt/log.tar.gz format=gz'
```

### unarchive

功能：解包与解压缩

```sh
# 范例1：解压控制端的包至被控端；
ansible localhost -m unarchive -a 'src=/root/php.zip dest=/tmp/'

# 范例2：解压被制端的包至被控端；
ansible localhost -m unarchive -a 'src=/log.tar.gz dest=/tmp/ remote_src=yes'
```

```yaml
- name: extract an archive into remote hosts
  unarchive:
    src: ~/archive.tar.gz
    dest: /usr/local/
    owner: user1
    group: developers
    mode: 0755
```

### lineinfile

当需要在远程主机的文件中插入或修改特定文本行时，Ansible 中的 lineinfile 模块非常有用。它允许你按照指定的规则，确保文件中包含特定的行或者替换已有的行。

该模块确保特定行位于文件中，或使用反向引用正则表达式替换现有行。

`lineinfile模块查找文件中的特定行并用预定义的正则表达式替换它`

当您只想更改文件中的一行时，这主要有用。

```sh
# 开启 selinux， 替换以 SELINUX=开头的行，如果没有匹配到，则新增一条数据。
ansible all -m lineinfile  -a "dest=/etc/selinux/config regexp=^SELINUX= line=SELINUX=enforcing"

# 删除以SELINUX=开头的行
ansible all -m lineinfile  -a "dest=/tmp/config regexp=^SELINUX= state=absent"

# 如果文件中, line值不存在，则向文件中添加line的内容
ansible all -m lineinfile  -a "dest=/tmp/config  line='test'"
```

```yaml
---
- name: Insert a line into /etc/hosts
  hosts: all
  tasks:
    # 插入新行
    - name: Add a new entry to /etc/hosts
      lineinfile:
        path: /etc/hosts
        line: "192.168.1.100   host1.example.com host1"
        state: present
    # 修改已有行
    - name: Ensure a specific option is set in /etc/ssh/sshd_config
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^PermitRootLogin"
        line: "PermitRootLogin no"
        state: present

    # 注意：在 2.3 之前，使用选项 'dest'、'destfile' 或 'name' 代替 'path'
    - name: Ensure SELinux is set to enforcing mode
      ansible.builtin.lineinfile:
        path: /etc/selinux/config
        regexp: "^SELINUX="
        line: SELINUX=enforcing

    # lineinfile模块查找文件中的特定行并用预定义的正则表达式替换它
    - name: change a sudo user to no longer need password with config testing
      lineinfile:
        path: /etc/sudoers
        regexp: '^%sudo\s'
        line: "%sudo ALL=(ALL) NOPASSWD: ALL"
        state: present
        validate: "/usr/sbin/visudo -cf %s"
```

### replace

Ansible 中的 replace 模块用于在文件中查找指定的模式，并将其替换为指定的内容。这在需要对文件中的特定文本进行全局替换时非常有用

`replace模块替换文件中特定模式的所有实例`

```sh
# 替换文件内容
ansible all -m  replace  -a "dest=/etc/selinux/config regexp=^SELINUX=disabled replace=SELINUX=enforcing"

ansible all -m replace -a "path=/etc/fstab regexp=^(UUID.*) replace='#\1'"
```

简单替换示例

```yaml
---
- name: Replace content in /etc/motd
  hosts: all
  tasks:
    - name: Replace a line in /etc/motd
      replace:
        path: /etc/motd
        regexp: "OldTextToReplace"
        replace: "NewText"

    - name: Supports a validate command
      ansible.builtin.replace:
        path: /etc/apache/ports
        regexp: '^(NameVirtualHost|Listen)\s+80\s*$'
        replace: '\1 127.0.0.1:8080'
        validate: "/usr/sbin/apache2ctl -f %s -t"

    - name: Explicitly specifying positional matched groups in replacement
      ansible.builtin.replace:
        path: /etc/ssh/sshd_config
        regexp: '^(ListenAddress[ ]+)[^\n]+$'
        replace: '\g<1>0.0.0.0'

    - name: change all static ethernet config to use a higher mtu
      ansible.builtin.replace:
        path: /etc/network/interfaces
        regexp: "^mtu 1400$"
        line: "mtu 9000"
        backup: yes
        validate: "systemd reload networking"
```

多行替换示例

```yaml
---
- name: Replace multiple lines in a configuration file
  hosts: all
  tasks:
    - name: Replace multiple lines in config file
      replace:
        path: /etc/myapp/config.ini
        regexp: |
          ^option1\s*=\s*value1$
          ^option2\s*=\s*value2$
        replace: |
          option1 = new_value1
          option2 = new_value2
        backup: yes
```

### blockinfile

该模块将插入/更新/删除由可自定义标记线包围的多行文本块。

`blockinfile在文件中两个标记行之间插入、修改或删除一个或多个文本行。`

```yaml
# 在 Ansible 2.3 之前，使用选项“dest”或“name”而不是“path”
- name: Insert/Update "Match User" configuration block in /etc/ssh/sshd_config
  blockinfile:
    path: /etc/ssh/sshd_config
    block: |
      Match User ansible-agent
      PasswordAuthentication no

- name: Insert/Update eth0 configuration stanza in /etc/network/interfaces
    (it might be better to copy files into /etc/network/interfaces.d/)
  blockinfile:
    path: /etc/network/interfaces
    block: |
      iface eth0 inet static
          address 192.0.2.23
          netmask 255.255.255.0

- name: Insert/Update configuration using a local file and validate it
  blockinfile:
    block: "{{ lookup('file', './local/sshd_config') }}"
    path: /etc/ssh/sshd_config
    backup: yes
    validate: /usr/sbin/sshd -T -f %s

- name: Make the user a system user to hide it from login interface
  blockinfile:
    path: /var/lib/AccountsService/users/ansuser
    state: present
    create: yes
    block: |
      [User]
      SystemAccount=true

- name: change a static ethernet configuration
  blockinfile:
    path: /etc/network/interfaces
    block: |
      iface eth1 inet dhcp
            dns-nameserver 8.8.8.8
            dns-nameserver 8.8.4.4
            mtu 9000
    backup: yes
    validate: "systemd reload networking"

- name: Add mappings to /etc/hosts
  blockinfile:
    path: /etc/hosts
    block: |
      {{ item.ip }} {{ item.name }}
    marker: "# {mark} ANSIBLE MANAGED BLOCK {{ item.name }}"
  loop:
    - { name: host1, ip: 10.10.1.10 }
    - { name: host2, ip: 10.10.1.11 }
    - { name: host3, ip: 10.10.1.12 }
```

### group_by

除了在 play 中动态创建主机，我们还可以创建组。group_by 模块可以根据关于机器的事实创建组，包括我们使用之前解释的 add_fact 模块设置的事实。group_by 模块接受一个参数 key，它接受机器将被添加到的组的名称。通过将其与变量的使用结合起来，我们可以使模块根据其操作系统、虚拟化技术或我们可以访问的任何其他事实将服务器添加到组中。然后我们可以在任何后续 play 的目标部分或模板中使用此组。

在实践中，这经常用于避免 Ansible 在执行时输出大量的“跳过”消息。我们可以创建一个组，用于应该发生操作的机器，而不是为每个需要跳过的任务添加 when 子句，然后使用一个单独的 play 来单独配置这些机器。

以下是在不使用 when 子句的情况下在 Debian 和 RedHat 机器上安装 ssl 私钥的示例：

```yaml
---
- name: Catergorize hosts
  hosts: all
  tasks:
    - name: Gather hosts by OS
      group_by:
        key: "os_{{ ansible_os_family }}"

- name: Install keys on RedHat
  hosts: os_RedHat
  tasks:
    - name: Install SSL certificate
      copy:
        src: sslcert.pem
        dest: /etc/pki/tls/private/sslcert.pem

- name: Install keys on Debian
  hosts: os_Debian
  tasks:
    - name: Install SSL certificate
      copy:
        src: sslcert.pem
        dest: /etc/ssl/private/sslcert.pem
```

### slurp

slurp 模块从远程系统抓取文件，使用 base 64 对其进行编码，然后返回结果。我们可以利用 register 关键字将内容放入事实中。在使用 slurp 模块获取文件时，我们应该注意文件大小。该模块将整个文件加载到内存中，因此使用 slurp 处理大文件可能会消耗所有可用的 RAM 并导致系统崩溃。文件还需要从受控机器传输到控制器机器，对于大文件，这可能需要相当长的时间。

将此模块与复制模块结合使用可以在两台机器之间复制文件。这在以下 playbook 中进行了演示：

```yaml
---
- name: Fetch a SSH key from a machine
  hosts: bastion01
  tasks:
    - name: Fetch key
      slurp:
        src: /root/.ssh/id_rsa.pub
      register: sshkey

- name: Copy the SSH key to all hosts
  hosts: all
  tasks:
    - name: Make directory for key
      file:
        state: directory
        path: /root/.ssh
        owner: root
        group: root
        mode: 0700

    - name: Install SSH key
      copy:
        contents: "{{ hostvars.bastion01.sshkey|b64decode }}"
        dest: /root/.ssh/authorized_keys
        owner: root
        group: root
        mode: 0600
```

> 注意
> 请注意，由于 slurp 模块使用 base 64 对数据进行编码，因此我们必须使用名为 b64decode 的 jinja2 过滤器来在复制模块使用数据之前对数据进行解码。

## Docker 模块

最近的 Ansible 版本引入了几个专门用于 Docker 容器管理的模块。要使用 Docker 的 Ansible 模块，管理主机应安装以下 Python 软件包：

```sh
pip install 'docker-py>=1.7.0'

pip install 'docker-compose>=1.7.0'
```

在处理 Docker 容器时，最好使用动态清单。

Ansible 最近引入了一个新功能，可以在不使用 Dockerfile 的情况下构建容器。ansible-container 模块构建容器并通过 playbook 进行部署。

### Docker 容器管理模块

该模块管理在本地计算机或其他主机上运行的 Docker 容器的生命周期。以下 playbook 显示了该模块的工作原理：

```yaml
---
- name: Docker Module running
  hosts: local
  tasks:
    - name: create a container
      docker_container:
        name: debianlinux
        image: debian:9
        pull: yes
        state: present

    - name: start a container
      docker_container:
        name: debianlinux
        state: started
        devices:
          - "/dev/sda:/dev/xvda:rwm"

    - name: stop a container
      docker_container:
        name: debianlinux
        state: stopped
```

### Docker 镜像管理模块

该模块对容器开发者非常有用。它有助于构建、加载、拉取和推送容器镜像到仓库或将容器存档为 tar 文件。以下 playbook 示例显示了可以使用该模块执行的一些可能任务：

```yaml
- name: pull a container image
  docker_image:
    name: ubuntu:18.04
    pull: yes

- name: push a container image to docker hub
  docker_image:
    name: labimages/ubuntu
    repository: labimages/ubuntu
    tag: lab18
    push: yes

- name: remove a container image
  docker_image:
    name: labimages/ubuntu
    state: absent
    tag: lab16
```

### Docker 登录模块

该模块允许用户登录到 DockerHub 或私有仓库。以下 playbook 显示了如何实现这一点：

```yaml
- name: login to DockerHub
  docker_login:
    username: labuser1
    password: "xxx"
    email: user1@lab.edu
```

## VMware 模块

Ansible 提供了一系列模块来实现 VMware 基础设施的自动化管理。

我们需要安装 pyVmomi Python SDK：

```sh
pip install pyvmomi
```

这些模块用于管理 VMware ESX、ESXi 和 vCenter 服务器。在本节中，我们将描述一些参与管理 VMware 基础设施的最有用的模块。

需要一个清单文件来托管一些数据中心信息：

```conf
---
[vms:vars]
datacenter: "vcenter.lab.edu"
vcenter_hostname: "vcenter.lab.edu"
vcenter_username: "admin"
vcenter_password: "@xxxxxx"

[vms]
vm0
vm1
vm2

[esxi_hostname]
esxihost1         esxihost1.lab.edu
esxihost2         esxihost2.lab.edu
```

### VMware 虚拟机管理模块

`vmware_guest` 和 `vsphere_guest`

- vsphere_guest 模块与 vmware_guest 执行相同的任务，但它是一个不太稳定的传统模块，不支持 vmare_guest 那么多的功能。
- vsphere_guest 该模块已被弃用，并将在 Ansible 2.9 中删除；建议您改用 vmware_guest 模块。

这个模块允许创建、修改和删除虚拟机。它们还允许对指定的虚拟机进行状态和资源控制，包括电源状态修改和自定义。以下 playbook 示例展示了如何基于模板创建虚拟机：

```yaml
---
- name: VMware Module running
  hosts: vms
  tasks:
    - name: create a new virtual machine from a template
      vmware_guest:
        hostname: "{{ vcenter_hostname }}"
        username: "{{ vcenter_username }}"
        password: "{{ vcenter_password }}"
        validate_certs: False
        folder: /lab-folder
        name: "{{ inventory_hostname }}"
        state: poweredon
        template: debian8_temp
        disk:
          - size_gb: 15
            type: thin
            datastore: labdatastore1
        hardware:
          memory_mb: 1024
          num_cpus: 2
          num_cpu_cores_per_socket: 2
          scsi: paravirtual
          max_connections: 5
          hotadd_cpu: True
          hotremove_cpu: True
          hotadd_memory: True
          hotremove_memory: True
          version: 11
        cdrom:
          type: iso
          iso_path: "[ labdatastore1] /iso_folder/debian8.iso"
        networks:
          - name: Lab Network
            wait_for_ip_address: yes
      delegate_to: localhost
```

此模块允许您在 VMware 集群中启动和管理虚拟机；以下示例显示了如何使用模板启动 VM：

```yaml
- name: Create a VM from a template
  vmware_guest:
    hostname: "{{ vsphere_host }}"
    username: "{{ vsphere_username }}"
    password: "{{ vsphere_password }}"
    validate_certs: "no"
    datacenter: "my-datacenter"
    folder: "/vms"
    name: "yet_another_example_vm"
    state: "poweredon"
    template: "centos7-x86_64-1804"
    disk:
      - size_gb: "40"
        type: "thin"
        datastore: "my_datastore"
    hardware:
      memory_mb: "4048"
      num_cpus: "4"
      max_connections: "3"
      hotadd_cpu: "True"
      hotremove_cpu: "True"
      hotadd_memory: "True"
    networks:
      - name: "VM Network"
        ip: "192.168.1.100"
        netmask: "255.255.255.0"
        gateway: "192.168.1.254"
        dns_servers:
          - "192.168.1.1"
          - "192.168.1.2"
    wait_for_ip_address: "yes"
  delegate_to: "localhost"
  register: deploy
```

### VMware 虚拟机快照管理模块

此模块允许您管理 VM 快照；例如，以下创建了一个快照：

- 创建了一个快照

```yaml
- name: Create a snapshot
  vmware_guest_snapshot:
    hostname: "{{ vsphere_host }}"
    username: "{{ vsphere_username }}"
    password: "{{ vsphere_password }}"
    validate_certs: "no"
    datacenter: "my-datacenter"
    folder: "/vms"
    name: "yet_another_example_vm"
    snapshot_name: "pre-patching"
    description: "snapshot made before patching"
    state: "present"
  delegate_to: localhost
```

- 恢复一个快照

```yaml
- name: Revert to a snapshot
  vmware_guest_snapshot:
    hostname: "{{ vsphere_host }}"
    username: "{{ vsphere_username }}"
    password: "{{ vsphere_password }}"
    validate_certs: "no"
    datacenter: "my-datacenter"
    folder: "/vms"
    name: "yet_another_example_vm"
    snapshot_name: "pre-patching"
    state: "revert"
  delegate_to: localhost
```

这个 Ansible 模块实现了虚拟机的自动快照管理。以下 playbook 示例展示了如何在虚拟机上拍摄快照：

```yaml
- name: create a virtual machine snapshot
  vmware_guest_snapshot:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    datacentre: vcenter.lab.edu
    validate_certs: False
    folder: /lab-folder
    name: "{{ inventory_hostname }}"
    state: present
    snapshot_name: Post_Fixes
    description: Fixes_done_on_vm
  delegate_to: localhost
```

在处理 VMware 模块时，大小写敏感度非常重要，特别是在处理虚拟机快照时。在稍后调用快照时，请确保其名称完全相同。

### VMware 虚拟机 shell 执行模块

以下模块允许用户通过使用 VMware 工具在虚拟机操作系统上运行命令：

```yaml
- name: run a command on a running virtual machine
  vmware_guest_snapshot:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    datacentre: vcenter.lab.edu
    validate_certs: False
    folder: /lab-folder
    vm_id: "{{ inventory_hostname }}"
    vm_username: setup
    vm_password: "@P@55w0rd"
    vm_shell: /bin/service
    vm_shell_args: networking restart
  delegate_to: localhost
```

### VMware 主机电源状态控制模块

该模块管理 VMware 基础设备。ESX/ESXi 主机是计算资源存储的地方。该模块管理主机的电源状态。在维护、更新或修复后安排重启时，这可能非常方便。以下示例 playbook 显示了如何使用该模块：

```yaml
- name: restart ESXi host
  vmware_guest_snapshot:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    validate_certs: no
    esxi_hostname: esxihost1.lab.edu
    state: reboot-host
  delegate_to: localhost
```

vmware_guest_powerstate 模块

这个模块很容易理解；它用于管理 VM 的电源状态。以下示例重新启动了一个 VM：

```yaml
- name: Powercycle a vm
  vmware_guest_powerstate:
    hostname: "{{ vsphere_host }}"
    username: "{{ vsphere_username }}"
    password: "{{ vsphere_password }}"
    validate_certs: "no"
    folder: "/vms"
    name: "yet_another_example_vm"
    state: "reboot-guest"
  delegate_to: localhost
```

### vmware_guest_facts 模块

此模块收集有关已创建的 VM 的信息：

```yaml
- name: Gather facts on the yet_another_example_vm vm
  vmware_guest_facts:
    hostname: "{{ vsphere_host }}"
    username: "{{ vsphere_username }}"
    password: "{{ vsphere_password }}"
    validate_certs: "no"
    datacenter: "my-datacenter"
    folder: "/vms"
    name: "yet_another_example_vm"
  delegate_to: localhost
  register: facts
```

还有很多其他模块，具体参见官方文档：

- https://runebook.dev/zh/docs/ansible/-index-

- https://docs.ansible.com/ansible/2.9/modules/

- Ansible 官方文档网站：docs.ansible.com/

- Ansible 模块索引：docs.ansible.com/ansible/latest/modules/list_of_all_modules.html

- Chocolatey 软件包库：chocolatey.org/packages
