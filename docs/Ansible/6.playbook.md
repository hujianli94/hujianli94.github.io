# 6.playbook

## playbook 介绍

playbook(也称为剧本)是一个不同于 Ansible Ad-hoc 命令行执行方式的模式，其功能更为强大灵活。

简而言之，它是一个非常简单的配置管理和多主机部署系统。playbook 是由一个或多个“play”组成的列表。play 的主要功能是将事先归为一组的主机装扮成通过
ansible 中的 task 事先定义好的角色。

从根本上来讲，所谓的 task 就是调用 Ansible 的一个个 module 将多个 play 组织在一个 playbook 中，这样就可以让它们连通起来，并按事先编排的机制同唱一台大戏。

playbook 的模板是使用 Python 的 jinjaz2 模块来处理的。

另外，playbook 也是通过 YAML 格式来描述定义的，可以实现多台主机的应用部署，语法也并不复杂，大家可以对照官方案例学习其语法，官方提供了大量
的案例。

官方案例址为： https:/github.com/ansible/ansible-examples。

编写 playbook

- 一个剧本（即 playbook），可以包含多个 play
- 每个 play 用于在指定的主机上，通过模块和参数执行相应的任务
- 每个 play 可以包含多个任务。
- 任务有模块和参数构成。

```yaml
---
- 名字: 猴王初问世
  职员表: 猴哥, 大马猴
  场景:
    - 名字: 石头裂开了

    - 名字: 天宫震颤了

- 名字: 官封弼马温
  职员表: 猴哥, 玉皇大帝
  场景:
    - 名字: 太白金星骗猴哥

    - 名字: 猴哥天宫放马
```

### 1.常用命令

格式

```sh
ansible-playbook <filename.yml> ... [options]
```

常见选项

```sh
--syntax, --syntax-check                   # 语法检查,功能相当于bash -n
-C --check                                # 模拟执行dry run ,只检测可能会发生的改变，但不真正执行操作
--list-hosts                              # 列出运行任务的主机
--list-tags                               # 列出tag
--list-tasks                              # 列出task
--limit 主机列表                           # 只针对主机列表中的特定主机执行
-i INVENTORY, --inventory INVENTORY       # 指定主机清单文件,通常一个项对应一个主机清单文件
--start-at-task START_AT_TASK             # 从指定task开始执行,而非从头开始,START_AT_TASK为任务的name
-v -vv  -vvv                              # 显示过程
```

范例: 检查和限制主机

```sh
ansible-playbook file.yml  --check # 只检测
ansible-playbook file.yml
ansible-playbook file.yml  --limit websrvs  # 只针对主机列表中的特定主机执行


# 如果您想在特定任务中开始执行您的剧本，您可以使用以下--start-at-task选项：
ansible-playbook playbook.yml --start-at-task="install packages"  # 从指定位置开始执行playbook

ansible-playbook -t TAGS_NAME playbook.yaml     # 只执行TAGS_NAME任务
```

范例：一个简单的 playbook

```yaml
- hosts: webservers
  vars:
    http_port: 80
    max_clients: 200
  remote_user: root

  tasks:
    - name: Ensure apache is at the latest version
      yum:
        name: httpd
        state: latest
    - name: Write the apache config file
      template:
        src: /srv/httpd.j2
        dest: /etc/httpd.conf

      notify:
        - restart apache

    - name: Ensure apache is running (and enable it at boot)
      service:
        name: httpd
        state: started
        enabled: yes

  handlers:
    - name: Restart apache
      service:
        name: httpd
        state: restarted
```

范例: 一个 playbook 多个 play

```yaml
# cat test_plays.yaml
---
- hosts: localhost
  remote_user: root
  gather_facts: no

tasks:
  - name: play1
    command: echo "play1"


- hosts: webservers
  remote_user: root
  gather_facts: no

tasks:
  - name: play2
    command: echo "play2"
```

#### 1.1 playbook 的核心元素

- hosts : playbook 配置文件作用的主机
- tasks: 任务列表
- variables: 变量
- templates:包含模板语法的文本文件
- handlers :由特定条件触发的任务
- roles :用于层次性、结构化地组织 playbook。roles 能够根据层次型结构自动装载变量文件、tasks 以及 handlers 等

**hosts 组件**

Hosts：playbook 中的每一个 play 的目的都是为了让特定主机以某个指定的用户身份执行任务。
hosts 用于指定要执行指定任务的主机，须事先定义在主机清单中

**remote_user 组件**

remote_user: 可用于 Host 和 task 中。
也可以通过指定其通过 sudo 的方式在远程主机上执行任务，其可用于 play 全局或某任务；
此外，甚至可以在 sudo 时使用 sudo_user 指定 sudo 时切换的用户

```yaml
- hosts: websrvs
  remote_user: root

tasks:
 - name: test connection
   ping:
   remote_user: magedu
   sudo: yes          # 默认sudo为root
   sudo_user:wang     # sudo为wang
```

**task 列表和 action 组件**

play 的主体部分是 task list，task list 中有一个或多个 task,各个 task 按次序逐个在 hosts 中指定的所有主机上执行，即在所有主机上完成第一个 task 后，再开始第二个 task

task 的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致

每个 task 都应该有其 name，用于 playbook 的执行结果输出，建议其内容能清晰地描述任务执行步骤。

如果未提供 name，则 action 的结果将用于输出

#### 1.2 playbook 运行方式

```shell
ansible-playbook first.yml -f 10  # 使用ansible-playbook命令执行playbook
ansible-playbook first.yml --syntax-check    #检查yaml文件的语法是否正确
ansible-playbook first.yml --list-task       #检查tasks任务
ansible-playbook first.yml --list-hosts      #检查生效的主机
ansible-playbook first.yml --start-at-task='Copy Nginx.conf'     #指定从某个task开始运行
ansible-playbook first.yml -k      #用来交互输入ssh密码
ansible-playbook first.yml -K      #用来交互输入sudo密码
ansible-playbook first.yml -u      #指定用户


ansible-playbook --check 只检测可能会发生的改变,但不真执行操作
ansible-playbook --list-hosts 列出运行任务的主机
ansible-playbook --syntax-check playbook.yaml 语法检测
ansible-playbook -t TAGS_NAME playbook.yaml 只执行TAGS_NAME任务


# 也可以使用ansible-lint 命令进行详细检查playbook文件
ansible-lint httpd.yml


# Ansible-playbook新增的功能参数如下：
·--list-tags：      # 列出所有可用的tags。
·--list-tasks：     # 列出所有即将被执行的任务。
·--skip-tags=SKIP_TAGS： # 跳过指定的tags任务。
·--start-at-task=START_AT_TASK：      # 从第几条任务开始执行。
·--step：                             # 逐步执行Playbook定义的任务，并经人工确认后继续执行下一步任务。
·--syntax-check：                     # 检查Playbook中的语法书写。
·-t TAGS，--tags=TAGS：               # 指定执行该tags的任务。


# 在yaml中打标签
# 最简洁的写法
tags: ['one', 'two', 'three']
# 最清晰的写法
tags:
    - one
    - two
    - three

#如果您只想运行一个非常长的剧本的"配置"和"包"部分，您可以在命令行上使用该选项：--tags
$ ansible-playbook example.yml --tags "configuration,packages"


#另一方面，如果要在没有某些标记任务的情况下运行playbook ，可以使用命令行选项：--skip-tags
$ ansible-playbook example.yml --skip-tags "packages"
ansible-playbook playbook.yaml


# Ansible-playbook：其他选项技巧
·--inventory=PATH（-i PATH）：指定inventory文件，默认文件是/etc/ansible/hosts。

·--verbose（-v）：显示详细输出，也可以使用-vvvv显示精确到每分钟的输出。

·--extra-vars=VARS（-e VARS）：定义在Playbook使用的变量，格式为："key=value，key=value"。

·--forks=NUM（-f NUM）：指定并发执行的任务数，默认为5，根据服务器性能，调大这个值可提高Ansible执行效率。

·--connection=TYPE（-c TYPE）：指定连接远程主机的方式，默认为SSH，设为local时，则只在本地执行Playbook，建议不做修改。

·--check：检测模式，Playbook中定义的所有任务将在每台远程主机上进行检测，但并不直正执行。
```

#### 1.3 playbook 命令行中定义变量

范例：

```sh
# vim var2.yml
---
- hosts: websrvs
  remote_user: root

tasks:
  - name: install package
    yum: name={{ pkname }} state=present

[root@ansible ~]#ansible-playbook -e pkname=httpd var2.yml
```

范例:

```sh
#也可以将多个变量放在一个文件中
[root@ansible ~]#cat vars
pkname1: memcached
pkname2: vsftpd


[root@ansible ~]#vim var2.yml
---
- hosts: websrvs
  remote_user: root

tasks:
  - name: install package {{ pkname1 }
    yum: name={{ pkname1 }} state=present
  
  - name: install package {{ pkname2 }
    yum: name={{ pkname2 }} state=present
```

```sh
[root@ansible ~]#ansible-playbook -e pkname1=memcached -e pkname2=httpd var2.yml

[root@ansible ~]#ansible-playbook -e '@vars' var2.yml
```

### 2.官方案例

Ansible 官方案例。

apache.yml

```yml
---
- name: Deploy Apache
  hosts: localhost
  become: yes
  vars:
    http_port: 8001
    max_clients: 200
  tasks:
    - name: Install Apache
      apt:
        name: httpd
        state: latest
    - name: Write the Apache config file
      template:
        src: /srv/httpd.j2
        dest: /etc/httpd.conf
      notify: Restart Apache
    - name: Ensure Apache is running
      service:
        name: httpd
        state: started
  handlers:
    - name: Restart Apache
      service:
        name: httpd
        state: restarted
```

`httpd.conf.j2`模板

```conf
Listen {{ http_port }}

ServerName localhost

MaxClients {{ max_clients }}

<VirtualHost *:{{ http_port }}>
  DocumentRoot /var/www/html
  <Directory /var/www/html>
    AllowOverride All
    Require all granted
  </Directory>
</VirtualHost>
```

```shell
# 查看hosts和task
ansible-playbook apache.yml --list-hosts --list-task
playbook: apache.yml

  play #1 (localhost): localhost        TAGS: []
    pattern: ['localhost']
    hosts (1):
      localhost
    tasks:
      Install Apache    TAGS: []
      Write the Apache config file      TAGS: []
      Ensure Apache is running  TAGS: []

# 执行部署
ansible-playbook apache.yml -f 10
```

参数-f 10 提高进程数，ansible 默认并行进程是 5(Ansible 默认是同步阻塞模式，会等待所有机器执行完毕再在前台显示)

### 3.playbook 的详细说明

#### 定义主机和用户

hosts 定义了主机清单的 patterns 来确定哪些主机为执行目标。remote_user 指定执行目标主机的执行用户。

```yml
- hosts: localhost
  remote_user: root
```

如果你想要为执行提升权限，可以设置 become 提权参数

```yaml
---
- hosts: webservers
  # 使用git用户进行远程连接。
  remote_user: git
  # 表示在执行任务时需要提权，通常是通过sudo来获得root权限。
  become: yes
  # 关闭关闭自动采集Facts
  gather_facts: no
  # 如果在执行过程中出现任何错误，整个剧本的执行将立即停止。
  any_errors_fatal: true
  # 使用智能连接方式，这通常意味着Ansible会根据情况选择最合适的连接方式。默认情况下它会选择ssh或paramiko。
  connection: smart
```

当然，你也可以为每个 task 设置

```yml
---
- hosts: webservers
  remote_user: yourname
  tasks:
    - service:
        name: nginx
        state: started
      become: yes
      become_user: root
      become_method: sudo
```

#### 任务列表

每个 play 包含一组任务列表， 任务之间是按照从上往下顺序执行的，执行完上一个任务再去执行下一个任务。

运行从上到下运行的剧本时，任务失败的主机将从整个剧本的轮换中删除。 如果失败，只需更正剧本文件并重新运行即可。

- 使用 service 模块的命令如下

```yaml
tasks:
  - name: make sure apache is running
    service:
      name: httpd
      state: started
```

也可以使用 key=value 的形式表示模块参数

```yaml
tasks:
  - name: make sure apache is running
    service: name=httpd state=started
```

- 使用 command 模块的命令如下

command 和 shell 模块只有一组参数，可以直接写在模块后面

```yaml
tasks:
  - name: enable selinux
    command: /sbin/setenforce 1
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand || /bin/true
```

如果想忽略模块的执行错误，可以为模块添加 ignore_errors

```yml
tasks:
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand
    ignore_errors: True
```

如果行太长了，可以换行缩进表示

```yml
tasks:
  - name: Copy ansible inventory file to client
    copy: src=/etc/ansible/hosts dest=/etc/ansible/hosts
      owner=root group=root mode=0644
```

- 使用 copy 模块的命令如下

```yml
tasks:
  - name: Copy a new "ntp.conf" file into place, backing up the original if it differs from the copied version
    copy:
      src: /mine/ntp.conf
      dest: /etc/ntp.conf
      owner: root
      group: root
      mode: "0644"
      backup: yes
```

- 使用 template 模块的命令如下

也可以使用变量 vhost

```yml
tasks:
  - name: create a virtual host file for {{ vhost }}
    template:
      src: somefile.j2
      dest: /etc/httpd/conf.d/{{ vhost }}
```

#### 事件处理 Handlers

这些 notify 动作在 play 中每个任务块结束时触发，并且即使由多个不同的任务通知，也只会触发一次。

```yml
- name: template configuration file
  template:
    src: template.j2
    dest: /etc/foo.conf
  notify:
     - restart memcached
     - restart apache

handlers:
  - name: restart memcached
    service:
      name: memcached
      state: restarted
  - name: restart apache
    service:
      name: apache
      state: restarted
```

Handlers 也是任务列表，与常规任务没有什么不同，它们由全局惟一的名称引用，并由 notify 动作通知。
如果没有通知处理程序，它将不会运行。

不管有多少任务通知一个处理程序，它都将只运行一次，即在一个特定 play 中的所有任务完成之后。

Handlers 里的任务名称 不能使用 变量

在 ansible 2.2 之后，handlers 支持 listen 来实现监听一个通知程序来实现执行多个通知任务。

```yml
handlers:
  - name: restart memcached
    service:
      name: memcached
      state: restarted
    listen: "restart web services"
  - name: restart apache
    service:
      name: apache
      state: restarted
    listen: "restart web services"

tasks:
  - name: restart everything
    command: echo "this task will restart the web services"
    notify: "restart web services"
```

#### 常用变量

##### 注册变量

变量的另一个主要用途是运行命令并将该命令的结果注册为变量。当您执行一个任务并将返回值保存在一个变量中供以后的任务使用时，您将创建一个已注册的变量。

register 捕获任务的结果并将其存储在一个变量中——在运行 shell 模块的情况下，它会捕获命令的所有输出

```yaml
---
- name: Jinja2 filtering demo 1
  hosts: localhost

  tasks:
    - copy:
        src: multiple-document-strings.yaml
        dest: /tmp/multiple-document-strings.yaml

    - shell: cat /tmp/multiple-document-strings.yaml
      register: result

    - debug:
        msg: "{{ item }}"
      loop: "{{ result.stdout | from_yaml_all | list }}"
```

```yaml
---
- hosts: all
  tasks:
    - shell: uptime
      register: result

    - name: show uptime
      debug: var=result
```

动态创建 fact 变量

使用`set_fact` 在运行中设置 facts 变量

```yaml
tasks:
  - command: whoami
    register: result
  - set_fact: w={{result.stdout}}
  - debug: var=w
```

##### 魔术变量进行节点发现

在日常配置编排过程中，我们经常需要用到一些内置的变量来进行一些判断或者配置的工作，这里整理一些常用的变量，以便于使用查阅。

- 部署客户端主机名：ansible_hostname
- 部署客户端主机 IP：ansible_default_ipv4.address
- 部署客户端主机详细信息：hostvars，返回主机详细信息，可以通过点操作定位具体需要的内容。

| 魔术变量           | 描述                                                             |
| ------------------ | ---------------------------------------------------------------- |
| hostvars           | 这些是设置在另一台主机上的查找变量或事实。                       |
| groups             | 这是清单中组的列表。可以使用它来遍历一组节点以发现其拓扑信息。   |
| group_names        | 这是节点所属的组列表。                                           |
| inventory_hostname | 这是清单文件中设置的主机名。它可能与 ansible_hostname 事实不同。 |
| play_hosts         | 这是属于当前播放的所有主机的列表。                               |

##### hostvars 变量

- `${hostvars.hostname.fact}`
- `${hostvars.ns1.ansible_distribution}`

以下示例将一个名为 zone master 的变量设置为名为 ns1 的服务器。然后调用 template 模块，该模块将使用此设置每个区域的主服务器。

```yaml
---
- name: Setup DNS Servers
  hosts: allnameservers
  tasks:
    - name: Install BIND
      yum:
        name: named
        state: installed

- name: Setup Slaves
  hosts: slavenamesservers
  tasks:
    - name: Get the masters IP
      set_fact:
        dns_master: "{{ hostvars.ns1.ansible_default_ipv4.address }}"

    - name: Configure BIND
      template:
        dest: /etc/named.conf src: templates/named.conf.j2
```

> 注意

使用 hostvars，您可以进一步将模板与环境分离。
如果您嵌套变量调用，那么在 play 的变量部分放置 IP 地址的地方，您可以添加主机名。要查找名为 the_machine 变量中的机器的地址，您可以使用`{{ hostvars.[the_machine].default_ipv4.address }}`。

##### groups 变量

groups 变量包含按清单组分组的所有主机的列表。这使您可以访问您配置的所有主机。这是一个潜力非常强大的工具。它允许您在整个组中进行迭代，并对每个主机应用当前机器的操作。

```yaml
---
- name: Configure the database
  hosts: dbservers
  user: root
  tasks:
    - name: Install mysql
      yum:
        name: "{{ item }}"
        state: installed
      with_items:
        - mysql-server
        - MySQL-python

    - name: Start mysql
      service:
        name: mysqld
        state: started
        enabled: true

    - name: Create a user for all app servers
      with_items: groups.appservers
      mysql_user:
        name: kate
        password: test
        host: "{{ hostvars.[item].ansible_eth0.ipv4.address }}"
        state: present
```

> 注意
> groups 变量不包含组中的实际主机；它包含表示其在清单中的名称的字符串。这意味着如果需要，您必须使用嵌套变量扩展来访问 hostvars 变量。

您甚至可以使用此变量为包含所有其他机器的 host 密钥的所有机器创建 known_hosts 文件。这将允许您从一台机器 SSH 到另一台机器，而无需确认远程主机的身份。它还将在机器离开服务或更换机器时处理删除机器或更新机器。以下是执行此操作的 known_hosts 文件的模板：

```yaml
{% for host in groups['all'] %}
{{ hostvars[host]['ansible_hostname'] }}
{{ hostvars[host]['ansible_ssh_host_key_rsa_public'] }}
{% endfor %}
```

使用此模板的 playbook 将如下所示：

```yaml
---
hosts: all
tasks:
- name: Setup known hosts
  hosts: all
  tasks:
    - name: Create known_hosts
      template:
        src: templates/known_hosts.j2 dest: /etc/ssh/ssh_known_hosts
        owner: root
        group: root
        mode: 0644
```

##### group_names 变量

`group_names` 变量包含当前主机所在的所有组的名称列表。这不仅对于调试很有用，而且对于检测组成员资格的条件也很有用

此变量主要用于跳过任务或在模板中作为条件。

例如，如果 SSH 守护程序有两种配置，一种安全，一种不太安全，但您只想在安全组中的机器上使用安全配置，您可以这样做：

```yaml
- name: Setup SSH
  hosts: sshservers
  tasks:
    - name: For secure machines
      set_fact:
        sshconfig: files/ssh/sshd_config_secure
      when: "'secure' in group_names"

    - name: For non-secure machines
      set_fact:
        sshconfig: files/ssh/sshd_config_default
      when: "'secure' not in group_names"

    - name: Copy over the config
      copy:
        src: "{{ sshconfig }}"
        dest: /tmp/sshd_config
```

##### haproxy 负载均衡器 role 示例

下图解释了使用 HAProxy 作为前端，在后端平衡 Web 服务器负载的情况。HAProxy 是一个广泛使用的开源 TCP/HTTP 负载均衡器。

![](https://fldop2.flygon.net/docs/asb-plbk-ess/img/B03800_07_01.jpg)

在接下来的步骤中，我们不仅将创建一个 haproxy 模块，还将使用魔术变量自动配置其 IP 地址为所有 Web 服务器节点：

```sh
$ ansible-galaxy init roles/haproxy
- Role roles/haproxy was created successfully

$ tree -L 3 roles/haproxy/
roles/haproxy/
├── README.md
├── defaults
│   └── main.yml
├── files
├── handlers
│   └── main.yml
├── meta
│   └── main.yml
├── tasks
│   └── main.yml
├── templates
├── tests
│   ├── inventory
│   └── test.yml
└── vars
    └── main.yml
```

hosts 文件

```conf
[ubuntu-servers]
192.168.0.107
192.168.0.108

[www:children]
ubuntu-servers


[lb:children]
ubuntu-servers

[ubuntu-servers:vars]
ansible_ssh_user=root
ansible_ssh_pass=OSChina@2021
ansible_ssh_port=22

[www:vars]
ansible_ssh_user=root
ansible_ssh_pass=OSChina@2021

[local]
127.0.0.1 ansible_connection=local ansible_python_interpreter="/usr/bin/python3"
```

haproxy 角色相关的一些变量

```yaml
---
# filename: roles/haproxy/defaults/main.yml
haproxy:
  config:
    cnfpath: /etc/haproxy/haproxy.cfg
    enabled: 1
    listen_address: 0.0.0.0
    listen_port: 8080
  service: haproxy
  pkg: haproxy
```

haproxy 一些任务和处理程序

```yaml
---
# tasks file for roles/haproxy
- include: install.yml
- include: configure.yml
- include: service.yml

---
# filename: roles/haproxy/tasks/install.yml
- name: copy source files
  copy:
    src: /etc/apt/sources.list
    dest: /etc/apt/sources.list.bak
    backup: yes
    force: yes

- name: modify sources.list
  shell: |
    sed -i 's/http:\/\/archive.ubuntu.com\/ubuntu\//http:\/\/mirrors.aliyun.com\/ubuntu\//g' /etc/apt/sources.list

- name: update apt cache
  shell: apt update

- name: install haproxy
  apt:
    name: "{{ haproxy['pkg'] }}"

---
# filename: roles/haproxy/tasks/configure.yml
- name: create haproxy config
  template: src="haproxy.cfg.j2" dest="{{ haproxy['config']['cnfpath'] }}" mode=0644
  notify:
    - restart haproxy service
  tags:
    - conf1

- name: enable haproxy
  template: src="haproxy.default.j2" dest=/etc/default/haproxy mode=0644
  notify:
    - restart haproxy service
  tags:
    - conf2
---
# filename: roles/haproxy/tasks/service.yml
- name: start haproxy server
  service:
    name: "{{ haproxy['service'] }}"
    state: started

---
# filename: roles/haproxy/handlers/main.yml
- name: restart haproxy service
  service: name="{{ haproxy['service'] }}" state=restarted
```

- 我们为每个阶段创建了单独的任务文件：install、configure 和 service。然后我们从主任务文件，即 tasks/main.yml 文件中调用这些文件。

- HAProxy 的配置文件将使用 Jinja2 模板创建在 /etc/haproxy/haproxy.cfg 中。除了创建配置外，我们还需要在 /etc/defaults/haproxy 文件中启用 haproxy 服务。

模板文件

```yaml
#filename: roles/haproxy/templates/haproxy.cfg.j2
defaults
        log global
        mode tcp
        option dontlognull
        retries 3
        option redispatch
        maxconn 2000
        contimeout 5000
        clitimeout 50000
        srvtimeout 50000

# add to the end
# define frontend and backend servers
frontend ssh-in
        bind {{ haproxy['config']['listen_address'] }}:{{ haproxy['config']['listen_port'] }}
        default_backend fifanews

backend fifanews
        balance roundrobin
    {% for host in groups['www'] %}
    server {{ hostvars[host]['ansible_hostname'] }}{{ 1 + loop.index0 }} {{ hostvars[host]['ansible_default_ipv4']['address'] }}:{{ hostvars[host]['ansible_ssh_port'] | default(22) }} check
    {% endfor %}


# {{ hostvars[host]['ansible_hostname'] }} 获取远程主机的主机名
# inventory_hostname 将获取 hosts inventory 中定义的主机名

# listen fifanews {{ haproxy['config']['listen_address'] }}:{{ haproxy['config']['listen_port'] }}
#         cookie SERVERID rewrite
#         balance roundrobin
#     {% for host in groups['webservers'] %}
#     server server {{ hostvars[host]['ansible_hostname'] }}-{{ 1 + loop.index0 }} {{ hostvars[host]['ansible_host'] }}:{{ hostvars[host].get('ansible_ssh_port', 22) }} cookie {{ hostvars[host]['inventory_hostname'] }} check
#     {% endfor %}

#filename: roles/haproxy/templates/haproxy.default
#EXTRAOPTS="-de -m 16"
ENABLED="{{ haproxy['config']['enabled'] }}"
```

让我们分析这个模板片段：

- 我们正在使用魔术变量 groups 来查找清单中属于 www 组的所有主机，如下所示：

```yaml
  {% for host in groups['www'] -%}
```

对于每个发现的主机，我们使用 hostvars 参数获取事实以及用户定义的变量，这是另一个魔术变量。

```yaml
 {{ hostvars[host]['ansible_default_ipv4']['address'] }}
```

们需要创建一个 play，这应该是 site.yml 文件的一部分，这是我们的主 playbook：

```yaml
---
#filename: lb.yml
- hosts: lb
  remote_user: root
  gather_facts: yes

  roles:
    - { role: haproxy, when: ansible_os_family == 'Debian' }
```

现在，使用以下命令运行 playbook：

```sh
$ ansible-playbook -i hosts site.yml
```

上述运行将安装 haproxy 并在后端部分的 haproxy.cfg 文件中添加所有 web 服务器的配置。haproxy.cfg 文件的示例如下所示：

```sh
root@ubuntu2004-base:/etc# cat /etc/haproxy/haproxy.cfg
#filename: roles/haproxy/templates/haproxy.cfg.j2
defaults
        log global
        mode tcp
        option dontlognull
        retries 3
        option redispatch
        maxconn 2000
        contimeout 5000
        clitimeout 50000
        srvtimeout 50000

# add to the end
# define frontend and backend servers
frontend ssh-in
        bind 0.0.0.0:8080
        default_backend fifanews

backend fifanews
        balance roundrobin
        server ubuntu2004-base1 192.168.0.107:22 check
        server ubuntu2004-base2 192.168.0.108:22 check
```

#### when 语句

ansible_os_family 是 facts 或 vars 的变量

```yml
---
- name: Play to patch only CentOS systems
  hosts: all
  become: true

  tasks:
    #  若操作系统是 Debian 时就执行关机操作
    - name: "shut down Debian flavored systems"
      command: /sbin/shutdown -t now
      when: ansible_os_family == "Debian"

    #  若操作系统是 CentOS 时就执行安装httpd
    - name: Patch CentOS systems
      yum:
        name: httpd
        state: latest
      when: ansible_facts['distribution'] == "CentOS"

    #  若操作系统是 CentOS 6 时就执行安装httpd
    - name: Patch CentOS systems
      yum:
        name: httpd
        state: latest
      when: (ansible_facts['distribution'] == "CentOS" and ansible_facts['distribution_major_version'] == "6")

    # 只在 Fedora 25 及更新版本上运行一个任务：
    - name: Only perform this task on Fedora 25 and later
      shell: echo "only on Fedora 25 and later"
      when: ansible_facts['distribution'] == "Fedora" and ansible_facts['distribution_major_version']|int >= 25

    # 只有在shell命令的输出中包含hosts字符串时才会打印
    - name: Gather directory listing from local system
      shell: "ls -l"
      register: shellresult

    - name: Alert if we find a hosts file
      debug:
        msg: "Found hosts file!"
      when: '"hosts" in shellresult.stdout'

    - name: node1 run this task
      ansible.builtin.debug:
        msg: "The hostname is: {{ ansible_hostname }}"
      when: ansible_hostname == "node1"

    - name: Multiple condition
      ansible.builtin.debug:
        msg: The memory is {{ ansible_memtotal_mb }} MB and the core number is {{ ansible_processor_cores }}
      when: ansible_memtotal_mb >= 1000 and ansible_processor_cores == 2

    - name: Create temporary file
      ansible.builtin.tempfile:
        state: file
        suffix: temp
      register: tempfile_1

    - name: Use the registered var and the file module to remove the temporary file
      ansible.builtin.file:
        path: "{{ tempfile_1.path }}"
        state: absent
      when: tempfile_1.path is defined
```

```yaml
---
# 当变量deploy的值为deploy时执行deploy.yaml的任务步骤
- name: "Starting deploy for nginx"
  include_tasks: deploy.yaml
  when: deploy == "deploy"

# 当变量deploy的值为rollback时执行rollback.yaml的任务步骤
- name: "Starting rollback for nginx"
  include_tasks: rollback.yaml
  when: deploy == "rollback"
```

```yaml
---
- name: Install VIM
  hosts: all
  tasks:
    - name: Install VIM via yum
      yum:
        name: vim-enhanced
        state: installed
      when: ansible_os_family == "RedHat"

    - name: Install VIM via apt
      apt:
        name: vim
        state: installed
      when: ansible_os_family == "Debian"

    - name: Unexpected OS family
      debug:
        msg: "OS Family {{ ansible_os_family }} is not supported"
        fail: yes
      when: ansible_os_family != "RedHat" and ansible_os_family != "Debian"
```

failed_when: 满足给定的条件时，使任务失败

```yml
tasks:
  - command: echo faild.
    register: command_result
    failed_when: "'faild' in command_result.stdout"

  - debug: msg="echo test"
```

使用注册变量判断

将给定命令的结果存储在变量中， 并在后续的任务中使用。

```yml
- name: test play
  hosts: all

  tasks:
    - shell: cat /etc/motd
      register: motd_contents

    - shell: echo "motd contains the word hi"
      when: motd_contents.stdout.find('hi') != -1
```

```yaml
- name: download wordpress
    register: wp_download

- name: extract wordpress
    when: wp_download.rc == 0
```

一个使用 when 的示例

```yml
- name: Ensure docker history packages are removed.
  yum: "name={{ item }} state=removed"
  with_items: "{{ docker_old }}"

- name: Ensure docker packages are installed.
  yum: "name={{ docker_packages }} state=installed  update_cache=yes"

- name: Install docker repo.
  shell: "yum-config-manager --add-repo {{ docker_repo }}"

- name: Modify the docker software source for keda.
  replace:
    path: /etc/yum.repos.d/docker-ce.repo
    regexp: 'download\.docker\.com'
    replace: "mirrors.ustc.edu.cn/docker-ce"

- name: Create Docker config directory.
  file: path=/etc/docker state=directory

- name: Configure docker startup parameters.
  template:
    src: daemon.json.j2
    dest: "/etc/docker/daemon.json"

- name: Ensure docker-ce are installed.
  yum: "name={{ docker_ce_packages }} state=installed update_cache=yes enablerepo=docker-ce-stable"

- name: Set docker completion.
  copy: src=/usr/share/bash-completion/completions/docker dest=/etc/bash_completion.d/docker remote_src=yes

- name: Ensure docker is started and enabled at boot.
  systemd: name=docker state=started enabled=yes
  when: docker_start

- name: Check if docker-compose file is already.
  stat: path={{ docker_exec_path }}
  register: docker_compose_result

- name: Install docker-compose.
  get_url: url={{ docker_compose_url }} dest={{ docker_exec_path }} validate_certs=no mode=0755
  when: not docker_compose_result.stat.exists

- name: docker-compose version.
  command: docker-compose -version
  register: version_result
  changed_when: false
  ignore_errors: True

- debug: var=version_result.stdout
```

Playbook 条件语句

- https://www.cnblogs.com/breezey/p/10996632.html#always

#### 循环语句

添加多个用户

```yml
- name: add several users
  user:
    name: "{{ item }}"
    state: present
    groups: "wheel"
  loop:
    - testuser1
    - testuser2

# 使用command模块在远程系统上依次echo数字 1 到 6（可以很容易地扩展到添加用户帐户或创建一系列文件）。
# loop:语句定义了循环的开始，循环中的项目被定义为一个 YAML 列表。
- name: Echo a value from the loop
  command: echo "{{ item }}"
  loop:
    - 1
    - 2
    - 3
    - 4
    - 5
    - 6

- name: add several users
  user:
    name: "{{ item.name }}"
    state: present
    groups: "{{ item.groups }}"
  with_items:
    - { name: "testuser1", groups: "wheel" }
    - { name: "testuser2", groups: "root" }

- name: Install Mysql package
  yum: name={{ item }} state=present
  with_items:
    - mysql-server
    - MySQL-python
    - libselinux-python
    - libsemanage-python

# 条件逻辑与循环结合起来
- name: Echo a value from the loop
  command: echo "{{ item }}"
  loop:
    - 1
    - 2
    - 3
    - 4
    - 5
    - 6
  when: item|int > 3

# 进一步增强 playbook
- name: Echo a value from the loop
  command: echo "{{ item }}"
  loop:
    - 1
    - 2
    - 3
    - 4
    - 5
    - 6
  when: item|int > 3
  register: loopresult

- name: Print the results from the loop
  debug:
    var: loopresult
```

循环还支持列表，可以通过 with_flattened 语句实现

```yml
- name: Example with_flattened loop
  hosts: localhost
  gather_facts: false
  vars:
    my_list:
      - [1, 2, 3]
      - [4, 5, 6]
      - [7, 8, 9]
  tasks:
    - name: Print item
      debug:
        msg: "{{ item }}"
      with_flattened:
        - "{{ my_list }}"
```

```sh
---
#filename: roles/php5-fpm/defaults/main.yml
#defaults file for php5-fpm
php5:
  packages:
    - php5-fpm
    - php5-common
    - php5-curl
    - php5-mysql
    - php5-cli
    - php5-gd
    - php5-mcrypt
    - php5-suhosin
    - php5-memcache
  service:
    name: php5-fpm
```

循环一个数组

```yaml
---
#filename: roles/php5-fpm/tasks/main.yml
# tasks file for php5-fpm
- include_vars: "{{ ansible_os_family }}.yml"
  when: ansible_os_family != 'Debian'

- include: install.yml
- include: service.yml

#filename: roles/php5-fpm/tasks/install.yml
  - name: install php5-fpm and family
    apt:
      name: "{{ item }}"
    with_items: php5.packages
    notify:
     - restart php5-fpm service

#filename: roles/php5-fpm/tasks/service.yml
# manage php5-fpm service
- name: start php5-fpm service
  service:
    name: "{{ php5['service']['name'] }}"
    state: started
```

Playbook 循环语句

- https://www.cnblogs.com/breezey/p/10996629.html

#### 滚动执行

管理节点过多导致的超时问题解决方法

默认情况下，Ansible 将尝试并行管理 playbook 中所有的机器。对于滚动更新用例，可以使用 serial 关键字定义 Ansible 一次应管理多少主机，还可以将 serial 关键字指定为百分比，表示每次并行执行的主机数占总数的比例

示例 1

```yaml
#vim test_serial.yml
---
- hosts: all
  # 每次只同时处理2个主机,将所有task执行完成后,再选下2个主机再执行所有task,直至所有主机
  serial: 2
  gather_facts: False

tasks:
 - name: task one
    comand: hostname

 - name: task two
    command: hostname
```

示例 2

```yaml
- name: test serail
  hosts: all
  # 每次只同时处理20%的主机
  serial: "20%"
```

示例 3

```yaml
# cat test_serial.yml
---
- hosts: websrvs
  serial: 1
  tasks:
    - name: task1
    shell: wall "{{ansible_nodename}} is running task1"
    - name: task2
    shell: wall "{{ansible_nodename}} is running task2"
    - name: task3
    shell: wall "{{ansible_nodename}} is running task3"
```

#### 委派至其它主机执行

利用委托技术,可以在非当前被控主机的其它主机上执行指定操作
范例: 将任务委派给指定的主机执行

```yaml
# cat delegate.yml
#在10.0.0.8上执行hostname -I,而非当前主机localhost
- hosts: localhost

tasks:
  - name: show ip address
    command: hostname -I
    # 指定当前任务被委派给的目标主机
    delegate_to: 10.0.0.8
    # 收集被委派的目标主机的facts信息
    delegate_facts: true
```

范例: 将任务被委派给控制端 ansible 主机执行

```yaml
# 在本地执行ifconfig,而非10.0.0.8
# cat delegate2.yml
- hosts: 10.0.0.8

tasks:
  - name: show ip address
    # 被委派给控制端ansible主机执行
    local_action: command ifconfig

  - name: show hostname
    shell: hostname
    # 被委派给控制端ansible主机执行
    connection: local

  - name: kernel version
    shell: uname -r
    # 被委派给控制端ansible主机执行
    delegate_to: localhost
    # 委派任务只执行一次
    run_one: true
```

范例: 创建普通用户基于 ssh key 验证

```yaml
# cat ssh_key_push.yml
# 创建普通用户管理ansible
- hosts: all
vars:
 - user_name: ssh_demo

tasks:

# manager
- name: Create Manager {{ user_name }}
  user:
    name: "{{ user_name }}"
    generate_ssh_key: yes
    ssh_key_bits: 2048
    ssh_key_file: .ssh/id_rsa
 register: user_message
 # 委派给管理端
 delegate_to: localhost
 # 委派任务仅执行一次
 run_once: true

# node
- name: 打印管理用户的key结果
  debug:
    msg: "{{ user_message.ssh_public_key }}"

- name: 在被控端上创建用户
  user:
    name: "{{ user_name }}"


- name: 在被控端上创建用户.ssh目录
  file:
    path: "/home/{{ user_name }}/.ssh"
    state: directory
    owner: "{{ user_name }}"
    group: "{{ user_name }}"
    mode: "0700"

- name: 将管理端 {{ user_name }} 用户的key存储到被控端
  copy:
    content: "{{ user_message.ssh_public_key }}"
    dest: "/home/{{ user_name }}/.ssh/authorized_keys"
    owner: "{{ user_name }}"
    group: "{{ user_name }}"
    mode: "0600"

- name: 配置被控制端sudo提权,最后追加一行
  lineinfile:
    path: /etc/sudoers
    line: "{{ user_name }} ALL=(ALL) NOPASSWD:ALL"
```

范例: 通过 hparoxy 代码升级

```yaml
- hosts: webservers
  serial: 1

tasks:
  - name: Down Node {{ inventory_hostname }}
    haproxy:
      state: disabled
      host: '{{ inventory_hostname }}'
      socket: /var/lib/haproxy/stats
      backend: ansible_cluster
    delegate_to: 10.0.0.100

  - name: Sleep
    shell:
      cmd: sleep 5

  - name: Update Nginx Code
    copy:
      content: "App Version V2.0{{ ansible_eth0.ipv4.address.split('.')[-1]}}"
      dest: /opt/index.html

  - name: Up Node {{ inventory_hostname }}
    haproxy:
      state: enabled
      host: '{{ inventory_hostname }}'
      socket: /var/lib/haproxy/stats
      backend: ansible_cluster
      wait: yes
    delegate_to: 10.0.0.100
```

#### 处理数据

以下是一些您可能会发现有用的流行过滤器：

| 过滤器          | 描述                                                                                                                              |
| --------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| min             | 当参数是一个列表时，它只返回最小值。                                                                                              |
| max             | 当参数是一个列表时，仅返回最大值。                                                                                                |
| random          | 当参数是一个列表时，它会从列表中随机选择一个项目。                                                                                |
| changed         | 当在使用 register 关键字创建的变量上使用时，如果任务更改了任何内容，则返回 true；否则返回 false。                                 |
| failed          | 当在使用 register 关键字创建的变量上使用时，如果任务失败，则返回 true；否则返回 false。                                           |
| skipped         | 当在使用 register 关键字创建的变量上使用时，如果任务更改了任何内容，则返回 true；否则返回 false。                                 |
| default(X)      | 如果变量不存在，则将使用 X 的值。                                                                                                 |
| unique          | 当参数是一个列表时，返回一个没有重复项的列表。                                                                                    |
| b64decode       | 将变量中的 base64 编码字符串转换为其二进制表示。这在与 slurp 模块一起使用时非常有用，因为它将其数据作为 base64 编码的字符串返回。 |
| replace(X, Y)   | 返回一个将字符串中任何出现的 X 替换为 Y 的副本。                                                                                  |
| join(X)         | 当变量是一个列表时，返回一个所有条目由 X 分隔的字符串。                                                                           |
| regex_search(x) | 正则匹配                                                                                                                          |
| quote           | 为 shell 增加双引号                                                                                                               |

使用示例：

```yaml
---
- name: Create user accounts
  hosts: all
  vars:
    users:
  tasks:
    - name: Create accounts
      user: name={{ item|lower }} state=present
      with_items:
        - Fred
        - John
        - DanielH

    - name: touch files with an optional mode
      file:
        dest: "{{ item.path }}"
        state: touch
        mode: "{{ item.mode | default(omit) }}"
      loop:
        - path: /tmp/foo
        - path: /tmp/bar
        - path: /tmp/baz
          mode: "0444"
```

#### 使用块分组任务

您可以将相同的 when 子句应用于每个任务，但这很麻烦和低效-最好将所有任务放在一个块中，并将条件逻辑应用于块本身。
这样，逻辑只需要声明一次。块在处理错误和特别是从错误条件中恢复时也非常有价值。

以下示例 playbook 显示了包含在块中的三个任务（请注意需要额外的缩进级别来表示它们在块中的存在）：

```yaml
---
- name: Conditional block play
  hosts: all
  become: true

  tasks:
    - name: Install and configure Apache
      block:
        - name: Install the Apache package
          dnf:
            name: httpd
            state: installed
        - name: Install the templated configuration to a dummy location
          template:
            src: templates/src.j2
            dest: /tmp/my.conf
        - name: Start the httpd service
          service:
            name: httpd
            state: started
            enabled: True
      when: ansible_facts['distribution'] == 'Fedora'
```

Ansible 优雅地处理错误条件

```yaml
---
- name: Play to demonstrate block error handling
  hosts: frontends

  tasks:
    - name: block to handle errors
      block:
        - name: Perform a successful task
          debug:
            msg: "Normally executing...."
        - name: Deliberately create an error
          command: /bin/whatever
        - name: This task should not run if the previous one results in an error
          debug:
            msg: "Never print this message if the above command fails!!!!"
      # 如果block任务没有导致错误，则rescue部分中的任务不会运行。
      # 如果在rescue部分运行的任务导致错误，则不会执行进一步的rescue任务，执行将移至always部分。
      rescue:
        - name: Catch the error (and perform recovery actions)
          debug:
            msg: "Caught the error"
        - name: Deliberately create another error
          command: /bin/whatever
        - name: This task should not run if the previous one results in an error
          debug:
            msg: "Do not print this message if the above command fails!!!!"
      # always部分中的任务始终运行，无论block或rescue部分是否出现错误。即使没有遇到错误，它们也会运行。
      always:
        - name: This task always runs!
          debug:
            msg: "Tasks in this part of the play will be ALWAYS executed!!!!"
```

### 4.Playbook 高级用法

#### 本地执行

如果希望在控制主机本地运行一个特定的任务，可以使用 local_action 语句。

假设我们需要配置的远程主机刚刚启动，如果我们直接运行 playbook，可能会因为 sshd 服务尚未开始监听而导致失败，我们可以在控制主机上使用如下示例来等待被控端 sshd 端口监听：

```yaml
- name: wait for ssh server to be running
  wait_for
      port: 22
      host: "{{ inventory_hostname }}"
      search_regex: OpenSSH
  connection: local
```

#### 任务委托

在有些时候，我们希望运行与选定的主机或主机组相关联的 task，但是这个 task 又不需要在选定的主机或主机组上执行，而需要在另一台服务器上执行。

这种特性适用于以下场景：

- 在告警系统中启用基于主机的告警
- 向负载均衡器中添加或移除一台主机
- 在 dns 上添加或修改针对某个主机的解析
- 在存储节点上创建一个存储以用于主机挂载
- 使用一个外部程序来检测主机上的服务是否正常

可以使用 delegate_to 语句来在另一台主机上运行 task：

```yaml
- name: enable alerts for web servers
  hosts: webservers
  tasks:
    - name: enable alerts
      nagios: action=enable_alerts service=web host="{{ inventory_hostname }}"
      delegate_to: nagios.example.com
```

> 如果 delegate_to: 127.0.0.1 的时候，等价于 local_action

#### 任务暂停

有些情况下，一些任务的运行需要等待一些状态的恢复，比如某一台主机或者应用刚刚重启，我们需要需要等待它上面的某个端口开启，此时就需要将正在运行的任务暂停，直到其状态满足要求。

Ansible 提供了 wait_for 模块以实现任务暂停的需求

wait_for 模块常用参数：

- connect_timeout：在下一个任务执行之前等待连接的超时时间
- delay：等待一个端口或者文件或者连接到指定的状态时，默认超时时间为 300 秒，在这等待的 300s 的时间里，wait_for 模块会一直轮询指定的对象是否到达指定的状态，delay 即为多长时间轮询一次状态。
- host：wait_for 模块等待的主机的地址，默认为 127.0.0.1
- port：wait_for 模块待待的主机的端口
- path：文件路径，只有当这个文件存在时，下一任务才开始执行，即等待该文件创建完成
- state：等待的状态，即等待的文件或端口或者连接状态达到指定的状态时，下一个任务开始执行。当等的对象为端口时，状态有 started，stoped，即端口已经监听或者端口已经关闭；当等待的对象为文件时，状态有 present 或者 started，absent，即文件已创建或者删除；当等待的对象为一个连接时，状态有 drained，即连接已建立。默认为 started
- timeout：wait_for 的等待的超时时间,默认为 300 秒

```yaml
#等待8080端口已正常监听，才开始下一个任务，直到超时
- wait_for:
    port: 8080
    state: started

#等待8000端口正常监听，每隔10s检查一次，直至等待超时
- wait_for:
    port: 8000
    delay: 10

#等待8000端口直至有连接建立
- wait_for:
    host: 0.0.0.0
    port: 8000
    delay: 10
    state: drained

#等待8000端口有连接建立，如果连接来自10.2.1.2或者10.2.1.3，则忽略。
- wait_for:
    host: 0.0.0.0
    port: 8000
    state: drained
    exclude_hosts: 10.2.1.2,10.2.1.3

#等待/tmp/foo文件已创建
- wait_for:
    path: /tmp/foo

#等待/tmp/foo文件已创建，而且该文件中需要包含completed字符串
- wait_for:
    path: /tmp/foo
    search_regex: completed

#等待/var/lock/file.lock被删除
- wait_for:
    path: /var/lock/file.lock
    state: absent

#等待指定的进程被销毁
- wait_for:
    path: /proc/3466/status
    state: absent

#等待openssh启动，10s检查一次
- wait_for:
    port: 22
    host: "{{ ansible_ssh_host | default(inventory_hostname) }}" search_regex: OpenSSH
    delay: 10
```

#### 滚动执行

默认情况下，ansible 会并行的在所有选定的主机或主机组上执行每一个 task，但有的时候，我们会希望能够逐台运行。最典型的例子就是对负载均衡器后面的应用服务器进行更新时。通常来讲，我们会将应用服务器逐台从负载均衡器上摘除，更新，然后再添加回去。我们可以在 play 中使用 serial 语句来告诉 ansible 限制并行执行 play 的主机数量。

下面是一个在 amazon EC2 的负载均衡器中移除主机，更新软件包，再添加回负载均衡的配置示例：

```yaml
- name: upgrade pkgs on servers behind load balancer
  hosts: myhosts
  serial: 1
  tasks:
    - name: get the ec2 instance id and elastic load balancer id
      ec2_facts:

    - name: take the host out of the elastic load balancer id
      local_action: ec2_elb
      args:
        instance_id: "{{ ansible_ec2_instance_id }}"
        state: absent

    - name: upgrade pkgs
      apt:
        update_cache: yes
        upgrade: yes

    - name: put the host back n the elastic load balancer
      local_action: ec2_elb
      args:
        instance_id: "{{ ansible_ec2_instance_id }}"
        state: present
        ec2_elbs: "{{ items }}"
      with_items: ec2_elbs
```

```yaml
---
- hosts: remote
  serial: 1
  max_fail_percentage: 25
  tasks:
    - debug:
        msg: "this is task a"
    - debug:
        msg: "this is task b"
```

25 是一个比例数据，表示构建列表中，如果有四分之一的失败，则会退出构建，如果我们希望一有失败就退出，则可以将之设为 0。

注意：当 serial: 1 时，就不必再用 `run_once: true`，因为这种定义是无意义的。

#### 只执行一次

某些时候，我们希望某个 task 只执行一次，即使它被绑定到了多个主机上。例如在一个负载均衡器后面有多台应用服务器，我们希望执行一个数据库迁移，只需要在一个应用服务器上执行操作即可。

- 可以使用 run_once 语句来处理：

```yaml
- name: run the database migrateions
  command: /opt/run_migrateions
  run_once: true
```

- 还可以与 local_action 配合使用，如下：

```yaml
- name: run the task locally, only once
  command: /opt/my-custom-command
  connection: local
  run_once: true
```

- 还可以与 delegate_to 配合使用，让这个只执行一次的任务在指定的机器上运行：

```yaml
- name: run the task locally, only once
  command: /opt/my-custom-command
  run_once: true
  delegate_to: app.a1-61-105.dev.unp
```

#### 设置环境变量

我们在命令行下执行某些命令的时候，这些命令可能会需要依赖环境变量。比如在安装某些包的时候，可能需要通过代理才能完成完装。或者某个脚本可能需要调用某个环境变量才能完成运行。

ansible 支持通过 environment 关键字来定义一些环境变量。

在如下场景中可能需要用到环境变量：

- 运行 shell 的时候，需要设置 path 变量
- 需要加载一些库，这些库不在系统的标准库路径当中

```yaml
---
- name: upload a remote file to aws s3
  hosts: test
  tasks:
    - name: install pip
      yum:
        name: python-pip
        state: installed

    - name: install the aws tools
      pip:
        name: awscli
        state: present

    - name upload file to s3
      shell aws s3 put-object --bucket=my-test-bucket --key={{ ansible_hostname }}/fstab --body=/etc/fstab --region=eu-west-1
      environment:
        AWS_ACCESS_KEY_ID: xxxxxx
        AWS_SECRET_ACCESS_KEY: xxxxxx
```

事实上，environment 也可以存储在变量当中：

```yaml
- hosts: all
  remote_user: root
  vars:
    proxy_env:
      http_proxy: http://proxy.example.com:8080
      https_proxy: http://proxy.bos.example.com:8080
  tasks:
    - apt: name=cobbler state=installed
      environment: proxy_env
```

#### 交互式提示

在少数情况下，ansible 任务运行的过程中需要用户输入一些数据，这些数据要么比较秘密不方便，或者数据是动态的，不同的用户有不同的需求，比如输入用户自己的账户和密码或者输入不同的版本号会触发不同的后续操作等。

ansible 的 vars_prompt 关键字就是用来处理上述这种与用户交互的情况的。

```yaml
 - hosts: all
   remote_user: root
   vars_prompt:
      - name: share_user
        prompt: "what is your network username?"
        private: yes

      - name: share_pass
        prompt: "what is your network password"
        private: yes

    tasks:
      - debug:
          var: share_user
      - debug:
          var: share_pass
```

vars_prompt 常用选项说明：

- private: 默认为 yes，表示用户输入的值在命令行不可见
- default：定义默认值，当用户未输入时则使用默认值
- confirm：如果设置为 yes，则会要求用户输入两次，适合输入密码的情况

#### 忽略错误 ignore_errors

如果一个 task 出错,默认将不会继续执行后续的其它 task
利用 ignore_errors: yes 可以忽略此 task 的错误,继续向下执行 playbook 其它 task

```sh
[root@ansible ansible]#cat test_ignore.yml
---
- hosts: websrvs

tasks:
  - name: error
    command: /bin/false
    ignore_errors: yes

  - name: continue
    command: wall continue
```

### 5.常用片段

#### 打印执行主机信息

```yaml
- name: debug inventory_hostname
  debug:
    var: inventory_hostname

- name: debug groups[hosts_src_ctl][0]
  debug:
    var: groups[hosts_src_ctl][0]
```

#### 删除文件

删除指定目录下，对应规则的文件

```yaml
- hosts: all
  tasks:

  - name: find to delete logs
    find:
      paths: /var/log/
      patterns: *.log
      # age: 3d 查找3天前的文件
    register: files_to_absent

  - name: absent logs
    file:
      path: "{{ item.path }}"
      state: absent
    with_items: "{{ files_to_absent.files }}"
```

删除已知的文件

```yaml
- name: absent logs
  file:
    path: "{{ item }}"
    state: absent
  with_items:
    - /tmp/log1.log
    - /tmp/log1.log
```

#### 删除进程

```yaml
- hosts: all
  tasks:
    - name: find running processes
      ignore_errors: yes
      shell: "ps -ef | grep -v grep | grep sshd | awk '{print $2}'"
      register: running_processes

    - name: Kill running processes
      ignore_errors: yes
      shell: "kill {{ item }}"
      with_items: "{{ running_processes.stdout_lines }}"
```

#### 在任务中设置变量

```yaml
# 获取组中第一个主机的 ip 地址
# {{ hostvars[groups['webservers'][0]]['ansible_eth0']['ipv4']['address'] }}

- set_fact: ipaddress="{{ hostvars[groups['webservers'][0]]['ansible_eth0']['ipv4']['address'] }}"
- set_fact: headnode="{{ groups[['webservers'][0]] }}"

- debug: msg={{ headnode }}
- debug: msg={{ ipaddress }}
```

#### 获取 ip 地址

```yaml
    {% for host in groups['db_servers'] %}
       {{ hostvars[host]['ansible_eth0']['ipv4']['address'] }}
    {% endfor %}

    {{ ansible_default_ipv4 }}
```

#### 如何获取 shell 变量

```yaml
vars:
    local_home: "{{ lookup('env','HOME') }}"
tasks:
  - debug: var=local_home

# 在ansible1.4版本以上，可以使用以下方式获取
- debug: var=ansible_env.HOME
```

#### 远程遍历拷贝文件

```yaml
- name: get files in /path/
  shell: ls /path/*
  register: path_files

- name: fetch these back to the local Ansible host for backup purposes
  fetch:
    src: /path/"{{item}}"
    dest: /path/to/backups/
  with_items: "{{ path_files.stdout_lines }}"
```

#### 递归目录中的模版文件

```yaml
- name: Copying the templated jinja2 files
  template: src={{item}} dest={{RUN_TIME}}/{{ item | regex_replace(role_path+'/templates','') | regex_replace('\.j2', '') }}
  with_items: "{{ lookup('pipe','find {{role_path}}/templates -type f').split('\n') }}"
```

#### 使用系统其他用户执行命令

```yaml
ansible node1 -m shell -a "touch /tmp/12345" --become-user=hadoop --become

- command: touch /tmp/1234567
  become: true
  become_user: hadoop

```

#### 判断文件是否存在

```yaml
- name: install | Check if Mysql file is already configured.
  stat: path=/tmp/123
  register: file_result

- name: install | Create software files path.
  file: path=/tmp/123 state=directory
  when: not file_result.stat.exists
```

#### 远程遍历拷贝文件

```yaml
- name: get files in /path/
  shell: ls /path/*
  register: path_files

- name: fetch these back to the local Ansible host for backup purposes
  fetch:
    src: /path/"{{item}}"
    dest: /path/to/backups/
  with_items: "{{ path_files.stdout_lines }}"
```

#### 使用系统其他用户执行命令

```yaml
ansible node1 -m shell -a "touch /tmp/12345" --become-user=hadoop --become

- command: touch /tmp/1234567
  become: true
  become_user: hadoop
```

#### 获取主机清单中组的 ip 地址

```yaml
- shell: "ping -c 1 {{item}} | grep icmp_seq | gawk -F'[()]'  '{print $2}'"
  with_inventory_hostnames: test2
  register: testip

- debug: "msg={{ item.stdout }}"
  with_items: "{{ testip.results }}"
```

#### 获取 redis 的 info 信息

```yaml
- hosts: localhost
  gather_facts: false
  tasks:
    - name: "query redis info"
      expect:
        command: "telnet 106.14.183.68 6379"
        responses:
          "Escape":
            - "auth test\ninfo\nquit\n"
      ignore_errors: true
      register: result
    - name: "show the variable"
      debug:
        var: result
```

#### 不显示失败内容

在执行 task 时，有些时候不希望模块报出 fatal 的错误信息，这时候我们可以使用 failed_when 关键字使 task 永不失败,在使用 register 关键字记录模块的信息，便于后续任务使用. changed_when 是永不改变，no_log 是不记录日志。

```yaml
- name: 检查主机连接状态
  wait_for_connection:
    connect_timeout: 1
    timeout: 3
  register: host_status
  failed_when: false
  changed_when: false
  no_log: true

- name: 结束运行连接失败的主机
  meta: end_host
  when: host_status.msg is defined and host_status.msg is search('SSH Error')
```

#### 只同步远程目录没有的文件

在 Nginx 对接 consul 的场景中，upsync 的 dump 文件一般只需要第一次同步上去，而后就不需要再同步，这个时候可以用 rsync 的参数来实现：

```yaml
- name: sync the upsync config
  synchronize:
    src: /data/.jenkins/jobs/ops-prod/jobs/ops-nginx-config/workspace/prod-nginx/upsync/
    dest: /etc/nginx/upsync/
    mode: push
    rsync_opts: "--ignore-existing"
    delete: yes
    rsync_timeout: 30
  tags:
    - prod-nginx
```

#### 打印多行

有时候我们在运行完一些任务之后，希望能够批量打印一些内容返回出来，此时可以使用如下方式进行打印：

```yaml
$ cat test.yaml
---
- hosts: localhost
  connection: local
  vars:
    msg: |
      lookupd-tcp
       {{ node1 }}:4160
       {{ node2 }}:4160
       {{ node3 }}:4160
       lookupd-http
       {{ node1 }}:4161
       {{ node2 }}:4161
       {{ node3 }}:4161
       data-tcp
       {{ node1 }}:41501
       {{ node1 }}:41502
       {{ node2 }}:41501
       {{ node2 }}:41502
       {{ node3 }}:41501
       {{ node3 }}:41502
       data-http
       {{ node1 }}:41511
       {{ node1 }}:41512
       {{ node2 }}:41511
       {{ node2 }}:41512
       {{ node3 }}:41511
       {{ node3 }}:41512
  tasks:
    - name: test
      debug:
        msg: "{{ msg.split('\n') }}"
```

Ansible Task 片段

- https://ansible.leops.cn/advanced/practice/snippets/

### 6.kolla-ansible 中常见 ansible 语法

#### 复杂判断

```yaml
# ansible.roles.prechecks.tasks.package_checks.yml
---
- name: Checking docker SDK version
  command: '/usr/bin/python -c "import docker; print docker.__version__"'
  register: result
  changed_when: false
  when: inventory_hostname in groups['baremetal']
  failed_when: result | failed or
    result.stdout | version_compare(docker_py_version_min, '<')
```

这个 playbook 的功能是：

1.开始执行 book 中的第一个 play：Checking docker SDK version

2.判断目标主机 inventory_hostname 是否属于主机清单中的 baremetal 组

3.如果属于，到这台主机上执行 command module，参数是"/usr/bin/python -c "import docker; print docker.version""

4.将执行的结果赋值给 result 变量

5.因为这个模块不会更改目标主机上的任何设置，所以 change_when 是 false，无论执行结果如何，都不会去改变这个当然任务的 changed 属性

6.将 result 变量传递给 failed 函数，判断命令是否执行成功

7.如果命令执行成功，将 result 中的输出结果，传递给 version_compare 函数，判断版本是否符合要求

8.因为这个模块不会更改目标主机上的任何设置，所以 change_when 永远是 false

9.如果 failed_when 判断结果为失败，则设置任务状态为失败，停止执行此 playbook

#### 条件语句

when，faild_when, change_when 后面可以接入一个条件语句，条件语句的值是 true 或者 false，条件语句示例如下：

```yaml
ansible_os_family == "Debian"
test == 1 or run == always
hostname in [1,2,3,4]
```

ansible 除了上文的==, or, in 来进行判断外，ansible 还支持通过管道调用 ansible 自定义的 test plugin 进行判断,

上文中的`result | failed or result.stdout | version_compare(docker_py_version_min, '<')`用到了 `version_compare` 和 `failed` 两个 `test plugin`，这两个 test plugin 本质是 ansible 指定目录下两个 python 函数，用来解析字符串判断版本版本是否匹配，执行命令是否成功。

它们的源码位于 ansible.plugins.test.core, ansible。所有 test plugin 位于 ansible.plugins.test，ansible 支持自定义 test plugin。

#### 迭代

with_itmes 是 ansible 的迭代语句，作用类似 python 的 for item in {}, 用法示例：

```yaml
- name: test list
  command: echo {{ item }}
  with_items: [0, 2, 4, 6, 8, 10]
  when: item > 56

- name: Setting sysctl values
  sysctl: name={{ item.name }} value={{ item.value }} sysctl_set=yes
  with_items:
    - { name: "net.bridge.bridge-nf-call-iptables", value: 1 }
    - { name: "net.bridge.bridge-nf-call-ip6tables", value: 1 }
    - { name: "net.ipv4.conf.all.rp_filter", value: 0 }
    - { name: "net.ipv4.conf.default.rp_filter", value: 0 }
  when:
    - set_sysctl | bool
    - inventory_hostname in groups['compute']
```

#### failed_when

一种错误处理机制，一般用来检测执行的结果，如果执行失败，终止任务，和条件语句搭配使用

范例: failed_when 满足条件时，则任务失败,和 when 功能相反

```yaml
tasks:
- command: echo failed
  register: result
  failed_when: "'failed' in result.stdout"
  # failed_when: false 不满足条件时,任务正常执行
  # failed_when: true 满足条件时,任务失败

- debug: msg="echo failed_when"
```

#### changed_when

当我们控制一些远程主机执行某些任务时，当任务在远程主机上成功执行，状态发生更改时，会返回 changed 状态响应，状态未发生更改时，会返回 OK 状态响应，当任务被跳过时，会返回 skipped 状态响应。我们可以通过 changed_when 来手动更改 changed 响应状态。

changed_when 检查 task 返回结果,决定是否继续向下执行

```yaml
---
- hosts: websrvs

tasks:
  - name: install nginx
    yum: name=nginx

  - name: config file
    template: src="nginx.conf.j2" dest="/etc/nginx/nginx.conf"
    notify: restart nginx
 
  - name: check config
    shell: /usr/sbin/nginx -t
    register: check_nginx_config
    changed_when:
      - check_nginx_config.stdout.find('successful')      # 如果执行结果中有successful字符串,则继续执行,如果没有则停止向下执行
      - false                                             # nginx -t 每次成功执行是changed状态,关闭此changed状态

  - name: start service
    service: name=nginx state=started enabled=yes

handlers:
  - name: restart nginx
    service: name=nginx state=restarted
```

#### run_once

当对一个主机组赋予进行操作时，有部分操作并不需要在每个主机上都执行，比如说 nova 服务安装时，需要初始化 nova 数据库，这个操作只需要在一个节点上执行一次就可以了，这种情况可以使用 run_once 标记，被标记的任务不会在多个节点上重复执行。
delegate_to 可以配合 run_once 使用，可以在 playbook 中指定数据库任务要执行的主机，下面的例子中，指定要执行数据库创建的主机是 `groups['nova-api'][0]`

```yaml
- name: Creating Nova databases
  kolla_toolbox:
    module_name: mysql_db
    module_args:
      login_host: "{{ database_address }}"
      login_port: "{{ database_port }}"
      login_user: "{{ database_user }}"
      login_password: "{{ database_password }}"
      name: "{{ item }}"
  register: database
  run_once: True
  delegate_to: "{{ groups['nova-api'][0] }}"
  with_items:
    - "{{ nova_database_name }}"
    - "{{ nova_database_name }}_cell0"
    - "{{ nova_api_database_name }}"
```

delegate_to 指定的机器可以当前任务的机器没有任何关系，比如，在部署 nova 服务时，可以 delegate_to 的目标不限于 nova 机器，可以到 delegate_to ansible 控制节点或者存储机器上执行任务。例如：

```yaml
hosts: app_servers
tasks:
  name: gather facts from db servers
  setup:
  delegate_to: "{{item}}"
  delegate_facts: True
  with_items: "{{groups[‘dbservers‘}}"
# 该例子会收集dbservers的facts并分配给这些机器, 而不会去收集app_servers的facts
```

#### serial

一般情况下, ansible 会同时在所有服务器上执行用户定义的操作, 但是用户可以通过 serial 参数来定义同时可以在多少太机器上执行操作.

```yaml
name: test play
hosts: webservers
serial: 3
# webservers组中的3台机器完全完成play后, 其他3台机器才会开始执行
```

#### until

这种循环由三个指令完成：

- until 是一个条件表达式，如果满足条件循环结束
- retry 是重试的次数
- delay 是延迟时间

示例如下：

```yaml
action: shell /usr/bin/foo
register: result
until: result.stdout.find("all systems go") != -1
retries: 5
delay:
```

#### wait_for

wait_for 可以让 ansible 等待一段时间，直到条件满足，再继续向下执行，这个模块主要用来等待之前的操作完成，比如服务启动成功，锁释放。

下面是一个 kolla-ansible 判断 murano-api 服务是否启动成功的例子：

在 `murano-api[0]`节点上, 尝试和 `api_interface_address:murano_api_port` 建立链接，如果成功建立连接，结束等待。

如果 1 秒（connect_timeout）内未建立成功，放弃，休眠 1 秒（参数 sleep，未配置，默认值）后重试，如果 60 秒（timeout）内没有成功创建链接，任务失败。

```yaml
- name: Waiting for Murano API service to be ready on first node
  wait_for:
    host: "{{ api_interface_address }}"
    port: "{{ murano_api_port }}"
    connect_timeout: 1
    timeout: 60
  run_once: True
  delegate_to: "{{ groups['murano-api'][0] }}"
```

#### 配合 register 循环列表

```yaml
- shell: echo "{{ item }}"
  with_items:
    - one
    - two
  register: echo

- name: Fail if return code is not 0
  fail:
    msg: "The command ({{ item.cmd }}) did not have a 0 return code"
  when: item.rc != 0
  with_items: echo.results
```

### 7.Nginx 配置修改工具 Ansible

#### 1.Ansible 剧本（playbook）

Ansible 中每个剧本只有一个主入口文件，并且只有一个主线任务，主线任务可根据不同条件选用不同的角色，每个角色由任务、变量、模板、处理器的 YAML 描述文件组成。

Ansible 及剧本目录结构如下:

```sh
├── ansible.cfg                 # ansible配置文件
├── hosts                       # 目标主机资源文件
└── roles                       # 剧本目录，可自定义
    ├── nginx                         # 剧本角色名称及角色任务文件目录
    │   ├── defaults                 # 角色默认变量目录
    │   │   └── main.yaml           # 默认变量自动加载的文件
    │   ├── files                    # 文件存放目录
    │   ├── handlers                 # 处理器任务文件目录
    │   │   └── main.yaml           # 默认处理器任务自动加载的文件
    │   ├── tasks                    # 角色任务文件存放目录
    │   │   └── main.yaml           # 当前角色默认的任务入口文件
    │   └── templates                # 任务模板存放目录
    └── nginx.yaml                    # 剧本入口文件
```

#### 2.基础语法

1. 步骤描述
   任务由多个步骤组成，每个步骤由步骤命名、任务模块、动作组成，配置样例如下:

```yaml
- name: reload Nginx Service # 步骤名
  systemd: "name=nginx state=reloaded enabled=yes" # 任务模块为systemd，动作是对系统服务     # Nginx执行reload操作
```

2. 执行顺序
   Ansible 剧本中的步骤是自上而下执行的，在默认情况下，每个步骤的执行结果返回值如果不为 0，就会报错，剧本任务也终止，也可以通过忽略错误指令继续运行，配置样例如下:

```yaml
- name: Create conf.d
  shell: mkdir -p /etc/nginx/conf.d # 任务模块是shell，动作是执行mkdir命令
  ignore_errors: True # 如果当前动作执行出错，忽略错误继续执行
```

3. 变量赋值
   Ansible 剧本中变量赋值有静态和动态两种方式，一种是在 defaults 目录的 main.yaml 文件中静态地直接赋值，这通常被用作默认变量的赋值，配置样例如下:

```yaml
confdir: "/etc/nginx" # 定义变量confdir的值为/etc/nginx
```

另一种是在当前执行的过程中动态地进行变量赋值，被赋值的变量可以在当前剧本执行过程中被引用，配置样例如下所示:

```yaml
# 方法一:将执行结果动态赋值给变量
- name: Test Nginx Config
  shell:
    nginx -c {{ confdir }}/nginx.conf -t # 任务模块是shell，动作是Nginx
    # 执行-t参数命令
  register: test_result # 将执行结果赋值给变量test_result
# 方法二:根据其他变量的值进行动态的变量赋值
- name: check set_fact output
  set_fact: output="{{ work }}/output" # 为变量output赋值
  when: test_result # 当变量test_result为真时
```

4. 条件判断
   在 Ansible 剧本中可以根据变量的值判断是否执行当前步骤，配置样例如下:

```yaml
- debug: msg="{{ test_result.stderr_lines }}" # 任务模块debug，输出变量test_result.stderr_lines的内容
  when: not test_result.stderr_lines == "" # 当test_result变量的输出结果不为空，执行当前步骤
```

5. 外部引入
   多个步骤可以编写在一个 YAML 文件中，并通过指令 include_tasks 被其他任务引入，结合条件判断，它可以使主线任务因变量不同而存在多个不同分支，配置样例如下:

```yaml
- name: "check system type"
  include_tasks: linux.yaml # 引入外部任务步骤
  when: ansible_os_family != "Windows" # 当目标操作系统非windows时，执行当前任务
```

#### 3.剧本执行

Ansible 剧本编写结束后，使用 ansible-playbook 命令调用剧本入口文件执行相应的剧本，即可自动完成预设的任务。

```sh
ansible-playbook -i /etc/ansible/hosts /etc/ansible/roles/nginx.yaml --extra-vars 'hosts=192.168.2.145'
```
