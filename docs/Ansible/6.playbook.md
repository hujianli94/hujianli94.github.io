# 6.playbook

## playbook 介绍

playbook(也称为剧本)是一个不同于 Ansible Ad-hoc 命令行执行方式的模式，其功能更为强大灵活。

简而言之，它是一个非常简单的配置管理和多主机部署系统。playbook 是由一个或多个“play”组成的列表。play 的主要功能是将事先归为一组的主机装扮成通过
ansible 中的 task 事先定义好的角色。

从根本上来讲，所谓的 task 就是调用 Ansible 的一个个 module 将多个 play 组织在一个 playbook 中，这样就可以让它们连通起来，并按事先编排的机制同唱一台大戏。

playbook 的模板是使用 Python 的 jinjaz2 模块来处理的。

另外，playbook 也是通过 YAML 格式来描述定义的，可以实现多台主机的应用部署，语法也并不复杂，大家可以对照官方案例学习其语法，官方提供了大量
的案例。

官方案例址为： https:/github.com/ansible/ansible-examples。

编写 playbook

- 一个剧本（即 playbook），可以包含多个 play
- 每个 play 用于在指定的主机上，通过模块和参数执行相应的任务
- 每个 play 可以包含多个任务。
- 任务有模块和参数构成。

```yaml
---
- 名字: 猴王初问世
  职员表: 猴哥, 大马猴
  场景:
    - 名字: 石头裂开了

    - 名字: 天宫震颤了

- 名字: 官封弼马温
  职员表: 猴哥, 玉皇大帝
  场景:
    - 名字: 太白金星骗猴哥

    - 名字: 猴哥天宫放马
```

### 1.常用命令

#### 1.1 playbook 的核心元素

```
hosts : playbook配置文件作用的主机
tasks: 任务列表
variables: 变量
templates:包含模板语法的文本文件
handlers :由特定条件触发的任务
roles :用于层次性、结构化地组织playbook。roles 能够根据层次型结构自动装载变量文件、tasks以及handlers等
```

#### 1.2 playbook 运行方式

```shell
ansible-playbook first.yml -f 10  # 使用ansible-playbook命令执行playbook
ansible-playbook first.yml --syntax-check    #检查yaml文件的语法是否正确
ansible-playbook first.yml --list-task       #检查tasks任务
ansible-playbook first.yml --list-hosts      #检查生效的主机
ansible-playbook first.yml --start-at-task='Copy Nginx.conf'     #指定从某个task开始运行
ansible-playbook first.yml -k      #用来交互输入ssh密码
ansible-playbook first.yml -K      #用来交互输入sudo密码
ansible-playbook first.yml -u      #指定用户


ansible-playbook --check 只检测可能会发生的改变,但不真执行操作
ansible-playbook --list-hosts 列出运行任务的主机
ansible-playbook --syntax-check playbook.yaml 语法检测
ansible-playbook -t TAGS_NAME playbook.yaml 只执行TAGS_NAME任务


# 也可以使用ansible-lint 命令进行详细检查playbook文件
ansible-lint httpd.yml


# Ansible-playbook新增的功能参数如下：
·--list-tags：      # 列出所有可用的tags。
·--list-tasks：     # 列出所有即将被执行的任务。
·--skip-tags=SKIP_TAGS： # 跳过指定的tags任务。
·--start-at-task=START_AT_TASK：      # 从第几条任务开始执行。
·--step：                             # 逐步执行Playbook定义的任务，并经人工确认后继续执行下一步任务。
·--syntax-check：                     # 检查Playbook中的语法书写。
·-t TAGS，--tags=TAGS：               # 指定执行该tags的任务。


# 在yaml中打标签
# 最简洁的写法
tags: ['one', 'two', 'three']
# 最清晰的写法
tags:
    - one
    - two
    - three

#如果您只想运行一个非常长的剧本的"配置"和"包"部分，您可以在命令行上使用该选项：--tags
$ ansible-playbook example.yml --tags "configuration,packages"


#另一方面，如果要在没有某些标记任务的情况下运行playbook ，可以使用命令行选项：--skip-tags
$ ansible-playbook example.yml --skip-tags "packages"
ansible-playbook playbook.yaml


# Ansible-playbook：其他选项技巧
·--inventory=PATH（-i PATH）：指定inventory文件，默认文件是/etc/ansible/hosts。

·--verbose（-v）：显示详细输出，也可以使用-vvvv显示精确到每分钟的输出。

·--extra-vars=VARS（-e VARS）：定义在Playbook使用的变量，格式为："key=value，key=value"。

·--forks=NUM（-f NUM）：指定并发执行的任务数，默认为5，根据服务器性能，调大这个值可提高Ansible执行效率。

·--connection=TYPE（-c TYPE）：指定连接远程主机的方式，默认为SSH，设为local时，则只在本地执行Playbook，建议不做修改。

·--check：检测模式，Playbook中定义的所有任务将在每台远程主机上进行检测，但并不直正执行。
```

### 2.官方案例

Ansible 官方案例。

apache.yml

```yml
---
- name: Deploy Apache
  hosts: localhost
  become: yes
  vars:
    http_port: 8001
    max_clients: 200
  tasks:
    - name: Install Apache
      apt:
        name: httpd
        state: latest
    - name: Write the Apache config file
      template:
        src: /srv/httpd.j2
        dest: /etc/httpd.conf
      notify: Restart Apache
    - name: Ensure Apache is running
      service:
        name: httpd
        state: started
  handlers:
    - name: Restart Apache
      service:
        name: httpd
        state: restarted
```

`httpd.conf.j2`模板

```conf
Listen {{ http_port }}

ServerName localhost

MaxClients {{ max_clients }}

<VirtualHost *:{{ http_port }}>
  DocumentRoot /var/www/html
  <Directory /var/www/html>
    AllowOverride All
    Require all granted
  </Directory>
</VirtualHost>
```

```shell
# 查看hosts和task
ansible-playbook apache.yml --list-hosts --list-task
playbook: apache.yml

  play #1 (localhost): localhost        TAGS: []
    pattern: ['localhost']
    hosts (1):
      localhost
    tasks:
      Install Apache    TAGS: []
      Write the Apache config file      TAGS: []
      Ensure Apache is running  TAGS: []

# 执行部署
ansible-playbook apache.yml -f 10
```

参数-f 10 提高进程数，ansible 默认并行进程是 5(Ansible 默认是同步阻塞模式，会等待所有机器执行完毕再在前台显示)

### 3.playbook 的详细说明

#### 定义主机和用户

hosts 定义了主机清单的 patterns 来确定哪些主机为执行目标。remote_user 指定执行目标主机的执行用户。

```yml
- hosts: localhost
  remote_user: root
```

如果你想要为执行提升权限，可以设置 become 提权参数

```yaml
---
- hosts: webservers
  remote_user: git
  become: yes
  # 关闭关闭自动采集Facts
  gather_facts: no
```

当然，你也可以为每个 task 设置

```yml
---
- hosts: webservers
  remote_user: yourname
  tasks:
    - service:
        name: nginx
        state: started
      become: yes
      become_user: root
      become_method: sudo
```

#### 任务列表

每个 play 包含一组任务列表， 任务之间是按照从上往下顺序执行的，执行完上一个任务再去执行下一个任务。

运行从上到下运行的剧本时，任务失败的主机将从整个剧本的轮换中删除。 如果失败，只需更正剧本文件并重新运行即可。

- 使用 service 模块的命令如下

```yaml
tasks:
  - name: make sure apache is running
    service:
      name: httpd
      state: started
```

也可以使用 key=value 的形式表示模块参数

```yaml
tasks:
  - name: make sure apache is running
    service: name=httpd state=started
```

- 使用 command 模块的命令如下

command 和 shell 模块只有一组参数，可以直接写在模块后面

```yaml
tasks:
  - name: enable selinux
    command: /sbin/setenforce 1
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand || /bin/true
```

如果想忽略模块的执行错误，可以为模块添加 ignore_errors

```yml
tasks:
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand
    ignore_errors: True
```

如果行太长了，可以换行缩进表示

```yml
tasks:
  - name: Copy ansible inventory file to client
    copy: src=/etc/ansible/hosts dest=/etc/ansible/hosts
      owner=root group=root mode=0644
```

- 使用 copy 模块的命令如下

```yml
tasks:
  - name: Copy a new "ntp.conf" file into place, backing up the original if it differs from the copied version
    copy:
      src: /mine/ntp.conf
      dest: /etc/ntp.conf
      owner: root
      group: root
      mode: "0644"
      backup: yes
```

- 使用 template 模块的命令如下

也可以使用变量 vhost

```yml
tasks:
  - name: create a virtual host file for {{ vhost }}
    template:
      src: somefile.j2
      dest: /etc/httpd/conf.d/{{ vhost }}
```

#### 事件处理 Handlers

这些 notify 动作在 play 中每个任务块结束时触发，并且即使由多个不同的任务通知，也只会触发一次。

```yml
- name: template configuration file
  template:
    src: template.j2
    dest: /etc/foo.conf
  notify:
     - restart memcached
     - restart apache

handlers:
  - name: restart memcached
    service:
      name: memcached
      state: restarted
  - name: restart apache
    service:
      name: apache
      state: restarted
```

Handlers 也是任务列表，与常规任务没有什么不同，它们由全局惟一的名称引用，并由 notify 动作通知。
如果没有通知处理程序，它将不会运行。

不管有多少任务通知一个处理程序，它都将只运行一次，即在一个特定 play 中的所有任务完成之后。

Handlers 里的任务名称 不能使用 变量

在 ansible 2.2 之后，handlers 支持 listen 来实现监听一个通知程序来实现执行多个通知任务。

```yml
handlers:
  - name: restart memcached
    service:
      name: memcached
      state: restarted
    listen: "restart web services"
  - name: restart apache
    service:
      name: apache
      state: restarted
    listen: "restart web services"

tasks:
  - name: restart everything
    command: echo "this task will restart the web services"
    notify: "restart web services"
```

#### 条件 when 语句

ansible_os_family 是 facts 或 vars 的变量

```yml
#  若操作系统是 Debian 时就执行关机操作
tasks:
  - name: "shut down Debian flavored systems"
    command: /sbin/shutdown -t now
    when: ansible_os_family == "Debian"
```

```yaml
---
# 当变量deploy的值为deploy时执行deploy.yaml的任务步骤
- name: "Starting deploy for nginx"
  include_tasks: deploy.yaml
  when: deploy == "deploy"

# 当变量deploy的值为rollback时执行rollback.yaml的任务步骤
- name: "Starting rollback for nginx"
  include_tasks: rollback.yaml
  when: deploy == "rollback"
```

failed_when: 满足给定的条件时，使任务失败

```yml
tasks:
  - command: echo faild.
    register: command_result
    failed_when: "'faild' in command_result.stdout"

  - debug: msg="echo test"
```

使用注册变量判断

将给定命令的结果存储在变量中， 并在后续的任务中使用。

```yml
- name: test play
  hosts: all

  tasks:
    - shell: cat /etc/motd
      register: motd_contents

    - shell: echo "motd contains the word hi"
      when: motd_contents.stdout.find('hi') != -1
```

```yaml
- name: download wordpress
    register: wp_download

- name: extract wordpress
    when: wp_download.rc == 0
```

一个使用 when 的示例

```yml
- name: Ensure docker history packages are removed.
  yum: "name={{ item }} state=removed"
  with_items: "{{ docker_old }}"

- name: Ensure docker packages are installed.
  yum: "name={{ docker_packages }} state=installed  update_cache=yes"

- name: Install docker repo.
  shell: "yum-config-manager --add-repo {{ docker_repo }}"

- name: Modify the docker software source for keda.
  replace:
    path: /etc/yum.repos.d/docker-ce.repo
    regexp: 'download\.docker\.com'
    replace: "mirrors.ustc.edu.cn/docker-ce"

- name: Create Docker config directory.
  file: path=/etc/docker state=directory

- name: Configure docker startup parameters.
  template:
    src: daemon.json.j2
    dest: "/etc/docker/daemon.json"

- name: Ensure docker-ce are installed.
  yum: "name={{ docker_ce_packages }} state=installed update_cache=yes enablerepo=docker-ce-stable"

- name: Set docker completion.
  copy: src=/usr/share/bash-completion/completions/docker dest=/etc/bash_completion.d/docker remote_src=yes

- name: Ensure docker is started and enabled at boot.
  systemd: name=docker state=started enabled=yes
  when: docker_start

- name: Check if docker-compose file is already.
  stat: path={{ docker_exec_path }}
  register: docker_compose_result

- name: Install docker-compose.
  get_url: url={{ docker_compose_url }} dest={{ docker_exec_path }} validate_certs=no mode=0755
  when: not docker_compose_result.stat.exists

- name: docker-compose version.
  command: docker-compose -version
  register: version_result
  changed_when: false
  ignore_errors: True

- debug: var=version_result.stdout
```

Playbook 条件语句

- https://www.cnblogs.com/breezey/p/10996632.html#always

#### 循环语句

添加多个用户

```yml
- name: add several users
  user:
    name: "{{ item }}"
    state: present
    groups: "wheel"
  loop:
    - testuser1
    - testuser2
```

```yml
- name: Install Mysql package
  yum: name={{ item }} state=present
  with_items:
    - mysql-server
    - MySQL-python
    - libselinux-python
    - libsemanage-python
```

循环还支持列表，可以通过 with_flattened 语句实现

```yml
- name: Example with_flattened loop
  hosts: localhost
  gather_facts: false
  vars:
    my_list:
      - [1, 2, 3]
      - [4, 5, 6]
      - [7, 8, 9]
  tasks:
    - name: Print item
      debug:
        msg: "{{ item }}"
      with_flattened:
        - "{{ my_list }}"
```

```sh
---
#filename: roles/php5-fpm/defaults/main.yml
#defaults file for php5-fpm
php5:
  packages:
    - php5-fpm
    - php5-common
    - php5-curl
    - php5-mysql
    - php5-cli
    - php5-gd
    - php5-mcrypt
    - php5-suhosin
    - php5-memcache
  service:
    name: php5-fpm
```

循环一个数组

```yaml
---
#filename: roles/php5-fpm/tasks/main.yml
# tasks file for php5-fpm
- include_vars: "{{ ansible_os_family }}.yml"
  when: ansible_os_family != 'Debian'

- include: install.yml
- include: service.yml

#filename: roles/php5-fpm/tasks/install.yml
  - name: install php5-fpm and family
    apt:
      name: "{{ item }}"
    with_items: php5.packages
    notify:
     - restart php5-fpm service

#filename: roles/php5-fpm/tasks/service.yml
# manage php5-fpm service
- name: start php5-fpm service
  service:
    name: "{{ php5['service']['name'] }}"
    state: started
```

Playbook 循环语句

- https://www.cnblogs.com/breezey/p/10996629.html

#### 滚动执行

管理节点过多导致的超时问题解决方法

默认情况下，Ansible 将尝试并行管理 playbook 中所有的机器。对于滚动更新用例，可以使用 serial 关键字定义 Ansible 一次应管理多少主机，还可以将 serial 关键字指定为百分比，表示每次并行执行的主机数占总数的比例

示例 1

```yaml
#vim test_serial.yml
---
- hosts: all
  # 每次只同时处理2个主机,将所有task执行完成后,再选下2个主机再执行所有task,直至所有主机
  serial: 2
  gather_facts: False

tasks:
 - name: task one
    comand: hostname

 - name: task two
    command: hostname
```

示例 2

```yaml
- name: test serail
  hosts: all
  # 每次只同时处理20%的主机
  serial: "20%"
```

示例 3

```yaml
# cat test_serial.yml
---
- hosts: websrvs
  serial: 1
  tasks:
    - name: task1
    shell: wall "{{ansible_nodename}} is running task1"
    - name: task2
    shell: wall "{{ansible_nodename}} is running task2"
    - name: task3
    shell: wall "{{ansible_nodename}} is running task3"
```

#### 委派至其它主机执行

利用委托技术,可以在非当前被控主机的其它主机上执行指定操作
范例: 将任务委派给指定的主机执行

```yaml
# cat delegate.yml
#在10.0.0.8上执行hostname -I,而非当前主机localhost
- hosts: localhost

tasks:
  - name: show ip address
    command: hostname -I
    # 指定当前任务被委派给的目标主机
    delegate_to: 10.0.0.8
    # 收集被委派的目标主机的facts信息
    delegate_facts: true
```

范例: 将任务被委派给控制端 ansible 主机执行

```yaml
# 在本地执行ifconfig,而非10.0.0.8
# cat delegate2.yml
- hosts: 10.0.0.8

tasks:
  - name: show ip address
    # 被委派给控制端ansible主机执行
    local_action: command ifconfig

  - name: show hostname
    shell: hostname
    # 被委派给控制端ansible主机执行
    connection: local

  - name: kernel version
    shell: uname -r
    # 被委派给控制端ansible主机执行
    delegate_to: localhost
    # 委派任务只执行一次
    run_one: true
```

范例: 创建普通用户基于 ssh key 验证

```yaml
# cat ssh_key_push.yml
# 创建普通用户管理ansible
- hosts: all
vars:
 - user_name: ssh_demo

tasks:

# manager
- name: Create Manager {{ user_name }}
  user:
    name: "{{ user_name }}"
    generate_ssh_key: yes
    ssh_key_bits: 2048
    ssh_key_file: .ssh/id_rsa
 register: user_message
 # 委派给管理端
 delegate_to: localhost
 # 委派任务仅执行一次
 run_once: true

# node
- name: 打印管理用户的key结果
  debug:
    msg: "{{ user_message.ssh_public_key }}"

- name: 在被控端上创建用户
  user:
    name: "{{ user_name }}"


- name: 在被控端上创建用户.ssh目录
  file:
    path: "/home/{{ user_name }}/.ssh"
    state: directory
    owner: "{{ user_name }}"
    group: "{{ user_name }}"
    mode: "0700"

- name: 将管理端 {{ user_name }} 用户的key存储到被控端
  copy:
    content: "{{ user_message.ssh_public_key }}"
    dest: "/home/{{ user_name }}/.ssh/authorized_keys"
    owner: "{{ user_name }}"
    group: "{{ user_name }}"
    mode: "0600"

- name: 配置被控制端sudo提权,最后追加一行
  lineinfile:
    path: /etc/sudoers
    line: "{{ user_name }} ALL=(ALL) NOPASSWD:ALL"
```

范例: 通过 hparoxy 代码升级

```yaml
- hosts: webservers
  serial: 1

tasks:
  - name: Down Node {{ inventory_hostname }}
    haproxy:
      state: disabled
      host: '{{ inventory_hostname }}'
      socket: /var/lib/haproxy/stats
      backend: ansible_cluster
    delegate_to: 10.0.0.100

  - name: Sleep
    shell:
      cmd: sleep 5

  - name: Update Nginx Code
    copy:
      content: "App Version V2.0{{ ansible_eth0.ipv4.address.split('.')[-1]}}"
      dest: /opt/index.html

  - name: Up Node {{ inventory_hostname }}
    haproxy:
      state: enabled
      host: '{{ inventory_hostname }}'
      socket: /var/lib/haproxy/stats
      backend: ansible_cluster
      wait: yes
    delegate_to: 10.0.0.100
```

### 4.Playbook 高级用法

#### 本地执行

如果希望在控制主机本地运行一个特定的任务，可以使用 local_action 语句。

假设我们需要配置的远程主机刚刚启动，如果我们直接运行 playbook，可能会因为 sshd 服务尚未开始监听而导致失败，我们可以在控制主机上使用如下示例来等待被控端 sshd 端口监听：

```yaml
- name: wait for ssh server to be running
  wait_for
      port: 22
      host: "{{ inventory_hostname }}"
      search_regex: OpenSSH
  connection: local
```

#### 任务委托

在有些时候，我们希望运行与选定的主机或主机组相关联的 task，但是这个 task 又不需要在选定的主机或主机组上执行，而需要在另一台服务器上执行。

这种特性适用于以下场景：

- 在告警系统中启用基于主机的告警
- 向负载均衡器中添加或移除一台主机
- 在 dns 上添加或修改针对某个主机的解析
- 在存储节点上创建一个存储以用于主机挂载
- 使用一个外部程序来检测主机上的服务是否正常

可以使用 delegate_to 语句来在另一台主机上运行 task：

```yaml
- name: enable alerts for web servers
  hosts: webservers
  tasks:
    - name: enable alerts
      nagios: action=enable_alerts service=web host="{{ inventory_hostname }}"
      delegate_to: nagios.example.com
```

> 如果 delegate_to: 127.0.0.1 的时候，等价于 local_action

#### 任务暂停

有些情况下，一些任务的运行需要等待一些状态的恢复，比如某一台主机或者应用刚刚重启，我们需要需要等待它上面的某个端口开启，此时就需要将正在运行的任务暂停，直到其状态满足要求。

Ansible 提供了 wait_for 模块以实现任务暂停的需求

wait_for 模块常用参数：

- connect_timeout：在下一个任务执行之前等待连接的超时时间
- delay：等待一个端口或者文件或者连接到指定的状态时，默认超时时间为 300 秒，在这等待的 300s 的时间里，wait_for 模块会一直轮询指定的对象是否到达指定的状态，delay 即为多长时间轮询一次状态。
- host：wait_for 模块等待的主机的地址，默认为 127.0.0.1
- port：wait_for 模块待待的主机的端口
- path：文件路径，只有当这个文件存在时，下一任务才开始执行，即等待该文件创建完成
- state：等待的状态，即等待的文件或端口或者连接状态达到指定的状态时，下一个任务开始执行。当等的对象为端口时，状态有 started，stoped，即端口已经监听或者端口已经关闭；当等待的对象为文件时，状态有 present 或者 started，absent，即文件已创建或者删除；当等待的对象为一个连接时，状态有 drained，即连接已建立。默认为 started
- timeout：wait_for 的等待的超时时间,默认为 300 秒

```yaml
#等待8080端口已正常监听，才开始下一个任务，直到超时
- wait_for:
    port: 8080
    state: started

#等待8000端口正常监听，每隔10s检查一次，直至等待超时
- wait_for:
    port: 8000
    delay: 10

#等待8000端口直至有连接建立
- wait_for:
    host: 0.0.0.0
    port: 8000
    delay: 10
    state: drained

#等待8000端口有连接建立，如果连接来自10.2.1.2或者10.2.1.3，则忽略。
- wait_for:
    host: 0.0.0.0
    port: 8000
    state: drained
    exclude_hosts: 10.2.1.2,10.2.1.3

#等待/tmp/foo文件已创建
- wait_for:
    path: /tmp/foo

#等待/tmp/foo文件已创建，而且该文件中需要包含completed字符串
- wait_for:
    path: /tmp/foo
    search_regex: completed

#等待/var/lock/file.lock被删除
- wait_for:
    path: /var/lock/file.lock
    state: absent

#等待指定的进程被销毁
- wait_for:
    path: /proc/3466/status
    state: absent

#等待openssh启动，10s检查一次
- wait_for:
    port: 22
    host: "{{ ansible_ssh_host | default(inventory_hostname) }}" search_regex: OpenSSH
    delay: 10
```

#### 滚动执行

默认情况下，ansible 会并行的在所有选定的主机或主机组上执行每一个 task，但有的时候，我们会希望能够逐台运行。最典型的例子就是对负载均衡器后面的应用服务器进行更新时。通常来讲，我们会将应用服务器逐台从负载均衡器上摘除，更新，然后再添加回去。我们可以在 play 中使用 serial 语句来告诉 ansible 限制并行执行 play 的主机数量。

下面是一个在 amazon EC2 的负载均衡器中移除主机，更新软件包，再添加回负载均衡的配置示例：

```yaml
- name: upgrade pkgs on servers behind load balancer
  hosts: myhosts
  serial: 1
  tasks:
    - name: get the ec2 instance id and elastic load balancer id
      ec2_facts:

    - name: take the host out of the elastic load balancer id
      local_action: ec2_elb
      args:
        instance_id: "{{ ansible_ec2_instance_id }}"
        state: absent

    - name: upgrade pkgs
      apt:
        update_cache: yes
        upgrade: yes

    - name: put the host back n the elastic load balancer
      local_action: ec2_elb
      args:
        instance_id: "{{ ansible_ec2_instance_id }}"
        state: present
        ec2_elbs: "{{ items }}"
      with_items: ec2_elbs
```

#### 只执行一次

某些时候，我们希望某个 task 只执行一次，即使它被绑定到了多个主机上。例如在一个负载均衡器后面有多台应用服务器，我们希望执行一个数据库迁移，只需要在一个应用服务器上执行操作即可。

- 可以使用 run_once 语句来处理：

```yaml
- name: run the database migrateions
  command: /opt/run_migrateions
  run_once: true
```

- 还可以与 local_action 配合使用，如下：

```yaml
- name: run the task locally, only once
  command: /opt/my-custom-command
  connection: local
  run_once: true
```

- 还可以与 delegate_to 配合使用，让这个只执行一次的任务在指定的机器上运行：

```yaml
- name: run the task locally, only once
  command: /opt/my-custom-command
  run_once: true
  delegate_to: app.a1-61-105.dev.unp
```

#### 设置环境变量

我们在命令行下执行某些命令的时候，这些命令可能会需要依赖环境变量。比如在安装某些包的时候，可能需要通过代理才能完成完装。或者某个脚本可能需要调用某个环境变量才能完成运行。

ansible 支持通过 environment 关键字来定义一些环境变量。

在如下场景中可能需要用到环境变量：

- 运行 shell 的时候，需要设置 path 变量
- 需要加载一些库，这些库不在系统的标准库路径当中

```yaml
---
- name: upload a remote file to aws s3
  hosts: test
  tasks:
    - name: install pip
      yum:
        name: python-pip
        state: installed

    - name: install the aws tools
      pip:
        name: awscli
        state: present

    - name upload file to s3
      shell aws s3 put-object --bucket=my-test-bucket --key={{ ansible_hostname }}/fstab --body=/etc/fstab --region=eu-west-1
      environment:
        AWS_ACCESS_KEY_ID: xxxxxx
        AWS_SECRET_ACCESS_KEY: xxxxxx
```

事实上，environment 也可以存储在变量当中：

```yaml
- hosts: all
  remote_user: root
  vars:
    proxy_env:
      http_proxy: http://proxy.example.com:8080
      https_proxy: http://proxy.bos.example.com:8080
  tasks:
    - apt: name=cobbler state=installed
      environment: proxy_env
```

#### 交互式提示

在少数情况下，ansible 任务运行的过程中需要用户输入一些数据，这些数据要么比较秘密不方便，或者数据是动态的，不同的用户有不同的需求，比如输入用户自己的账户和密码或者输入不同的版本号会触发不同的后续操作等。

ansible 的 vars_prompt 关键字就是用来处理上述这种与用户交互的情况的。

```yaml
 - hosts: all
   remote_user: root
   vars_prompt:
      - name: share_user
        prompt: "what is your network username?"
        private: yes

      - name: share_pass
        prompt: "what is your network password"
        private: yes

    tasks:
      - debug:
          var: share_user
      - debug:
          var: share_pass
```

vars_prompt 常用选项说明：

- private: 默认为 yes，表示用户输入的值在命令行不可见
- default：定义默认值，当用户未输入时则使用默认值
- confirm：如果设置为 yes，则会要求用户输入两次，适合输入密码的情况

### 5.常用片段

#### 打印执行主机信息

```yaml
- name: debug inventory_hostname
  debug:
    var: inventory_hostname

- name: debug groups[hosts_src_ctl][0]
  debug:
    var: groups[hosts_src_ctl][0]
```

#### 删除文件

删除指定目录下，对应规则的文件

```yaml
- hosts: all
  tasks:

  - name: find to delete logs
    find:
      paths: /var/log/
      patterns: *.log
      # age: 3d 查找3天前的文件
    register: files_to_absent

  - name: absent logs
    file:
      path: "{{ item.path }}"
      state: absent
    with_items: "{{ files_to_absent.files }}"
```

删除已知的文件

```yaml
- name: absent logs
  file:
    path: "{{ item }}"
    state: absent
  with_items:
    - /tmp/log1.log
    - /tmp/log1.log
```

#### 删除进程

```yaml
- hosts: all
  tasks:
    - name: find running processes
      ignore_errors: yes
      shell: "ps -ef | grep -v grep | grep sshd | awk '{print $2}'"
      register: running_processes

    - name: Kill running processes
      ignore_errors: yes
      shell: "kill {{ item }}"
      with_items: "{{ running_processes.stdout_lines }}"
```

#### 在任务中设置变量

```yaml
# 获取组中第一个主机的 ip 地址
# {{ hostvars[groups['webservers'][0]]['ansible_eth0']['ipv4']['address'] }}

- set_fact: ipaddress="{{ hostvars[groups['webservers'][0]]['ansible_eth0']['ipv4']['address'] }}"
- set_fact: headnode="{{ groups[['webservers'][0]] }}"

- debug: msg={{ headnode }}
- debug: msg={{ ipaddress }}
```

#### 获取 ip 地址

```yaml
    {% for host in groups['db_servers'] %}
       {{ hostvars[host]['ansible_eth0']['ipv4']['address'] }}
    {% endfor %}

    {{ ansible_default_ipv4 }}
```

#### 如何获取 shell 变量

```yaml
vars:
    local_home: "{{ lookup('env','HOME') }}"
tasks:
  - debug: var=local_home

# 在ansible1.4版本以上，可以使用以下方式获取
- debug: var=ansible_env.HOME
```

#### 远程遍历拷贝文件

```yaml
- name: get files in /path/
  shell: ls /path/*
  register: path_files

- name: fetch these back to the local Ansible host for backup purposes
  fetch:
    src: /path/"{{item}}"
    dest: /path/to/backups/
  with_items: "{{ path_files.stdout_lines }}"
```

#### 递归目录中的模版文件

```yaml
- name: Copying the templated jinja2 files
  template: src={{item}} dest={{RUN_TIME}}/{{ item | regex_replace(role_path+'/templates','') | regex_replace('\.j2', '') }}
  with_items: "{{ lookup('pipe','find {{role_path}}/templates -type f').split('\n') }}"
```

#### 使用系统其他用户执行命令

```yaml
ansible node1 -m shell -a "touch /tmp/12345" --become-user=hadoop --become

- command: touch /tmp/1234567
  become: true
  become_user: hadoop

```

#### 判断文件是否存在

```yaml
- name: install | Check if Mysql file is already configured.
  stat: path=/tmp/123
  register: file_result

- name: install | Create software files path.
  file: path=/tmp/123 state=directory
  when: not file_result.stat.exists
```

#### 远程遍历拷贝文件

```yaml
- name: get files in /path/
  shell: ls /path/*
  register: path_files

- name: fetch these back to the local Ansible host for backup purposes
  fetch:
    src: /path/"{{item}}"
    dest: /path/to/backups/
  with_items: "{{ path_files.stdout_lines }}"
```

#### 使用系统其他用户执行命令

```yaml
ansible node1 -m shell -a "touch /tmp/12345" --become-user=hadoop --become

- command: touch /tmp/1234567
  become: true
  become_user: hadoop
```

#### 获取主机清单中组的 ip 地址

```yaml
- shell: "ping -c 1 {{item}} | grep icmp_seq | gawk -F'[()]'  '{print $2}'"
  with_inventory_hostnames: test2
  register: testip

- debug: "msg={{ item.stdout }}"
  with_items: "{{ testip.results }}"
```

#### 获取 redis 的 info 信息

```yaml
- hosts: localhost
  gather_facts: false
  tasks:
    - name: "query redis info"
      expect:
        command: "telnet 106.14.183.68 6379"
        responses:
          "Escape":
            - "auth test\ninfo\nquit\n"
      ignore_errors: true
      register: result
    - name: "show the variable"
      debug:
        var: result
```

#### 不显示失败内容

在执行 task 时，有些时候不希望模块报出 fatal 的错误信息，这时候我们可以使用 failed_when 关键字使 task 永不失败,在使用 register 关键字记录模块的信息，便于后续任务使用. changed_when 是永不改变，no_log 是不记录日志。

```yaml
- name: 检查主机连接状态
  wait_for_connection:
    connect_timeout: 1
    timeout: 3
  register: host_status
  failed_when: false
  changed_when: false
  no_log: true

- name: 结束运行连接失败的主机
  meta: end_host
  when: host_status.msg is defined and host_status.msg is search('SSH Error')
```

Ansible Task 片段

- https://ansible.leops.cn/advanced/practice/snippets/

### 6.kolla-ansible 中常见 ansible 语法

#### 复杂判断

```yaml
# ansible.roles.prechecks.tasks.package_checks.yml
---
- name: Checking docker SDK version
  command: '/usr/bin/python -c "import docker; print docker.__version__"'
  register: result
  changed_when: false
  when: inventory_hostname in groups['baremetal']
  failed_when: result | failed or
    result.stdout | version_compare(docker_py_version_min, '<')
```

这个 playbook 的功能是：

1.开始执行 book 中的第一个 play：Checking docker SDK version

2.判断目标主机 inventory_hostname 是否属于主机清单中的 baremetal 组

3.如果属于，到这台主机上执行 command module，参数是"/usr/bin/python -c "import docker; print docker.version""

4.将执行的结果赋值给 result 变量

5.因为这个模块不会更改目标主机上的任何设置，所以 change_when 是 false，无论执行结果如何，都不会去改变这个当然任务的 changed 属性

6.将 result 变量传递给 failed 函数，判断命令是否执行成功

7.如果命令执行成功，将 result 中的输出结果，传递给 version_compare 函数，判断版本是否符合要求

8.因为这个模块不会更改目标主机上的任何设置，所以 change_when 永远是 false

9.如果 failed_when 判断结果为失败，则设置任务状态为失败，停止执行此 playbook

#### 条件语句

when，faild_when, change_when 后面可以接入一个条件语句，条件语句的值是 true 或者 false，条件语句示例如下：

```yaml
ansible_os_family == "Debian"
test == 1 or run == always
hostname in [1,2,3,4]
```

ansible 除了上文的==, or, in 来进行判断外，ansible 还支持通过管道调用 ansible 自定义的 test plugin 进行判断,

上文中的`result | failed or result.stdout | version_compare(docker_py_version_min, '<')`用到了 `version_compare` 和 `failed` 两个 `test plugin`，这两个 test plugin 本质是 ansible 指定目录下两个 python 函数，用来解析字符串判断版本版本是否匹配，执行命令是否成功。

它们的源码位于 ansible.plugins.test.core, ansible。所有 test plugin 位于 ansible.plugins.test，ansible 支持自定义 test plugin。

#### 迭代

with_itmes 是 ansible 的迭代语句，作用类似 python 的 for item in {}, 用法示例：

```yaml
- name: test list
  command: echo {{ item }}
  with_items: [0, 2, 4, 6, 8, 10]
  when: item > 56

- name: Setting sysctl values
  sysctl: name={{ item.name }} value={{ item.value }} sysctl_set=yes
  with_items:
    - { name: "net.bridge.bridge-nf-call-iptables", value: 1 }
    - { name: "net.bridge.bridge-nf-call-ip6tables", value: 1 }
    - { name: "net.ipv4.conf.all.rp_filter", value: 0 }
    - { name: "net.ipv4.conf.default.rp_filter", value: 0 }
  when:
    - set_sysctl | bool
    - inventory_hostname in groups['compute']
```

#### failed_when

一种错误处理机制，一般用来检测执行的结果，如果执行失败，终止任务，和条件语句搭配使用

#### changed_when

当我们控制一些远程主机执行某些任务时，当任务在远程主机上成功执行，状态发生更改时，会返回 changed 状态响应，状态未发生更改时，会返回 OK 状态响应，当任务被跳过时，会返回 skipped 状态响应。我们可以通过 changed_when 来手动更改 changed 响应状态。

#### run_once

当对一个主机组赋予进行操作时，有部分操作并不需要在每个主机上都执行，比如说 nova 服务安装时，需要初始化 nova 数据库，这个操作只需要在一个节点上执行一次就可以了，这种情况可以使用 run_once 标记，被标记的任务不会在多个节点上重复执行。
delegate_to 可以配合 run_once 使用，可以在 playbook 中指定数据库任务要执行的主机，下面的例子中，指定要执行数据库创建的主机是 `groups['nova-api'][0]`

```yaml
- name: Creating Nova databases
  kolla_toolbox:
    module_name: mysql_db
    module_args:
      login_host: "{{ database_address }}"
      login_port: "{{ database_port }}"
      login_user: "{{ database_user }}"
      login_password: "{{ database_password }}"
      name: "{{ item }}"
  register: database
  run_once: True
  delegate_to: "{{ groups['nova-api'][0] }}"
  with_items:
    - "{{ nova_database_name }}"
    - "{{ nova_database_name }}_cell0"
    - "{{ nova_api_database_name }}"
```

delegate_to 指定的机器可以当前任务的机器没有任何关系，比如，在部署 nova 服务时，可以 delegate_to 的目标不限于 nova 机器，可以到 delegate_to ansible 控制节点或者存储机器上执行任务。例如：

```yaml
hosts: app_servers
tasks:
  name: gather facts from db servers
  setup:
  delegate_to: "{{item}}"
  delegate_facts: True
  with_items: "{{groups[‘dbservers‘}}"
# 该例子会收集dbservers的facts并分配给这些机器, 而不会去收集app_servers的facts
```

#### serial

一般情况下, ansible 会同时在所有服务器上执行用户定义的操作, 但是用户可以通过 serial 参数来定义同时可以在多少太机器上执行操作.

```yaml
name: test play
hosts: webservers
serial: 3
# webservers组中的3台机器完全完成play后, 其他3台机器才会开始执行
```

#### until

这种循环由三个指令完成：

- until 是一个条件表达式，如果满足条件循环结束
- retry 是重试的次数
- delay 是延迟时间

示例如下：

```yaml
action: shell /usr/bin/foo
register: result
until: result.stdout.find("all systems go") != -1
retries: 5
delay:
```

#### wait_for

wait_for 可以让 ansible 等待一段时间，直到条件满足，再继续向下执行，这个模块主要用来等待之前的操作完成，比如服务启动成功，锁释放。

下面是一个 kolla-ansible 判断 murano-api 服务是否启动成功的例子：

在 `murano-api[0]`节点上, 尝试和 `api_interface_address:murano_api_port` 建立链接，如果成功建立连接，结束等待。

如果 1 秒（connect_timeout）内未建立成功，放弃，休眠 1 秒（参数 sleep，未配置，默认值）后重试，如果 60 秒（timeout）内没有成功创建链接，任务失败。

```yaml
- name: Waiting for Murano API service to be ready on first node
  wait_for:
    host: "{{ api_interface_address }}"
    port: "{{ murano_api_port }}"
    connect_timeout: 1
    timeout: 60
  run_once: True
  delegate_to: "{{ groups['murano-api'][0] }}"
```

#### 配合 register 循环列表

```yaml
- shell: echo "{{ item }}"
  with_items:
    - one
    - two
  register: echo

- name: Fail if return code is not 0
  fail:
    msg: "The command ({{ item.cmd }}) did not have a 0 return code"
  when: item.rc != 0
  with_items: echo.results
```

### 7.Nginx 配置修改工具 Ansible

#### 1.Ansible 剧本（playbook）

Ansible 中每个剧本只有一个主入口文件，并且只有一个主线任务，主线任务可根据不同条件选用不同的角色，每个角色由任务、变量、模板、处理器的 YAML 描述文件组成。

Ansible 及剧本目录结构如下:

```sh
├── ansible.cfg                 # ansible配置文件
├── hosts                       # 目标主机资源文件
└── roles                       # 剧本目录，可自定义
    ├── nginx                         # 剧本角色名称及角色任务文件目录
    │   ├── defaults                 # 角色默认变量目录
    │   │   └── main.yaml           # 默认变量自动加载的文件
    │   ├── files                    # 文件存放目录
    │   ├── handlers                 # 处理器任务文件目录
    │   │   └── main.yaml           # 默认处理器任务自动加载的文件
    │   ├── tasks                    # 角色任务文件存放目录
    │   │   └── main.yaml           # 当前角色默认的任务入口文件
    │   └── templates                # 任务模板存放目录
    └── nginx.yaml                    # 剧本入口文件
```

#### 2.基础语法

1. 步骤描述
   任务由多个步骤组成，每个步骤由步骤命名、任务模块、动作组成，配置样例如下:

```yaml
- name: reload Nginx Service # 步骤名
  systemd: "name=nginx state=reloaded enabled=yes" # 任务模块为systemd，动作是对系统服务     # Nginx执行reload操作
```

2. 执行顺序
   Ansible 剧本中的步骤是自上而下执行的，在默认情况下，每个步骤的执行结果返回值如果不为 0，就会报错，剧本任务也终止，也可以通过忽略错误指令继续运行，配置样例如下:

```yaml
- name: Create conf.d
  shell: mkdir -p /etc/nginx/conf.d # 任务模块是shell，动作是执行mkdir命令
  ignore_errors: True # 如果当前动作执行出错，忽略错误继续执行
```

3. 变量赋值
   Ansible 剧本中变量赋值有静态和动态两种方式，一种是在 defaults 目录的 main.yaml 文件中静态地直接赋值，这通常被用作默认变量的赋值，配置样例如下:

```yaml
confdir: "/etc/nginx" # 定义变量confdir的值为/etc/nginx
```

另一种是在当前执行的过程中动态地进行变量赋值，被赋值的变量可以在当前剧本执行过程中被引用，配置样例如下所示:

```yaml
# 方法一:将执行结果动态赋值给变量
- name: Test Nginx Config
  shell:
    nginx -c {{ confdir }}/nginx.conf -t # 任务模块是shell，动作是Nginx
    # 执行-t参数命令
  register: test_result # 将执行结果赋值给变量test_result
# 方法二:根据其他变量的值进行动态的变量赋值
- name: check set_fact output
  set_fact: output="{{ work }}/output" # 为变量output赋值
  when: test_result # 当变量test_result为真时
```

4. 条件判断
   在 Ansible 剧本中可以根据变量的值判断是否执行当前步骤，配置样例如下:

```yaml
- debug: msg="{{ test_result.stderr_lines }}" # 任务模块debug，输出变量test_result.stderr_lines的内容
  when: not test_result.stderr_lines == "" # 当test_result变量的输出结果不为空，执行当前步骤
```

5. 外部引入
   多个步骤可以编写在一个 YAML 文件中，并通过指令 include_tasks 被其他任务引入，结合条件判断，它可以使主线任务因变量不同而存在多个不同分支，配置样例如下:

```yaml
- name: "check system type"
  include_tasks: linux.yaml # 引入外部任务步骤
  when: ansible_os_family != "Windows" # 当目标操作系统非windows时，执行当前任务
```

#### 3.剧本执行

Ansible 剧本编写结束后，使用 ansible-playbook 命令调用剧本入口文件执行相应的剧本，即可自动完成预设的任务。

```sh
ansible-playbook -i /etc/ansible/hosts /etc/ansible/roles/nginx.yaml --extra-vars 'hosts=192.168.2.145'
```
