# Dockerfile

## 1.运行的容器来构建新的镜像
比如一个 python 镜像，我们要在内网中使用，但是内网环境没有 pip 源，所以我们只能把对应的包先在外网环境下载做成镜像。

```shell
┌──[root@vms100.liruilongs.github.io]-[~]
└─$docker run -d  python  python -m http.server 33333
009033ff4c0155f81647b857c0bf8975ee750a13d7aa2584638af032aafa758b
```

然后进入容器下载相关的依赖包，之后生成镜像导出

```shell
┌──[root@vms100.liruilongs.github.io]-[~]
└─$docker commit bcdd82ca5b48  my-python:latest
sha256:cb7c9965c541dfc794f78eb06ae1c4af0c77bb87c92e5e6e768c7770eb61a5bb

┌──[root@vms100.liruilongs.github.io]-[~]
└─$docker save  my-python:latest -o ./my-python.tar
```

在操作上有些繁琐，使用 Dockerfile 的方式可能方便一点
```shell
┌──[root@vms100.liruilongs.github.io]-[~]
└─$docker build -<<EOF
> FROM python
> RUN python -m pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
> RUN python -m pip install psycopg2
> EOF
Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM python
 ---> a5d7930b60cc
Step 2/3 : RUN python -m pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
 ---> Running in 88140ad45551
Writing to /root/.config/pip/pip.conf
Removing intermediate container 88140ad45551
 ---> df41fddd2cd2
Step 3/3 : RUN python -m pip install psycopg2
 ---> Running in 1eddfbf7fa58
Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple
Collecting psycopg2
  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/89/d6/cd8c46417e0f7a16b4b0fc321f4ab676a59250d08fce5b64921897fb07cc/psycopg2-2.9.5.tar.gz (384 kB)
Building wheels for collected packages: psycopg2
  Building wheel for psycopg2 (setup.py): started
.....
  14/44f32ab3b3f40f2e9a1a9ab8281a40ff4a911a930121c928b1
Successfully built psycopg2
Installing collected packages: psycopg2
.......
Removing intermediate container 1eddfbf7fa58
 ---> 8791cb1dc692
Successfully built 8791cb1dc692
```

忘记打标签了。这里我们手动打一下。可以在 build 的时候通过 -t 命令指定

```shell
┌──[root@vms100.liruilongs.github.io]-[~]
└─$docker tag  8791cb1dc692 my-python:latest

┌──[root@vms100.liruilongs.github.io]-[~]
└─$docker images my-python
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
my-python    latest    8791cb1dc692   8 minutes ago   927MB
```


## 2.Dockerfile自定义镜像

构建常用指令温习


- FROM：基础镜像 
- RUN：制作镜像时执行的命令，可以有多个，每个命令一层 
- ADD：复制文件到镜像，自动解压 (文件类型为: tar.gz 或 tar.bz2)
- COPY：复制文件到镜像，不解压 
- MAINTAINER：镜像创建者信息(新版本以弃用，可以使用LABLE )
- EXPOSE：开放的端口 
- ENV：设置变量 
- WORKDIR：定义容器默认工作目录 
- CMD: 容器启动时执行的命令，仅可以有一条CMD. 
- ENTRYPOINT:类似CMD指令的功能，用于为容器指定默认运行程序，从而使得容器像是一具单独的可执行程序

一些需要注意的事项：

- 当 docker run 命令中声明了参数时，Docker 守护程序会忽略 CMD 命令。

- 与CMD不同的是，由ENTRYPOINT启动的程序不会被docker run命令行指定的参数所覆盖，而且，这些命令行参数会被当作参数传递给ENTRYPOINT指定的程序。不过，docker run 命令的`--entrypoint`选项的参数可覆盖ENTRYPOINT指令指定的程序

- Dockfile中，如果没有使用CMD指定启动命令，则会继承上一个镜像的默认启动命令；CMD 容器的默认启动命令，有且只能有一条；



根据Dockerfile生成新的镜像命令中,build 创建新的镜像；`-t `指定新镜像的名字和标签；`. `指定Dockerfile文件所在的目录

```shell
docker build -t imagename:latest Dockerfile所在目录
```




容器和镜像之间的主要区别在于顶部 可写层。对容器的所有添加新数据或修改现有数据的写入都存储在此 可写层 中。删除容器时，可写层也会被删除。基础镜像保持不变。

这里利用了`写时复制技术(COW,copy on write)` , 对于开发的小伙伴，可以结合享元设计模式理解，对于运维的小伙伴，可以结合 Openstack 组件 Glance 原理来理解

用通俗的话讲，当修改时，会把数据复制到容器层修改。当新增的时候直接在容器层新增，当删除时，会屏蔽镜像层。

Docker 通过读取给定的指令来自动构建镜像。`遵循特定的格式和指令集，其中的 每一条指令在容器镜像中创建一个层。这些层是堆叠的，每个层都是与前一层相比的变化的增量`


这里我们以 redis:7 这个官方镜像为例,看看一个标准的 Dockerfile 如何书写，可以看到镜像构建了 16 层。


```shell
┌──[root@vms107.liruilongs.github.io]-[/etc/systemd]
└─$docker history --human=true  redis:7
IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT
19c51d4327cf   6 weeks ago   /bin/sh -c #(nop)  CMD ["redis-server"]         0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  EXPOSE 6379                  0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  ENTRYPOINT ["docker-entry…   0B
<missing>      6 weeks ago   /bin/sh -c #(nop) COPY file:e873a0e3c13001b5…   661B
<missing>      6 weeks ago   /bin/sh -c #(nop) WORKDIR /data                 0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  VOLUME [/data]               0B
<missing>      6 weeks ago   /bin/sh -c mkdir /data && chown redis:redis …   0B
<missing>      6 weeks ago   /bin/sh -c set -eux;   savedAptMark="$(apt-m…   32MB
<missing>      6 weeks ago   /bin/sh -c #(nop)  ENV REDIS_DOWNLOAD_SHA=06…   0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  ENV REDIS_DOWNLOAD_URL=ht…   0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  ENV REDIS_VERSION=7.0.8      0B
<missing>      7 weeks ago   /bin/sh -c set -eux;  savedAptMark="$(apt-ma…   4.13MB
<missing>      7 weeks ago   /bin/sh -c #(nop)  ENV GOSU_VERSION=1.14        0B
<missing>      7 weeks ago   /bin/sh -c groupadd -r -g 999 redis && usera…   329kB
<missing>      7 weeks ago   /bin/sh -c #(nop)  CMD ["bash"]                 0B
<missing>      7 weeks ago   /bin/sh -c #(nop) ADD file:e2398d0bf516084b2…   80.5MB
┌──[root@vms107.liruilongs.github.io]-[/etc/systemd]
└─$docker history --human=true  redis:7 | wc -l
17
```

涉及 两个Dockerfile文件构建的镜像

基础镜像构建

```shell
FROM scratch
ADD rootfs.tar.xz /
CMD ["bash"]
```


reids镜像构建
```dockerfile

FROM debian:bullseye-slim

# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r -g 999 redis && useradd -r -g redis -u 999 redis

# grab gosu for easy step-down from root
# https://github.com/tianon/gosu/releases
ENV GOSU_VERSION 1.16
RUN set -eux; \
 savedAptMark="$(apt-mark showmanual)"; \
 apt-get update; \
 apt-get install -y --no-install-recommends ca-certificates dirmngr gnupg wget; \
 rm -rf /var/lib/apt/lists/*; \
 dpkgArch="$(dpkg --print-architecture | awk -F- '{ print $NF }')"; \
 wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch"; \
 wget -O /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch.asc"; \
 export GNUPGHOME="$(mktemp -d)"; \
 gpg --batch --keyserver hkps://keys.openpgp.org --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4; \
 gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu; \
 gpgconf --kill all; \
 rm -rf "$GNUPGHOME" /usr/local/bin/gosu.asc; \
 apt-mark auto '.*' > /dev/null; \
 [ -z "$savedAptMark" ] || apt-mark manual $savedAptMark > /dev/null; \
 apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \
 chmod +x /usr/local/bin/gosu; \
 gosu --version; \
 gosu nobody true

ENV REDIS_VERSION 7.0.9
ENV REDIS_DOWNLOAD_URL http://download.redis.io/releases/redis-7.0.9.tar.gz
ENV REDIS_DOWNLOAD_SHA f77135c2a47c9151d4028bfea3b34470ab4d324d1484f79a84c6f32a3cfb9f65

RUN set -eux; \
 \
 savedAptMark="$(apt-mark showmanual)"; \
 apt-get update; \
 apt-get install -y --no-install-recommends \
  ca-certificates \
  wget \
  \
  dpkg-dev \
  gcc \
  libc6-dev \
  libssl-dev \
  make \
 ; \
 rm -rf /var/lib/apt/lists/*; \
 \
 wget -O redis.tar.gz "$REDIS_DOWNLOAD_URL"; \
 echo "$REDIS_DOWNLOAD_SHA *redis.tar.gz" | sha256sum -c -; \
 mkdir -p /usr/src/redis; \
 tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1; \
 rm redis.tar.gz; \
 \
# disable Redis protected mode [1] as it is unnecessary in context of Docker
# (ports are not automatically exposed when running inside Docker, but rather explicitly by specifying -p / -P)
# [1]: https://github.com/redis/redis/commit/edd4d555df57dc84265fdfb4ef59a4678832f6da
 grep -E '^ *createBoolConfig[(]"protected-mode",.*, *1 *,.*[)],$' /usr/src/redis/src/config.c; \
 sed -ri 's!^( *createBoolConfig[(]"protected-mode",.*, *)1( *,.*[)],)$!\10\2!' /usr/src/redis/src/config.c; \
 grep -E '^ *createBoolConfig[(]"protected-mode",.*, *0 *,.*[)],$' /usr/src/redis/src/config.c; \
# for future reference, we modify this directly in the source instead of just supplying a default configuration flag because apparently "if you specify any argument to redis-server, [it assumes] you are going to specify everything"
# see also https://github.com/docker-library/redis/issues/4#issuecomment-50780840
# (more exactly, this makes sure the default behavior of "save on SIGTERM" stays functional by default)
 \
# https://github.com/jemalloc/jemalloc/issues/467 -- we need to patch the "./configure" for the bundled jemalloc to match how Debian compiles, for compatibility
# (also, we do cross-builds, so we need to embed the appropriate "--build=xxx" values to that "./configure" invocation)
 gnuArch="$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)"; \
 extraJemallocConfigureFlags="--build=$gnuArch"; \
# https://salsa.debian.org/debian/jemalloc/-/blob/c0a88c37a551be7d12e4863435365c9a6a51525f/debian/rules#L8-23
 dpkgArch="$(dpkg --print-architecture)"; \
 case "${dpkgArch##*-}" in \
  amd64 | i386 | x32) extraJemallocConfigureFlags="$extraJemallocConfigureFlags --with-lg-page=12" ;; \
  *) extraJemallocConfigureFlags="$extraJemallocConfigureFlags --with-lg-page=16" ;; \
 esac; \
 extraJemallocConfigureFlags="$extraJemallocConfigureFlags --with-lg-hugepage=21"; \
 grep -F 'cd jemalloc && ./configure ' /usr/src/redis/deps/Makefile; \
 sed -ri 's!cd jemalloc && ./configure !&'"$extraJemallocConfigureFlags"' !' /usr/src/redis/deps/Makefile; \
 grep -F "cd jemalloc && ./configure $extraJemallocConfigureFlags " /usr/src/redis/deps/Makefile; \
 \
 export BUILD_TLS=yes; \
 make -C /usr/src/redis -j "$(nproc)" all; \
 make -C /usr/src/redis install; \
 \
# TODO https://github.com/redis/redis/pull/3494 (deduplicate "redis-server" copies)
 serverMd5="$(md5sum /usr/local/bin/redis-server | cut -d' ' -f1)"; export serverMd5; \
 find /usr/local/bin/redis* -maxdepth 0 \
  -type f -not -name redis-server \
  -exec sh -eux -c ' \
   md5="$(md5sum "$1" | cut -d" " -f1)"; \
   test "$md5" = "$serverMd5"; \
  ' -- '{}' ';' \
  -exec ln -svfT 'redis-server' '{}' ';' \
 ; \
 \
 rm -r /usr/src/redis; \
 \
 apt-mark auto '.*' > /dev/null; \
 [ -z "$savedAptMark" ] || apt-mark manual $savedAptMark > /dev/null; \
 find /usr/local -type f -executable -exec ldd '{}' ';' \
  | awk '/=>/ { print $(NF-1) }' \
  | sort -u \
  | xargs -r dpkg-query --search \
  | cut -d: -f1 \
  | sort -u \
  | xargs -r apt-mark manual \
 ; \
 apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \
 \
 redis-cli --version; \
 redis-server --version

RUN mkdir /data && chown redis:redis /data
VOLUME /data
WORKDIR /data

COPY docker-entrypoint.sh /usr/local/bin/
ENTRYPOINT ["docker-entrypoint.sh"]

EXPOSE 6379
CMD ["redis-server"]
```

运行此镜像并创建一个容器时，我们实际上在底层之上添加了一个新的可写层（容器层）。对正在运行的容器所做的所有更改（例如写入新文件、修改现有文件和删除文件）都将写入此可写容器层。

可以看到上面的 Dockerfile 文件很庞大，通过这个文件我们来总结一些 在编写时需要注意的地方


### 热门Dockerfile示例

下面是Docker Hub上两个热门镜像nginx和Go的Dockerfile的例子，通过这两个例子。读者可以对Dockerfile结构有个基本的感知。


#### Nginx
基于debian：jessie基础镜像基础上安装Nginx环境，从而创建一个新的nginx镜像：

```dockerfile

FROM debian:jessie
LABEL maintainer docker_user<docker_user@email.com>
ENV NGINX_VERSION 1.10.1-1~jessie
RUN apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-keys 573BFD6B3D8FBC64107
    9A6ABABF5BD827BD9BF62 \
        && echo "deb http://nginx.org/packages/debian/ jessie nginx" >> /etc/apt/sources.list \
        && apt-get update \
        && apt-get install --no-install-recommends --no-install-suggests -y \
        ca-certificates \
        nginx=${NGINX_VERSION} \
        nginx-module-xslt \
        nginx-module-geoip \
        nginx-module-image-filter \
        nginx-module-perl \
        nginx-module-njs \
        gettext-base \
        && rm -rf /var/lib/apt/lists/*
# forward request and error logs to docker log collector
RUN ln -sf /dev/stdout /var/log/nginx/access.log \
    && ln -sf /dev/stderr /var/log/nginx/error.log
EXPOSE 80 443
CMD ["nginx", "-g", "daemon off;"]
```


Nginx的官方仓库还提供了Dockerfile构建Nginx镜像，目前的版本是1.7.9，其内容为：

```dockerfile
FROM debian:wheezy
MAINTAINER NGINX Docker Maintainers "docker-maint@nginx.com"
RUN apt-key adv --keyserver pgp.mit.edu --recv-keys 573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62
RUN echo "deb http://nginx.org/packages/mainline/debian/ wheezy nginx" >> /etc/apt/sources.list
ENV NGINX_VERSION 1.7.9-1~wheezy
RUN apt-get update && apt-get install -y nginx=${NGINX_VERSION} && rm -rf /var/lib/apt/lists/*
# forward request and error logs to docker log collector
RUN ln -sf /dev/stdout /var/log/nginx/access.log
RUN ln -sf /dev/stderr /var/log/nginx/error.log
VOLUME ["/var/cache/nginx"]
EXPOSE 80 443
CMD ["nginx", "-g", "daemon off;"]
```


官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/nginx` 查看。

#### ubuntu

官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/ubuntu` 查看。


#### Node.js

官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/node` 查看。



#### Go
基于buildpack-deps：jessie-scm基础镜像，安装Golang相关环境，制作一个Go语言的运行环境镜像：

```dockerfile

FROM buildpack-deps:jessie-scm
# gcc for cgo
RUN apt-get update && apt-get install -y --no-install-recommends \
    g++ \
    gcc \
    libc6-dev \
    make \
    && rm -rf /var/lib/apt/lists/*
ENV GOLANG_VERSION 1.6.3
ENV GOLANG_DOWNLOAD_URL https://golang.org/dl/go$GOLANG_VERSION.linux-amd64.tar.gz
ENV GOLANG_DOWNLOAD_SHA256 cdde5e08530c0579255d6153b08fdb3b8e47caabbe717bc7bcd7561275a87aeb
RUN curl -fsSL "$GOLANG_DOWNLOAD_URL" -o golang.tar.gz \
    && echo "$GOLANG_DOWNLOAD_SHA256  golang.tar.gz" | sha256sum -c - \
    && tar -C /usr/local -xzf golang.tar.gz \
    && rm golang.tar.gz
ENV GOPATH /go
ENV PATH $GOPATH/bin:/usr/local/go/bin:$PATH
RUN mkdir -p "$GOPATH/src" "$GOPATH/bin" && chmod -R 777 "$GOPATH"
WORKDIR $GOPATH
COPY go-wrapper /usr/local/bin/
```


#### Centos-Nginx


centos7

官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/centos`  查看。

```dockerfile

FROM centos:7
LABEL auther="hjl@oschina.com"

ENV container docker
RUN yum -y swap -- remove fakesystemd -- install systemd systemd-libs
RUN yum -y update; yum clean all; \
  (cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i ==systemd-tmpfiles-setup.service ] || rm -f $i; done); \
  rm -f /lib/systemd/system/multi-user.target.wants/*;\
  rm -f /etc/systemd/system/*.wants/*;\
  rm -f /lib/systemd/system/local-fs.target.wants/*; \
  rm -f /lib/systemd/system/sockets.target.wants/*udev*; \
  rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \
  rm -f /lib/systemd/system/basic.target.wants/*;\
  rm -f /lib/systemd/system/anaconda.target.wants/*;
VOLUME [ "/sys/fs/cgroup" ]
CMD ["/usr/sbin/init"]
```

基于centos7镜像再构建nginx
```dockerfile

FROM centos:7
MAINTAINER www.humingzhe.com
RUN yum install -y gcc gcc-c++ make openssl-devel pcre-devel && yum clean all
ADD nginx-1.12.1.tar.gz /tmp

RUN cd /tmp/nginx-1.12.1 && \
    ./configure --prefix=/usr/local/nginx && \
    make -j 2 && \
    make install && \
    rm -rf /tmp/nginx-1.12.1* && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo 'Asia/Shanghai' >/etc/timezone

COPY nginx.conf /usr/local/nginx/conf
COPY vhost/ /usr/local/nginx/conf

WORKDIR /usr/local/nginx
EXPOSE 80
CMD ["./sbin/nginx", "-g", "daemon off;"]
```




#### Redis
通过Dockerfile也可以构建和官方一样的Redis镜像。这里以2.8版本为例，其Dockerfile为：
```dockerfile

FROM debian:wheezy
# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r redis && useradd -r -g redis redis
RUN apt-get update \
  && apt-get install -y curl \
  && rm -rf /var/lib/apt/lists/*
# grab gosu for easy step-down from root
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4

RUN curl -o /usr/local/bin/gosu -SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture)" \
  && curl -o /usr/local/bin/gosu.asc -SL"https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture).asc" \
  && gpg --verify /usr/local/bin/gosu.asc \
  && rm /usr/local/bin/gosu.asc \
  && chmod +x /usr/local/bin/gosu
ENV REDIS_VERSION 2.8.19
ENV REDIS_DOWNLOAD_URL http://download.redis.io/releases/redis-2.8.19.tar.gz
ENV REDIS_DOWNLOAD_SHA1 3e362f4770ac2fdbdce58a5aa951c1967e0facc8
# for redis-sentinel see: http://redis.io/topics/sentinel
RUN buildDeps='gcc libc6-dev make'; \
  set -x \
  && apt-get update && apt-get install -y $buildDeps --no-install-recommends \
  && rm -rf /var/lib/apt/lists/* \
  && mkdir -p /usr/src/redis \
  && curl -sSL "$REDIS_DOWNLOAD_URL" -o redis.tar.gz \
  && echo "$REDIS_DOWNLOAD_SHA1 *redis.tar.gz" | sha1sum -c - \
  && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
  && rm redis.tar.gz \
  && make -C /usr/src/redis \
  && make -C /usr/src/redis install \
  && rm -r /usr/src/redis \
  && apt-get purge -y --auto-remove $buildDeps
RUN mkdir /data && chown redis:redis /data
VOLUME /data
WORKDIR /data
COPY docker-entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
EXPOSE 6379
CMD [ "redis-server" ]
```

官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/redis` 查看。


#### MySQL

通过Dockerfile来创建mysql
```dockerfile
FROM debian:wheezy
# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r mysql && useradd -r -g mysql mysql
# FATAL ERROR: please install the following Perl modules before executing /usr/local/mysql/scripts/mysql_install_db:
# File::Basename
# File::Copy
# Sys::Hostname
# Data::Dumper
RUN apt-get update && apt-get install -y perl --no-install-recommends && rm -rf /var/lib/apt/lists/*
# gpg: key 5072E1F5: public key "MySQL Release Engineering <mysql-build@oss.oracle.com>" imported
RUN apt-key adv --keyserver pool.sks-keyservers.net --recv-keys A4A9406876FCBD3C456770C88C718D3B5072E1F5
ENV MYSQL_MAJOR 5.7
ENV MYSQL_VERSION 5.7.5-m15
RUN echo "deb http://repo.mysql.com/apt/debian/ wheezy mysql-${MYSQL_MAJOR}-dmr" > /etc/apt/sources.list.d/mysql.list
# the "/var/lib/mysql" stuff here is because the mysql-server postinst doesn't have an explicit way
# to disable the mysql_install_db codepath besides having a database already "configured" (ie, stuff in /var/lib/mysql/mysql)
# also, we set debconf keys to make APT a little quieter
RUN { \
  echo mysql-community-server mysql-community-server/data-dir select ''; \
  echo mysql-community-server mysql-community-server/root-pass password ''; \
  echo mysql-community-server mysql-community-server/re-root-pass password ''; \
  echo mysql-community-server mysql-community-server/remove-test-db select false; \
  } | debconf-set-selections \
  && apt-get update && apt-get install -y mysql-server="${MYSQL_VERSION}"* && rm -rf /var/lib/apt/lists/* \
  && rm -rf /var/lib/mysql && mkdir -p /var/lib/mysql
# comment out a few problematic configuration values
RUN sed -Ei 's/^(bind-address|log)/#&/' /etc/mysql/my.cnf
VOLUME /var/lib/mysql
COPY docker-entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
EXPOSE 3306
CMD ["mysqld"]
```

官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/mysql` 查看


#### Mongodb
```dockerfile
FROM debian:wheezy

RUN groupadd -r mongodb && useradd -r -g mongodb mongodb
RUN apt-get update \
  && apt-get install -y curl numactl \
  && rm -rf /var/lib/apt/lists/*
# grab gosu for easy step-down from root
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4
RUN curl -o /usr/local/bin/gosu -SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg--print-architecture)" \
  && curl -o /usr/local/bin/gosu.asc -SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture).asc" \
  && gpg --verify /usr/local/bin/gosu.asc \
  && rm /usr/local/bin/gosu.asc \
  && chmod +x /usr/local/bin/gosu
ENV MONGO_RELEASE_FINGERPRINT BDC0DB28022D7DEA1490DC3E7085801C857FD301
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys $MONGO_RELEASE_FINGERPRINT
ENV MONGO_VERSION 3.0.0-rc6
RUN curl -SL "https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-$MONGO_VERSION.tgz" -o mongo.tgz \
  && curl -SL "https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-$MONGO_VERSION.tgz.sig" –o mongo.tgz.sig \
  && gpg --verify mongo.tgz.sig \
  && tar -xvf mongo.tgz -C /usr/local --strip-components=1 \
  && rm mongo.tgz*
VOLUME /data/db
COPY docker-entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
EXPOSE 27017
CMD ["mongod"]
```

官方提供的Dockerfile 请到 `https://github.com/docker-library/docs/tree/master/mongo` 查看。


#### Postgres

```dockerfile

FROM debian:wheezy
# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r postgres && useradd -r -g postgres postgres
# grab gosu for easy step-down from root
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/* \
  && curl -o /usr/local/bin/gosu –SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture)" \
  && curl -o /usr/local/bin/gosu.asc -SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture).asc" \
  && gpg --verify /usr/local/bin/gosu.asc \
  && rm /usr/local/bin/gosu.asc \
  && chmod +x /usr/local/bin/gosu \
  && apt-get purge -y --auto-remove curl
# make the "en_US.UTF-8" locale so postgres will be utf-8 enabled by default
RUN apt-get update && apt-get install -y locales && rm -rf /var/lib/apt/lists/* \
  && localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8
ENV LANG en_US.utf8
RUN mkdir /docker-entrypoint-initdb.d
RUN apt-key adv --keyserver pool.sks-keyservers.net --recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8
ENV PG_MAJOR 9.4
ENV PG_VERSION 9.4.0-1.pgdg70+1
RUN echo 'deb http://apt.postgresql.org/pub/repos/apt/ wheezy-pgdg main' $PG_MAJOR > /etc/apt/sources.list.d/pgdg.list
RUN apt-get update \
  && apt-get install -y postgresql-common \
  && sed -ri 's/#(create_main_cluster) .*$/\1 = false/' /etc/postgresql-common/createcluster.conf \
  && apt-get install -y \
  postgresql-$PG_MAJOR=$PG_VERSION \
  postgresql-contrib-$PG_MAJOR=$PG_VERSION \
  && rm -rf /var/lib/apt/lists/*
RUN mkdir -p /var/run/postgresql && chown -R postgres /var/run/postgresql
ENV PATH /usr/lib/postgresql/$PG_MAJOR/bin:$PATH
ENV PGDATA /var/lib/postgresql/data
VOLUME /var/lib/postgresql/data
COPY docker-entrypoint.sh /
ENTRYPOINT ["/docker-entrypoint.sh"]
EXPOSE 5432
CMD ["postgres"]
```

#### httpd

```dockerfile

FROM debian:jessie
# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
#RUN groupadd -r www-data && useradd -r --create-home -g www-data www-data
ENV HTTPD_PREFIX /usr/local/apache2
ENV PATH $PATH:$HTTPD_PREFIX/bin
RUN mkdir -p "$HTTPD_PREFIX" \
  && chown www-data:www-data "$HTTPD_PREFIX"
WORKDIR $HTTPD_PREFIX
# install httpd runtime dependencies
# https://httpd.apache.org/docs/2.4/install.html#requirements
RUN apt-get update \
  && apt-get install -y --no-install-recommends \
  libapr1 \
  libaprutil1 \
  libpcre++0 \
  libssl1.0.0 \
  && rm -r /var/lib/apt/lists/*
# see https://httpd.apache.org/download.cgi#verify
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys A93D62ECC3C8EA12DB220EC934EA76E6791485A8
ENV HTTPD_VERSION 2.4.12
ENV HTTPD_BZ2_URL https://www.apache.org/dist/httpd/httpd-$HTTPD_VERSION.tar.bz2
RUN buildDeps=' \
  ca-certificates \
  curl \
  bzip2 \
  gcc \
  libapr1-dev \
  libaprutil1-dev \
  libc6-dev \
  libpcre++-dev \
  libssl-dev \
  make \
  ' \
  set -x \
  && apt-get update \
  && apt-get install -y --no-install-recommends $buildDeps \
  && rm -r /var/lib/apt/lists/* \
  && curl -SL "$HTTPD_BZ2_URL" -o httpd.tar.bz2 \
  && curl -SL "$HTTPD_BZ2_URL.asc" -o httpd.tar.bz2.asc \
  && gpg --verify httpd.tar.bz2.asc \
  && mkdir -p src/httpd \
  && tar -xvf httpd.tar.bz2 -C src/httpd --strip-components=1 \
  && rm httpd.tar.bz2* \
  && cd src/httpd \
  && ./configure --enable-so --enable-ssl --prefix=$HTTPD_PREFIX \
  && make -j"$(nproc)" \
  && make install \
  && cd ../../ \
  && rm -r src/httpd \
  && sed -ri ' \
  s!^(\s*CustomLog)\s+\S+!\1 /proc/self/fd/1!g; \
  s!^(\s*ErrorLog)\s+\S+!\1 /proc/self/fd/2!g; \
  ' /usr/local/apache2/conf/httpd.conf \
  && apt-get purge -y --auto-remove $buildDeps
COPY httpd-foreground /usr/local/bin/
EXPOSE 80
CMD ["httpd-foreground"]
```






## 3.Dockerfile编写优化

### 3.1 使用小的基础镜像
在上面的  Dockerfile  中基础镜像使用有FROM debian:bullseye-slim, FROM scratch

- scratch 是一个空镜像，一般用不到，在构建最基础的镜像的时候会用到。
- debian:bullseye-slim 是一个 debian 系统的 bullseye 版本的精简版镜像。看的出来，使用的镜像很小。

使用较小的镜像可以更快地构建、推送和拉取 镜像。

往往更安全，因为只包含运行应用程序所需的必要库和系统依赖项。

尤其是在 CI/CD 等流水线中，庞大的 基础镜像 在每个环节都要消耗一些时间，从而使流水线的时间变得很长。

镜像之间的区别主要在于底层的操作系统


镜像选择类型

- `Official Image`：官方镜像，或者叫标准镜像，一般由官方维护的镜像，它是正确的选择，但是可能不是最优的。镜像基于最新的稳定 Debian 操作系统发行版，上面的 有 Dockerfile 构建完成的镜像即为 redis:7 的一个官网镜像。

- `Debian(bullseye/buster/stretch/jessie)`：不同的 Debian Linux 发行版镜像，jessie(8.0)，stretch(9.0) 是比较老旧的版本,buster(10.0) ,bullseye(11.0)为较新的版本

- `slim`：精简版，它通常会安装运行特定工具所需的最小包

- `alpine`：基于 Alpine Linux项目，专门为在容器内部使用而构建的操作系统。相比较 Debian 来说 Alpine 很小很小，但是需要考虑一些时区，兼容性问题。

!!! info "参考文献"


     [编写Dockerfile的一些实践经验](https://blog.frognew.com/2021/07/relearning-container-25.html)


- `scratch`: 一个明确的空镜像，特别是用于建立 "从头开始" 的镜像。

在选择最小基础镜像的同时，要尽量避免安装不必要的软件包


### 3.2 指令链式运行

可以很明显的发现，上面 Dockerfile 中的 RUN 指令很长

这是由于每个指令都会创建一个可缓存单元并构建一个新的中间镜像层。
所以可以通过链接所有命令来避免过多层级。此外，尽量避免链接过多的可缓存 RUN 命令，因为这会导致创建大型缓存并最终导致缓存突发。


```dockerfile

RUN set -eux; \
 \
 savedAptMark="$(apt-mark showmanual)"; \
 apt-get update; \
 apt-get install -y --no-install-recommends \
  ca-certificates \
  wget \
  \
  dpkg-dev \
  gcc \
  libc6-dev \
  libssl-dev \
  make \
 ; \
 rm -rf /var/lib/apt/lists/*; \
 \
 wget -O redis.tar.gz "$REDIS_DOWNLOAD_URL"; \
  ..................
```

### 3.3 变动的指令放到最后

在 RUN 之后放置 COPY
在某些情况下，您对代码进行了细微的更改，并且需要反复从 dockerfile 构建镜像。
在这种情况下，将 COPY 命令放在 RUN 命令之后将有助于减小镜像大小，因为在这种情况下 docker 将能够更好地使用缓存功能。

它将为安装了依赖项的镜像创建缓存，每次更改代码时，docker 都会使用该缓存并创建镜像。它还将减少 docker 构建时间。


所以 `始终将最常更改的指令放在末尾`。会提高构建速度.

```dockerfile

FROM python:3.9-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r /requirements.txt
COPY app.py .
```


```dockerfile

FROM ubuntu:latest
RUN apt update -y && \
apt install unzip -y --no-install-recommends && \
apt install curl --no-install-recommends -y && \
apt install python3 -y --no-install-recommends && \
rm -rf /var/lib/apt/lists/*
COPY file /home/ubuntu
```

### 3.4 首选数组而不是字符串语法

我们可以通过两种不同的方式编写 最后的进程启动 命令 ENTRYPOINT

数组：`ENTRYPOINT ["python","-m","http.server","33333"]`
字符串：`ENTRYPOINT "python -m http.server 33333"`

数组形式是首选。
这是因为使用字符串形式会导致 Docker 使用 bash 运行您的进程，这无法正确处理信号。
由于大多数 shell 不处理子进程的信号，因此如果使用 shell 格式，CTRL-C（生成 SIGTERM）可能不会停止子进程。


### 3.5 COPY而不是ADD
如果有多个步骤使用上下文中的不同文件，请 单独复制 它们，而不是一次全部复制。

这可确保每个步骤的生成缓存仅失效，并在特别需要的文件发生更改时强制重新运行该步骤。

```dockerfile
COPY requirements.txt /tmp/
RUN pip install --requirement /tmp/requirements.txt
COPY . /tmp/
```

!!! Warning "拷贝目录的一个坑"


    拷贝文件不需要写目标
    ```dockerfile
    # 拷贝文件
    FROM centos
    COPY 2.txt /usr/local/
    ```


    拷贝目录则需要这样写,目标,不然拷贝不进去

    ```dockerfile
    # 拷贝目录
    FROM centos
    COPY mysql /usr/local/mysql
    ```


### 3.6 使用.dockerignore

`.dockerignore`文件的作用类似于git工程中的 .gitignore 。不同的是 .dockerignore 应用于 docker 镜像的构建，它存在于 docker 构建上下文的根目录，用来忽略不需要打入镜像的文件

`.dockerignore`文件的写法和 .gitignore 类似，支持正则和通配符，具体规则如下：


- 每行为一个条目；
- 以 # 开头的行为注释；
- 空行被忽略；
- 构建上下文路径为所有文件的根路径；

```
.git
script
static
!README*.md
```


### 3.7 利用多阶段构建

多阶段构建可以让我们大幅度减小最终的镜像大小，而不需要去想办法减少中间层和文件的数量。因为镜像是在生成过程的最后阶段生成的，所以可以利用生成缓存来最小化镜像层。

例如，如果你的构建包含多个层，则可以将它们从变化频率较低（以确保生成缓存可重用）到变化频率较高的顺序排序：

- 安装构建应用程序所需的依赖工具
- 安装或更新依赖项
- 构建你的应用

比如我们构建一个 Go 应用程序的 Dockerfile 可能类似于这样：

```dockerfile

FROM golang:1.11-alpine AS build

# 安装项目需要的工具
# 运行 `docker build --no-cache .` 来更新依赖
RUN apk add --no-cache git
RUN go get github.com/golang/dep/cmd/dep

# 通过 Gopkg.toml 和 Gopkg.lock 获取项目的依赖
# 仅在更新 Gopkg 文件时才重新构建这些层
COPY Gopkg.lock Gopkg.toml /go/src/project/
WORKDIR /go/src/project/
# 安装依赖库
RUN dep ensure -vendor-only

# 拷贝整个项目进行构建
# 当项目下面有文件变化的时候该层才会重新构建
COPY . /go/src/project/
RUN go build -o /bin/project

# 将打包后的二进制文件拷贝到 scratch 镜像下面，将镜像大小降到最低
FROM scratch
COPY --from=build /bin/project /bin/project
ENTRYPOINT ["/bin/project"]
CMD ["--help"]
```

其他示例Dockerfile

```dockerfile
# 构建：使用golang:1.13版本
FROM golang:1.13 as build

# 容器环境变量添加，会覆盖默认的变量值
ENV GO111MODULE=on
ENV GOPROXY=https://goproxy.cn,direct

# 设置工作区
WORKDIR /go/release

# 把全部文件添加到/go/release目录
ADD . .

# 编译：把cmd/main.go编译成可执行的二进制文件，命名为app
RUN GOOS=linux CGO_ENABLED=0 GOARCH=amd64 go build -ldflags="-s -w" -installsuffix cgo -o app cmd/main.go

# 运行：使用scratch作为基础镜像
FROM scratch as prod

# 在build阶段复制时区到
COPY --from=build /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
# 在build阶段复制可执行的go二进制文件app
COPY --from=build /go/release/app /
# 在build阶段复制配置文件
COPY --from=build /go/release/config ./config

# 启动服务
CMD ["/app"]
```

可以使用多个语句。每个指令都可以使用不同的基础，并且每个指令都开始构建的新阶段。

我们可以有选择地将伪影从一个阶段复制到另一个阶段，在最终镜像中留下我们不想要的所有内容。
```

#syntax=docker/dockerfile:1.4
FROM … AS build1
COPY –from=app1 . /src

FROM … AS build2
COPY –from=app2 . /src

FROM …
COPY --from=build1 /out/app1 /bin/
COPY –-from=build2 /out/app2 /bin/
```

!!! info "参考文献"


    [多阶段构建Golang程序Docker镜像](https://www.cnblogs.com/FireworksEasyCool/p/12838875.html)




```dockerfile
# Official docker build image, Using  node:14.17-alpine3.14 image for stage-1.
# Stage-1
FROM node:14.17-alpine3.14 as build
# Copy Required files
COPY public /home/app/public/
COPY src /home/app/src/
# dockerfile install multiple packages
RUN apk add g++ make python2
RUN npm install --silent
# Create Build
RUN npm run build
RUN apk --purge del python2
#Run the build by copying the files form previous stage.
# Stage-2
FROM nginx:stable-alpine
COPY nginx.conf /etc/nginx/conf.d/default.conf
COPY --from=build /home/app/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```



### 3.8 写Dockerfile的一些技巧

#### 1.用 python -m pip 而不是 pip
```shell
# 升级 pip,让 pip install 更安静,--quiet 参数
$ python -m pip install --quiet --upgrade pip

# pip使用国内源
$ python -m pip install --quiet --upgrade pip \
&& pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt
```

#### 2.让 apt-get install 更安静
```shell
#我们用 -qq 命令，甚至重定向输出到 /dev/null 让它更安静。
$ apt-get -qq update
$ apt-get -qq install -y curl > /dev/null
```


#### 3.让 curl 和 wget 更安静
```shell
# 首先，如果要下载文件，curl 和 wget 二选一即可。如果用 curl，可以用 --silent 参数。
$ curl -sLO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64

#wget 有 --quiet 参数。
$ wget -q https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
```


#### 4.用axel而不是curl或者wget
对于身处国内的开发者，axel 完全可以取代 curl 以及 wget
```shell
echo "Install Go compiler ..."

GO_MIRROR_0="http://mirrors.ustc.edu.cn/golang/go1.13.4.linux-amd64.tar.gz"

GO_MIRROR_1="https://dl.google.com/go/go1.13.4.linux-amd64.tar.gz"

axel --quiet --output go.tar.gz $GO_MIRROR_0 $GO_MIRROR_1
```

#### 5.设置容器时间同步

```shell
#设置容器时间与宿主机时间同步
RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo 'Asia/Shanghai' >/etc/timezone
```


!!! example "写 Dockerfile 的一些技巧"

    https://zhuanlan.zhihu.com/p/147995194







## 4.BuildKit

简单的说就是：

BuildKit或DOCKER_BUILDKIT=1 特性可以将docker build完成的数据输出到本地

基于BuildKit优化Dockerfile的构建

> https://mp.weixin.qq.com/s/OjeQsalkthe-YksIe0HtVg
>

### 4.1 安装buildx
```shell
# Buildx 0.6+
$ docker buildx bake "https://github.com/docker/buildx.git"
$ mkdir -p ~/.docker/cli-plugins
$ mv ./bin/buildx ~/.docker/cli-plugins/docker-buildx

# Docker 19.03+
$ DOCKER_BUILDKIT=1 docker build --platform=local -o . "https://github.com/docker/buildx.git"
$ mkdir -p ~/.docker/cli-plugins
$ mv buildx ~/.docker/cli-plugins/docker-buildx

# Local
$ git clone https://github.com/docker/buildx.git && cd buildx
$ make install
```

① 第一种方式使用BuildKit特性，设置环境变量

```shell
DOCKER_BUILDKIT=1 docker build .
```

下面的示例Dockerfile使用一个单独的阶段来收集要导出的生成文件：

示例1
```shell
FROM
Learn more about the "FROM" Dockerfile command.
 golang AS build-stage
RUN go get -u github.com/LK4D4/vndr

FROM scratch AS export-stage
COPY --from=build-stage /go/bin/vndr /
```

示例2
```shell
FROM nodejs:buster-slimv1.0 AS builder
MAINTAINER 1879324764@qq.com

COPY sources.list /etc/apt/sources.list
COPY gitee-ent-web /home/gitee-ent-web

RUN set -eux;\
    apt-get update && \
    apt-get install -y wget git && \
    cd /home/gitee-ent-web && \
    yarn install && \
    yarn run build-i18n && \
    yarn run build-vendor && \
    yarn web:prod-ci-runjs

FROM scratch AS export-stage
COPY --from=builder /home/gitee-ent-web/dist ./dist
```

② 第二种方式使用BuildKit特性

```shell
docker buildx build -o out .
```
下面命令会在当前out目录下生成输出的文件，out如果不存在会自动创建

```shell

DOCKER_BUILDKIT=1 docker build -o out .
```
或者
```shell
# 直接使用 docker buildx build 命令构建镜像。
docker buildx build -o out .
```


### 4.2 buildx示例

一个go编译环境的例子
```shell
$ ls
Dockerfile  go.mod  main.go

$ cat Dockerfile
FROM golang:1.12-alpine as dev
RUN apk add --no-cache git ca-certificates
RUN adduser -D appuser
WORKDIR /src
COPY . /src/
CMD CGO_ENABLED=0 go build -o app . && ./app

FROM dev as build
RUN CGO_ENABLED=0 go build -o app .
USER appuser
CMD [ "./app" ]

FROM scratch as release
COPY --from=build /etc/passwd /etc/group /etc/
COPY --from=build /src/app /app
USER appuser
CMD [ "/app" ]

FROM scratch as artifact
COPY --from=build /src/app /app

FROM release
$ DOCKER_BUILDKIT=1 docker build --target artifact --output type=local,dest=. .
或者
$ docker buildx build  --output type=local,dest=path/to/output-dir
After the build was complete the app binary was exported:

$ ls
Dockerfile  app  go.mod  main.go

$ ./app
Ready to receive requests on port 8080
```

!!! example "参考文献"

    https://www.yuque.com/morlay/me/docker-buildx



## 5.参考文献

!!! tip "推荐阅读"

    [Dockerfile 最佳实践](https://vuepress.mirror.docker-practice.com/appendix/best_practices/#)
    [Dockerfile 实践](https://www.qikqiak.com/k8strain2/docker/dockerfile-practice/)