# Docker相关脚本



## 1. 备份还原环境

docker导出

```shell
$ docker save -o centos-binary-neutron-server-2.0.0.5.tar.gz  kollaglue/centos-binary-neutron-server:2.0.0.5
```

docker导入
```shell
$ docker load < centos-binary-neutron-server-2.0.0.5.tar.gz
```




=== "示例1"

    docker导出镜像(backup_image.sh)
    
    ```shell
    
    #!/usr/bin/env bash
    # 备份镜像列表
    docker images |awk 'NR>1{print $1":"$2}'|sort > images.list
    
    # 导出所有镜像为当前目录下文件
    while read img; do
        echo $img
        file="${img//\//-}"
        sudo docker save $img > $file.tar
    done < images.list
    ```
    
    
    docker导入镜像(Restore_image.sh)
    
    ```shell
    #!/usr/bin/env bash
    
    while read img; do
        echo $img
        file="${img//\//-}"
        sudo docker load < $file.tar
    done < images.list
    ```

=== "示例2"

    
    docker导出镜像(backup_image.sh)

    ```shell
    #!/bin/bash
    IMAGES_LIST=($(docker images|sed '1d'|awk '{print $1}'))
    IMAGES_NM_LIST=($(docker images|sed '1d'|awk '{print $1"-"$2}'|awk -F/ '{print $NF}'))
    IMAGES_NUM=${#IMAGES_LIST[*]}
    for((i=0;i<$IMAGES_NUM;i++))
    do
        docker save "${IMAGES_LIST[$i]}"  -o "${IMAGES_NM_LIST[$i]}".tar.gz
        echo $i ${IMAGES_NM_LIST[$i]} is ok
    done
    ```



    docker导入镜像(Restore_image.sh)

    ```shell
    #!/bin/bash
    for image_name in $(ls ./*.tar.gz)
    do
        docker load < ${image_name}
    done
    ```



## 2.docker镜像上传下载脚本

镜像下载以及替换tag

```shell
list=`cat $1`
#修改后的镜像仓库
Registry='harbor.zhangzhuo.org/base/'
echo > images-save.txt
echo > images-name.txt
for var in $list;do
  #取镜像名称及tag
  tmp=${var##*/}
  #取镜像仓库url
  repo=${var%/*}
  #取镜像名称
  project=${tmp%%:*}
  #取镜像tag
  tag=${tmp##*:}
  #修改原本镜像仓库url地址为新的的仓库url地址
  eval new_image_url=${Registry}${tmp}
  #拉取镜像
  docker pull ${var}
  #修改镜像tag
  docker tag ${var} ${new_image_url}
  #导出镜像
  docker save ${new_image_url} -o ${project}-${tag}.tar.gz
  #记录导出的文件名称
  echo ${project}-${tag}.tar.gz >> images-save.txt
  #记录修改后的镜像名称
  echo ${new_image_url} >>images-name.txt
done
```


上传镜像脚本
```shell
#!/bin/bash
docker_load=`cat images-save.txt`
docker_push=`cat image-name.txt`

for load  in ${docker_load};do
  docker load < ${load}
  echo '*****************镜像导入信息**********************'
  echo "镜像包${load}导入完成"
done

for push in ${docker_push};do
  docker push ${push}
  echo '*****************镜像上传信息**********************'
  echo "镜像${push}上传完成"
done
```



## 3.批量将kubernetes镜像上传到阿里云

pull_all.sh

```shell
#!/usr/bin/env bash
PWD=$(pwd)
for image in `docker images|grep -v "REPOSITORY"|grep -v "<none>"|awk '{print $1":"$2}'` ; do
    img=${image##*/}
    bash ${PWD}/push_image.sh $image
    #echo  "${PWD}/push_image.sh $image"
done
```


push_image.sh

```shell
#!/usr/bin/env bash
#This script is used to upload many images to local or private repositories

# Usage: push_images image1 [image2...]

# 这里是阿里云镜像仓库地址
registry=registry.cn-hangzhou.aliyuncs.com/hu_k8s

echo_r() {
    [ $# -ne 1 ] && return 0
    echo -e "\033[31m$1\033[0m"
}

echo_g() {
    [ $# -ne 1 ] && return 0
    echo -e "\033[32m$1\033[0m"
}


echo_b() {
    [ $# -ne 1 ] && return 0
    echo -e "\033[34m$1\033[0m"
}

usage() {
    docker images
    echo "Usage: $0 registry:tag1 [registry2:tag2...]"
}

[ $# -lt 1 ] && usage && exit
echo_b "The registry server is $registry"

for image in "$@" ; do
    img=${image##*/}
    echo_b "Uploading $img"
    docker tag $image $registry/$img
    docker push $registry/$img
    docker rmi $registry/$img
    sleep 1
    echo_g "Done"
done
```


## 4.量清理临时镜像文件
```shell
$ docker rmi $(docker images -q -f dangling=true)

# 查看状态是关闭的镜像
docker ps -a --filter status=exited
```


## 5.删除所有本地的镜像

=== "删除镜像操作"
    ```shell
    
    $ docker rm $(docker ps -a -q)
    
    # 删除none的镜像，要先删除镜像中的容器。要删除镜像中的容器，必须先停止容器
    docker stop $(docker ps -a | grep "Exited" | awk '{print $1 }')         //停止容器
    docker rm $(docker ps -a | grep "Exited" | awk '{print $1 }')           //删除容器
    docker rmi $(docker images | grep "none" | awk '{print $3}')            //删除镜像
    
    # 删除容器
    docker rm container                     #：删除一个或多个 container
    docker rm `docker ps -aq`               #：删除所有的 container
    docker ps -aq | xargs docker rm         #：同上, 删除所有的 containe创建容器基础的命令格式
    

    # docker 删除所有none的镜像
    docker images|grep none|awk '{print $3}'|xargs docker rmi
    
    # ~/.bash_aliases
    
    # 杀死所有正在运行的容器.
    alias dockerkill='docker kill $(docker ps -a -q)'
    
    # 删除所有已经停止的容器.
    alias dockercleanc='docker rm $(docker ps -a -q)'
    
    # 删除所有未打标签的镜像.
    alias dockercleani=$(docker rmi $(docker images -q -f dangling=true))
    # 删除所有未打 tag 的镜像
    docker rmi $(docker images -q | awk '/^<none>/ { print $3 }')
    
    # 删除所有已经停止的容器和未打标签的镜像.
    alias dockerclean='dockercleanc || true && dockercleani'
    
    
    
    # Docker清理数据卷volumes
    # 参考文献：
    https://blog.csdn.net/songxi_bo/article/details/119910471
    ```

    Docker 删除无用数据卷
    ```shell
    # Docker 1.13 引入了类似于 Linux 上 df 的命令，用于查看 Docker 的磁盘使用情况
    $ docker system df
    
    # 手动删除命令
    # 删除所有dangling数据卷（即无用的Volume，僵尸文件）
    docker volume rm $(docker volume ls -qf dangling=true)
    
    # 删除所有dangling镜像（即无tag的镜像）
    docker rmi $(docker images | grep "^<none>" | awk "{print $3}")
    
    # 删除所有关闭的容器
    docker ps -a | grep Exit | cut -d ' ' -f 1 | xargs docker rm
    
    ```

    删除关闭的容器、无用的数据卷和网络，以及dangling镜像（即无tag的镜像）
    
    > 注意，所有关闭的容器都会被删除，请核查是否存在关闭运行但是需要保留的容器

    ```shell
    # 删除关闭的容器、无用的数据卷和网络
    docker system prune
    # 删除更彻底，可以将没有容器使用Docker镜像都删掉
    docker system prune -a
    ```

    Docker垃圾处理

    ```shell
    1  查找docker文件夹
    find / -name docker
    
    
    2 列举文件夹大小
    du -h --time --max-depth=1 .
    df -h
    df -TH
    
    
    3 Docker占用磁盘空间查看
    docker system df
    
    
    4 删除所有未运行的容器（也可以使用docker-gc）
    docker rm $(docker ps -a|grep Exited |awk '{print $1}')
    docker rm $(docker ps -qf status=exited  )
    
    
    5 删除所有未打标签的 镜像
    docker rmi $(docker images -q -f dangling=true)
    
    
    6 删除所有无用的volume
    docker volume rm $(docker volume ls -qf dangling=true)
    
    
    7 清理磁盘，删除关闭的容器，无用的数据卷和网络
    docker system prune
    
    
    8 停止所有运行的容器
    docker stop $(docker ps -q)
    
    
    9 停止所有容器
    docker stop $(docker ps -a -q)
    
    
    10 删除所有容器
    docker rm $(docker ps -aq)
    
    
    11 删除所有镜像
    docker rmi $(docker images -q)


    12 容器和宿主机之间文件复制
    docker cp [文件目录容器 ID:内部路径]
    docker cp [容器 ID:内部路径文件目录]
    ```



    !!! example "参考文献"

        https://www.cnblogs.com/zhuminghui/p/14566178.html
        
        https://blog.csdn.net/truelove12358/article/details/102949386



=== "批量删除指定 repository"

    ```shell
    #!/bin/sh
    # Writed by yijian on 2020/8/31
    # 批量删除指定 repository 所有镜像工具
    # 运行时需要指定一个参数：
    # 1）参数1：必选参数，repository 名，即“docker images”的第一列值
    
    function usage()
    {
      echo "Remove all images with the given repository."
      echo "Usage: `basename $0` repository"
      echo "Example1: `basename $0` \"<none>\""
      echo "Example2: `basename $0` \"redis\""
    }
    
    # 参数检查
    if test $# -ne 1; then
      usage
      exit 1
    fi
    
    repository="$1"
    images=(`docker images|awk -v repository=$repository '{ if ($1==repository) print $3 }'`)
    for ((i=0; i<${#images[@]}; ++i))
    do
      image="${images[$i]}"
      echo "[$i] docker rmi \"$image\""
      docker rmi "$image"
    done
    ```


## 6.清理Docker系统中的无用数据

如下命令会自动清理处于停止状态的容器、无用的网络和挂载卷、临时镜像和创建镜像缓存。
```shell
docker system prune --volumes -f
```


## 7.Docker存储位置修改

Docker的默认存储位置是/var/lib/docker，如果希望将Docker的本地文件存储到其他分区，可以使用Linux软连接的方式来完成，或者在启动daemon时通过-g参数指定。

例如，如下操作将默认存储位置迁移到/storage/docker：

```shell
[root@s26 ~]# df -h
Filesystem                    Size  Used Avail Use% Mounted on
/dev/mapper/VolGroup-lv_root   50G  5.3G   42G  12% /
tmpfs                          48G  228K   48G   1% /dev/shm
/dev/mapper/VolGroup-lv_home  222G  188M  210G   1% /home
/dev/sdb2                     2.7T  323G  2.3T  13% /storage

[root@s26 ~]# service docker stop
[root@s26 ~]# cd /var/lib/

[root@s26 lib]# mv docker /storage/
[root@s26 lib]# ln -s /storage/docker/ docker

[root@s26 lib]# ls -la docker
lrwxrwxrwx. 1 root root 15 11月 17 13:43 docker -> /storage/docker

[root@s26 lib]# service docker start
```



!!! example "参考文献"

    https://blog.youqiqi.cn/archives/docker-cun-chu-wei-zhi-xiu-gai


## 8.迁移Docker环境
停止Docker服务。将整个Docker存储文件夹（如默认的/var/lib/docker）复制到另外一台宿主主机，然后调整另外一台宿主主机的配置即可。




## 9.操作系统镜像制作脚本
基于RHEL7.4（3.10.0-693.el7.86_64）虚拟机操作系统和统一yum源，自定义基础rpm包后通过makeImageForRedhat.sh脚本可自动完成操作系统基础镜像的制作过程。

- yum源配置说明
基础镜像/etc/yum.repos.d/rhel_7_rmps.repo已配置yum源，这样后续应用层制作容器时可直接使用yum命令安装需要的rpm包。

- 制作过程

1) 重新安装或利用现有RHEL7.4（3.10.0-693.el7.86_64）操作系统的主机。

2) 根据宿主机操作系统的安装要求进行相关的参数配置，如文件句柄数等。

3) 在该主机上安装Docker，原因是使用docker import生成镜像时需要Docker。

4) 在该机器根目录下创建tmp目录，将需要复制到镜像的原始文件复制到此目录下。

5) 在tmp目录下建立临时目录。

6) 读取rpm包列表，使用yum命令在tmp目录安装文件系统和软件包。

7) 将tmp目录tar打包并通过docker import导入本地镜像文件后上传到镜像仓库。

8) 清理tmp临时目录。


其中第6、7两步可以通过执行makeImageForRedhat.sh脚本完成。

- 制作脚本`makeImageForRedhat.sh`
```shell
#!/usr/bin/env bash
#
# Create a base Redhat7.4 Docker image.
#
# This script is useful on systems with yum installed (e.g., building
# a Redhat7image on Redhat7).  See contrib/mkimage-rinse.sh for a way
# to build Redhat7images on other systems.

set -e

usage() {
    cat <<EOOPTS
$(basename $0) [OPTIONS] <name> <version>
OPTIONS:
  -p "<packages>"  The list of packages to install in the container.
                   The default is "telnet.x86_64 telnet-server.x86_64".
  -g "<groups>"    The groups of packages to install in the container.
                   The default is "Core".
  -d "<packages>"  The list of packages to remove from the container.
                   The default is blank.
  -f "<rpm file>"  The list of packages to install in the container.(in file)
                   The default is blank
  -y <yumconf>     The path to the yum config to install packages from. The
                   default is /etc/yum.conf for Centos/RHEL and /etc/dnf/dnf.conf for Fedora
EOOPTS
    exit 1
}

set -x
# option defaults
yum_config=/etc/yum.conf
if [ -f /etc/dnf/dnf.conf ] && command -v dnf &> /dev/null; then
	yum_config=/etc/dnf/dnf.conf
	alias yum=dnf
fi
#install_groups="Core"
#install_packages="telnet.x86_64 telnet-server.x86_64"
# remove_packages="openssh-server-7.4p1-13.el7_4.x86_64 openssh-clients-7.4p1-13.el7_4.x86_64"
while getopts "y:p:g:h:d:f:" opt; do
    case $opt in
        y)
            yum_config=$OPTARG
            ;;
        h)
            usage
            ;;
        p)
            install_packages="$OPTARG"
            ;;
        g)
            install_groups="$OPTARG"
            ;;
        d)
            remove_packages="$OPTARG"
            ;;
        f)
            rpm_file="$OPTARG"
            ;;
        \?)
            echo "Invalid option: -$OPTARG"
            usage
            ;;
    esac
done
shift $((OPTIND - 1))
name=$1
version=$2
if [[ -z $name ]]; then
    usage
fi
if [[ -z $version ]]; then
    usage
fi

target=$(mktemp -d --tmpdir $(basename $0).XXXXXX)

mkdir -m 755 "$target"/dev
mknod -m 600 "$target"/dev/console c 5 1
mknod -m 600 "$target"/dev/initctl p
mknod -m 666 "$target"/dev/full c 1 7
mknod -m 666 "$target"/dev/null c 1 3
mknod -m 666 "$target"/dev/ptmx c 5 2
mknod -m 666 "$target"/dev/random c 1 8
mknod -m 666 "$target"/dev/tty c 5 0
mknod -m 666 "$target"/dev/tty0 c 4 0
mknod -m 666 "$target"/dev/urandom c 1 9
mknod -m 666 "$target"/dev/zero c 1 5

# amazon linux yum will fail without vars set
if [ -d /etc/yum/vars ]; then
	mkdir -p -m 755 "$target"/etc/yum
	cp -a /etc/yum/vars "$target"/etc/yum/
fi

if [[ -n "$install_groups" ]];
then
    yum -c "$yum_config" --installroot="$target" --releasever=/ --setopt=tsflags=nodocs \
        --setopt=group_package_types=mandatory -y groupinstall $install_groups
fi

rm -f "$target"/etc/yum.repos.d/*.repo
#mkdir -p "$target"/etc/yum.repos.d/
#cp /etc/yum.repos.d/redhat.repo  "$target"/etc/yum.repos.d/

if [[ -n "$install_packages" ]];
then
    yum -c "$yum_config" --installroot="$target" -y install $install_packages
fi

if [[ -n "$remove_packages" ]];
then
    yum -c "$yum_config" --installroot="$target" --releasever=/ \
        -y remove $remove_packages
fi

if [[ -n "$rpm_file" ]];
then
    rpmlist=`cat "$rpm_file"`
   # while read rpm_name
    #do

        yum -c "$yum_config" --installroot="$target" --releasever=/ --setopt=tsflags=nodocs \
            --setopt=group_package_types=mandatory -y install $rpmlist
    #done < $rpm_file
fi

cp /etc/yum.repos.d/rhel_7_rpms.repo  "$target"/etc/yum.repos.d/
yum -c "$yum_config" --installroot="$target" -y clean all

cat > "$target"/etc/sysconfig/network <<EOF
NETWORKING=yes
HOSTNAME=localhost.localdomain
EOF


chroot "$target" /bin/bash -c "cd /usr/share/locale/; ls | grep -v zh_CN| xargs rm -rf"
chroot "$target" /bin/bash -c "rm -f /usr/lib/locale/locale-archive;localedef -i zh_CN -f UTF-8 zh_CN.UTF-8"
chroot "$target" /bin/bash -c "rm -rf /var/cache/yum/*"

# effectively: febootstrap-minimize --keep-zoneinfo --keep-rpmdb --keep-services "$target".
#  locales
#rm -rf "$target"/usr/{{lib,share}/locale,{lib,lib64}/gconv,bin/localedef,sbin/build-locale-archive}
#  docs and man pages
rm -rf "$target"/usr/share/{man,doc,info,gnome/help}
#  cracklib
rm -rf "$target"/usr/share/cracklib
#  i18n
rm -rf "$target"/usr/share/i18n
#  yum cache
#rm -rf "$target"/var/cache/yum
#mkdir -p --mode=0755 "$target"/var/cache/yum
#  sln
#rm -rf "$target"/sbin/sln
#  ldconfig
rm -rf "$target"/etc/ld.so.cache "$target"/var/cache/ldconfig
mkdir -p --mode=0755 "$target"/var/cache/ldconfig

#version=
#for file in "$target"/etc/{redhat,system}-release
#do
#    if [ -r "$file" ]; then
#        version="$(sed 's/^[^0-9\]*\([0-9.]\+\).*$/\1/' "$file")"
#        break
#    fi
#done

#if [ -z "$version" ]; then
#    echo >&2 "warning: cannot autodetect OS version, using '$name' as tag"
#    version=$name
#fi

if [ -r "$target"/etc/ssh/sshd_config ]; then
    chroot "$target" ssh-keygen -A
    chroot "$target" sed -i 's/#UseDNS yes/UseDNS no/' /etc/ssh/sshd_config
fi
#chroot "$target" bash -c "echo -n 'root' | passwd --stdin root"

##dockerfile create && build image
cd "$target"
tar cf "$name.tar" --numeric-owner -c -C "$target" .
mkdir "$target/dockrfile"
mv $name.tar "$target/dockerfile"
cd dockerfile
echo "#!/bin/sh" > run.sh
echo "ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime" > run.sh
echo "exec /bin/bash" > run.sh
chmod +x run.sh
echo "FROM scratch" > dockerfile
echo "LABEL name=\"CMPC Base Image\"" >> dockerfile
echo "ADD $name.tar /" >> dockerfile
echo "ENV LC_ALL=zh_CN.UTF-8" >> dockerfile
echo "COPY run.sh /" >> dockerfile
echo "CMD exec ./run.sh" >> dockerfile
docker build -t $name:$version -f "$target/dockerfile/dockerfile"

#tar --numeric-owner -c -C "$target" . | docker import - $name:$version

docker run -i -t --rm $name:$version /bin/bash -c 'echo success'

echo "$target"
rm -rf "$target"
```





!!! example "参考资源链接"

    官方网站
    
    Docker官方主页：https://www.docker.com
    
    Docker官方博客：https://blog.docker.com/
    
    Docker官方文档：https://docs.docker.com/
    
    Docker Hub：https://hub.docker.com
    
    Docker公司的开源代码仓库：https://github.com/docker
    
    Docker的开源项目Moby仓库：https://github.com/moby/moby
    
    Docker发布版本历史：https://docs.docker.com/release-notes/
    
    Docker常见问题：https://docs.docker.com/engine/faq/
    
    Docker SDK和API：https://docs.docker.com/develop/sdk/
    
    开发容器组织OCI：https://www.opencontainers.org/
    

    实践参考
    
    Dockerfile参考：https://docs.docker.com/engine/reference/builder/

    
    Dockerfile最佳实践：https://docs.docker.com/develop/develop-images/dockerfile_best-practices/