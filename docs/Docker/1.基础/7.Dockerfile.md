# 7.Dockerfile


## 1. Dockerfile指令


**Docker Dockerfile**


https://www.runoob.com/docker/docker-dockerfile.html


https://www.cnblogs.com/ssgeek/p/15600966.html



Dockerfile中的指令及说明


| 指令        | 说明                                                         |
| ----------- | ---------------------------------------------- |
| FROM        | 指定创建基础镜像                                             |
| MAINTAINER  | 指定维护者信息                                               |
| RUN         | 运行命令                                                     |
| CMD         | 指定启动容器时默认执行的命令                                 |
| LABEL       | 指定生成镜像的元数据标签信息                                 |
| EXPOSE      | 声明镜像内服务所监听的端口                                   |
| ENV         | 指定环境变量                                                 |
| ADD         | 复制指定的src下的内容到容器中的dest                 |
| COPY        | 复制本地主机的src路径下的内容到镜像中的dest下          |
| ENTRYPOINT  | 指定镜像的默认入口                                           |
| VOLUME      | 创建数据卷挂载点                                             |
| USER        | 指定运行容器时的用户名或UID                                  |
| WORKDIR     | 配置工作目录                                                 |
| ARG         | 指定镜像内使用的参数（例如版本号信息等）                     |
| ONBUILD     | 当作为其他镜像的基础镜像时，所执行的创建操作指令             |
| STOPSIGNAL  | 容器退出的信号值                                             |
| HEALTHCHECK | 如何进行健康检查                                             |
| SHELL       | 指定使用shell时的默认shell类型                               |




## 2.Dockerfile自定义镜像


### 2.1 查看运行容器的Dockerfile工具

- 项目地址：[Whaler(opens new window)](https://github.com/P3GLEG/Whaler)
- 项目说明：能够查看在运行容器的Dockerfile的工具，有时候我们可能会维护一个没有Dockerfile的容器，即可借助此工具。
- 相关文章：[博文介绍](https://samaritan.ai/blog/reversing-docker-images-into-dockerfiles/)



### 2.2 查看docker容器运行命令的所有参数

- 项目地址：[runlike(opens new window)](https://github.com/lavie/runlike)
- 项目说明：给定一个现有的 docker 容器，打印运行它的副本所需的命令行。
- 相关文章：README


可以将运行的docker 推导反写为docker-compose文件








一些需要注意的事项：

- 当 docker run 命令中声明了参数时，Docker 守护程序会忽略 CMD 命令。


- 与CMD不同的是，由ENTRYPOINT启动的程序不会被docker run命令行指定的参数所覆盖，而且，这些命令行参数会被当作参数传递给ENTRYPOINT指定的程序。不过，docker run 命令的`--entrypoint`选项的参数可覆盖ENTRYPOINT指令指定的程序


- Dockfile中，如果没有使用CMD指定启动命令，则会继承上一个镜像的默认启动命令；CMD 容器的默认启动命令，有且只能有一条；





根据Dockerfile生成新的镜像命令中,build 创建新的镜像；`-t `指定新镜像的名字和标签；`. `指定Dockerfile文件所在的目录

```shell
docker build -t imagename:latest Dockerfile所在目录
```




容器和镜像之间的主要区别在于顶部 可写层。对容器的所有添加新数据或修改现有数据的写入都存储在此 可写层 中。删除容器时，可写层也会被删除。基础镜像保持不变。

这里利用了`写时复制技术(COW,copy on write)` , 对于开发的小伙伴，可以结合享元设计模式理解，对于运维的小伙伴，可以结合 Openstack 组件 Glance 原理来理解

用通俗的话讲，当修改时，会把数据复制到容器层修改。



当新增的时候直接在容器层新增，当删除时，会屏蔽镜像层。

Docker 通过读取给定的指令来自动构建镜像。`遵循特定的格式和指令集，其中的 每一条指令在容器镜像中创建一个层。这些层是堆叠的，每个层都是与前一层相比的变化的增量`


这里我们以 `redis:7` 这个官方镜像为例,看看一个标准的 Dockerfile 如何书写，可以看到镜像构建了 16 层。



```shell
$ docker history --human=true  redis:7
IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT
19c51d4327cf   6 weeks ago   /bin/sh -c #(nop)  CMD ["redis-server"]         0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  EXPOSE 6379                  0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  ENTRYPOINT ["docker-entry…   0B
<missing>      6 weeks ago   /bin/sh -c #(nop) COPY file:e873a0e3c13001b5…   661B
<missing>      6 weeks ago   /bin/sh -c #(nop) WORKDIR /data                 0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  VOLUME [/data]               0B
<missing>      6 weeks ago   /bin/sh -c mkdir /data && chown redis:redis …   0B
<missing>      6 weeks ago   /bin/sh -c set -eux;   savedAptMark="$(apt-m…   32MB
<missing>      6 weeks ago   /bin/sh -c #(nop)  ENV REDIS_DOWNLOAD_SHA=06…   0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  ENV REDIS_DOWNLOAD_URL=ht…   0B
<missing>      6 weeks ago   /bin/sh -c #(nop)  ENV REDIS_VERSION=7.0.8      0B
<missing>      7 weeks ago   /bin/sh -c set -eux;  savedAptMark="$(apt-ma…   4.13MB
<missing>      7 weeks ago   /bin/sh -c #(nop)  ENV GOSU_VERSION=1.14        0B
<missing>      7 weeks ago   /bin/sh -c groupadd -r -g 999 redis && usera…   329kB
<missing>      7 weeks ago   /bin/sh -c #(nop)  CMD ["bash"]                 0B
<missing>      7 weeks ago   /bin/sh -c #(nop) ADD file:e2398d0bf516084b2…   80.5MB
┌──[root@vms107.liruilongs.github.io]-[/etc/systemd]
└─$docker history --human=true  redis:7 | wc -l
17
```

涉及 两个Dockerfile文件构建的镜像

基础镜像构建

```shell
FROM scratch
ADD rootfs.tar.xz /
CMD ["bash"]
```


reids镜像构建
```dockerfile

FROM debian:bullseye-slim

# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r -g 999 redis && useradd -r -g redis -u 999 redis

# grab gosu for easy step-down from root
# https://github.com/tianon/gosu/releases
ENV GOSU_VERSION 1.16
RUN set -eux; \
 savedAptMark="$(apt-mark showmanual)"; \
 apt-get update; \
 apt-get install -y --no-install-recommends ca-certificates dirmngr gnupg wget; \
 rm -rf /var/lib/apt/lists/*; \
 dpkgArch="$(dpkg --print-architecture | awk -F- '{ print $NF }')"; \
 wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch"; \
 wget -O /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch.asc"; \
 export GNUPGHOME="$(mktemp -d)"; \
 gpg --batch --keyserver hkps://keys.openpgp.org --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4; \
 gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu; \
 gpgconf --kill all; \
 rm -rf "$GNUPGHOME" /usr/local/bin/gosu.asc; \
 apt-mark auto '.*' > /dev/null; \
 [ -z "$savedAptMark" ] || apt-mark manual $savedAptMark > /dev/null; \
 apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \
 chmod +x /usr/local/bin/gosu; \
 gosu --version; \
 gosu nobody true

ENV REDIS_VERSION 7.0.9
ENV REDIS_DOWNLOAD_URL http://download.redis.io/releases/redis-7.0.9.tar.gz
ENV REDIS_DOWNLOAD_SHA f77135c2a47c9151d4028bfea3b34470ab4d324d1484f79a84c6f32a3cfb9f65

RUN set -eux; \
 \
 savedAptMark="$(apt-mark showmanual)"; \
 apt-get update; \
 apt-get install -y --no-install-recommends \
  ca-certificates \
  wget \
  \
  dpkg-dev \
  gcc \
  libc6-dev \
  libssl-dev \
  make \
 ; \
 rm -rf /var/lib/apt/lists/*; \
 \
 wget -O redis.tar.gz "$REDIS_DOWNLOAD_URL"; \
 echo "$REDIS_DOWNLOAD_SHA *redis.tar.gz" | sha256sum -c -; \
 mkdir -p /usr/src/redis; \
 tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1; \
 rm redis.tar.gz; \
 \
# disable Redis protected mode [1] as it is unnecessary in context of Docker
# (ports are not automatically exposed when running inside Docker, but rather explicitly by specifying -p / -P)
# [1]: https://github.com/redis/redis/commit/edd4d555df57dc84265fdfb4ef59a4678832f6da
 grep -E '^ *createBoolConfig[(]"protected-mode",.*, *1 *,.*[)],$' /usr/src/redis/src/config.c; \
 sed -ri 's!^( *createBoolConfig[(]"protected-mode",.*, *)1( *,.*[)],)$!\10\2!' /usr/src/redis/src/config.c; \
 grep -E '^ *createBoolConfig[(]"protected-mode",.*, *0 *,.*[)],$' /usr/src/redis/src/config.c; \
# for future reference, we modify this directly in the source instead of just supplying a default configuration flag because apparently "if you specify any argument to redis-server, [it assumes] you are going to specify everything"
# see also https://github.com/docker-library/redis/issues/4#issuecomment-50780840
# (more exactly, this makes sure the default behavior of "save on SIGTERM" stays functional by default)
 \
# https://github.com/jemalloc/jemalloc/issues/467 -- we need to patch the "./configure" for the bundled jemalloc to match how Debian compiles, for compatibility
# (also, we do cross-builds, so we need to embed the appropriate "--build=xxx" values to that "./configure" invocation)
 gnuArch="$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)"; \
 extraJemallocConfigureFlags="--build=$gnuArch"; \
# https://salsa.debian.org/debian/jemalloc/-/blob/c0a88c37a551be7d12e4863435365c9a6a51525f/debian/rules#L8-23
 dpkgArch="$(dpkg --print-architecture)"; \
 case "${dpkgArch##*-}" in \
  amd64 | i386 | x32) extraJemallocConfigureFlags="$extraJemallocConfigureFlags --with-lg-page=12" ;; \
  *) extraJemallocConfigureFlags="$extraJemallocConfigureFlags --with-lg-page=16" ;; \
 esac; \
 extraJemallocConfigureFlags="$extraJemallocConfigureFlags --with-lg-hugepage=21"; \
 grep -F 'cd jemalloc && ./configure ' /usr/src/redis/deps/Makefile; \
 sed -ri 's!cd jemalloc && ./configure !&'"$extraJemallocConfigureFlags"' !' /usr/src/redis/deps/Makefile; \
 grep -F "cd jemalloc && ./configure $extraJemallocConfigureFlags " /usr/src/redis/deps/Makefile; \
 \
 export BUILD_TLS=yes; \
 make -C /usr/src/redis -j "$(nproc)" all; \
 make -C /usr/src/redis install; \
 \
# TODO https://github.com/redis/redis/pull/3494 (deduplicate "redis-server" copies)
 serverMd5="$(md5sum /usr/local/bin/redis-server | cut -d' ' -f1)"; export serverMd5; \
 find /usr/local/bin/redis* -maxdepth 0 \
  -type f -not -name redis-server \
  -exec sh -eux -c ' \
   md5="$(md5sum "$1" | cut -d" " -f1)"; \
   test "$md5" = "$serverMd5"; \
  ' -- '{}' ';' \
  -exec ln -svfT 'redis-server' '{}' ';' \
 ; \
 \
 rm -r /usr/src/redis; \
 \
 apt-mark auto '.*' > /dev/null; \
 [ -z "$savedAptMark" ] || apt-mark manual $savedAptMark > /dev/null; \
 find /usr/local -type f -executable -exec ldd '{}' ';' \
  | awk '/=>/ { print $(NF-1) }' \
  | sort -u \
  | xargs -r dpkg-query --search \
  | cut -d: -f1 \
  | sort -u \
  | xargs -r apt-mark manual \
 ; \
 apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \
 \
 redis-cli --version; \
 redis-server --version

RUN mkdir /data && chown redis:redis /data
VOLUME /data
WORKDIR /data

COPY docker-entrypoint.sh /usr/local/bin/
ENTRYPOINT ["docker-entrypoint.sh"]

EXPOSE 6379
CMD ["redis-server"]
```

运行此镜像并创建一个容器时，我们实际上在底层之上添加了一个新的可写层（容器层）。对正在运行的容器所做的所有更改（例如写入新文件、修改现有文件和删除文件）都将写入此可写容器层。

可以看到上面的 Dockerfile 文件很庞大，通过这个文件我们来总结一些 在编写时需要注意的地方


### 2.3 热门Dockerfile示例



#### Nginx


=== "debian-nginx"

    基于debian:jessie基础镜像

    ```dockerfile
    FROM debian:jessie
    LABEL maintainer docker_user<docker_user@email.com>
    ENV NGINX_VERSION 1.10.1-1~jessie
    RUN apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-keys 573BFD6B3D8FBC64107
        9A6ABABF5BD827BD9BF62 \
            && echo "deb http://nginx.org/packages/debian/ jessie nginx" >> /etc/apt/sources.list \
            && apt-get update \
            && apt-get install --no-install-recommends --no-install-suggests -y \
            ca-certificates \
            nginx=${NGINX_VERSION} \
            nginx-module-xslt \
            nginx-module-geoip \
            nginx-module-image-filter \
            nginx-module-perl \
            nginx-module-njs \
            gettext-base \
            && rm -rf /var/lib/apt/lists/*

    # forward request and error logs to docker log collector
    RUN ln -sf /dev/stdout /var/log/nginx/access.log \
        && ln -sf /dev/stderr /var/log/nginx/error.log
    EXPOSE 80 443
    CMD ["nginx", "-g", "daemon off;"]
    ```


    Nginx的官方仓库还提供了Dockerfile构建Nginx镜像，目前的版本是1.7.9，其内容为：

    ```dockerfile
    FROM debian:wheezy

    MAINTAINER NGINX Docker Maintainers "docker-maint@nginx.com"
    RUN apt-key adv --keyserver pgp.mit.edu --recv-keys 573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62
    RUN echo "deb http://nginx.org/packages/mainline/debian/ wheezy nginx" >> /etc/apt/sources.list
    ENV NGINX_VERSION 1.7.9-1~wheezy
    RUN apt-get update && apt-get install -y nginx=${NGINX_VERSION} && rm -rf /var/lib/apt/lists/*
    # forward request and error logs to docker log collector
    RUN ln -sf /dev/stdout /var/log/nginx/access.log
    RUN ln -sf /dev/stderr /var/log/nginx/error.log
    VOLUME ["/var/cache/nginx"]
    EXPOSE 80 443
    CMD ["nginx", "-g", "daemon off;"]
    ```




=== "centos7-nginx"



    基于centos7镜像

    ```dockerfile
    FROM centos:7
    MAINTAINER shichao@scajy.cn
    RUN yum install -y gcc gcc-c++ make pcre \
                    pcre-devel openssl openssl-devel  \
                    pcre-davel gd-devel iproute net-tools \
                    telnet wget curl \
                    && yum clean all \
                    && rm -rf /var/cache/yum/*

    RUN useradd -M -s /sbin/nologin nginx
    RUN  wget http://nginx.org/download/nginx-1.17.6.tar.gz && tar zxf  nginx-1.17.6.tar.gz && \
        cd nginx-1.17.6  && \
      ./configure --prefix=/usr/local/nginx  \
      --with-http_stub_status_module \
      --with-http_ssl_module \
      --with-http_gzip_static_module  \
      --with-http_flv_module \
      --with-http_mp4_module \
      --with-http_gunzip_module && \
      make && make install
    ENV PATH /usr/local/nginx/sbin:$PATH

    EXPOSE 80

    ENTRYPOINT ["nginx"]

    CMD ["-g","daemon off;"]
    ```



官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/nginx` 




#### Python


=== "alpine"

    ```Dockerfile
    FROM python:3.9-alpine

    MAINTAINER Logan <admin@attacker.club>
    WORKDIR /opt/app
    COPY requirements.txt /opt/app

    ## 国内加速源
    RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories 
    ## 工具包
    RUN apk --no-cache add curl vim busybox-extras
    ## ldap依赖
    RUN apk --no-cache add gcc \ 
    libldap \
    libc-dev \
    openldap-dev 
    # python3-dev 
    ## Pillow图片库依赖
    RUN apk --no-cache add libjpeg  jpeg-dev musl-dev zlib-dev libffi-dev 
    # python3-dev 
    RUN pip --no-cache-dir install -i https://mirrors.aliyun.com/pypi/simple -r requirements.txt
    COPY . /opt/app

    ## 清理数据
    RUN apk del \
            gcc \
            libc-dev \
            openldap-dev
    # RUN apk del libjpeg  jpeg-dev musl-dev zlib-dev libffi-dev 
    RUN rm -rf  /tmp/* /opt/app/env /opt/app/db.sqlite3 /opt/app/logs/* /root/.cache/pip  /var/cache/apk/*

    EXPOSE 8000
    CMD ["/bin/sh","run.sh"]

    ## 构建镜像
    # docker build -t lghost/python:3.9 . -f Dockerfile-alpine

    ## 简洁启动
    # docker run  -d -p8000:8000  --name cmdb  lghost/python:3.9

    ## 初始化数据
    # docker exec -it cmdb python init.py
    ```





=== "Centos"


    `python.Dockerfile-centos`

    ```Dockerfile
    FROM centos:7
    RUN rm /etc/yum.repos.d/* \
        && curl -s -o ./Centos-7.repo https://mirrors.aliyun.com/repo/Centos-7.repo \
        && curl -s -o ./epel.repo https://mirrors.aliyun.com/repo/epel-7.repo \
        && sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' Centos-7.repo \
        && yum install  -y wget openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel python-devel \
    libffi-devel  tk-devel


    RUN wget -c https://www.python.org/ftp/python/3.9.16/Python-3.9.16.tar.xz \
        && tar xf Python*.xz \
        && cd Python-3.9.16 \
        && ./configure prefix=/usr/local/python3 \
        && make  -j 2 && make  altinstall  && ln -s /usr/local/python3/bin/python3.9 /usr/bin/python3

    #  docker build -t lghost/python:3.9 . -f Dockerfile-alpine
    ```





    ```Dockerfile

    FROM centos:7
    LABEL auther="hjl@oschina.com"

    ENV container docker
    RUN yum -y swap -- remove fakesystemd -- install systemd systemd-libs
    RUN yum -y update; yum clean all; \
      (cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i ==systemd-tmpfiles-setup.service ] || rm -f $i; done); \
      rm -f /lib/systemd/system/multi-user.target.wants/*;\
      rm -f /etc/systemd/system/*.wants/*;\
      rm -f /lib/systemd/system/local-fs.target.wants/*; \
      rm -f /lib/systemd/system/sockets.target.wants/*udev*; \
      rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \
      rm -f /lib/systemd/system/basic.target.wants/*;\
      rm -f /lib/systemd/system/anaconda.target.wants/*;
    VOLUME [ "/sys/fs/cgroup" ]
    CMD ["/usr/sbin/init"]
    ```

    官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/centos`




=== "Ubuntu"



      官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/ubuntu` 查看。


      `python.Dockerfile-ubuntu`

      ```Dockerfile
      FROM ubuntu:22.04

      MAINTAINER Logan <admin@attacker.club>
      WORKDIR /opt

      ## 依赖包
      RUN  sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list  \
          && apt update \
          && apt install nload iftop net-tools curl git -y \
          && apt install python3 python3-pip -y

      ## 清理数据
      RUN rm -rf /var/lib/apt/lists/*  \
      && apt  clean \
      && apt autoclean 

      EXPOSE 8000

      # docker build -t lghost/python3 . -f Dockerfile-ubuntu-python3
      ```


=== "Debian"


    ```Dockerfile
    FROM python:3.9.13-slim
    ENV PYTHONUNBUFFERED 1


    # RUN sed -i 's/deb.debian.org/mirrors.aliyun.com/g' /etc/apt/sources.list # 国内源

    WORKDIR /opt/app

    RUN apt-get update \
      && apt-get install -y  net-tools apt-utils \
      libtiff5-dev libjpeg8-dev zlib1g-dev
    COPY requirements.txt /opt/app
    ```






#### Django


`dockerfile-django`


```Dockerfile
FROM python:3.4

RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        postgresql-client \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /usr/src/app
COPY requirements.txt ./
RUN pip install -r requirements.txt
COPY . .

EXPOSE 8000
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
# docker build -t python-django:3.4.
```





`django_python.dockerfile`

```Dockerfile
FROM python:3.8-alpine

WORKDIR /home
COPY . /home

RUN pip install -i http://mirrors.aliyun.com/pypi/simple --trusted-host mirrors.aliyun.com -r requirements.txt
RUN  rm -rf /home/venv 

# RUN  python manage.py makemigrations  &&  python manage.py migrate
# CMD [ "python", "./manage.py", "runserver", "0.0.0.0:8000"]
RUN chmod +x run.sh
EXPOSE 8000
CMD ["/bin/sh","run.sh"]  
# 容器启动时默认执行的命令

# docker build -t lghost/bind9:latest . # build images
# docker push lghost/bind9:latest # 推送到dockerhub
```


`run.sh`

```sh
#!/bin/bash
###

db_init() {
pip3  install -i http://mirrors.aliyun.com/pypi/simple  --trusted-host mirrors.aliyun.com  -r requirements.txt
python manage.py makemigrations
python manage.py migrate
# 初始化数据
python init.py
# 第一次初始化密码
}

# shellcheck disable=SC2120
replace_settings() {
if [ $1x == "debug"x ]; then
  sed -i  's/DEBUG = False/DEBUG = True/'g  website/settings.py
  echo -e "Enable Debug ......"
else
  sed -i  's/DEBUG = True/DEBUG = False/'g  website/settings.py
  echo -e "Disable Debug ......"
  # 关闭调试模式
fi

}

run_server() {
db_init
replace_settings
python manage.py runserver 0.0.0.0:8000
}

run_server # 启动服务
```




#### Flask

```dockerfile
# 使用官方 Python 3 镜像作为基础镜像
FROM python:3

# 设置工作目录
WORKDIR /app

# 复制项目的依赖文件到容器中
COPY requirements.txt /app/requirements.txt

# 安装项目的依赖项
RUN pip install -r requirements.txt

# 将项目文件复制到容器中
COPY . /app

# 暴露容器的端口
EXPOSE 5000

# 在容器中运行 Flask 应用程序
CMD ["python", "app.py"]
```



#### Golang

```Dockerfile
FROM golang:alpine AS builder
# Set necessary environmet variables needed for our image
ENV GO111MODULE=on \
    GOPROXY=https://goproxy.cn,direct \
    CGO_ENABLED=0 \
    GOOS=linux \
    GOARCH=amd64
# Move to working directory /build

WORKDIR /build
# Copy and download dependency using go mod
COPY go.mod .
COPY go.sum .
RUN go mod download
# Copy the code into the container
COPY . .
# Run test
#RUN go test ./...

# Build the application
RUN go build -o main .

# Move to /dist directory as the place for resulting binary folder
WORKDIR /dist

# Copy binary from build to main folder
RUN cp /build/main .

############################
# STEP 2 build a small image
############################
FROM scratch
COPY --from=builder /dist/main /
COPY ./env/demo.env /env/demo.env
COPY ./logs /logs

# Command to run the executable
ENTRYPOINT ["/main"]
```




```Dockerfile
# start from golang base image
FROM golang:1.16-alpine as builder
WORKDIR /usr/src/app
COPY go.mod go.sum ./
# RUN echo "nameserver 114.114.114.114" >> /etc/resolv.conf
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories
RUN apk add --no-cache git
ENV GO111MODULE=on \
    GOPROXY=https://goproxy.cn \
    GOSUMDB=off \
    GIN_MODE=release

RUN go mod download -x
RUN go mod tidy
COPY . .
RUN go build -v -o /usr/local/bin ./...
WORKDIR /usr/src/tool
RUN git clone https://gitee.com/edmondfrank/tern.git
WORKDIR /usr/src/tool/tern
RUN go mod download -x
RUN go mod tidy
RUN go build -v -o /usr/local/bin ./...


FROM alpine
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories
RUN apk add --no-cache ca-certificates && update-ca-certificates
COPY --from=builder /usr/local/bin/forudad /usr/bin/forudad
COPY ./cmd/migrations /usr/migrations
COPY --from=builder /usr/local/bin/tern /usr/bin/tern
COPY ./examples/config/postgre-example.toml /usr/bin/config.toml
COPY ./migration.sh .
EXPOSE 4200 4200
ENTRYPOINT ["./migration.sh"]
CMD ["/usr/bin/forudad", "-config", "/usr/bin/config.toml"]
```



- demo

```Dockerfile
# 构建：使用golang:1.13版本
FROM golang:1.18 as build

# 容器环境变量添加，会覆盖默认的变量值
ENV GO111MODULE=on
ENV GOPROXY=https://goproxy.cn,direct

# 设置工作区
WORKDIR /go/release

# 把全部文件添加到/go/release目录
ADD . .

# # 执行go mod download
RUN go mod download

# 编译：把cmd/main.go编译成可执行的二进制文件，命名为app
RUN GOOS=linux CGO_ENABLED=0 GOARCH=amd64 go build -ldflags="-s -w" -installsuffix cgo -o app main.go

# 运行：使用alpine作为基础镜像
FROM alpine
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories
RUN apk add --no-cache ca-certificates && update-ca-certificates

# 在build阶段复制时区到
COPY --from=build /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
# 在build阶段复制可执行的go二进制文件app
COPY --from=build /go/release/app /
# 在build阶段复制配置文件
COPY --from=build /go/release/config ./config

EXPOSE 9090 9091

# 启动服务
ENTRYPOINT ["/app"]
```




!!!info "参考文献"

    [Golang/Python应用部署到Docker](https://www.cnblogs.com/yance-dev/p/16499553.html)






#### Node.js
    
官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/node` 查看。


下面是一个生产级别的 Vue.js 项目的 Dockerfile 示例：

```Dockerfile
# 使用 Node.js 官方提供的 LTS 版本作为基础镜像
FROM node:lts-alpine as build-stage

# 设置工作目录
WORKDIR /app
# 复制 package.json 和 package-lock.json 到工作目录
COPY package*.json ./
# 安装项目依赖
RUN npm install
# 复制项目源代码到工作目录
COPY . .
# 构建项目
RUN npm run build



# 使用 Nginx 镜像作为生产环境镜像
FROM nginx:stable-alpine as production-stage
# 从构建阶段复制构建结果到 Nginx 服务器目录
COPY --from=build-stage /app/dist /usr/share/nginx/html
# 暴露 80 端口
EXPOSE 80
# 启动 Nginx
CMD ["nginx", "-g", "daemon off;"]
```




- demo


```Dockerfile
# server image

FROM nginx:latest as base

EXPOSE 8080

# builder image

FROM node:16-alpine3.15 as builder

WORKDIR /usr/src/app

RUN mkdir -p /usr/src/transport/http/admin

RUN npm i -g pnpm@6.32.3

COPY ["package*.json", "./"]

# install project dependencies
RUN pnpm i

COPY . .

RUN sed -i 's/http:\/\/localhost:4200/https:\/\/foruda.runjs.cn/g' ./.env.build

# build app for production with minification
RUN pnpm run build

FROM base AS final

COPY ./nginx/nginx.conf /etc/nginx/conf.d/default.conf

COPY --from=builder /usr/src/transport/http/admin /var/www/html/
```






#### Redis

通过Dockerfile也可以构建和官方一样的Redis镜像。这里以2.8版本为例，其Dockerfile为：

```Dockerfile

FROM debian:wheezy
# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r redis && useradd -r -g redis redis
RUN apt-get update \
  && apt-get install -y curl \
  && rm -rf /var/lib/apt/lists/*
# grab gosu for easy step-down from root
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4

RUN curl -o /usr/local/bin/gosu -SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture)" \
  && curl -o /usr/local/bin/gosu.asc -SL"https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture).asc" \
  && gpg --verify /usr/local/bin/gosu.asc \
  && rm /usr/local/bin/gosu.asc \
  && chmod +x /usr/local/bin/gosu
ENV REDIS_VERSION 2.8.19
ENV REDIS_DOWNLOAD_URL http://download.redis.io/releases/redis-2.8.19.tar.gz
ENV REDIS_DOWNLOAD_SHA1 3e362f4770ac2fdbdce58a5aa951c1967e0facc8
# for redis-sentinel see: http://redis.io/topics/sentinel
RUN buildDeps='gcc libc6-dev make'; \
  set -x \
  && apt-get update && apt-get install -y $buildDeps --no-install-recommends \
  && rm -rf /var/lib/apt/lists/* \
  && mkdir -p /usr/src/redis \
  && curl -sSL "$REDIS_DOWNLOAD_URL" -o redis.tar.gz \
  && echo "$REDIS_DOWNLOAD_SHA1 *redis.tar.gz" | sha1sum -c - \
  && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
  && rm redis.tar.gz \
  && make -C /usr/src/redis \
  && make -C /usr/src/redis install \
  && rm -r /usr/src/redis \
  && apt-get purge -y --auto-remove $buildDeps
RUN mkdir /data && chown redis:redis /data
VOLUME /data
WORKDIR /data
COPY docker-entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
EXPOSE 6379
CMD [ "redis-server" ]
```

官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/redis` 查看。




#### MySQL

通过Dockerfile来创建mysql
```dockerfile
FROM debian:wheezy
# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r mysql && useradd -r -g mysql mysql
# FATAL ERROR: please install the following Perl modules before executing /usr/local/mysql/scripts/mysql_install_db:
# File::Basename
# File::Copy
# Sys::Hostname
# Data::Dumper
RUN apt-get update && apt-get install -y perl --no-install-recommends && rm -rf /var/lib/apt/lists/*
# gpg: key 5072E1F5: public key "MySQL Release Engineering <mysql-build@oss.oracle.com>" imported
RUN apt-key adv --keyserver pool.sks-keyservers.net --recv-keys A4A9406876FCBD3C456770C88C718D3B5072E1F5
ENV MYSQL_MAJOR 5.7
ENV MYSQL_VERSION 5.7.5-m15
RUN echo "deb http://repo.mysql.com/apt/debian/ wheezy mysql-${MYSQL_MAJOR}-dmr" > /etc/apt/sources.list.d/mysql.list
# the "/var/lib/mysql" stuff here is because the mysql-server postinst doesn't have an explicit way
# to disable the mysql_install_db codepath besides having a database already "configured" (ie, stuff in /var/lib/mysql/mysql)
# also, we set debconf keys to make APT a little quieter
RUN { \
  echo mysql-community-server mysql-community-server/data-dir select ''; \
  echo mysql-community-server mysql-community-server/root-pass password ''; \
  echo mysql-community-server mysql-community-server/re-root-pass password ''; \
  echo mysql-community-server mysql-community-server/remove-test-db select false; \
  } | debconf-set-selections \
  && apt-get update && apt-get install -y mysql-server="${MYSQL_VERSION}"* && rm -rf /var/lib/apt/lists/* \
  && rm -rf /var/lib/mysql && mkdir -p /var/lib/mysql
# comment out a few problematic configuration values
RUN sed -Ei 's/^(bind-address|log)/#&/' /etc/mysql/my.cnf
VOLUME /var/lib/mysql
COPY docker-entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
EXPOSE 3306
CMD ["mysqld"]
```

官方提供的Dockerfile 请到`https://github.com/docker-library/docs/tree/master/mysql` 查看




#### Mongodb


```dockerfile
FROM debian:wheezy

RUN groupadd -r mongodb && useradd -r -g mongodb mongodb
RUN apt-get update \
  && apt-get install -y curl numactl \
  && rm -rf /var/lib/apt/lists/*
# grab gosu for easy step-down from root
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4
RUN curl -o /usr/local/bin/gosu -SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg--print-architecture)" \
  && curl -o /usr/local/bin/gosu.asc -SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture).asc" \
  && gpg --verify /usr/local/bin/gosu.asc \
  && rm /usr/local/bin/gosu.asc \
  && chmod +x /usr/local/bin/gosu
ENV MONGO_RELEASE_FINGERPRINT BDC0DB28022D7DEA1490DC3E7085801C857FD301
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys $MONGO_RELEASE_FINGERPRINT
ENV MONGO_VERSION 3.0.0-rc6
RUN curl -SL "https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-$MONGO_VERSION.tgz" -o mongo.tgz \
  && curl -SL "https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-$MONGO_VERSION.tgz.sig" –o mongo.tgz.sig \
  && gpg --verify mongo.tgz.sig \
  && tar -xvf mongo.tgz -C /usr/local --strip-components=1 \
  && rm mongo.tgz*
VOLUME /data/db
COPY docker-entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
EXPOSE 27017
CMD ["mongod"]
```

官方提供的Dockerfile 请到 `https://github.com/docker-library/docs/tree/master/mongo` 查看。


#### Postgres

```dockerfile

FROM debian:wheezy
# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r postgres && useradd -r -g postgres postgres
# grab gosu for easy step-down from root
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/* \
  && curl -o /usr/local/bin/gosu –SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture)" \
  && curl -o /usr/local/bin/gosu.asc -SL "https://github.com/tianon/gosu/releases/download/1.2/gosu-$(dpkg --print-architecture).asc" \
  && gpg --verify /usr/local/bin/gosu.asc \
  && rm /usr/local/bin/gosu.asc \
  && chmod +x /usr/local/bin/gosu \
  && apt-get purge -y --auto-remove curl
# make the "en_US.UTF-8" locale so postgres will be utf-8 enabled by default
RUN apt-get update && apt-get install -y locales && rm -rf /var/lib/apt/lists/* \
  && localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8
ENV LANG en_US.utf8
RUN mkdir /docker-entrypoint-initdb.d
RUN apt-key adv --keyserver pool.sks-keyservers.net --recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8
ENV PG_MAJOR 9.4
ENV PG_VERSION 9.4.0-1.pgdg70+1
RUN echo 'deb http://apt.postgresql.org/pub/repos/apt/ wheezy-pgdg main' $PG_MAJOR > /etc/apt/sources.list.d/pgdg.list
RUN apt-get update \
  && apt-get install -y postgresql-common \
  && sed -ri 's/#(create_main_cluster) .*$/\1 = false/' /etc/postgresql-common/createcluster.conf \
  && apt-get install -y \
  postgresql-$PG_MAJOR=$PG_VERSION \
  postgresql-contrib-$PG_MAJOR=$PG_VERSION \
  && rm -rf /var/lib/apt/lists/*
RUN mkdir -p /var/run/postgresql && chown -R postgres /var/run/postgresql
ENV PATH /usr/lib/postgresql/$PG_MAJOR/bin:$PATH
ENV PGDATA /var/lib/postgresql/data
VOLUME /var/lib/postgresql/data
COPY docker-entrypoint.sh /
ENTRYPOINT ["/docker-entrypoint.sh"]
EXPOSE 5432
CMD ["postgres"]
```

#### httpd

```dockerfile

FROM debian:jessie
# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
#RUN groupadd -r www-data && useradd -r --create-home -g www-data www-data
ENV HTTPD_PREFIX /usr/local/apache2
ENV PATH $PATH:$HTTPD_PREFIX/bin
RUN mkdir -p "$HTTPD_PREFIX" \
  && chown www-data:www-data "$HTTPD_PREFIX"
WORKDIR $HTTPD_PREFIX
# install httpd runtime dependencies
# https://httpd.apache.org/docs/2.4/install.html#requirements
RUN apt-get update \
  && apt-get install -y --no-install-recommends \
  libapr1 \
  libaprutil1 \
  libpcre++0 \
  libssl1.0.0 \
  && rm -r /var/lib/apt/lists/*
# see https://httpd.apache.org/download.cgi#verify
RUN gpg --keyserver pool.sks-keyservers.net --recv-keys A93D62ECC3C8EA12DB220EC934EA76E6791485A8
ENV HTTPD_VERSION 2.4.12
ENV HTTPD_BZ2_URL https://www.apache.org/dist/httpd/httpd-$HTTPD_VERSION.tar.bz2
RUN buildDeps=' \
  ca-certificates \
  curl \
  bzip2 \
  gcc \
  libapr1-dev \
  libaprutil1-dev \
  libc6-dev \
  libpcre++-dev \
  libssl-dev \
  make \
  ' \
  set -x \
  && apt-get update \
  && apt-get install -y --no-install-recommends $buildDeps \
  && rm -r /var/lib/apt/lists/* \
  && curl -SL "$HTTPD_BZ2_URL" -o httpd.tar.bz2 \
  && curl -SL "$HTTPD_BZ2_URL.asc" -o httpd.tar.bz2.asc \
  && gpg --verify httpd.tar.bz2.asc \
  && mkdir -p src/httpd \
  && tar -xvf httpd.tar.bz2 -C src/httpd --strip-components=1 \
  && rm httpd.tar.bz2* \
  && cd src/httpd \
  && ./configure --enable-so --enable-ssl --prefix=$HTTPD_PREFIX \
  && make -j"$(nproc)" \
  && make install \
  && cd ../../ \
  && rm -r src/httpd \
  && sed -ri ' \
  s!^(\s*CustomLog)\s+\S+!\1 /proc/self/fd/1!g; \
  s!^(\s*ErrorLog)\s+\S+!\1 /proc/self/fd/2!g; \
  ' /usr/local/apache2/conf/httpd.conf \
  && apt-get purge -y --auto-remove $buildDeps
COPY httpd-foreground /usr/local/bin/
EXPOSE 80
CMD ["httpd-foreground"]
```



#### Java

使用多阶段构建的Dockerfile示例，用于构建Java应用程序

```dockerfile
# 第一阶段：构建应用程序
FROM maven:3.8.4-openjdk-11 AS builder
# 将项目代码复制到容器中
COPY . /app
# 设置工作目录
WORKDIR /app
# 构建应用程序
RUN mvn clean package


# 第二阶段：运行应用程序
FROM openjdk:11
# 将构建好的应用程序复制到容器中
COPY --from=builder /app/target/my-java-app.jar /app/my-java-app.jar
# 在容器中运行 Java 应用程序
CMD ["java", "-jar", "/app/my-java-app.jar"]
```


```shell
# 要构建此多阶段构建的镜像，请在包含 Dockerfile 的目录下运行以下命令：
docker build -t my-java-app .

# 使用以下命令来运行该镜像：
docker run -d my-java-app
```



## 3.Dockerfile编写优化

### 3.1 使用小的基础镜像


Docker的基础镜像选择

我们在使用Docker hub挑选Docker的基础镜像的时候，发现了很多版本，包括Alpine、Slim、Stretch、Buster、Jessie、Bullseye。



#### 应用已安装环境的镜像

我将使用python和node作为例子，因为这些是我最常用的docker镜像，这也同样适用于任何镜像。

根据DockerHub，这是事实上的标准镜像，如果你不确定，你应该使用它。

- python:3.8.3

- node:14.1.1

这些镜像基于最新的稳定Debian操作系统发行版。 

**当我试图让一个项目快速启动和运行时，我通常会从其中的一个开始，我并不关心最终镜像的大小。完整镜像是最安全的选择**



#### buster/stretch/jessie

- buster:Debian 10

- stretch:Debian 9

- jessie:Debian 8


带有stretch、buster或jessie标签的镜像是不同Debian发行版的代号。

正在开发的未来版本是“bullseye ”和“bookworm”，但还不稳定。

你可能会在DockerHub上的镜像版本列表中看到这些标签。

如果您的代码与Debian操作系统的特定版本兼容，请选择其中一个镜像。

在开始一个新项目时，你很少需要使用旧版本的Debian。



#### slim

slim的镜像是完整镜像的配对版本。

这个镜像通常只安装运行特定工具所需的最小包。

以python为例，就是运行python的最小包，node.js同理。

通过省去较少使用的工具，镜像会更小。如果有空间限制且不需要完整版本，请使用此镜像。

**但是，在使用这个镜像时，一定要进行彻底的测试！**如果您遇到无法解释的错误，请尝试切换到完整的镜像，看看是否能够解决问题。



#### alpine

这些是最受欢迎的镜像变体，因为它们的尺寸很小。

然而，一些团队正在弃用alpine镜像，因为这些镜像可能会导致难以调试的兼容性问题。具体来说，如果使用python镜像，一些 wheels将被构建成与Debian兼容，并且需要重新编译，才能与基于apline的镜像一起工作。

使用alpine镜像的主要原因是使你得到的镜像尽可能小。基础镜像将小于5MB。

python基础镜像(将python添加到基础alpine镜像)目前是78.9MB。这仍然很小。

**如果考虑到空间问题，强烈推荐使用此镜像。**

它的缺点是不包含一些你可能会需要的包。

主要是，它使用了一个更小的musl lib代替glibc。如果您的应用程序有特定的libc需求，您可能会遇到问题。

如果你发现Alpine镜像缺少你需要的东西，你可以直接在Dockerfile中安装它，这样能确保镜像只包含你需要的内容。需要注意，如果您正在安装外部包，您的Dockerfile将会更改。

主要的区别是，您将使用apk而不是apt-get来安装包。

对alpine镜像的使用有很多担心之处，所以你需要充分了解它。

需要充分阅读文档并研究。 同样，如果您在构建Dockerfile时遇到了无法解释的问题，请尝试切换到完整的镜像，看看是否能解决问题。



#### 选择镜像

以下是我使用的通用准则：

- 如果我需要快速启动并运行项目，没有空间限制，并且没有时间进行太多测试，那么我就使用实际的标准镜像。 我最关心的是镜像有我需要的所有东西，镜像大小并不关心。


- 如果空间是一个问题，并且我知道我只需要最小的包来运行特定的语言，如python，我会选择slim


- 对于一些我有时间彻底测试的项目，并且有极端的空间限制，我将使用alpine镜像。但是要注意，这可能会导致更长的构建时间和不确定的bug。 如果您在将docker容器移植到新环境时遇到了困难，或者在添加新包时出现了故障，这可能是因为Alpine镜像。



- 最后，滚动到特定镜像的DockerHub页面底部，阅读有关选择镜像的建议。


#### 关于版本的说明

不要在生产系统 Dockerfile 中使用 `<image>:latest`。

这样做将总是获取最新的镜像，并且应用程序的依赖项可能与未来的版本不兼容。

当开始一个新项目时，我通常会从最近标记的版本开始，进行彻底的测试，然后根据需要升级，在投入生产之前进行彻底的测试。



在上面的 Dockerfile中基础镜像使用有FROM debian:bullseye-slim, FROM scratch

- scratch 是一个空镜像，一般用不到，在构建最基础的镜像的时候会用到。
  
- debian:bullseye-slim 是一个 debian 系统的 bullseye 版本的精简版镜像。看的出来，使用的镜像很小。


使用较小的镜像可以更快地构建、推送和拉取 镜像。往往更安全，因为只包含运行应用程序所需的必要库和系统依赖项。

尤其是在 CI/CD 等流水线中，庞大的 基础镜像 在每个环节都要消耗一些时间，从而使流水线的时间变得很长。

镜像之间的区别主要在于底层的操作系统


镜像选择类型

- `Official Image`：官方镜像，或者叫标准镜像，一般由官方维护的镜像，它是正确的选择，但是可能不是最优的。镜像基于最新的稳定 Debian 操作系统发行版，上面的 有 Dockerfile 构建完成的镜像即为 redis:7 的一个官网镜像。


- `Debian(bullseye/buster/stretch/jessie)`：不同的 Debian Linux 发行版镜像，jessie(8.0)，stretch(9.0) 是比较老旧的版本,buster(10.0) ,bullseye(11.0)为较新的版本


- `slim`：精简版，它通常会安装运行特定工具所需的最小包


- `alpine`：基于 Alpine Linux项目，专门为在容器内部使用而构建的操作系统。相比较 Debian 来说 Alpine 很小很小，但是需要考虑一些时区，兼容性问题。



!!! info "参考文献"


     [编写Dockerfile的一些实践经验](https://blog.frognew.com/2021/07/relearning-container-25.html)



- `scratch`: 一个明确的空镜像，特别是用于建立 "从头开始" 的镜像。

在选择最小基础镜像的同时，要尽量避免安装不必要的软件包









### 3.2 指令链式运行

可以很明显的发现，上面 Dockerfile 中的 RUN 指令很长

这是由于每个指令都会创建一个可缓存单元并构建一个新的中间镜像层。

所以可以通过链接所有命令来避免过多层级。

此外，尽量避免链接过多的可缓存 RUN 命令，因为这会导致创建大型缓存并最终导致缓存突发。

将所有的RUN指令合并为一个

```dockerfile
FROM ubuntu
ADD . /app
RUN apt-get update \  
    && apt-get install -y nodejs \
    && cd /app \
    && npm install
CMD npm start
```


```dockerfile
RUN set -eux; \
 \
 savedAptMark="$(apt-mark showmanual)"; \
 apt-get update; \
 apt-get install -y --no-install-recommends \
  ca-certificates \
  wget \
  \
  dpkg-dev \
  gcc \
  libc6-dev \
  libssl-dev \
  make \
 ; \
 rm -rf /var/lib/apt/lists/*; \
 \
 wget -O redis.tar.gz "$REDIS_DOWNLOAD_URL"; \
  ..................
```


### 3.3 变动的指令放到最后

在 RUN 之后放置 COPY 在某些情况下，您对代码进行了细微的更改，并且需要反复从 dockerfile 构建镜像。

在这种情况下，将 COPY 命令放在 RUN 命令之后将有助于减小镜像大小，因为在这种情况下 docker 将能够更好地使用缓存功能。

它将为安装了依赖项的镜像创建缓存，每次更改代码时，docker 都会使用该缓存并创建镜像。它还将减少 docker 构建时间。


所以 `始终将最常更改的指令放在末尾`。会提高构建速度.

```dockerfile

FROM python:3.9-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r /requirements.txt
COPY app.py .
```


```dockerfile

FROM ubuntu:latest
RUN apt update -y && \
apt install unzip -y --no-install-recommends && \
apt install curl --no-install-recommends -y && \
apt install python3 -y --no-install-recommends && \
rm -rf /var/lib/apt/lists/*
COPY file /home/ubuntu
```

### 3.4 首选数组而不是字符串语法

#### CMD

类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:

- CMD 在docker run 时运行。
- RUN 是在 docker build。

作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。**CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖**。

注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个

格式

```shell
CMD <shell 命令> 
CMD ["<可执行文件或命令>","<param1>","<param2>",...] 
CMD ["<param1>","<param2>",...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数
```
推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。


#### ENTRYPOINT

类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。

但是, 如果运行 docker run 时使用了 --entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。

- 优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。

- 注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。

格式

```shell
ENTRYPOINT ["<executeable>","<param1>","<param2>",...]
```

可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。


示例：

假设已通过 Dockerfile 构建了 nginx:test 镜像：

```dockerfile
FROM nginx

ENTRYPOINT ["nginx", "-c"] # 定参
CMD ["/etc/nginx/nginx.conf"] # 变参 
```

1、不传参运行

```shell
$ docker run  nginx:test
# 容器内会默认运行以下命令，启动主进程。

nginx -c /etc/nginx/nginx.conf
```

2、传参运行

```shell
$ docker run  nginx:test -c /etc/nginx/new.conf
# 容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)

nginx -c /etc/nginx/new.conf
```

我们可以通过两种不同的方式编写 最后的进程启动 命令 ENTRYPOINT

- 数组：`ENTRYPOINT ["python","-m","http.server","33333"]`


- 字符串：`ENTRYPOINT "python -m http.server 33333"`


**数组形式是首选**。

这是因为使用字符串形式会导致 Docker 使用 bash 运行您的进程，这无法正确处理信号。

由于大多数 shell 不处理子进程的信号，因此如果使用 shell 格式，CTRL-C（生成 SIGTERM）可能不会停止子进程。



### 3.5 每个RUN指令后删除多余文件

示例Dockerfile中，我们可以删除/var/lib/apt/lists/目录中的文件（它们是由apt-get update生成的）。

```dockerfile
FROM ubuntu:20.04
RUN apt-get update \  
    && apt-get install -y nodejs \
    # added lines
    && rm -rf /var/lib/apt/lists/*
ADD . /app  
RUN cd /app && npm install
CMD npm start
```


### 3.6 COPY而不是ADD


```sh
# 格式
COPY <src> <dest>
COPY [--chown=<user>:<group>] <源路径1>...  <目标路径>
COPY [--chown=<user>:<group>] ["<源路径1>",...  "<目标路径>"]

# [--chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。
# 复制本地主机的 `<src>`（为 Dockerfile 所在目录的相对路径）到容器中的 `<dest>`

```

`<源路径>`：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 `filepath.Match` 规则。例如：

```shell
COPY hom* /mydir/
COPY hom?.txt /mydir/
```

`<目标路径>`：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。


如果有多个步骤使用上下文中的不同文件，请单独复制它们，而不是一次全部复制。

这可确保每个步骤的生成缓存仅失效，并在特别需要的文件发生更改时强制重新运行该步骤。

```dockerfile
COPY requirements.txt /tmp/
RUN pip install --requirement /tmp/requirements.txt
COPY . /tmp/
```



!!! Warning "拷贝目录的一个坑"


    拷贝文件不需要写目标

    ```dockerfile
    # 拷贝文件
    FROM centos
    COPY 2.txt /usr/local/
    ```

    拷贝目录则需要这样写,目标,不然拷贝不进去

    ```dockerfile
    # 拷贝目录
    FROM centos
    COPY mysql /usr/local/mysql
    ```


### 3.7 使用.dockerignore

`.dockerignore`文件的作用类似于git工程中的 .gitignore 。不同的是 .dockerignore 应用于 docker 镜像的构建，它存在于 docker 构建上下文的根目录，用来忽略不需要打入镜像的文件

`.dockerignore`文件的写法和 .gitignore 类似，支持正则和通配符，具体规则如下：


- 每行为一个条目；

- 以 # 开头的行为注释；

- 空行被忽略；

- 构建上下文路径为所有文件的根路径；

|规则|	行为|
|---|-----|
|/temp	|匹配根路径下一级目录下所有以 temp 开头的文件或目录|
|//temp*	|匹配根路径下两级目录下所有以 temp 开头的文件或目录|
|temp?	|匹配根路径下以 temp 开头，任意一个字符结尾的文件或目录|
|**/*.go	|匹配所有路径下以 .go 结尾的文件或目录，即递归搜索所有路径|
|*.md !README.md	|匹配根路径下所有以 .md 结尾的文件或目录，但 README.md 除外|





### 3.8 利用多阶段构建

多阶段构建可以让我们大幅度减小最终的镜像大小，而不需要去想办法减少中间层和文件的数量。因为镜像是在生成过程的最后阶段生成的，所以可以利用生成缓存来最小化镜像层。

例如，如果你的构建包含多个层，则可以将它们从变化频率较低（以确保生成缓存可重用）到变化频率较高的顺序排序：

- 安装构建应用程序所需的依赖工具
- 安装或更新依赖项
- 构建你的应用

比如我们构建一个 Go 应用程序的 Dockerfile 可能类似于这样：

```dockerfile

FROM golang:1.11-alpine AS build

# 安装项目需要的工具
# 运行 `docker build --no-cache .` 来更新依赖
RUN apk add --no-cache git
RUN go get github.com/golang/dep/cmd/dep

# 通过 Gopkg.toml 和 Gopkg.lock 获取项目的依赖
# 仅在更新 Gopkg 文件时才重新构建这些层
COPY Gopkg.lock Gopkg.toml /go/src/project/
WORKDIR /go/src/project/
# 安装依赖库
RUN dep ensure -vendor-only

# 拷贝整个项目进行构建
# 当项目下面有文件变化的时候该层才会重新构建
COPY . /go/src/project/
RUN go build -o /bin/project

# 将打包后的二进制文件拷贝到 scratch 镜像下面，将镜像大小降到最低
FROM scratch
COPY --from=build /bin/project /bin/project
ENTRYPOINT ["/bin/project"]
CMD ["--help"]
```


其他示例Dockerfile

```dockerfile
# 构建：使用golang:1.13版本
FROM golang:1.13 as build

# 容器环境变量添加，会覆盖默认的变量值
ENV GO111MODULE=on
ENV GOPROXY=https://goproxy.cn,direct

# 设置工作区
WORKDIR /go/release

# 把全部文件添加到/go/release目录
ADD . .

# 编译：把cmd/main.go编译成可执行的二进制文件，命名为app
RUN GOOS=linux CGO_ENABLED=0 GOARCH=amd64 go build -ldflags="-s -w" -installsuffix cgo -o app cmd/main.go

# 运行：使用scratch作为基础镜像
FROM scratch as prod

# 在build阶段复制时区到
COPY --from=build /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
# 在build阶段复制可执行的go二进制文件app
COPY --from=build /go/release/app /
# 在build阶段复制配置文件
COPY --from=build /go/release/config ./config

# 启动服务
CMD ["/app"]
```

可以使用多个语句。每个指令都可以使用不同的基础，并且每个指令都开始构建的新阶段。

我们可以有选择地将伪影从一个阶段复制到另一个阶段，在最终镜像中留下我们不想要的所有内容。

```dockerfile
#syntax=docker/dockerfile:1.4
FROM … AS build1
COPY –from=app1 . /src

FROM … AS build2
COPY –from=app2 . /src

FROM …
COPY --from=build1 /out/app1 /bin/
COPY –-from=build2 /out/app2 /bin/
```

!!! info "参考文献"


    [多阶段构建Golang程序Docker镜像](https://www.cnblogs.com/FireworksEasyCool/p/12838875.html)




```dockerfile
# Official docker build image, Using  node:14.17-alpine3.14 image for stage-1.
# Stage-1
FROM node:14.17-alpine3.14 as build
# Copy Required files
COPY public /home/app/public/
COPY src /home/app/src/
# dockerfile install multiple packages
RUN apk add g++ make python2
RUN npm install --silent
# Create Build
RUN npm run build
RUN apk --purge del python2
#Run the build by copying the files form previous stage.
# Stage-2
FROM nginx:stable-alpine
COPY nginx.conf /etc/nginx/conf.d/default.conf
COPY --from=build /home/app/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```



### 3.9 写Dockerfile的一些技巧

#### 1.用 python -m pip 而不是 pip
```shell
# 升级 pip,让 pip install 更安静,--quiet 参数
$ python -m pip install --quiet --upgrade pip

# pip使用国内源
$ python -m pip install --quiet --upgrade pip \
&& pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt
```

#### 2.让 apt-get install 更安静
```shell
#我们用 -qq 命令，甚至重定向输出到 /dev/null 让它更安静。
$ apt-get -qq update
$ apt-get -qq install -y curl > /dev/null
```


#### 3.让 curl 和 wget 更安静
```shell
# 首先，如果要下载文件，curl 和 wget 二选一即可。如果用 curl，可以用 --silent 参数。
$ curl -sLO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64

#wget 有 --quiet 参数。
$ wget -q https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
```


#### 4.用axel而不是curl或者wget

对于身处国内的开发者，axel 完全可以取代 curl 以及 wget
```shell
echo "Install Go compiler ..."

GO_MIRROR_0="http://mirrors.ustc.edu.cn/golang/go1.13.4.linux-amd64.tar.gz"

GO_MIRROR_1="https://dl.google.com/go/go1.13.4.linux-amd64.tar.gz"

axel --quiet --output go.tar.gz $GO_MIRROR_0 $GO_MIRROR_1
```

#### 5.设置容器时间同步

```shell
#设置容器时间与宿主机时间同步
RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo 'Asia/Shanghai' >/etc/timezone
```



Dockerfile中配置时区
```yaml
FROM docker.io/centos
MAINTAINER DAVID

# 使用RUN命令设置时区
RUN cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo 'Asia/Shanghai'>/etc/timezone
```


docker-compose.yaml设置时区

```yaml
方式一：
environment:
  - SET_CONTAINER_TIMEZONE=true
  - CONTAINER_TIMEZONE=Asia/Shanghai

```


```yaml

方式二：
environment:
  - TZ=Asia/Shanghai
```


!!! example "写 Dockerfile 的一些技巧"

    https://zhuanlan.zhihu.com/p/147995194




### 3.10 docker build镜像创建


> 通过Dockerfile创建docker镜像


```shell
docker build [OPTIONS] PATH | URL | -
```


```
--build-arg=[] :设置镜像创建时的变量；
--cpu-shares :设置 cpu 使用权重；
--cpu-period :限制 CPU CFS周期；
--cpu-quota :限制 CPU CFS配额；
--cpuset-cpus :指定使用的CPU id；
--cpuset-mems :指定使用的内存 id；
--disable-content-trust :忽略校验，默认开启；
-f :指定要使用的Dockerfile路径；
--force-rm :设置镜像过程中删除中间容器；
--isolation :使用容器隔离技术；
--label=[] :设置镜像使用的元数据；
-m :设置内存最大值；
--memory-swap :设置Swap的最大值为内存+swap，"-1"表示不限swap；
--no-cache :创建镜像的过程不使用缓存；
--pull :尝试去更新镜像的新版本；
--quiet, -q :安静模式，成功后只输出镜像 ID；
--rm :设置镜像成功后删除中间容器；
--shm-size :设置/dev/shm的大小，默认值是64M；
--ulimit :Ulimit配置。
--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。
--network: 默认 default。在构建期间设置RUN指令的网络模式
```




### 3.11 dockerfile参考


=== "Debian-8"



    ```Dockerfile
    FROM buildpack-deps:jessie

    # remove several traces of debian python
    RUN apt-get purge -y python.*

    # http://bugs.python.org/issue19846
    # > At the moment, setting "LANG=C" on a Linux system *fundamentally breaks Python 3*, and that's not OK.
    ENV LANG C.UTF-8

    # gpg: key F73C700D: public key "Larry Hastings <larry@hastings.org>" imported
    ENV GPG_KEY 97FC712E4C024BBEA48A61ED3A5CA953F73C700D

    ENV PYTHON_VERSION 3.5.1

    # if this is called "PIP_VERSION", pip explodes with "ValueError: invalid truth value '<VERSION>'"
    ENV PYTHON_PIP_VERSION 8.1.2

    RUN set -ex \
            && curl -fSL "https://www.python.org/ftp/python/${PYTHON_VERSION%%[a-z]*}/Python-$PYTHON_VERSION.tar.xz" -o python.tar.xz \
            && curl -fSL "https://www.python.org/ftp/python/${PYTHON_VERSION%%[a-z]*}/Python-$PYTHON_VERSION.tar.xz.asc" -o python.tar.xz.asc \
            && export GNUPGHOME="$(mktemp -d)" \
            && gpg --keyserver ha.pool.sks-keyservers.net --recv-keys "$GPG_KEY" \
            && gpg --batch --verify python.tar.xz.asc python.tar.xz \
            && rm -r "$GNUPGHOME" python.tar.xz.asc \
            && mkdir -p /usr/src/python \
            && tar -xJC /usr/src/python --strip-components=1 -f python.tar.xz \
            && rm python.tar.xz \
            \
            && cd /usr/src/python \
            && ./configure --enable-shared --enable-unicode=ucs4 \
            && make -j$(nproc) \
            && make install \
            && ldconfig \
            && pip3 install --no-cache-dir --upgrade --ignore-installed pip==$PYTHON_PIP_VERSION \
            && find /usr/local -depth \
                    \( \
                        \( -type d -a -name test -o -name tests \) \
                        -o \
                        \( -type f -a -name '*.pyc' -o -name '*.pyo' \) \
                    \) -exec rm -rf '{}' + \
            && rm -rf /usr/src/python ~/.cache

    # make some useful symlinks that are expected to exist
    RUN cd /usr/local/bin \
            && ln -s easy_install-3.5 easy_install \
            && ln -s idle3 idle \
            && ln -s pydoc3 pydoc \
            && ln -s python3 python \
            && ln -s python3-config python-config

    CMD ["python3"]
    ```


=== "ubuntu20.04-Dockerfile示例1"



    ```Dockerfile
    FROM ubuntu:focal
    WORKDIR /opt
    ARG TARGETARCH \
        Version=v2.28.7
    ENV Version=${Version} \
        LANG=zh_CN.UTF-8

    RUN set -ex \
        && apt-get update \
        && apt-get install -y --no-install-recommends wget curl gnupg2 ca-certificates lsb-release language-pack-zh-hans netcat software-properties-common \
        && ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \
        && echo "LANG=$LANG" > /etc/default/locale \
        && echo "deb https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/6.0 multiverse" > /etc/apt/sources.list.d/mongodb-org-6.0.list \
        && wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | apt-key add - \
        && add-apt-repository -y ppa:redislabs/redis \
        && apt-get update \
        && apt-get install -y --no-install-recommends openssh-client mariadb-client bash-completion redis-tools mongodb-mongosh \
        && apt-get clean all \
        && rm -rf /var/lib/apt/lists/*

    RUN set -ex \
        && wget https://github.com/jumpserver/koko/releases/download/${Version}/koko-${Version}-linux-${TARGETARCH}.tar.gz \
        && tar -xf koko-${Version}-linux-${TARGETARCH}.tar.gz \
        && mv koko-${Version}-linux-${TARGETARCH} koko \
        && mv /opt/koko/kubectl /usr/local/bin/ \
        && mv /opt/koko/helm /usr/local/bin/ \
        && chown root:root /usr/local/bin/kubectl /usr/local/bin/helm \
        && wget https://download.jumpserver.org/public/kubectl-linux-${TARGETARCH}.tar.gz \
        && tar -xf kubectl-linux-${TARGETARCH}.tar.gz \
        && chmod 755 kubectl \
        && mv kubectl /usr/local/bin/rawkubectl \
        && wget https://download.jumpserver.org/public/helm-v3.9.0-linux-${TARGETARCH}.tar.gz -O helm.tar.gz \
        && tar -xf helm.tar.gz \
        && mv linux-${TARGETARCH}/helm /usr/local/bin/rawhelm \
        && chmod 755 /usr/local/bin/rawhelm \
        && chown root:root /usr/local/bin/rawhelm \
        && rm -rf linux-${TARGETARCH} \
        && wget http://download.jumpserver.org/public/kubectl_aliases.tar.gz \
        && mkdir /opt/kubectl-aliases/ \
        && tar -xf kubectl_aliases.tar.gz -C /opt/kubectl-aliases/ \
        && chown -R root:root /opt/kubectl-aliases/ \
        && chmod 755 /opt/koko/init-kubectl.sh \
        && rm -rf /opt/*.tar.gz

    COPY koko/entrypoint.sh .
    RUN chmod 755 ./entrypoint.sh

    CMD [ "./entrypoint.sh" ]
    ```



=== "ubuntu20.04-Dockerfile示例2"


    ```Dockerfile
    FROM ubuntu:20.04
    ARG DEBIAN_FRONTEND=noninteractive
    ENV TZ=Asia/Shanghai
    ENV LC_ALL=en_US.UTF-8


    ARG BUILD_DEPENDENCIES="              \
            python3                       \
            python3-pip                   \
            python3-setuptools            \
            build-essential               \
            python3-dev                   \
            g++                           \
            make                          \
            pkg-config"

    ARG DEPENDENCIES="                    \
            libxml2                       \
            libxml2-dev                   \
            libxslt1-dev                  \
            libffi-dev                    \
            libssl-dev                    \
            zlib1g-dev"

    ARG TOOLS="                           \
            sudo                          \
            ca-certificates               \
            bash-completion               \
            cron                          \
            curl                          \
            default-libmysqlclient-dev    \
            default-mysql-client          \
            git                           \
            zsh                           \
            git-lfs                       \
            iputils-ping                  \
            locales                       \
            logrotate                     \
            dumb-init                     \
            net-tools                     \
            openssl                       \
            openssh-client                \
            procps                        \
            telnet                        \
            unzip                         \
            vim                           \
            wget"


    RUN set -ux; \
      sed -i 's/http:\/\/archive.ubuntu.com\/ubuntu\//http:\/\/mirrors.aliyun.com\/ubuntu\//g' /etc/apt/sources.list \
      && ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \
      && apt-get update \
      && apt-get -y install --no-install-recommends ${BUILD_DEPENDENCIES} \
      && apt-get -y install --no-install-recommends ${DEPENDENCIES} \
      && apt-get -y install --no-install-recommends ${TOOLS} \
      && apt-get clean all \
      && rm -rf /var/lib/apt/lists/*

    RUN chsh -s /bin/bash
    ENV SHELL=/bin/bash


    # fixuid
    ADD fixuid-0.5.1-linux-amd64.tar.gz /usr/local/bin/
    RUN set -ux; \
      chown root:root /usr/local/bin/fixuid && \
      chmod 4755 /usr/local/bin/fixuid && \
      mkdir -p /etc/fixuid && \
      printf "user: coder\ngroup: coder\n" > /etc/fixuid/config.yml


    # code_server
    COPY code-server_4.13.0_amd64.deb /tmp/
    RUN set -ux; \
      cd /tmp/ && \
      sudo dpkg -i code-server_4.13.0_amd64.deb && \
      rm -rf code-server_4.13.0_amd64.deb



    # add user
    RUN set -ux; \
      adduser --disabled-password --gecos '' coder && \
      adduser coder sudo && \
      echo '%sudo ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers && \
      echo "root:P@ssw0rd" | chpasswd && \
      echo "coder:oschina" | chpasswd && \
      locale-gen en_US.UTF-8


    # add workspace
    RUN chmod g+rw /home && \
      mkdir -p /home/coder/workspace && \
      mkdir -p /home/coder/.local && \
      chown -R coder:coder /home/coder && \
      chown -R coder:coder /home/coder/.local && \
      chown -R coder:coder /home/coder/workspace;


    ENV PASSWORD=${PASSWORD:-P@ssw0rd}


    # kubectl and helm
    RUN curl -LO "https://storage.googleapis.com/kubernetes-release/release/v1.21.1/bin/linux/amd64/kubectl" && \
      chmod 755 ./kubectl && \
      mv ./kubectl /usr/bin/ && \
      HELM_VERSION=v3.8.0 && \
      curl -sSL "https://mirrors.huaweicloud.com/helm/${HELM_VERSION}/helm-${HELM_VERSION}-linux-amd64.tar.gz" | tar -xzf - && \
      mv ./linux-amd64/helm  /usr/bin/


    USER coder


    # fzf
    COPY --chown=1000:1000 fzf /home/coder/.fzf
    RUN set -ux;\
      /home/coder/.fzf/install


    COPY ./extensions /home/coder/.local/extensions


    RUN set -eux; \
      python3 -m pip install -U pip setuptools && \
      python3 -m pip install requests autopep8 -i  https://mirrors.aliyun.com/pypi/simple



    COPY entrypoint.sh /home/coder/.local/entrypoint.sh
    COPY settings.json /home/coder/.local/share/code-server/User/settings.json


    RUN set -eux; \
      sudo chmod +x /home/coder/.local/entrypoint.sh && \
      sudo chown coder /home/coder/.local/share/code-server/User/settings.json && \
      sudo sed -i 's/.*NOPASSWD:*/#&/g' /etc/sudoers


    WORKDIR /home/coder/workspace

    EXPOSE 8080

    ENTRYPOINT ["/bin/sh", "/home/coder/.local/entrypoint.sh"]
    ```


### 3.12 添加HEALTHCHECK

运行容器时，可以指定—restart always选项。

这样的话，容器崩溃时，Docker守护进程(docker daemon)会重启容器。对于需要长时间运行的容器，这个选项非常有用。

但是，如果容器的确在运行，但是不可(陷入死循环，配置错误)用怎么办？

使用HEALTHCHECK指令可以让Docker周期性的检查容器的健康状况。我们只需要指定一个命令，如果一切正常的话返回0，否则返回1。


对HEALTHCHECK感兴趣的话，可以参考这篇博客。示例如下：

```dockerfile
FROM node:7-alpine  
LABEL maintainer "jakub.skalecki@example.com"
ENV PROJECT_DIR=/app  
WORKDIR $PROJECT_DIR
COPY package.json $PROJECT_DIR  
RUN npm install  
COPY . $PROJECT_DIR
ENV MEDIA_DIR=/media \  
    NODE_ENV=production \
    APP_PORT=3000
VOLUME $MEDIA_DIR  
EXPOSE $APP_PORT  
HEALTHCHECK CMD curl --fail http://localhost:$APP_PORT || exit 1
ENTRYPOINT ["./entrypoint.sh"]  
CMD ["start"]
```


### 3.13 Dockerfile优化实例

下面以Dockerfile内容为基础，按照检查项进行逐步优化。该Dockerfile的内容如下：

```dockerfile
FROM RHEL
ADD . /mywebapp
RUN apt-get update
RUN apt-get upgrade -y
RUN apt-get install -y tomcat ssh MySQL
RUN cd /app && npm install
CMD MySQL & sshd & npm start
```


1）编写.dockerignore文件。.dockerignore 的作用和语法类似于 .gitignore ，用来忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少 Docker 镜像的大小。

示例如下：
```
.git/
```

2）容器只运行单个应用。

```dockerfile
FROM RHEL
ADD . /mywebapp
RUN apt-get update
RUN apt-get upgrade -y
RUN apt-get install -y tomcat    #ssh MySQL
RUN cd /app && npm install
CMD MySQL & sshd & npm start
```

3）run指令合并。

```dockerfile
FROM RHEL
ADD . /mywebapp
RUN apt-get update \
&& apt-get upgrade -y \
&& apt-get install -y tomcat \   #ssh MySQL
&& cd /app && npm install
```

4）基础镜像的标签不要用latest。

```dockerfile
FROM RHEL:7.4
ADD . /mywebapp
RUN apt-get update \
&& apt-get upgrade -y \
&& apt-get install -y tomcat \   #ssh MySQL
&& cd /app && npm install
```

5）设置默认工作目录。

```dockerfile
FROM RHEL:7.4
WORKDIR /mywebapp
ADD . /mywebapp
RUN apt-get update \
&& apt-get upgrade -y \
&& apt-get install -y tomcat \   #ssh MySQL
&& cd /app && npm install
```
6）设置环境变量。

```dockerfile
FROM RHEL:7.4
WORKDIR /mywebapp
ADD . /mywebapp
RUN apt-get update \
&& apt-get upgrade -y \
&& apt-get install -y tomcat \   #ssh MySQL
ENV  HOST=10.47.43.1 \
    PORT=8080
```




## 4.BuildKit

简单的说就是：

BuildKit或DOCKER_BUILDKIT=1 特性可以将docker build完成的数据输出到本地

基于BuildKit优化Dockerfile的构建

> https://mp.weixin.qq.com/s/OjeQsalkthe-YksIe0HtVg
>

### 4.1 安装buildx
```shell
# Buildx 0.6+
$ docker buildx bake "https://github.com/docker/buildx.git"
$ mkdir -p ~/.docker/cli-plugins
$ mv ./bin/buildx ~/.docker/cli-plugins/docker-buildx

# Docker 19.03+
$ DOCKER_BUILDKIT=1 docker build --platform=local -o . "https://github.com/docker/buildx.git"
$ mkdir -p ~/.docker/cli-plugins
$ mv buildx ~/.docker/cli-plugins/docker-buildx

# Local
$ git clone https://github.com/docker/buildx.git && cd buildx
$ make install
```


① 第一种方式使用BuildKit特性，设置环境变量

```shell
DOCKER_BUILDKIT=1 docker build .
```

下面的示例Dockerfile使用一个单独的阶段来收集要导出的生成文件：

示例1
```shell
FROM
Learn more about the "FROM" Dockerfile command.
 golang AS build-stage
RUN go get -u github.com/LK4D4/vndr

FROM scratch AS export-stage
COPY --from=build-stage /go/bin/vndr /
```

示例2
```shell
FROM nodejs:buster-slimv1.0 AS builder
MAINTAINER 1879324764@qq.com

COPY sources.list /etc/apt/sources.list
COPY gitee-ent-web /home/gitee-ent-web

RUN set -eux;\
    apt-get update && \
    apt-get install -y wget git && \
    cd /home/gitee-ent-web && \
    yarn install && \
    yarn run build-i18n && \
    yarn run build-vendor && \
    yarn web:prod-ci-runjs

FROM scratch AS export-stage
COPY --from=builder /home/gitee-ent-web/dist ./dist
```

② 第二种方式使用BuildKit特性

```shell
docker buildx build -o out .
```
下面命令会在当前out目录下生成输出的文件，out如果不存在会自动创建

```shell

DOCKER_BUILDKIT=1 docker build -o out .
```
或者
```shell
# 直接使用 docker buildx build 命令构建镜像。
docker buildx build -o out .
```


### 4.2 buildx示例

一个go编译环境的例子
```shell
$ ls
Dockerfile  go.mod  main.go

$ cat Dockerfile
FROM golang:1.12-alpine as dev
RUN apk add --no-cache git ca-certificates
RUN adduser -D appuser
WORKDIR /src
COPY . /src/
CMD CGO_ENABLED=0 go build -o app . && ./app

FROM dev as build
RUN CGO_ENABLED=0 go build -o app .
USER appuser
CMD [ "./app" ]

FROM scratch as release
COPY --from=build /etc/passwd /etc/group /etc/
COPY --from=build /src/app /app
USER appuser
CMD [ "/app" ]

FROM scratch as artifact
COPY --from=build /src/app /app

FROM release
$ DOCKER_BUILDKIT=1 docker build --target artifact --output type=local,dest=. .
或者
$ docker buildx build  --output type=local,dest=path/to/output-dir
After the build was complete the app binary was exported:

$ ls
Dockerfile  app  go.mod  main.go

$ ./app
Ready to receive requests on port 8080
```

!!! example "参考文献"

    https://www.yuque.com/morlay/me/docker-buildx


    参考文献：https://www.cnblogs.com/yance-dev/p/16499553.html





## 5.Dockerfile实践


!!! info "Golang/Python应用部署到Docker"





### 5.1 构建Nginx基础镜像

```yaml
FROM centos:7
LABEL wenlong
RUN yum install -y gcc gcc-c++ make \
    openssl-devel pcre-devel gd-devel \
    iproute net-tools telnet wget curl && \
    yum clean all && \
    rm -rf /var/cache/yum/*
RUN wget http://nginx.org/download/nginx-1.15.5.tar.gz && \
    tar zxf nginx-1.15.5.tar.gz && \
    cd nginx-1.15.5 && \
    ./configure --prefix=/usr/local/nginx \
    --with-http_ssl_module \
    --with-http_stub_status_module && \
    make -j 4 && make install && \
    rm -rf /usr/local/nginx/html/* && \
    echo "ok" >> /usr/local/nginx/html/status.html && \
    cd / && rm -rf nginx-1.15.5* && \
    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
 
ENV PATH $PATH:/usr/local/nginx/sbin
COPY nginx.conf /usr/local/nginx/conf/nginx.conf
WORKDIR /usr/local/nginx
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 5.2 构建PHP基础镜像

```yaml
复制代码
FROM centos:7
LABEL maintainer wenlong
RUN yum install epel-release -y && \
    yum install -y gcc gcc-c++ make gd-devel libxml2-devel \
    libcurl-devel libjpeg-devel libpng-devel openssl-devel \
    libmcrypt-devel libxslt-devel libtidy-devel autoconf \
    iproute net-tools telnet wget curl && \
    yum clean all && \
    rm -rf /var/cache/yum/*
 
RUN wget http://docs.php.net/distributions/php-5.6.36.tar.gz && \
    tar zxf php-5.6.36.tar.gz && \
    cd php-5.6.36 && \
    ./configure --prefix=/usr/local/php \
    --with-config-file-path=/usr/local/php/etc \
    --enable-fpm --enable-opcache \
    --with-mysql --with-mysqli --with-pdo-mysql \
    --with-openssl --with-zlib --with-curl --with-gd \
    --with-jpeg-dir --with-png-dir --with-freetype-dir \
    --enable-mbstring --with-mcrypt --enable-hash && \
    make -j 4 && make install && \
    cp php.ini-production /usr/local/php/etc/php.ini && \
    cp sapi/fpm/php-fpm.conf /usr/local/php/etc/php-fpm.conf && \
    sed -i "90a \daemonize = no" /usr/local/php/etc/php-fpm.conf && \
    mkdir /usr/local/php/log && \
    cd / && rm -rf php* && \
    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
 
ENV PATH $PATH:/usr/local/php/sbin
COPY php.ini /usr/local/php/etc/
COPY php-fpm.conf /usr/local/php/etc/
WORKDIR /usr/local/php
EXPOSE 9000
CMD ["php-fpm"]

```


### 5.3 构建Tomcat基础镜像

```yaml
FROM centos:7
LABEL maintainer wenlong
 
ENV VERSION=8.0.52
 
RUN yum install java-1.8.0-openjdk wget curl unzip iproute net-tools -y && \
    yum clean all && \
    rm -rf /var/cache/yum/*
 
RUN wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v${VERSION}/bin/apache-tomcat-${VERSION}.tar.gz && \
    tar zxf apache-tomcat-${VERSION}.tar.gz && \
    mv apache-tomcat-${VERSION} /usr/local/tomcat && \
    rm -rf apache-tomcat-${VERSION}.tar.gz /usr/local/tomcat/webapps/* && \
    mkdir /usr/local/tomcat/webapps/test && \
    echo "ok" > /usr/local/tomcat/webapps/test/status.html && \
    sed -i '1a JAVA_OPTS="-Djava.security.egd=file:/dev/./urandom"' /usr/local/tomcat/bin/catalina.sh && \
    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
 
ENV PATH $PATH:/usr/local/tomcat/bin
 
WORKDIR /usr/local/tomcat
 
EXPOSE 8080
CMD ["catalina.sh", "run"]
```





!!! info "总结"
    
    上面可以看出python的应用一般直接跑在某个python版本的alpine基础环境下的，而Gloang则是在GO的alpine环境下完成编译与测试后，然后通过多阶段构建的策略，
    最后将编译完成Gloang程序运行在scratch镜像中，这样可以减小Golang程序最终的镜像大小，避免浪费资源。


!!! example "参考文献"

    https://www.bococ.cn/Docker/106.html


## 6.Dockerfile工具


!!! info "查看运行容器的Dockerfile工具"


    项目地址：[Whaler(opens new window)](https://github.com/P3GLEG/Whaler)

    项目说明：能够查看在运行容器的Dockerfile的工具，有时候我们可能会维护一个没有Dockerfile的容器，即可借助此工具。

    相关文章：[博文介绍](https://samaritan.ai/blog/reversing-docker-images-into-dockerfiles/)




!!! info "查看docker容器运行命令的所有参数"


    项目地址：[runlike(opens new window)](https://github.com/lavie/runlike)

    项目说明：给定一个现有的 docker 容器，打印运行它的副本所需的命令行。

    相关文章：README


可以将运行的docker 推导反写为docker-compose文件



## 7.参考文献


!!! info "推荐阅读"

    [Dockerfile 最佳实践](https://vuepress.mirror.docker-practice.com/appendix/best_practices/#)

    [Dockerfile 实践](https://www.qikqiak.com/k8strain2/docker/dockerfile-practice/)

    [Dockerfile那么多，哪个才是真正的最佳实践？](https://mp.weixin.qq.com/s/K7hD2hdwx_xXCFDQFHWvMg)