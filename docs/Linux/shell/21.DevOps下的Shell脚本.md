# 21.DevOps下的Shell脚本

## 生产环境下的备份类脚本

### 版本控制软件SVN的代码库的备份脚本

```shell
#!/bin/sh
SVNDIR=/data/svn
SVNADMIN=/usr/bin/svnadmin
DATE=`date +%Y-%m-%d`
OLDDATE=`date +%Y-%m-%d -d '30 days'`
BACKDIR=/data/backup/svn-backup

[ -d ${BACKDIR} ] || mkdir -p ${BACKDIR}
LogFile=${BACKDIR}/svnbak.log
[ -f ${LogFile} ] || touch ${LogFile}
mkdir ${BACKDIR}/${DATE}


for PROJECT in myproject official analysis mypharma
do
  cd $SVNDIR
  $SVNADMIN hotcopy $PROJECT  $BACKDIR/$DATE/$PROJECT --clean-logs
  cd $BACKDIR/$DATE
  tar zcvf ${PROJECT}_svn_${DATE}.tar.gz $PROJECT  > /dev/null
  rm -rf $PROJECT
sleep 2
done

HOST=192.168.2.112
FTP_USERNAME=svn
FTP_PASSWORD=svn101

cd ${BACKDIR}/${DATE}

ftp -i -n -v << !
open ${HOST}
user ${FTP_USERNAME} ${FTP_PASSWORD}
bin
cd ${OLDDATE}
mdelete *
cd ..
rmdir ${OLDDATE}
mkdir ${DATE}
cd ${DATE}
mput *
bye
!

```


### 备份文件shell脚本

Auto_Backup_Linux_System_Files.sh

```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh
SOURCE_DIR=(
    $*
)
TARGET_DIR=/data/backup/
YEAR=`date +%Y`
MONTH=`date +%m`
DAY=`date +%d`
WEEK=`date +%u`
FILES=system_backup.tgz
CODE=$?


if [ -z "$*" ]; then
    echo -e "\033[32mUsage:\nPlease Ebter Your Backup Files or Directories\n--------------------------------------------\n
    \nUsage:{ $0 /boot/etc}\033[0m"
    exit
fi

# Deternube Wgether the Target Directory Exists

if [ ! -d $TARGET_DIR ]; then
    mkdir -p $TARGET_DIR/$YEAR/$MONTH/$DAY
    echo -e "\033[32mThe $TARGET_DIR Create Successfully ! \033[0m"
fi

#EXEC Full_Backup Function Command
#EXEC Full_Backup Function Command
Full_Backup()
{
if
    [ "$WEEK" -eq "7" ];then
    rm -rf $TARGET_DIR/snapshot
    cd $TARGET_DIR/$YEAR/$MONTH/$DAY ;tar -g $TARGET_DIR/snapshot -czvf $FILES `echo ${SOURCE_DIR[@]}`
    [ "$CODE" == "0" ]&&echo -e  "--------------------------------------------\nFull_Backup System Files Backup Successfully !"
fi
}
#Perform incremental BACKUP Function Command
Add_Backup()
{
   cd $TARGET_DIR/$YEAR/$MONTH/$DAY ;
if
    [ -f $TARGET_DIR/$YEAR/$MONTH/$DAY/$FILES ];then
    read -p "$FILES Already Exists, overwrite confirmation yes or no ? : " SURE
    if [ $SURE == "no" -o $SURE == "n" ];then
    sleep 1;exit 0
    fi
#Add_Backup Files System
    if
        [ $WEEK -ne "7" ];then
        cd $TARGET_DIR/$YEAR/$MONTH/$DAY;tar -g $TARGET_DIR/snapshot -czvf $$_$FILES `echo ${SOURCE_DIR[@]}`
        [ "$CODE" == "0" ]&&echo -e  "-----------------------------------------\n\033[32mAdd_Backup System Files Backup Successfully !\033[0m"
   fi
else
   if
      [ $WEEK -ne "7" ];then
      cd $TARGET_DIR/$YEAR/$MONTH/$DAY ;tar -g $TARGET_DIR/snapshot -czvf $FILES `echo ${SOURCE_DIR[@]}`
      [ "$CODE" == "0" ]&&echo -e  "-------------------------------------------\n\033[32mAdd_Backup System Files Backup Successfully !\033[0m"
   fi
fi
}
Full_Backup
Add_Backup


# crontab计划任务中加入如下语句，每天凌晨1点整执行备份脚本。
# 0 1 *  *  * /bin/sh /data/sh/Auto_Backup_Linux_System_Files.sh /boot /etc/ >> /tmp/back.log 2>&1
```


### Mysql数据库备份至S3文件系统
```shell
#!/bin/bash
#
# Filename:
# backupdatabase.sh
# Description:
# backup cms database and remove backup data before 7 days
# crontab
# 55 23 * * * /bin/sh /yundisk/cms/crontab/backupdatabase.sh >> /yundisk/cms/crontab/backupdatabase.log 2>&1

DATE=`date +%Y-%m-%d`
OLDDATE=`date +%Y-%m-%d -d '-7 days'`

#MYSQL=/usr/local/mysql/bin/mysql
#MYSQLDUMP=/usr/local/mysql/bin/mysqldump
#MYSQLADMIN=/usr/local/mysql/bin/mysqladmin

BACKDIR=/yundisk/cms/database
[ -d ${BACKDIR} ] || mkdir -p ${BACKDIR}
[ -d ${BACKDIR}/${DATE} ] || mkdir ${BACKDIR}/${DATE}
[ ! -d ${BACKDIR}/${OLDDATE} ] || rm -rf ${BACKDIR}/${OLDDATE}

mysqldump --default-character-set=utf8 --no-autocommit --quick --hex-blob --single-transaction -uroot  cms_production  | gzip > ${BACKDIR}/${DATE}/cms-backup-${DATE}.sql.gz
echo "Database cms_production and bbs has been backup successful"
/bin/sleep 5

aws s3 cp ${BACKDIR}/${DATE}/* s3://example-share/cms/databackup/
```


### mysql定时备份脚本
```shell
#!/bin/bash
# 初始化时，创建相应目录
# mkdir /home/node/bakmysql/sql/

# 定时任务
# 每天凌晨1:00执行备份脚本
#0 1 * * * /bin/bash -x /home/node/bakmysql/backup.sh >/dev/null 2>&1
#2分钟运行一次-测试用
#*/2 * * * * /bin/bash -x /home/node/bakmysql/backup.sh >/dev/null 2>&1

BakDir=/home/node/bakmysql/sql
LogFile=/home/node/bakmysql/sql/bak.log
Date=`date +%Y%m%d`
Begin=`date +"%Y年%m月%d日 %H:%M:%S"`
cd $BakDir
DumpFile=$Date.sql


# 导出到本地
mysqldump -uroot -p123456 test --quick --single-transaction | gzip > $DumpFile.gz
Last=`date +"%Y年%m月%d日 %H:%M:%S"`
echo [FullBack] 开始:$Begin 结束:$Last $DumpFile.gz successful >> $LogFile


# 删除7天前的备份文件
find $BakDir -mtime +7 -type f -name "*.sql.gz" | xargs rm -f
```



### MySQL数据库分库备份


```shell
#!/bin/bash
# author: xiongminghao
# mail: jasonminghao@163.com
# describe：Mysql database backup
# 定义变量
IP=$(ifconfig eth1 |awk 'NR==2{print $2}')
Path=/backup/database  # 备份目录路径
Time=$(date +%F)
Ba_Path=$Path/$Time
Ba_Logs=/var/log/db_database_$Time # 定义一个存放日志的文件
Md5_Path=$Path/$Time/md5 # 定义一个存放md5校验的目录


# 创建两个目录以当天时间为命名
[ ! -d $Ba_Path ] && mkdir $Ba_Path
[ ! -d $Md5_Path ] && mkdir $Md5_Path

# 循环获取数据库名进行备份和生成MD5校验文件
for dbname in `mysql  -e 'show databases' |sed '1d' |grep -v "_schema"`
do
# 判断是否有数据库已经备份了,如果备份了则continue 调出当次循环，否则进行备份

if [ ! -f $Ba_Path/${dbname}.sql.gz ];then

   # 备份参数
   # -B 增加use[name]语句, -R 备份存储过程和函数数据
   # --master=data2 记录备份时刻的binlog位置点，2表示将其位置点注释
   # --single-ransaction 对innodb引擎进行热备（对数据进行快照）
   # gzip 对备份的数据进行gzip压缩
   mysqldump  -B -R --master-data=2 --single-transaction  |gzip >$Ba_Path/${dbname}.sql.gz
   RETVAL=$?

   # 通过返回值判断备份是否执行成功,把执行的成功与否纪录到日志中
   [ $? -eq 0 ] && echo "${dbname} successful" >>$Ba_Logs || echo "${dbname} failed" >>$Ba_Logs

   # 对数据库的数据完整性做MD5校验
   md5sum $Ba_Path/${dbname}.sql.gz  >$Md5_Path/${dbname}_md5.log

 else
    # 如果备份已存在则跳出当次循环,进行下次循环
    continue

  fi
done

# 将备份日志结果邮件方式发送给管理员
 mail -s "$HOSTNAME $IP" jasonminghao@163.com < $Ba_Logs
```


### MySQL数据库分库分表备份

```shell
#!/bin/bash
# author: xiongminghao
# mail: jasonminghao@163.com
# describe：Mysql database table backup
# 定义变量
IP=$(ifconfig eth1 |awk 'NR==2{print $2}')
Path=/backup/table # 备份目录
Time=$(date +%F)
Ba_Path=$Path/$Time
Ba_Logs=/var/log/db_table_$Time  # 定义一个存放日志的文件
Md5_Path=$Path/$Time/md5 # 定义一个存放md5校验的目录

# 创建两个目录以当天时间为命名
[ ! -d $Ba_Path ] && mkdir $Ba_Path
[ ! -d $Md5_Path ] && mkdir $Md5_Path

# 循环获取数据库名
for dbname in `mysql  -e 'show databases' |sed '1d' |grep -v "_schema"`
do

  # 循环获取到数据库名后再次循环获取到该库名下的表，进行备份和MD5校验
  for tablename in `mysql -e "show tables from $dbname" |sed '1d'`
  do

  # 判断是否有表已经备份了,如果备份了则continue 调出当次循环，否则进行备份
  if [ ! -f $Ba_Path/${dbname}_${tablename}.sql.gz ];then

   mysqldump -R --master-data=2 --single-transaction  ${dbname} ${tablename} |gzip >$Ba_Path/${dbname}_${tablename}.sql.gz
   RETVAL=$?

   # 通过返回值判断备份是否执行成功,把执行的成功与否纪录到日志中
   [ $? -eq 0 ] && echo "${dbname}_${tablename} successful" >>$Ba_Logs || echo "${dbname}_${tablename} failed" >>$Ba_Logs
   # 对表的数据完整性做MD5校验
   md5sum $Ba_Path/${dbname}_${tablename}.sql.gz  >$Md5_Path/${dbname}_${tablename}_md5.log

 else
    continue

  fi
 done
done
# 将备份日志结果邮件方式发送给管理员
mail -s "$HOSTNAME $IP" jasonminghao@163.com < $Ba_Logs
```



## 生产环境下的统计类脚本

### 统计设备资产明细脚本

```shell
#!/bin/bash

#####get cpu info#####
cpu_num=`cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l`
cpu_sum=`cat /proc/cpuinfo |grep processor |wc -l`
cpu_hz=`cat /proc/cpuinfo |grep 'model name' |uniq -c |awk '{print $NF}'`

#####get mem info#####
mem_m=0
for i in `dmidecode -t memory |grep Size: |grep -v "No Module Installed" |awk '{print $2}'`
do
    mem_m=`expr $mem_m + $i`
done
mem_sum=`echo $mem_m / 1024 | bc`

#####get nic info#####
qian_num=`lspci |grep Ethernet |egrep -v '10-Gigabit|10 Gigabit' |wc -l`
wan_num=`lspci |grep Ethernet |egrep  '10-Gigabit|10 Gigabit' |wc -l`

#####get disk num#####
B=`date +%s`
ssd_num=0=
sata_num=0
for i in `lsblk |grep "disk"|awk '{print $1}'|egrep -v "ram"|sort`;
do
    code=`cat /sys/block/$i/queue/rotational`
    if [ "$code" = "0" ];then
       ssd_num=`expr $ssd_num + 1` && echo $i >>/tmp/$B.ssd
    else
       sata_num=`expr $sata_num + 1` && echo $i >>/tmp/$B.sata
    fi
done

#####get disk sum#####
C=`date +%N`
ssd_sum=0
sata_sum=0
if [ -f /tmp/$B.ssd ];then
    for n in `cat /tmp/$B.ssd`;do
        fdisk -l /dev/$n >>/tmp/$C.ssd 2>&1
        for x in `grep "Disk /dev" /tmp/$C.ssd |awk '{print $3}'`;do
            u=`echo $x / 1|bc`
        done
     ssd_sum=`expr $ssd_sum + $u + 1`
    done
fi

for m in `cat /tmp/$B.sata`;do
   fdisk -l /dev/$m >>/tmp/$C.sata 2>&1
   for y in `grep "Disk /dev" /tmp/$C.sata |awk '{print $3}'`;do
      v=`echo $y / 1|bc`
   done
   sata_sum=`expr $sata_sum + $v + 1`
done

#####show dev info#####
echo -n "$ip `hostname` $plat $pop $prov "
echo -n "CPU(物理核数,逻辑核数,频率): $cpu_num $cpu_sum $cpu_hz "
echo -n "内存(GB): $mem_sum "
echo -n "网卡数量(千兆,万兆): $qian_num $wan_num "
echo "SSD数量: ${ssd_num} SSD容量: ${ssd_sum}GB SATA数量: ${sata_num} SATA容量 ${sata_sum}GB "
```


### 统计重要业务程序是否正常运行

```shell
#!/bin/bash
sync_redis_status=`ps aux | grep sync_redis.py | grep -v grep | wc -l `
if [ ${sync_redis_status} != 1 ]; then
    echo "Critical! sync_redis is Died"
    exit 2
else
    echo "OK! sync_redis is Alive"
    exit 0
fi
```

### 统计机器的IP连接数

```shell
#!/bin/bash
#脚本的$1和$2报警阀值可以根据业务的实际情况调整。
#$1 = 15000，$2 = 20000
ip_conns=`netstat -an | grep tcp | grep EST | wc -l`
messages=`netstat -ant | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'|tr -s '\n' ',' | sed -r 's/(.*),/\1\n/g' `

if [ $ip_conns -lt $1 ]
then
    echo "$messages,OK -connect counts is $ip_conns"
    exit 0
fi
if [ $ip_conns -gt $1 -a $ip_conns -lt $2 ]
then
    echo "$messages,Warning -connect counts is $ip_conns"
    exit 1
fi
if [ $ip_conns -gt $2 ]
then
    echo "$messages,Critical -connect counts is $ip_conns"
    exit 2
fi
```

### 修改IP_主机名_网卡信息脚本
```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh

#静态IP修改
#动态IP修改
#根据IP生产主机名并配置
#修改DNS域名解析
ETHCONF=/etc/sysconfig/network-scripts/ifcfg-ens32
HOSTS=/etc/hosts
NETWORK=/etc/sysconfig/network
DIR=/data/backup/`date +%Y%m%d`
NETMASK=255.255.255.0
echo "------------------------------------------------------------------"
judeg_ip(){
    read -p "Please enter ip Address,example 192.168.0.11 ip":IPADDR
    echo $IPADDR|grep -v "[Az-Zz]"|grep --color -E "([0-9]{1,3}\.){3}[0-9]{1,3}"
}

count_ip(){
    count=(`echo ${IPADDR}|awk -F. '{print $1,$2,$3,$4}'`)
    IP1=${count[0]}
    IP2=${count[1]}
    IP3=${count[2]}
    IP4=${count[3]}
}


ip_check(){
judeg_ip

while [ "$?" -ne 0 ]; do
    judeg_ip
done

count_ip
while [ "$IP1" -lt 0 -o "$IP1" -ge 255 -o "$IP2" -ge 255 -o "$IP3" -ge 255 -o "$IP4" -ge 255 ]; do
    judeg_ip
    while [ "$?" -ne 0 ]; do
        judeg_ip
    done
    count_ip
done
}


change_ip(){

if [ ! -d $DIR ]; then
    mkdir -p $DIR
fi
echo "The Change ip address to Backup Interface eth0"
cp $ETHCONF $DIR
grep "dhcp" $ETHCONF
if [ "$?" -eq 0 ]; then
    read -p "Please enter ip Address:" IPADDR
    sed -i 's/dhcp/static/g' $ETHCONF
    echo -e "IPADDR=$IPADDR\nNERMASK=$NETMASK\nGATEWAY=`echo $IPADDR|awk -F. '{print $1"."$2"."$3}'`.2" >> $ETHCONF
    echo "The IP configuration success. !"
else
    echo -n "Static IP has been configured,please confirm whether to modify,yes or No";
    read i
fi
if [ "$i" == "y" -o "$i" == "yes" ]; then
    ip_check
    sed -i -e '/IPADDR/d' -e '/NETMASK/d' -e '/GATEWAY/d' $ETHCONF
    echo -e "IPADDR=$IPADDR\nNETMASK=$NETMASK\nGATEWAY=`echo  $IPADDR|awk -F. '{print $1"."$2"."$3}'`.2" >> $ETHCONF
    echo "The IP configuration success. !"
    echo
else
    echo "Static IP already exists,please exit."
    echo $?
fi
}

change_hosts(){
    if [ ! -d $DIR ]; then
        mkdir -p $DIR
    fi
    cp $HOSTS $DIR
    ip_check
    host=`echo $IPADDR|sed 's/\./-/g'|awk '{print "BJ-IDC-" $0 "-Hujianli.net"}'`
    cat $HOSTS|grep "$host"
    if [ "$?" -ne 0 ]; then
        echo "$IPADDR    $host" >> $HOSTS
        echo "The hosts modify success"
    fi
    grep "$host" $NETWORK
    if [ "$?" -ne 0 ]; then
        sed -i 's/^HOSTNAME/#HOSTNAME/g' $NETWORK
        echo "NETWORK=$host" >> $NETWORK
        hostname $host;su
    fi
}


PS3="Please Select configuration ip or configuration host:"
select i in "modify_ip" "modify_hosts" "exit"
do
    case "$i" in
    modify_ip)
        change_ip
       ;;
    modify_hosts)
        change_hosts
       ;;
    exit)
        exit
       ;;
    *)
       echo -e "1)modify_ip\n2)modify_host\n3)exit"
    esac
done
```


## 生产环境下的监控类脚本

### 监控Nginx进程的脚本


```shell
#!/bin/bash
while :
do
 nginxpid=`ps -C nginx --no-header | wc -l`
 if [ $nginxpid -eq 0 ];then
    ulimit -SHn 65535
    /usr/local/nginx/sbin/nginx
    sleep 5
   if [ $nginxpid -eq 0 ];then
     /etc/init.d/keepalived stop
   fi
 fi
 sleep 5
done

```


### 监控httpd服务状态脚本

```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh
# author：xiaojian

LogTime=$(date +%Y%m%d-%T)
Log_File="/home/check_httpd.log"

while true; do
    HTTPD_STATUS=`service httpd status | grep running`
    if test -z "$HTTPD_STATUS"; then
        echo "$LogTime  HTTPD is stopped, try to restart" >> $Log_File
        service httpd restart
    else
        echo "HTTPD is running ,wait 2 sec until next check" &>/dev/null
        sleep 2
    fi
done
```


### 监控mysql数据库示例


```shell
#!/usr/bin/env bash
#方法1
if [ `lsof -i tcp:3306|wc -l` -gt 0 ] #<==过滤端口转成数字，很优秀的取值判断方法。
then
    echo "MySQL is Running."
else
    echo "MySQL is Stopped."
    /etc/init.d/mysqld start
fi

#方法2

if [ `ps aux| grep -v grep | grep mysql |wc - l`  -gt 0]; then
    echo  "Mysql is Running"
else
    echo "Mysql is Stopped. "
    /etc/init.d/mysqld start
fi
```



### 系统文件数打开监控脚本

```shell
#!/bin/bash
for pid in `ps aux |grep nginx |grep -v grep|awk '{print $2}'`
do
cat /proc/${pid}/limits | grep 'Max open files'
done
```


### 监控机器CPU利用率脚本

```shell
#!/bin/bash
# CPU Utilization Statistics plugin for Nagios
#
# USAGE     :   ./check_cpu_utili.sh [-w <user,system,iowait>] [-c <user,system,iowait>] ( [ -i <intervals in second> ] [ -n <report number> ])
#
# Exemple: ./check_cpu_utili.sh
#          ./check_cpu_utili.sh -w 70,40,30 -c 90,60,40
#          ./check_cpu_utili.sh -w 70,40,30 -c 90,60,40 -i 3 -n 5
# Paths to commands used in this script.  These may have to be modified to match your system setup.
IOSTAT="/usr/bin/iostat"

# Nagios return codes
STATE_OK=0
STATE_WARNING=1
STATE_CRITICAL=2
STATE_UNKNOWN=3

# Plugin parameters value if not define
LIST_WARNING_THRESHOLD="70,40,30"
LIST_CRITICAL_THRESHOLD="90,60,40"
INTERVAL_SEC=1
NUM_REPORT=1
# Plugin variable description
PROGNAME=$(basename $0)

if [ ! -x $IOSTAT ]; then
    echo "UNKNOWN: iostat not found or is not executable by the nagios user."
    exit $STATE_UNKNOWN
fi

print_usage() {
        echo ""
        echo "$PROGNAME $RELEASE - CPU Utilization check script for Nagios"
        echo ""
        echo "Usage: check_cpu_utili.sh -w -c (-i -n)"
        echo ""
        echo "  -w  Warning threshold in % for warn_user,warn_system,warn_iowait CPU (default : 70,40,30)"
        echo "  Exit with WARNING status if cpu exceeds warn_n"
        echo "  -c  Critical threshold in % for crit_user,crit_system,crit_iowait CPU (default : 90,60,40)"
        echo "  Exit with CRITICAL status if cpu exceeds crit_n"
        echo "  -i  Interval in seconds for iostat (default : 1)"
        echo "  -n  Number report for iostat (default : 3)"
        echo "  -h  Show this page"
        echo ""
    echo "Usage: $PROGNAME"
    echo "Usage: $PROGNAME --help"
    echo ""
    exit 0
}

print_help() {
    print_usage
        echo ""
        echo "This plugin will check cpu utilization (user,system,CPU_Iowait in %)"
        echo ""
    exit 0
}

# Parse parameters
while [ $# -gt 0 ]; do
    case "$1" in
        -h | --help)
            print_help
            exit $STATE_OK
            ;;
        -v | --version)
                print_release
                exit $STATE_OK
                ;;
        -w | --warning)
                shift
                LIST_WARNING_THRESHOLD=$1
                ;;
        -c | --critical)
               shift
                LIST_CRITICAL_THRESHOLD=$1
                ;;
        -i | --interval)
               shift
               INTERVAL_SEC=$1
                ;;
        -n | --number)
               shift
               NUM_REPORT=$1
                ;;
        *)  echo "Unknown argument: $1"
            print_usage
            exit $STATE_UNKNOWN
            ;;
        esac
shift
done

# List to Table for warning threshold (compatibility with
TAB_WARNING_THRESHOLD=(`echo $LIST_WARNING_THRESHOLD | sed 's/,/ /g'`)
if [ "${#TAB_WARNING_THRESHOLD[@]}" -ne "3" ]; then
  echo "ERROR : Bad count parameter in Warning Threshold"
  exit $STATE_WARNING
else
USER_WARNING_THRESHOLD=`echo ${TAB_WARNING_THRESHOLD[0]}`
SYSTEM_WARNING_THRESHOLD=`echo ${TAB_WARNING_THRESHOLD[1]}`
IOWAIT_WARNING_THRESHOLD=`echo ${TAB_WARNING_THRESHOLD[2]}`
fi

# List to Table for critical threshold
TAB_CRITICAL_THRESHOLD=(`echo $LIST_CRITICAL_THRESHOLD | sed 's/,/ /g'`)
if [ "${#TAB_CRITICAL_THRESHOLD[@]}" -ne "3" ]; then
  echo "ERROR : Bad count parameter in CRITICAL Threshold"
  exit $STATE_WARNING
else
USER_CRITICAL_THRESHOLD=`echo ${TAB_CRITICAL_THRESHOLD[0]}`
SYSTEM_CRITICAL_THRESHOLD=`echo ${TAB_CRITICAL_THRESHOLD[1]}`
IOWAIT_CRITICAL_THRESHOLD=`echo ${TAB_CRITICAL_THRESHOLD[2]}`
fi

if [ ${TAB_WARNING_THRESHOLD[0]} -ge ${TAB_CRITICAL_THRESHOLD[0]} -o ${TAB_WARNING_THRESHOLD[1]} -ge ${TAB_CRITICAL_THRESHOLD[1]} -o ${TAB_WARNING_THRESHOLD[2]} -ge ${TAB_CRITICAL_THRESHOLD[2]} ]; then
  echo "ERROR : Critical CPU Threshold lower as Warning CPU Threshold "
  exit $STATE_WARNING
fi

CPU_REPORT=`iostat -c $INTERVAL_SEC $NUM_REPORT | sed -e 's/,/./g' | tr -s ' ' ';' | sed '/^$/d' | tail -1`
CPU_REPORT_SECTIONS=`echo ${CPU_REPORT} | grep ';' -o | wc -l`
CPU_USER=`echo $CPU_REPORT | cut -d ";" -f 2`
CPU_SYSTEM=`echo $CPU_REPORT | cut -d ";" -f 4`
CPU_IOWAIT=`echo $CPU_REPORT | cut -d ";" -f 5`
CPU_STEAL=`echo $CPU_REPORT | cut -d ";" -f 6`
CPU_IDLE=`echo $CPU_REPORT | cut -d ";" -f 7`
NAGIOS_STATUS="user=${CPU_USER}%,system=${CPU_SYSTEM}%,iowait=${CPU_IOWAIT}%,idle=${CPU_IDLE}%"
NAGIOS_DATA="CpuUser=${CPU_USER};${TAB_WARNING_THRESHOLD[0]};${TAB_CRITICAL_THRESHOLD[0]};0"

CPU_USER_MAJOR=`echo $CPU_USER| cut -d "." -f 1`
CPU_SYSTEM_MAJOR=`echo $CPU_SYSTEM | cut -d "." -f 1`
CPU_IOWAIT_MAJOR=`echo $CPU_IOWAIT | cut -d "." -f 1`
CPU_IDLE_MAJOR=`echo $CPU_IDLE | cut -d "." -f 1`



# Return
if [ ${CPU_USER_MAJOR} -ge $USER_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_CRITICAL
    elif [ ${CPU_SYSTEM_MAJOR} -ge $SYSTEM_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_CRITICAL
    elif [ ${CPU_IOWAIT_MAJOR} -ge $IOWAIT_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_CRITICAL
    elif [ ${CPU_USER_MAJOR} -ge $USER_WARNING_THRESHOLD ] && [ ${CPU_USER_MAJOR} -lt $USER_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_WARNING
      elif [ ${CPU_SYSTEM_MAJOR} -ge $SYSTEM_WARNING_THRESHOLD ] && [ ${CPU_SYSTEM_MAJOR} -lt $SYSTEM_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_WARNING
      elif  [ ${CPU_IOWAIT_MAJOR} -ge $IOWAIT_WARNING_THRESHOLD ] && [ ${CPU_IOWAIT_MAJOR} -lt $IOWAIT_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_WARNING
else

        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_OK
fi
```

### monitor_Linux系统性能

```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh
echo -e "\033[34m \033[1m"
cat <<EOF
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++ Wellcom to use system Collect ++++++++++++++++++++++++++
EOF
#定义常量
Mysql_ROOT=root
Mysql_password=admin#123
DB_name=App1

ip_info=$(ifconfig|grep "broadcast"|tail -1|awk  '{print $2}')
cpu_info1=$(cat /proc/cpuinfo | grep 'model name'|tail -1|awk -F: '{print $2}'|sed 's/^//g'|awk '{print $1,$3,$4,$NF}')
cpu_info2=$(cat /proc/cpuinfo | grep 'physical id'|sort|uniq -c|wc -l)
serv_info=$( hostname| tail -1)
disk_info=$(fdisk -l| grep "磁盘"|awk '{print $2,$3,$4}'|sed 's/,//g')
mem_info=$( free -m|grep "Mem"|awk '{print "Total",$1,$2}')
load_info=$(uptime|awk '{print "Current load: " $(NF-2),$(NF-1),$NF}'|sed 's/\,//g')
makr_info="BeiJing_IDC"
echo -e "\033[32m -------------------------------------- \033[1m"
echo IPADDR:${ip_info}
echo HOSTNAME:${serv_info}
echo CUP_INFO:${cpu_info1} X${cpu_info2}
echo DISK_INFO:${disk_info}
echo MEM_INFO:${mem_info}"M"
echo LOAD_INFO:${load_info}
echo -e "\033[32m -------------------------------------- \033[0m"


monitor_jk () {
    mysql -u${Mysql_ROOT} -p${Mysql_password} -D $DB_name -e "
    INSERT INTO system_info VALUES ('','$ip_info' , '$serv_info', '${cpu_info1} X${cpu_info2}', '$disk_info', '$mem_info', '$load_info');
    "
}

echo -e -n "\033[36m *******You want to write the data to the databases? 【yes|y|Y】: \033[1m"; read ensure
if [ "$ensure" == "yes" -o "$ensure" == "y" -o "$ensure" == "Y" ]; then
    echo "-------------------------------------------------------------"

    mysql -uroot -padmin#123 -D App1 -e "select count(*) from system_info;" > /dev/null 2>&1
    if [ "$?" -eq 0 ]; then
        monitor_jk
    else
        echo -e "$DB_name is not exists! Create $DB_name"
        mysql -u${Mysql_ROOT} -p${Mysql_password} -D $DB_name -e "
         CREATE TABLE `system_info` (
          `id` int(10) NOT NULL AUTO_INCREMENT,
          `address` varchar(15) DEFAULT NULL COMMENT 'IP address',
          `Hostname` varchar(30) DEFAULT NULL COMMENT 'hostname',
          `CPU_info` varchar(100) DEFAULT NULL COMMENT 'cpu_info',
          `Disk_info` varchar(200) DEFAULT NULL COMMENT 'disk_info',
          `Mem_info` int(8) DEFAULT NULL COMMENT 'mem_info',
          `Load_info` varchar(80) DEFAULT NULL COMMENT 'load_info',
          PRIMARY KEY (`id`)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8;;

        "
    fi
    monitor_jk

fi

mysql -u${Mysql_ROOT} -p${Mysql_password} -D $DB_name -e "select * from system_info;"
```


### 监控服务器主要性能参数指标
```shell
#!/bin/bash
#功能描述(Description):监控服务器主要性能参数指标.
#监控项目:内核信息,主机名称,IP地址,登陆账户,内存与swap信息,磁盘信息,CPU负载.

kernel=$(uname -r)                                         #内核信息
release=$(cat /etc/redhat-release)                         #操作系统版本
hostname=$HOSTNAME                                         #主机名称
localip=$(ip a s | awk '/inet /{print $2}')                #本地IP地址列表
mem_total=$(free | awk '/Mem/{print $2}')                  #总内存容量
mem_free=$(free | awk '/Mem/{print $NF}')                  #剩余内存容量
swap_total=$(free | awk '/Swap/{print $2}')                #总swap容量
swap_free=$(free | awk '/Swap/{print $NF}')                #剩余swap容量
disk=$(df | awk '/^\/dev/{print $1,$2,$4}'|column -t)      #磁盘信息
load1=$(uptime | sed 's/,//g' | awk '{print $(NF-2)}')     #CPU最近1分钟平均负载
load5=$(uptime | sed 's/,//g' | awk '{print $(NF-1)}')     #CPU最近5分钟平均负载
load15=$(uptime | sed 's/,//g' | awk '{print $NF}')        #CPU最近15分钟平均负载
login_users=$(who | wc -l)                                 #登陆用户数量
procs=$(ps aux | wc -l)                                    #进程数量
users=$(sed -n '$=' /etc/passwd)                           #系统总账户数量
cpu_info=$(LANG=C lscpu | awk -F: '/Model name/ {print $2}')         #CPU型号
cpu_core=$(awk '/processor/{core++} END{print core}' /proc/cpuinfo)  #CPU内核数量

yum -y -q install sysstat &>/dev/null                                #安装性能监控软件
echo -e "\033[34m提取磁盘性能指标,请稍后...\033[0m"
tps=$(LANG=C sar -d -p 1 6 | awk '/Average/' | tail -n +2 | awk '{print "["$2"]磁盘平均IO数量:"$3}') &
read_write=$(LANG=C sar -d -p 1 6 | awk '/Average/' | tail -n +2 | awk '{print "["$2"]平均每秒读写扇区量:"$4,$5}') &

irq=$(vmstat 1 2 | tail -n +4 | awk '{print $11}')         #中断数量
cs=$(vmstat 1 2 | tail -n +4 | awk '{print $12}')          #上下文切换数量

top_proc_mem=$(ps --no-headers -eo comm,rss | sort -k2 -n | tail -10) #占用内存资源最多的10个进程列表
top_proc_cpu=$(ps --no-headers -eo comm,pcpu | sort -k2 -n | tail -5) #占用CPU资源最多的5个进程列表

#获取网卡流量,接收|发送的数据流量,单位为字节bytes).
net_monitor=$(cat /proc/net/dev | tail -n +3 | \
              awk 'BEGIN{ print "网卡名称 入站数据流量(bytes) 出站数据流量(bytes)" } \
                   { print $1,$2,$10 }' | column -t)

#输出数据信息.
echo -e "\033[32m--------------本机主要数据参数表-----------------\033[0m"
echo -e "本机IP地址列表:\033[32m$localip\033[0m"
echo -e "本机主机名称:\033[32m$hostname\033[0m"
echo -e "操作系统版本:\033[32m$release\033[0m,内核版本:\033[32m$kernel\033[0m"
echo -e "CPU型号为:\033[32m$cpu_info\033[0m,CPU内核数量:\033[32m$cpu_core\033[0m"
echo -e "本机总内存容量:\033[32m$mem_total\033[0m,剩余可用内存容量:\033[32m$mem_free\033[0m"
echo -e "本机swap总容量:\033[32m$swap_total\033[0m,剩余容量:\033[32m$swap_free\033[0m"
echo -e "CPU最近1分钟,5分钟,15分钟的平均负载分别为:\033[32m$load1 $load5 $load15\033[0m"
echo -e "本机总账户数量为:\033[32m$users\033[0m,当前登陆系统的账户数量:\033[32m$login_users\033[0m"
echo -e "当前系统中启动的进程数量:\033[32m$procs\033[0m"
echo -e "占用CPU资源最多的5个进程列表为:"
echo -e "\033[32m$top_proc_cpu\033[0m"
echo -e "占用内存资源最多的10个进程列表为:"
echo -e "\033[32m$top_proc_mem\033[0m"
echo -e "CPU中断数量:\033[32m$irq\033[0m,CPU上下文切换数量:\033[32m$cs\033[0m"
echo -e "每个磁盘分区的总容量与剩余容量信息如下:"
echo -e "$disk"
echo -e "$tps"
echo -e "$read_write"
echo -e "$net_monitor"
echo -e "\033[32m------------------The End------------------------\033[0m"
```




## 生产环境下运维开发类脚本

### 系统初始化脚本Centos6

系统初始化脚本用于新装Linux的相关配置工作，

比如禁掉iptables和SELinux及IPv6、优化系统内核、停掉一些没必要启动的系统服务等。

我们将系统初始化脚本应用于公司内部的运维开发机器的批量部署（比如用Ansible来下发）上。事实上，复杂的系统业务初始化initial脚本由于涉及了多条产品线和多个业务平台，因此远比这里列出的开发环境下的初始化脚本复杂得多，而且其代码量也极大，基本上都是6000～7000行的Shell脚本，各功能模块以函数的形式进行封装。下面的脚本只是涉及一些基础部分，希望大家注意这点。

脚本代码如下所示（此脚本已在CentOS 6.8 x86_x64下测试通过）：


```shell
#!/bin/bash

#添加epel外部yum扩展源
cd /usr/local/src
wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
rpm -ivh epel-release-6-8.noarch.rpm

#安装gcc基础库文件以及sysstat工具
yum -y install gcc gcc-c++ vim-enhanced unzip unrar sysstat

#配置ntpdate自动对时
yum -y install ntp
echo "01 01 * * * /usr/sbin/ntpdate ntp.api.bz    >> /dev/null 2>&1" >> /etc/crontab
ntpdate ntp.api.bz
service crond restart

#配置文件的ulimit值
ulimit -SHn 65535
echo "ulimit -SHn 65535" >> /etc/rc.local
cat >> /etc/security/limits.conf << EOF
*                     soft     nofile             65535
*                     hard     nofile             65535
EOF

#基础系统内核优化
cat >> /etc/sysctl.conf << EOF
fs.file-max=419430
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 1
net.ipv4.tcp_keepalive_time = 1200
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.tcp_max_tw_buckets = 36000
net.ipv4.route.gc_timeout = 100
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_synack_retries = 1
net.core.somaxconn = 16384
net.core.netdev_max_backlog = 16384
net.ipv4.tcp_max_orphans = 16384
EOF
/sbin/sysctl -p

#禁用control-alt-delete组合键以防止误操作
sed -i 's@ca::ctrlaltdel:/sbin/shutdown -t3 -r now@#ca::ctrlaltdel:/sbin/shutdown -t3 -r now@' /etc/inittab

#关闭SELinux
sed -i 's@SELINUX=enforcing@SELINUX=disabled@' /etc/selinux/config

#关闭iptables
service iptables stop
chkconfig iptables off

#ssh服务配置优化,请至少保持机器中至少有一个具有sudo权限的用户，下面的配置会禁止root远程登录
sed -i 's@#PermitRootLogin yes@PermitRootLogin no@' /etc/ssh/sshd_config #禁止root远程登录
sed -i 's@#PermitEmptyPasswords no@PermitEmptyPasswords no@' /etc/ssh/sshd_config #禁止空密码登录
sed -i 's@#UseDNS yes@UseDNS no@' /etc/ssh/sshd_config /etc/ssh/sshd_config
service sshd restart

#禁用IPv6地址
echo "alias net-pf-10 off" >> /etc/modprobe.d/dist.conf
echo "alias ipv6 off" >> /etc/modprobe.d/dist.conf
chkconfig ip6tables off

#vim基础语法优化
echo "syntax on" >> /root/.vimrc
echo "set nohlsearch" >> /root/.vimrc

#精简开机自启动服务，安装最小化服务的机器初始可以只保留crond，network，rsyslog，sshd这四个服务。
for i in `chkconfig --list|grep 3:on|awk '{print $1}'`;do chkconfig --level 3 $i off;done
for CURSRV  in crond rsyslog sshd network;do chkconfig --level 3 $CURSRV on;done

#重启服务器
reboot
```



### 系统初始化脚本Centos7


```shell
#!/bin/bash
#author shunxin by
#this script is only for CentOS 7.x
#check the OS
platform=`uname -i`
if [ $platform != "x86_64" ];then
echo "this script is only for 64bit Operating System !"
exit 1
fi
echo "the platform is ok"
cat << EOF
+---------------------------------------+
|   your system is CentOS 7 x86_64      |
|      start optimizing.......          |
+---------------------------------------
EOF
#Yum源更换为国内阿里源
yum install wget -y
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
#添加阿里的epel源
#add the epel
wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
#yum重新建立缓存
yum clean all
yum makecache
#同步时间
yum -y install ntp
/usr/sbin/ntpdate ntp1.aliyun.com
echo "* 3 * * * /usr/sbin/ntpdate ntp1.aliyun.com > /dev/null 2>&1" >> /var/spool/cron/root
systemctl  restart crond.service
#设置主机名
hostnamectl   set-hostname qiuyuetao
#设置字符集
#设置最大打开文件描述符数
echo "ulimit -SHn 102400" >> /etc/rc.local
cat >> /etc/security/limits.conf << EOF
*           soft   nofile       655350
*           hard   nofile       655350
EOF
#禁用selinux
sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
setenforce 0
#关闭防火墙
systemctl disable firewalld.service
systemctl stop firewalld.service
#set ssh
sed -i 's/^GSSAPIAuthentication yes$/GSSAPIAuthentication no/' /etc/ssh/sshd_config
sed -i 's/#UseDNS yes/UseDNS no/' /etc/ssh/sshd_config
systemctl  restart sshd.service
#内核参数优化
cat >> /etc/sysctl.conf << EOF
#CTCDN系统优化参数
#关闭ipv6
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
#决定检查过期多久邻居条目
net.ipv4.neigh.default.gc_stale_time=120
#使用arp_announce / arp_ignore解决ARP映射问题
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.all.arp_announce=2
net.ipv4.conf.lo.arp_announce=2
# 避免放大攻击
net.ipv4.icmp_echo_ignore_broadcasts = 1
# 开启恶意icmp错误消息保护
net.ipv4.icmp_ignore_bogus_error_responses = 1
#开启路由转发
net.ipv4.ip_forward = 1
net.ipv4.conf.all.send_redirects = 1
net.ipv4.conf.default.send_redirects = 1
#开启反向路径过滤
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1
#处理无源路由的包
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0
#关闭sysrq功能
kernel.sysrq = 0
#core文件名中添加pid作为扩展名
kernel.core_uses_pid = 1
# 开启SYN洪水攻击保护
net.ipv4.tcp_syncookies = 1
#修改消息队列长度
kernel.msgmnb = 65536
kernel.msgmax = 65536
#设置最大内存共享段大小bytes
kernel.shmmax = 68719476736
kernel.shmall = 4294967296
#timewait的数量，默认180000
net.ipv4.tcp_max_tw_buckets = 6000
net.ipv4.tcp_sack = 1
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_rmem = 4096        87380   4194304
net.ipv4.tcp_wmem = 4096        16384   4194304
net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目
net.core.netdev_max_backlog = 262144
#限制仅仅是为了防止简单的DoS 攻击
net.ipv4.tcp_max_orphans = 3276800
#未收到客户端确认信息的连接请求的最大值
net.ipv4.tcp_max_syn_backlog = 262144
net.ipv4.tcp_timestamps = 0
#内核放弃建立连接之前发送SYNACK 包的数量
net.ipv4.tcp_synack_retries = 1
#内核放弃建立连接之前发送SYN 包的数量
net.ipv4.tcp_syn_retries = 1
#启用timewait 快速回收
net.ipv4.tcp_tw_recycle = 0
#开启重用。允许将TIME-WAIT sockets 重新用于新的TCP 连接
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_mem = 94500000 915000000 927000000
net.ipv4.tcp_fin_timeout = 1
#当keepalive 起用的时候，TCP 发送keepalive 消息的频度。缺省是2 小时
net.ipv4.tcp_keepalive_time = 1800
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.tcp_keepalive_intvl = 15
#允许系统打开的端口范围
net.ipv4.ip_local_port_range = 1024    65000
#修改防火墙表大小，默认65536
net.netfilter.nf_conntrack_max=655350
net.netfilter.nf_conntrack_tcp_timeout_established=1200
# 确保无人能修改路由表
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.secure_redirects = 0
EOF
/sbin/sysctl -p
#vim定义退格键可删除最后一个字符类型
echo 'alias vi=vim' >> /etc/profile
echo 'stty erase ^H' >> /etc/profile
echo 'curl ip.6655.com/ip.aspx&&echo' >> /etc/profile
cat >> /root/.vimrc << EOF
set tabstop=4
set shiftwidth=4
set expandtab
syntax on
"set number
EOF
#update soft
yum -y update
cat << EOF
+-------------------------------------------------+
|                优 化 已 完 成             |
|             5s 后 重启 这台服务器 !       |
+-------------------------------------------------+
EOF
sleep 5
echo -e "\n\033[31m请重启机器 使内核修改生效！！！\033[0m\n"  ##重启加载内核修改
```

### 控制shell多进程数量的脚本

下面的run.py是爬虫程序，经测试，在机器上运行8个run.py进程是机器性能最好的时候，该进程数量既能充分发挥机器的性能又不会导致机器响度速度过慢。

而且有时为了避免并发进程数过多导致机器卡死，**需要限制并发的数量**。下面的脚本可以实现这个需求，其代码如下所示：



```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:${NAME}.sh
# author：xiaojian

CE_HOME="/data/ContentEnginne"
LOG_PATH="/data/logs"

# 控制爬虫数量为8
MAX_SPIDER_COUNT=8

count=`ps -ef|grep -v grep|grep run.py|wc -l`
try_time=0

cd $CE_HOME

# 限制并发的数量
while [ $count -lt $MAX_SPIDER_COUNT -a $try_time -lt $MAX_SPIDER_COUNT ]; do
    let try_time +=1
    python run.py >> ${LOG_PATH}/spider.log 2>&1 &
    count=`ps -ef|grep -v grep|grep run.py|wc -l`
done
```


### 手动建立软Raid级别需求

```shell
#!/bin/bash
function rg_mkfs_interac() {
    read -p "请输入您要做的RAID级别，可选择项为0|1|5|10:" raid
    read -p "请输入哪些磁盘需要并进RAID，磁盘之间请用空格格开，例如sdb sdc等" mydev
    echo $raid
    echo $mydev
    # create md0
        rg_info "Create RAID..."
        mdadm -Ss
        yes | mdadm -C /dev/md0 --level=$raid --auto=yes $mydev >/dev/null
        mdadm -D /dev/md0 >/dev/null || rg_info 58 "Create RAID /dev/md0 failed."
            # public
            partprobe /dev/$DISK_SYS 2>/dev/null
            sleep 3
            # mkfs
            for i in {${DISK_SYS}4,md0}; do
                echo -n "$MKFS /dev/$i... "
                if $MKFS /dev/$i &>/dev/null; then
                echo OK
                else
                echo failed && rg_info 55 "mkfs $i failed"
                fi
            done
            rg_info "Create cache direcotry..." && mkdir -p /cache/{cache,logs}
            echo -e "/dev/${DISK_SYS}4 \t\t/cache/logs \t\t$FS \tdefaults \t0 0" >>/etc/fstab
            echo -e "/dev/md0 \t\t/cache/cache \t\t$FS \t$MOUNT_OPTS \t0 0" >>/etc/fstab
        echo "--"
#save mdadm.conf
        if (mdadm -Ds 2>/dev/null |grep -q .); then
            [ -f /etc/mdadm.conf ] && rg_info "Backup old mdadm.conf..." && /bin/cp /etc/mdadm.conf /etc/mdadm.conf.bak
            rg_info "Save RAID configration (mdadm.conf)..."
                if [ "$VER6" == 'yes' ]; then
                    mdadm -Ds |sed 's!/dev/md[^ ]*:\([0-9]\)!/dev/md\1!; s!metadata[^ ]* !!; s/$/ auto=yes/' >/etc/mdadm.conf
                else
                    mdadm -Ds |sed 's/$/ auto=yes/' >/etc/mdadm.conf
                fi
        fi
#mount all
        fgrep -q /cache /etc/fstab || rg_info 48 "Internal error: f_mkfs has BUG!"
        rg_info "挂载所有分区..."
        if mount -a; then
            rg_info "创建mkpart锁..."
            echo "$VERSION" >$MKFS_LOCK 2>/dev/null && chattr +i $MKFS_LOCK
            ret=0
        else
            rg_info 49 "mount -a 出错"
        fi
        return $ret
}
```


### 在脚本中修改crontab

```shell
(crontab -l 2>/dev/null; echo '*/2 * * * * bash /usr/local/src/kestrel.openfiles.check > /usr/local/src/logs/kestrel_openfiles.check.$(date "+\%Y\%m\%d-\%H\%M\%S").details 2>&1') | crontab -
```


### 字符串处理完整脚本


```shell
#!/bin/bash

string="Bigdata process framework is Hadoop,Hadoop is an open source project"

function print_tips
{
    echo "******************************"
    echo "(1)打印string长度"
    echo "(2)删除字符串中所有的Hadoop"
    echo "(3)替换第一个Hadoop为Mapreduce"
    echo "(4)替换全部Hadoop为Mapreduce"
    echo "*******************************"
}

function len_of_string
{
    echo "${#string}"
}

function del_hadoop
{
    echo "${string//Hadoop/}"
}

function rep_hadoop_mapreduce_first
{
    echo "${string/Hadoop/Mapreduce}"
}

function rep_hadoop_mapreduce_all
{
        echo "${string//Hadoop/Mapreduce}"
}

while true
do
    echo "[string=$string]"
    echo
    print_tips
    read -p "Pls input your choice(1|2|3|4|q|Q): " choice

    case $choice in
        1)
            len_of_string
            ;;
        2)
            del_hadoop
            ;;
        3)
            rep_hadoop_mapreduce_first
            ;;
        4)
            rep_hadoop_mapreduce_all
            ;;
        q|Q)
            exit
            ;;
        *)
            echo "Error,input only in {1|2|3|4|q|Q|}"
            ;;
    esac
done
```

### 设置锁文件防止脚本重复执行

```shell
#!/bin/bash
#功能描述(Description):通过设置锁文件防止脚本重复执行.

#使用Ctrl+C中断脚本时,删除锁文件.
trap 'rm -rf /tmp/lockfile;exit' HUP INT

#检查是否存在锁文件,没有锁文件就执行backup备份函数,如果有锁文件脚本则脚本直接退出.
lock_check(){
    if (set -C; :> /tmp/lockfile) 2>/dev/null ;then
        backup
    else
        echo -e "\033[91mWarning:其他用户在执行该脚本.\033[0m"
        exit 66
    fi
}

#执行备份前创建所文件,然后执行备份数据库的操作,备份完成后删除锁文件.
#sleep 10实验测试时使用,为了防止小数据库备份太快,无法验证重复执行脚本的效果.
backup(){
    touch /tmp/lockfile
    mysqldump --all-database > /var/log/mysql-$(date +%Y%m%d).bak
    sleep 10
    rm -rf /tmp/lockfile
}

lock_check
backup
```


### 修改sshd配置文件

```shell
#!/bin/bash
#功能描述(Description):修改SSHD配置文件,提升SSH安全性.

config_file="/etc/ssh/sshd_config"
PORT=12345

#将默认端口号修改为自定义端口号.
if grep -q "^Port" $config_file;then
    sed -i "/^Port/c Port $PORT" $config_file
else
    echo "Port $PORT" >> $config_file
fi

#禁止root远程登陆SSH服务器.
if grep -q "^PermitRootLogin" $config_file;then
    sed -i '/^PermitRootLogin/s/yes/no/' $config_file
else
    sed -i '$a PermitRootLogin no' $config_file
fi

#禁止使用密码远程登陆SSH服务器.
if grep -q "^PasswordAuthentication" $config_file;then
    sed -i '/^PasswordAuthentication/s/yes/no/' $config_file
else
    sed -i '$a PasswordAuthentication no' $config_file
fi

#禁止X11图形转发功能.
if grep -q "^X11Forwarding" $config_file;then
    sed -i '/^X11Forwarding/s/yes/no/' $config_file
else
    sed -i '$a X11Forwarding no' $config_file
fi

#禁止DNS查询.
if grep -q "^UseDNS" $config_file;then
    sed -i '/^UseDNS/s/yes/no/' $config_file
else
    sed -i '$a UseDNS no' $config_file
fi
```


### 多种test的写法


```shell
#!/usr/bin/env bash
FreeMem=`free -m|awk 'NR==3 {print $NF}'`
if (( $FreeMem < 1000 )); then
    echo "xxxxxxxxxx"
fi

if [[ $FreeMem -lt 1000 ]]; then
    echo "xxxxxxxx"
fi

if test $FreeMem -lt 1000; then
    echo "xxxxxxxxxxxx"
fi

if grep  /etc/passwd >/dev/null 2>&1; then
    echo "xxxxxxxxxx"
fi
```


### color输出

```shell
#!/usr/bin/env bash
#方法1
color_printf1(){
    if [[ $1 == "red" ]]; then
        echo -e "\033[32;40m$2\033[0m"
    elif [[ $1 == "green" ]];then
        echo -e "\033[31;40m$2\033[0m"
    fi
}

#方法2
color_printf2(){
    case "$1" in
    "red")
       echo -e "\033[32;40m$2\033[0m"
       ;;
    "green")
       echo -e "\033[31;40m$2\033[0m"
       ;;
    *)
       echo -e "Example: color_printf2 red xxxxxx"
       ;;
    esac

}

# 方法3
function echo_r (){
    # Color red: Error, Failed
    [ $# -ne 1 ] && return 1
    echo -e "\033[31m$1\033[0m"
}

function echo_g (){
    # Color green: Success
    [ $# -ne 1 ] && return 1
    echo -e "\033[32m$1\033[0m"
}
```



## 一些常用的函数 

```shell
#判断是否是false
is_false() {
    case "$1" in
    [fF] | [nN] | [nN][oO] | [fF][aA][lL][sS][eE] | 0)
        return 0
        ;;
    esac
    return 1
}

#判断进程是否运行
is_running()
{
    if [ -f $1 ]; then
        read pid < $1
        if [ -d "/proc/$pid" ]; then
            return 0
        fi
    fi
    return -1
}

#安装epel源
function _install_epel {
    # NOTE: We always remove and install latest -- some environments
    # use snapshot images, and if EPEL version updates they break
    # unless we update them to latest version.
    if sudo yum repolist enabled epel | grep -q 'epel'; then
        uninstall_package epel-release || true
    fi

    # This trick installs the latest epel-release from a bootstrap
    # repo, then removes itself (as epel-release installed the
    # "real" repo).
    #
    # You would think that rather than this, you could use
    # $releasever directly in .repo file we create below.  However
    # RHEL gives a $releasever of "6Server" which breaks the path;
    # see https://bugzilla.redhat.com/show_bug.cgi?id=1150759
    cat <<EOF | sudo tee /etc/yum.repos.d/epel-bootstrap.repo
[epel-bootstrap]
name=Bootstrap EPEL
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=epel-7&arch=\$basearch
failovermethod=priority
enabled=0
gpgcheck=0
EOF
    # Enable a bootstrap repo.  It is removed after finishing
    # the epel-release installation.
    is_package_installed yum-utils || install_package yum-utils
    sudo yum-config-manager --enable epel-bootstrap
    yum_install epel-release || \
        die $LINENO "Error installing EPEL repo, cannot continue"
    sudo rm -f /etc/yum.repos.d/epel-bootstrap.repo
}

#记录日志的function
function fnLogInfo()
{
        local infomsg=$1
        echo ${infomsg}
        echo `date "${data_format}"` "Info:${infomsg}" >> ${log_file}
}


#备份文件的function
fnBackupBeforeModify()
{
        local file=$1
        local backupFile="${file}.bak"

        fnLogInfo "Start to backup file $file"

        cp ${file} -p ${backupFile}

        fnLogInfo "End to backup file $file"
}

# 1. change the network config as DHCP
# 2. delete the 70-persistent-net.rules file
fnModifyNetworkConfig()
{
        fnLogInfo "----------------------------------------"
        fnLogInfo "Start to modify the network configuration"

        local files=''

        #1. change the network config as DHCP
        case $os_type in

        #/etc/sysconfig/network-scripts
        "redhat")
        files="`ls /etc/sysconfig/network-scripts/ifcfg-eth* |grep -v .bak`"
        files="${files} `ls /etc/sysconfig/network-scripts/ifcfg-ens* |grep -v .bak`"
        for file in $files
        do
            fnLogInfo "Start to modify the network configuration: $file"
            #backup  the file
            fnBackupBeforeModify $file
            #modify the file
            sed -i '/PERSISTENT_DHCLIENT/d' $file
            sed -i '$a\PERSISTENT_DHCLIENT=yes' $file
            fnLogInfo "End to modify the network configuration: $file"
        done
        ;;

        #/etc/sysconfig/network/dhcp
        "suse")
        file='/etc/sysconfig/network/dhcp'

        #first backup file
        fnBackupBeforeModify $file

        sed -i "s/DHCLIENT_USE_LAST_LEASE=yes\|DHCLIENT_USE_LAST_LEASE='yes'\|DHCLIENT_USE_LAST_LEASE=\"yes\"/DHCLIENT_USE_LAST_LEASE=\"no\"/g" $file
        ;;

        #/etc/network/interfaces
        "debian" | "ubuntu")
        file='/etc/network/interfaces'

        #backup the file
        fnBackupBeforeModify $file

        sed -i "s/static\| manual/ dhcp/g" $file
        sed -i "s/address /#address /g" $file
        sed -i "s/netmask /#netmask /g" $file
        sed -i "s/gateway /#gateway /g" $file

        ;;

        *)
        fnLogInfo "Other Linux, network configuration cannot be modified."
        ;;
        esac

        #2. delete the 70-persistent-net.rules file
        rm -rf /etc/udev/rules.d/70-persistent-net.rules

        fnLogInfo "Delete 70-persistent-net.rules file, resut: $?"

        fnLogInfo "End to modify the network configuration"
}
#check OS的function
fnGetOSType()
{
        fnLogInfo "---------------------------"
        fnLogInfo "Start to get the os type"

        local version="/proc/version"
        if ! [ -e "${version}" ];then
            return 1
        elif [ -n "$(grep -i 'suse' ${version})" ];then
            os_type='suse'
        elif [ -n "$(grep -i 'ubuntu' ${version})" ];then
            os_type='ubuntu'
        elif [ -n "$(grep -i 'Red Hat' ${version})" ];then
            os_type='redhat'
                elif [ -n "$(grep -i 'debian' ${version})" ];then
            os_type='debian'
        fi


        fnLogInfo "End to get the os type: $os_type"
}

#输入选择Yes和No函数
YES_NO_choice(){
read -t 10 -p "Please input you commit ,wait 5.....to exit: " input

case $input in
    [yY]|[yY][eE][sS] )
        echo "YES!!!!!"
        ;;
    [nN]|[nN][oO] )
        echo "NO  Error!!!!!"
        ;;
        *)
        echo "============================"
        ;;

esac

#错误提示函数
die () {
    echo "ERROR: $1. Aborting!"
    exit 1
}

#判断用户输入如果没有输入，选择默认值 redis为例
_REDIS_PORT=6379
_MANUAL_EXECUTION=false     #标志信息
check_input_redis_port(){
if ! echo $REDIS_PORT | egrep -q '^[0-9]+$' ; then
    _MANUAL_EXECUTION=true      #重置标志信息
    #Read the redis port
    read  -p "Please select the redis port for this instance: [$_REDIS_PORT] " REDIS_PORT
    if ! echo $REDIS_PORT | egrep -q '^[0-9]+$' ; then
        echo "Selecting default: $_REDIS_PORT"
        REDIS_PORT=$_REDIS_PORT
    fi
fi
}


Get_OS_Bit()
{
    if [[ `getconf WORD_BIT` = '32' && `getconf LONG_BIT` = '64' ]] ; then
        Is_64bit='y'
    else
        Is_64bit='n'
    fi
}


Download_Files()
{
    local URL=$1
    local FileName=$2
    if [ -s "${FileName}" ]; then
        echo "${FileName} [found]"
    else
        echo "Notice: ${FileName} not found!!!download now..."
        wget -c --progress=bar:force --prefer-family=IPv4 --no-check-certificate ${URL}
    fi
}

#批量安装基础包
CentOS_Dependent()
{
    \cp /etc/yum.conf /etc/yum.conf.lnmp
    sed -i 's:exclude=.*:exclude=:g' /etc/yum.conf

    Echo_Blue "[+] Yum installing dependent packages..."
    for packages in make cmake gcc gcc-c++ gcc-g77 flex bison file libtool libtool-libs autoconf kernel-devel patch wget crontabs libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel libxml2 libxml2-devel zlib zlib-devel glib2 glib2-devel unzip tar bzip2 bzip2-devel libevent libevent-devel ncurses ncurses-devel curl curl-devel libcurl libcurl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel vim-minimal gettext gettext-devel ncurses-devel gmp-devel pspell-devel unzip libcap diffutils ca-certificates net-tools libc-client-devel psmisc libXpm-devel git-core c-ares-devel libicu-devel libxslt libxslt-devel xz;
    do yum -y install $packages; done

    mv -f /etc/yum.conf.lnmp /etc/yum.conf
}


#设置cron计划任务
Crontab_func(){
#!/bin/bash
cat  <<EOF > /var/spool/cron/root
*/30 * * * * sh /home/cheungssh/mysite/mysite/cheungssh/cheungssh_demo.sh 2>>/home/cheungssh/logs/demo.log  >> /home/cheungssh/logs/demo.log
EOF
}



#判断进程信息，杀掉进程
kill_Process(){
ps -fel|grep websocket_server_cheung.py|grep  -v "$$"|awk  '{print  $4}'|xargs -i kill  -9 {}
}

#获取MD5值
MD5_value(){
md5sum /etc/hosts |awk '{print $1}'

}

data_format="+%Y-%m-%d %H:%M:%S"

#记录日志的function
function fnLogInfo()
{
        local infomsg=$1
        echo ${infomsg}
        echo `date "${data_format}"` "Info:${infomsg}" >> ${log_file}
}


#scritps path
dir_path(){
pwd=`dirname $0`
}
```



## Linux下function函数库参考



- 在cenntos7 中 `/etc/init.d/functions` 是系统自带的函数库。


- 在 Ubuntu 20.04 中，类似于 `/etc/init.d/functions` 的系统自带的函数库 functions.sh 可以在 `/lib/lsb/init-functions`路径下找到。



```shell
#!/usr/bin/env bash
# -*-Shell-script-*-
#
# functions This file contains functions to be used by most or all
#       shell scripts in the /etc/init.d directory.
#

:<<EOF

checkpid():检查是否已存在pid，如果有一个存在，返回0（通过查看/proc目录）

daemon:启动某个服务。/etc/init.d目录部分脚本的start使用到这个

killproc():杀死某个进程。/etc/init.d目录部分脚本的stop使用到这个

pidfileofproc():寻找某个进程的pid

pidofproc():类似上面的，只是还查找了pidof命令

status():返回一个服务的状态

echo_success():打印OK

echo_failure():打印FAILED

echo_passed():打印PASSED

echo_warning():打印WARNING

success():打印OK并记录日志

failure():打印FAILED并记录日志

passed():打印PASSED并记录日志

action():打印某个信息并执行给定的命令，它会根据命令执行的结果来调用 success,failure方法

strstr():判断$1是否含有$2

confirm:显示 “Start service $1 (Y)es/(N)o/(C)ontinue? [Y]“的提示信息，并返回选择结果

is_ignored_file():检查$1文件是否是*.bak、*.orig、*.rpmnew....等文件

is_true()/is_false():交互式yes|no的选项

apply_sysctl()应用sysctl设置，包括/etc/sysctl.d中的文件

EOF


TEXTDOMAIN=initscripts

# Make sure umask is sane
umask 022

# Set up a default search path.
PATH="/sbin:/usr/sbin:/bin:/usr/bin"

#导出环境变量
export PATH


#判断PPID和字符串否为空
if [ $PPID -ne 1 -a -z "$SYSTEMCTL_SKIP_REDIRECT" ] && \
        [ -d /run/systemd/system ] ; then
    case "$0" in
    /etc/init.d/*|/etc/rc.d/init.d/*)
        _use_systemctl=1
        ;;
    esac
fi

systemctl_redirect () {
    local s
    local prog=${1##*/}
    local command=$2
    local options=""

    case "$command" in
    start)
        s=$"Starting $prog (via systemctl): "
        ;;
    stop)
        s=$"Stopping $prog (via systemctl): "
        ;;
    reload|try-reload)
        s=$"Reloading $prog configuration (via systemctl): "
        ;;
    restart|try-restart|condrestart)
        s=$"Restarting $prog (via systemctl): "
        ;;
    esac

    if [ -n "$SYSTEMCTL_IGNORE_DEPENDENCIES" ] ; then
        options="--ignore-dependencies"
    fi

    if ! systemctl show "$prog.service" > /dev/null 2>&1 || \
            systemctl show -p LoadState "$prog.service" | grep -q 'not-found' ; then
        action $"Reloading systemd: " /bin/systemctl daemon-reload
    fi

    action "$s" /bin/systemctl $options $command "$prog.service"
}

# Get a sane screen width
[ -z "${COLUMNS:-}" ] && COLUMNS=80

if [ -z "${CONSOLETYPE:-}" ]; then
    if [ -c "/dev/stderr" -a -r "/dev/stderr" ]; then
        CONSOLETYPE="$(/sbin/consoletype < /dev/stderr 2>/dev/null)"
    else
        CONSOLETYPE="serial"
    fi
fi

if [ -z "${NOLOCALE:-}" ] && [ -z "${LANGSH_SOURCED:-}" ] && \
        [ -f /etc/sysconfig/i18n -o -f /etc/locale.conf ] ; then
    . /etc/profile.d/lang.sh 2>/dev/null
    # avoid propagating LANGSH_SOURCED any further
    unset LANGSH_SOURCED
fi

# Read in our configuration
if [ -z "${BOOTUP:-}" ]; then
    if [ -f /etc/sysconfig/init ]; then
        . /etc/sysconfig/init
    else
        # This all seem confusing? Look in /etc/sysconfig/init,
        # or in /usr/share/doc/initscripts-*/sysconfig.txt
        BOOTUP=color
        RES_COL=60
        MOVE_TO_COL="echo -en \\033[${RES_COL}G"
        SETCOLOR_SUCCESS="echo -en \\033[1;32m"
        SETCOLOR_FAILURE="echo -en \\033[1;31m"
        SETCOLOR_WARNING="echo -en \\033[1;33m"
        SETCOLOR_NORMAL="echo -en \\033[0;39m"
        LOGLEVEL=1
    fi
    if [ "$CONSOLETYPE" = "serial" ]; then
        BOOTUP=serial
        MOVE_TO_COL=
        SETCOLOR_SUCCESS=
        SETCOLOR_FAILURE=
        SETCOLOR_WARNING=
        SETCOLOR_NORMAL=
    fi
fi

# Check if any of $pid (could be plural) are running
checkpid() {
    local i

    for i in $* ; do
        [ -d "/proc/$i" ] && return 0
    done
    return 1
}

__kill_pids_term_kill_checkpids() {
    local base_stime=$1
    shift 1
    local pid=
    local pids=$*
    local remaining=
    local stat=
    local stime=

    for pid in $pids ; do
        [ ! -e  "/proc/$pid" ] && continue
        read -r line < "/proc/$pid/stat" 2> /dev/null

        stat=($line)
        stime=${stat[21]}

        [ -n "$stime" ] && [ "$base_stime" -lt "$stime" ] && continue
        remaining+="$pid "
    done

    echo "$remaining"
    [ -n "$remaining" ] && return 1

    return 0
}

__kill_pids_term_kill() {
    local try=0
    local delay=3;
    local pid=
    local stat=($(< /proc/self/stat))
    local base_stime=${stat[21]}

    if [ "$1" = "-d" ]; then
        delay=$2
        shift 2
    fi

    local kill_list=$*

    kill_list=$(__kill_pids_term_kill_checkpids $base_stime $kill_list)

    [ -z "$kill_list" ] && return 0

    kill -TERM $kill_list >/dev/null 2>&1
    usleep 100000

    kill_list=$(__kill_pids_term_kill_checkpids $base_stime $kill_list)
    if [ -n "$kill_list" ] ; then
        while [ $try -lt $delay ] ; do
            sleep 1
            kill_list=$(__kill_pids_term_kill_checkpids $base_stime $kill_list)
            [ -z "$kill_list" ] && break
            let try+=1
        done
        if [ -n "$kill_list" ] ; then
            kill -KILL $kill_list >/dev/null 2>&1
            usleep 100000
            kill_list=$(__kill_pids_term_kill_checkpids $base_stime $kill_list)
        fi
    fi

    [ -n "$kill_list" ] && return 1
    return 0
}

# __proc_pids {program} [pidfile]
# Set $pid to pids from /var/run* for {program}.  $pid should be declared
# local in the caller.
# Returns LSB exit code for the 'status' action.
__pids_var_run() {
    local base=${1##*/}
    local pid_file=${2:-/var/run/$base.pid}
    local pid_dir=$(/usr/bin/dirname $pid_file > /dev/null)
    local binary=$3

    [ -d "$pid_dir" -a ! -r "$pid_dir" ] && return 4

    pid=
    if [ -f "$pid_file" ] ; then
            local line p

        [ ! -r "$pid_file" ] && return 4 # "user had insufficient privilege"
        while : ; do
            read line
            [ -z "$line" ] && break
            for p in $line ; do
                if [ -z "${p//[0-9]/}" ] && [ -d "/proc/$p" ] ; then
                    if [ -n "$binary" ] ; then
                        local b=$(readlink /proc/$p/exe | sed -e 's/\s*(deleted)$//')
                        [ "$b" != "$binary" ] && continue
                    fi
                    pid="$pid $p"
                fi
            done
        done < "$pid_file"

            if [ -n "$pid" ]; then
                    return 0
            fi
        return 1 # "Program is dead and /var/run pid file exists"
    fi
    return 3 # "Program is not running"
}

# Output PIDs of matching processes, found using pidof
__pids_pidof() {
    pidof -c -m -o $$ -o $PPID -o %PPID -x "$1" || \
        pidof -c -m -o $$ -o $PPID -o %PPID -x "${1##*/}"
}


# A function to start a program.
daemon() {
    # Test syntax.
    local gotbase= force= nicelevel corelimit
    local pid base= user= nice= bg= pid_file=
    local cgroup=
    nicelevel=0
    while [ "$1" != "${1##[-+]}" ]; do
        case $1 in
        '')
            echo $"$0: Usage: daemon [+/-nicelevel] {program}" "[arg1]..."
            return 1
            ;;
        --check)
            base=$2
            gotbase="yes"
            shift 2
            ;;
        --check=?*)
            base=${1#--check=}
            gotbase="yes"
            shift
            ;;
        --user)
            user=$2
            shift 2
            ;;
        --user=?*)
            user=${1#--user=}
            shift
            ;;
        --pidfile)
            pid_file=$2
            shift 2
            ;;
        --pidfile=?*)
            pid_file=${1#--pidfile=}
            shift
            ;;
        --force)
            force="force"
            shift
            ;;
        [-+][0-9]*)
            nice="nice -n $1"
            shift
            ;;
        *)
            echo $"$0: Usage: daemon [+/-nicelevel] {program}" "[arg1]..."
            return 1
            ;;
      esac
    done

    # Save basename.
    [ -z "$gotbase" ] && base=${1##*/}

    # See if it's already running. Look *only* at the pid file.
    __pids_var_run "$base" "$pid_file"

    [ -n "$pid" -a -z "$force" ] && return

    # make sure it doesn't core dump anywhere unless requested
    corelimit="ulimit -S -c ${DAEMON_COREFILE_LIMIT:-0}"

    # if they set NICELEVEL in /etc/sysconfig/foo, honor it
    [ -n "${NICELEVEL:-}" ] && nice="nice -n $NICELEVEL"

    # if they set CGROUP_DAEMON in /etc/sysconfig/foo, honor it
    if [ -n "${CGROUP_DAEMON}" ]; then
        if [ ! -x /bin/cgexec ]; then
            echo -n "Cgroups not installed"; warning
            echo
        else
            cgroup="/bin/cgexec";
            for i in $CGROUP_DAEMON; do
                cgroup="$cgroup -g $i";
            done
        fi
    fi

    # Echo daemon
    [ "${BOOTUP:-}" = "verbose" -a -z "${LSB:-}" ] && echo -n " $base"

    # And start it up.
    if [ -z "$user" ]; then
       $cgroup $nice /bin/bash -c "$corelimit >/dev/null 2>&1 ; $*"
    else
       $cgroup $nice runuser -s /bin/bash $user -c "$corelimit >/dev/null 2>&1 ; $*"
    fi

    [ "$?" -eq 0 ] && success $"$base startup" || failure $"$base startup"
}

# A function to stop a program.
killproc() {
    local RC killlevel= base pid pid_file= delay try binary=

    RC=0; delay=3; try=0
    # Test syntax.
    if [ "$#" -eq 0 ]; then
        echo $"Usage: killproc [-p pidfile] [ -d delay] {program} [-signal]"
        return 1
    fi
    if [ "$1" = "-p" ]; then
        pid_file=$2
        shift 2
    fi
    if [ "$1" = "-b" ]; then
        if [ -z $pid_file ]; then
            echo $"-b option can be used only with -p"
            echo $"Usage: killproc -p pidfile -b binary program"
            return 1
        fi
        binary=$2
        shift 2
    fi
    if [ "$1" = "-d" ]; then
        delay=$(echo $2 | awk -v RS=' ' -v IGNORECASE=1 '{if($1!~/^[0-9.]+[smhd]?$/) exit 1;d=$1~/s$|^[0-9.]*$/?1:$1~/m$/?60:$1~/h$/?60*60:$1~/d$/?24*60*60:-1;if(d==-1) exit 1;delay+=d*$1} END {printf("%d",delay+0.5)}')
        if [ "$?" -eq 1 ]; then
            echo $"Usage: killproc [-p pidfile] [ -d delay] {program} [-signal]"
            return 1
        fi
        shift 2
    fi


    # check for second arg to be kill level
    [ -n "${2:-}" ] && killlevel=$2

    # Save basename.
    base=${1##*/}

    # Find pid.
    __pids_var_run "$1" "$pid_file" "$binary"
    RC=$?
    if [ -z "$pid" ]; then
        if [ -z "$pid_file" ]; then
            pid="$(__pids_pidof "$1")"
        else
            [ "$RC" = "4" ] && { failure $"$base shutdown" ; return $RC ;}
        fi
    fi

    # Kill it.
    if [ -n "$pid" ] ; then
        [ "$BOOTUP" = "verbose" -a -z "${LSB:-}" ] && echo -n "$base "
        if [ -z "$killlevel" ] ; then
            __kill_pids_term_kill -d $delay $pid
            RC=$?
            [ "$RC" -eq 0 ] && success $"$base shutdown" || failure $"$base shutdown"
        # use specified level only
        else
            if checkpid $pid; then
                kill $killlevel $pid >/dev/null 2>&1
                RC=$?
                [ "$RC" -eq 0 ] && success $"$base $killlevel" || failure $"$base $killlevel"
            elif [ -n "${LSB:-}" ]; then
                RC=7 # Program is not running
            fi
        fi
    else
        if [ -n "${LSB:-}" -a -n "$killlevel" ]; then
            RC=7 # Program is not running
        else
            failure $"$base shutdown"
            RC=0
        fi
    fi

    # Remove pid file if any.
    if [ -z "$killlevel" ]; then
        rm -f "${pid_file:-/var/run/$base.pid}"
    fi
    return $RC
}

# A function to find the pid of a program. Looks *only* at the pidfile
pidfileofproc() {
    local pid

    # Test syntax.
    if [ "$#" = 0 ] ; then
        echo $"Usage: pidfileofproc {program}"
        return 1
    fi

    __pids_var_run "$1"
    [ -n "$pid" ] && echo $pid
    return 0
}

# A function to find the pid of a program.
pidofproc() {
    local RC pid pid_file=

    # Test syntax.
    if [ "$#" = 0 ]; then
        echo $"Usage: pidofproc [-p pidfile] {program}"
        return 1
    fi
    if [ "$1" = "-p" ]; then
        pid_file=$2
        shift 2
    fi
    fail_code=3 # "Program is not running"

    # First try "/var/run/*.pid" files
    __pids_var_run "$1" "$pid_file"
    RC=$?
    if [ -n "$pid" ]; then
        echo $pid
        return 0
    fi

    [ -n "$pid_file" ] && return $RC
    __pids_pidof "$1" || return $RC
}

status() {
    local base pid lock_file= pid_file= binary=

    # Test syntax.
    if [ "$#" = 0 ] ; then
        echo $"Usage: status [-p pidfile] {program}"
        return 1
    fi
    if [ "$1" = "-p" ]; then
        pid_file=$2
        shift 2
    fi
    if [ "$1" = "-l" ]; then
        lock_file=$2
        shift 2
    fi
    if [ "$1" = "-b" ]; then
        if [ -z $pid_file ]; then
            echo $"-b option can be used only with -p"
            echo $"Usage: status -p pidfile -b binary program"
            return 1
        fi
        binary=$2
        shift 2
    fi
    base=${1##*/}

    if [ "$_use_systemctl" = "1" ]; then
        systemctl status ${0##*/}.service
        ret=$?
        # LSB daemons that dies abnormally in systemd looks alive in systemd's eyes due to RemainAfterExit=yes
        # lets adjust the reality a little bit
        if systemctl show -p ActiveState ${0##*/}.service | grep -q '=active$' && \
        systemctl show -p SubState ${0##*/}.service | grep -q '=exited$' ; then
            ret=3
        fi
        return $ret
    fi

    # First try "pidof"
    __pids_var_run "$1" "$pid_file" "$binary"
    RC=$?
    if [ -z "$pid_file" -a -z "$pid" ]; then
        pid="$(__pids_pidof "$1")"
    fi
    if [ -n "$pid" ]; then
        echo $"${base} (pid $pid) is running..."
        return 0
    fi

    case "$RC" in
    0)
        echo $"${base} (pid $pid) is running..."
        return 0
        ;;
    1)
        echo $"${base} dead but pid file exists"
        return 1
        ;;
    4)
        echo $"${base} status unknown due to insufficient privileges."
        return 4
        ;;
    esac
    if [ -z "${lock_file}" ]; then
        lock_file=${base}
    fi
    # See if /var/lock/subsys/${lock_file} exists
    if [ -f /var/lock/subsys/${lock_file} ]; then
        echo $"${base} dead but subsys locked"
        return 2
    fi
    echo $"${base} is stopped"
    return 3
}

echo_success() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    echo -n "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
    echo -n $"  OK  "
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo -n "]"
    echo -ne "\r"
    return 0
}

echo_failure() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    echo -n "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
    echo -n $"FAILED"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo -n "]"
    echo -ne "\r"
    return 1
}

echo_passed() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    echo -n "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
    echo -n $"PASSED"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo -n "]"
    echo -ne "\r"
    return 1
}

echo_warning() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    echo -n "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
    echo -n $"WARNING"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo -n "]"
    echo -ne "\r"
    return 1
}

# Inform the graphical boot of our current state
update_boot_stage() {
    if [ -x /bin/plymouth ]; then
        /bin/plymouth --update="$1"
    fi
    return 0
}

# Log that something succeeded
success() {
    [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_success
    return 0
}

# Log that something failed
failure() {
    local rc=$?
    [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_failure
    [ -x /bin/plymouth ] && /bin/plymouth --details
    return $rc
}

# Log that something passed, but may have had errors. Useful for fsck
passed() {
    local rc=$?
    [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_passed
    return $rc
}

# Log a warning
warning() {
    local rc=$?
    [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_warning
    return $rc
}

# Run some action. Log its output.
action() {
    local STRING rc

    STRING=$1
    echo -n "$STRING "
    shift
    "$@" && success $"$STRING" || failure $"$STRING"
    rc=$?
    echo
    return $rc
}

# returns OK if $1 contains $2
strstr() {
    [ "${1#*$2*}" = "$1" ] && return 1
    return 0
}

# Check whether file $1 is a backup or rpm-generated file and should be ignored
is_ignored_file() {
    case "$1" in
    *~ | *.bak | *.orig | *.rpmnew | *.rpmorig | *.rpmsave)
        return 0
        ;;
    esac
    return 1
}

# Evaluate shvar-style booleans
is_true() {
    case "$1" in
    [tT] | [yY] | [yY][eE][sS] | [tT][rR][uU][eE] | 1)
        return 0
        ;;
    esac
    return 1
}

# Evaluate shvar-style booleans
is_false() {
    case "$1" in
    [fF] | [nN] | [nN][oO] | [fF][aA][lL][sS][eE] | 0)
        return 0
        ;;
    esac
    return 1
}

# Apply sysctl settings, including files in /etc/sysctl.d
apply_sysctl() {
    if [ -x /lib/systemd/systemd-sysctl ]; then
    /lib/systemd/systemd-sysctl
    else
        for file in /usr/lib/sysctl.d/*.conf ; do
            is_ignored_file "$file" && continue
            [ -f /run/sysctl.d/${file##*/} ] && continue
            [ -f /etc/sysctl.d/${file##*/} ] && continue
            test -f "$file" && sysctl -e -p "$file" >/dev/null 2>&1
        done
        for file in /run/sysctl.d/*.conf ; do
            is_ignored_file "$file" && continue
            [ -f /etc/sysctl.d/${file##*/} ] && continue
            test -f "$file" && sysctl -e -p "$file" >/dev/null 2>&1
        done
        for file in /etc/sysctl.d/*.conf ; do
            is_ignored_file "$file" && continue
            test -f "$file" && sysctl -e -p "$file" >/dev/null 2>&1
        done
        sysctl -e -p /etc/sysctl.conf >/dev/null 2>&1
    fi
}

# A sed expression to filter out the files that is_ignored_file recognizes
__sed_discard_ignored_files='/\(~\|\.bak\|\.orig\|\.rpmnew\|\.rpmorig\|\.rpmsave\)$/d'

if [ "$_use_systemctl" = "1" ]; then
        if  [ "x$1" = xstart -o \
              "x$1" = xstop -o \
              "x$1" = xrestart -o \
              "x$1" = xreload -o \
              "x$1" = xtry-restart -o \
              "x$1" = xforce-reload -o \
              "x$1" = xcondrestart ] ; then

        systemctl_redirect $0 $1
        exit $?
    fi
fi

strstr "$(cat /proc/cmdline)" "rc.debug" && set -x
return 0
```