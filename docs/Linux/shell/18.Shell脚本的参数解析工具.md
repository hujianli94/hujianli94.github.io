# 18.Shell脚本的参数解析工具


## 简单demo

该脚本是一个简单的命令行工具，可以通过命令行参数来指定不同的选项。


```shell
#!/bin/bash

version="1.0.0"
string=""
flag=0

while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do
case $1 in
  -V | --version )
    echo $version
    exit
    ;;
  -s | --string )
    shift; string=$1
    ;;
  -f | --flag )
    flag=1
    ;;
esac;
shift; # shift n 表示把第n+1个参数移到第1个参数, 即命令结束后$1的值等于$n+1的值
done


echo $string
echo $flag
```



其中 [options] 是您要传递给脚本的选项。下面是该脚本支持的选项说明：


```shell
-V 或 --version: 显示版本信息并退出脚本。
-s 或 --string: 指定一个字符串作为参数，并将其赋值给变量 string。
-f 或 --flag: 设置一个标志变量 flag
```


使用
```shell

./script.sh -V      # 显示版本信息
./script.sh -s hello  # 指定字符串参数为 "hello"
./script.sh -f       # 设置标志变量 flag
./script.sh -s world -f  # 指定字符串参数为 "world" 并设置标志变量 flag

```



## 1. 使用空格分隔


实际用法

```shell
./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts
```


实现脚本


```shell

#!/bin/bash
POSITIONAL=()
while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    -e|--extension)
      EXTENSION="$2"
      shift # past argument
      shift # past value
      ;;
    -s|--searchpath)
      SEARCHPATH="$2"
      shift # past argument
      shift # past value
      ;;
    -l|--lib)
      LIBPATH="$2"
      shift # past argument
      shift # past value
      ;;
    --default)
      DEFAULT=YES
      shift # past argument
      ;;
      *)
    POSITIONAL+=("$1") # save it in an array for later
      shift # past argument
      ;;
  esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters
echo FILE EXTENSION  = "${EXTENSION}"
echo SEARCH PATH     = "${SEARCHPATH}"
echo LIBRARY PATH    = "${LIBPATH}"
echo DEFAULT         = "${DEFAULT}"
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
if [[ -n $1 ]]; then
  echo "Last line of file specified as non-opt/last argument:"
  tail -1 "$1"
fi
```



## 2. 使用等号分隔


实际用法

```shell
./myscript.sh -e=conf -s=/etc -l=/usr/lib /etc/hosts
```


实现脚本

```shell
#!/bin/bash
for key in "$@"; do
  case $key in
    -e=*|--extension=*)
      EXTENSION="${key#*=}"
      shift # past argument=value
      ;;
    -s=*|--searchpath=*)
      SEARCHPATH="${key#*=}"
      shift # past argument=value
      ;;
    -l=*|--lib=*)
      LIBPATH="${key#*=}"
      shift # past argument=value
      ;;
    --default)
      DEFAULT=YES
      shift # past argument with no value
      ;;
    *)
      ;;
  esac
done
echo "FILE EXTENSION  = ${EXTENSION}"
echo "SEARCH PATH     = ${SEARCHPATH}"
echo "LIBRARY PATH    = ${LIBPATH}"
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
if [[ -n $1 ]]; then
  echo "Last line of file specified as non-opt/last argument:"
  tail -1 $1
fi 

```


## 3. 使用 getopts 工具

实际用法

```sh
./myscript.sh -h
./myscript.sh -v -f
```



实现脚本

```shell
#!/bin/sh
# 重置以防止在前面的shell中使用getopts工具(这是一个POSIX变量)
OPTIND=1
# 初始化变量名称
OUTPUT_FILE=""
VERSION=0
# getopts的缺点就是它只能处理短选项，如-h，而不能是--help格式
while getopts "h?vf:" key; do
    case "$key" in
    h|\?)
        show_help
        exit 0
        ;;
    v)
        VERSION=1
        ;;
    f)
        output_file=$OPTARG
        ;;
    esac
done
shift $((OPTIND-1))
[ "${1:-}" = "--" ] && shift
echo "verbose=$VERSION, output_file='$output_file', Leftovers: $@" |

```


## 4. 使用 argbash 工具

这个工具主要提供脚本参数的解析功能，而且不再引用任何第三方库的情况下。一般会比普通脚本多30多行而且，但是效果非常好。
详细信息可以通过官方网站地址了解。

https://argbash.io/generate#results



```shell
#!/bin/bash
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
# [可选参数]
# ARG_OPTIONAL_SINGLE([option], [o], [optional argument help msg])
# [可选布尔参数]
# ARG_OPTIONAL_BOOLEAN([print], , [boolean optional argument help msg])
# [固定参数]
# ARG_POSITIONAL_SINGLE([positional-arg], [positional argument help  msg], )
# [帮助信息]
# ARG_HELP([The general script's help msg])
# ARGBASH_GO
# [ <-- needed because of Argbash
echo "Value of --option: $_arg_option"
echo "print is $_arg_print"
echo "Value of positional-arg: $_arg_positional_arg"
# ] <-- needed because of Argbash |

```
