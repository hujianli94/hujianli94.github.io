# 1.Ansible入门和实践


相比较于Puppet和Saltstack而言，Ansible是一款轻量级的服务器集中管理软件。


Ansible默认采用SSH的方式管理客户端，部署简单，只需要在跳板机或主控端部署Ansible环境即可，被控端无须进行任何操作。

Ansible是基于Python开发的，由Paramiko和PyYAML两个关键模块构建，我们可以使用它的各种模块来实现对客户端的批量管理
(执行命令、安装软件、指定特定任务等)，对于一些较为复杂的需要重复执行的任务，我们可以通过Ansible下的playbook来管理这些复杂的任务。


Ansible是基于Paramiko开发的。


那么Paramiko到底是什么呢？Paramiko是用Python语言编写的一个模块，遵循SSH2协议，支持以加密和认
证的方式，进行远程服务器的连接。


与常用软件xshell、xftp的功能一样，不过Paramiko可以连接多台服务器，进行复杂的操作。


Ansible与轻量级的自动化运维工具Fabric还有一个共同点，那就是不需要在远程主机上安装客户端，因为它们都是基于SSH来与远程主机进行通信的。



相比较于其他自动化运维工具，Ansible的优势也有很多，具体如下。

+ 轻量级，无须在客户端安装Aget,更新时只需要在操作机上进行一次更新即可。

+ 批量任务执行可以写成脚本，而且不用分发到远程就可以执行。

+ 使用Python编写，维护简单，二次开发更方便。

+ 支持非root用户管理操作，支持sudo。

+支持云计算、大数据平台（如AWS、OpenStack、CloudStack等）。

+ Ansible社区非常活跃，Ansible本身提供的模块也非常丰富，第三方资源众多。

2015年，红帽公司宣布收购Ansible,在产品层面，Ansible符合Red Hat希望通过开放式开发提供无障碍设计和模块化架构的目标，主要体现在以下几个方面。


**Ansible易于使用**：这一点从下面的两个例子得以体现。一是，Ansible的playbook使用的是人类可读的YAML代码编写，简化了自动化流程的编写和维护；
二是，Ansible使用标准的SSH连接来执行自动化流程，不需要代理，更容易融入已有的企业IT环境。



**Ansible是模块化的**：Ansible提供了400多个模块，而且还在不断增加，这些模块可以用于扩展Ansible的功能。这是Red Hat希望在其管理的产品中提供的一个重要的功能。


**Ansible是一个非常受欢迎的开源项目**：在GitHub上，Ansible有将近13000颗星和4000个分支。另外，根据Redmonk统计，Hacker News提及Ansible的次数也在飞速
增长。

在资产组合方面，Ansible符合Red Hat希望提供多层架构、多层一致性和多供应商支持的目标，主要体现在以下几个方面。


**Ansible支持多层部署**：按照设计，Ansible通过VM和容器为多层应用程序的部署和配置提供支持。这意味着组织可以将同一应用程序的不同组件自动部署到运行效率最
高的层上。比如，Ansible可以同时在VMware vSphere服务器虚拟环境中管理VM和客户操作系统，在OpenStack laaS云上部署和管理实例，在OpenShift PaaS云上部署应用
程序。


**Ansible为架构的多个层次带来一致性**：惜助Ansible,我们可以通过编程来操作计算
架构中从基础设施到应用程序之间的每一层。比如，Ansible可以自动化包括网络、存储、OS、中间件和应用程序层在内的所有配置工作。


**Ansible支持异构IT环境**：Ansible可以自动配置来自许多供应商的各种技术，而不只是Red Hat的技术。比如，Ansible既支持Linux,也支持Windows;Ansible使IT组织可
以管理各种ISV和IHV技术，比如硬件F5Big-IP和Citrix NetScaler到Amazon Web服务和Google云计算平台。


从Ansible1.7版本开始，Ansbile加入了支持管理Windows系统的模块,有兴趣的朋友可以参考Ansible官网。




## 1.YAML介绍

YAML是一个可读性高的用于表达资料序列的格式。它的主要特点是可读性好、语法简单明了、表达能力强、扩展性和通用性强等。

为什么这里不用大家所熟悉的XML呢？具体原因如下。

+ YAML的可读性好。
  
+ YAML和脚本语言的交互性好。

+ YAML使用实现语言的数据类型。

+ YAML有一个一致的信息模型。
  
+ YAML易于实现。

上面5条也是XML不足的地方。此外，YAML也具有XML所具有的下列优点。
+ YAML可以基于流来处理。

+ YAML表达能力强，扩展性好。

总之，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务。另外，建议所有的YAML文件都以“-”作为开始行，这是YAML文件格式的一部分，表明是一个文件的开始。

YAML的语法与其他高阶语言类似，并且可以简单地表达列表、字典等数据结构，除此之外，它还支持纯量这种数据结构。

+ 字典(dictionary):键值对的集合，又称为映射(mapping)。

+ 列表(1ist):一组按次序排列的值。

+ 常量(scalars):单个的、不可再分的值。


### 1.1 通用结构

下面是一个通用示例，文件内容如下所示：

```yaml
---
name: Tome smith
age: 37
spouse:
  name: Jane smith
  age: 35

children:
  - name: Jimmy smith
    age: 15
  - name1: Jenny smith
    age1: 12

# YAML中的多行字符事可以使用“”保留换行符，也可以使用“>”折叠换行，示例
this: |
  Foo
  Bar

that: >
  Foo
  Bar

# list结构
Fruit:
  - apple
  - banana
  - orange
  - pear
```

使用python读取yaml文件，代码如下

```python
# -*- coding:utf8 -*-

import yaml

file = open("test.yaml", 'r',encoding='utf-8')

x = yaml.load(file, Loader=yaml.FullLoader)

print(x)
```

对应Python结果如下：

```shell
{'name': 'Tome smith', 'age': 37, 'spouse': {'name': 'Jane smith', 'age': 35}, 'children': [{'name': 'Jimmy smith', 'age': 15}, {'name1': 'Jenny smith', 'age1': 12}], 'this': 'Foo\nBar\n', 'that': 'Foo Bar\n', 'Fruit': ['apple', 'banana', 'orange', 'pear']}
```


`|`和`>`的区别：`|`它保留换行符，`>`把多行合并为一行。


```shell
# 通过copy模块创建/tmp/1.txt，文件中有两行内容，分别是Hello World和ni hao
[root@control ansible]# vim f1.yml
---
- name: play 1
  hosts: test
  tasks:
    - name: mkfile 1.txt
      copy:
        dest: /tmp/1.txt
        content: |
          Hello World!
          ni hao.

[root@control ansible]# ansible-playbook f1.yml
# 查看结果
[root@node1 ~]# cat /tmp/1.txt 
Hello World!
ni hao.


# 通过copy模块创建/tmp/2.txt，文件中有一行内容，分别是Hello World! ni hao
[root@control ansible]# vim f2.yml 
---
- name: play 1
  hosts: test
  tasks:
    - name: mkfile 2.txt
      copy:
        dest: /tmp/2.txt
        content: >
          Hello World!
          ni hao.

[root@control ansible]# ansible-playbook f2.yml
[root@node1 ~]# cat /tmp/2.txt 
Hello World! ni hao.
```


### 1.2 字典结构

```yaml
node_a:
  conntimeout:300

external:
  iface: eth0
  port: 556


internal:
  iface: eth0
  port: 778


broadcast:
  client: 1000
  server: 2000

node_b:
  0:
    ip: 10.0.0.1
    name: bl
  1:
    ip: 10.0.0.2
    name: b2
```

对应Python结果如下：

```shell
{'node_a': 'conntimeout:300', 'external': {'iface': 'eth0', 'port': 556}, 'internal': {'iface': 'eth0', 'port': 778}, 'broadcast': {'client': 1000, 'server': 2000}, 'node_b': {0: {'ip': '10.0.0.1', 'name': 'bl'}, 1: {'ip': '10.0.0.2', 'name': 'b2'}}}
```

### 1.3 列表和字典混用

```yaml
#一位职工记录
name: Example Developer
job: Developer
skill: Elite
employed: True

foods:
  - Apple
  - Orange
  - Strawberry
  - Mango

languages:
  Python: edite
  Java: edite
  C++: edite
```

使用python代码读取文件

```python
# -*- coding:utf8 -*-
import yaml

with open("list_dict.yaml", 'r', encoding='utf-8') as file:
    x = yaml.safe_load(file)

print(x)

```

对应Python结果如下：

```shell
{'name': 'Example Developer', 'job': 'Developer', 'skill': 'Elite', 'employed': True, 'foods': ['Apple', 'Orange', 'Strawberry', 'Mango'], 'languages': {'Python': 'edite', 'Java': 'edite', 'C++': 'Lame'}}
```


### 1.4 多种常量结构使用


```yaml
boolean:
  - TRUE    # true,TRUE都可以
  - FALSE   #false,False都可以

float:
  - 3.14
  - 6.8523015e+5   #可以使用科学计数法

int:
  - 123
  - 0b10100111010010101110   #二进制表示


nu11:
  nodeName: 'node'
  parent: ~  #使用“~”表示nul1

string:
  - 'hello,yhc'
  - 'He11owor1d'      #可以使用双引号或者单引号包裹特殊字符
  - newline
      newline2        #字符串可以拆成多行，每一行都会被转化成一个空格

date:
  - 2018-02-17        #日期必须使用IS08601格式，即yyyy-MM-dd

datetime:
  - 2018-02-17T15:02:31+08:00 # 时间使用IS08601格式，时间和日期之间使用T连接，最后使用“+”代表时区
```


对应Python结果如下：

```shell
{'boolean': [True, False], 'float': [3.14, 685230.15], 'int': [123, 685230], 'nu11': {'nodeName': 'node', 'parent': None}, 'string': ['hello,yhc', 'He11owor1d', 'newline newline2'], 'date': [datetime.date(2018, 2, 17)], 'datetime': [datetime.datetime(2018, 2, 17, 15, 2, 31, tzinfo=datetime.timezone(datetime.timedelta(seconds=28800)))]}
```


列举了这么多例子，最后我们在此总结一下YAML的基本语法规则，大家在工作中请记得遵循，语法规则具体如下所示。

- YAML文件对大小写敏感。

- 使用缩进代表层级关系。

- 缩进只能使用空格，不能使用TAB,空格个数不作要求，只需要相同层级左对齐(一般为2个或4个空格)即可。

- YAML文件是以“#”作为注释，YAML中只有行注释。





!!!info "参考文档"


      [YAML 语法](https://ansible-tran.readthedocs.io/en/latest/docs/YAMLSyntax.html)

      [Playbooks 采用YMAL 语法结构，基本的YMAL 语法请参考](http://docs.ansible.com/YAMLSyntax.html)

      [python利用pyyaml模块进行解析yaml语言](http://pyyaml.org/wiki/PyYAMLDocumentation)

      [yaml格式在线检查](http://yaml-online-parser.appspot.com/)




## 2.Ansible的安装和配置


=== "ubuntu"


    ```shell
    $ sudo apt update
    $ sudo apt install software-properties-common
    $ sudo apt-add-repository --yes --update ppa:ansible/ansible
    $ sudo apt install ansible
    ```



=== "pip"


    ```shell
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
    python get-pip.py
    pip install ansible==2.12.10 -i https://mirrors.ustc.edu.cn/pypi/web/simple

    # 通过此方式安装的没有生成/etc/ansible文件，可以手动生成，配置文件示例到https://github.com/ansible/ansible/tree/devel/examples
    ```



=== "python3"


    ```shell
    yum install -y python36 python36-tools
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
    python3.6 get-pip.py 
    pip3.6 install ansible==2.12.10 -i https://mirrors.ustc.edu.cn/pypi/web/simple
    # 通过此方式安装的没有生成/etc/ansible文件，可以手动生成，配置文件示例到https://github.com/ansible/ansible/tree/devel/examples
    ```



Ansible的安装过程非常简便，安装步骤具体如下。

1. 这里采用的是pip安装方式，建议带上Ansible版本号，因为Ansible2.x的API语法与Ansible1.9的API语法差别很大（我们内容主要基于Ansible1.9.6),命令如下示：

```shell
pip install ansible==2.12.10 -i https://mirrors.ustc.edu.cn/pypi/web/simple
```

2. 安装完毕后，查看版本

```shell
ansible --version
ansible [core 2.12.9]
  config file = /etc/ansible/ansible.cfg
  configured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/local/lib/python3.8/dist-packages/ansible
  ansible collection location = /root/.ansible/collections:/usr/share/ansible/collections
  executable location = /usr/local/bin/ansible
  python version = 3.8.10 (default, Nov 14 2022, 12:59:47) [GCC 9.4.0]
  jinja version = 3.1.2
  libyaml = True
```

3. Ansible配置文件ansible.cfg可以存储于系统中的不同位置，但只有一个可用。

在下列列表中，Ansible会从上往下依次检查，检查到哪个可用就用哪个。

+ ANSIBLE CFG环境变量，可以定义配置文件的位置。

+ ansible.cfg存储于当前工作目录。

+ ansible.cfg存储于当前用户的家目录。

+ 默认存储位置：/etc/ansible/ansible.cfg。

Ansible配置文件默认存储于/etc/ansible/ansible.cfg,hosts文件默认存储于/etc/ansible/hosts,在这里我们采用默认值。


如下为Ansible.cfg常用参数详解


| 配置项                     | 描述                                                     |
| ------------------------ | -------------------------------------------------------- |
|inventory      = /etc/ansible/hosts |指定Ansible的主机清单文件路径。|
| remote_user              | 远程连接的用户名。                                                |
| private_key_file         | 远程连接的私钥文件路径。                                             |
| become                   | 是否切换到特权用户进行操作。                                           |
| become_user              | 切换到的特权用户。                                                 |
| become_method            | 切换特权用户的方法。                                               |
| gather_facts             | 是否收集主机信息。                                                 |
| fact_caching             | 是否缓存收集到的主机信息。                                             |
| fact_caching_connection   | 用于主机信息缓存的连接信息。                                             |
| roles_path               | 角色目录的搜索路径。                                                |
| host_key_checking=False  | 是否检查主机密钥。                                                 |
| log_path                 | 日志文件路径。                                                   |
| forks=5                    | 并发执行任务的数量。                                                |
| max_fail_percentage      | 最大失败百分比，超过则停止执行。                                         |
| timeout=10               | 连接超时时间。                                                   |
| module_lang=C            | 默认模块之间的计算机语言,默认C语言|
| ssh_args                 | SSH参数。                                                    |
| log_path = ~/ansible.log | Ansible日志存放具体路径                                       |
| scp_if_ssh               | 如果SSH可用，则使用SCP传输文件。                                       |
| control_path             | SSH控制套接字路径。                                                |
| allow_world_readable_tmp | 是否允许临时文件可由其他用户读取。                                       |
| roles                    | 定义要在主机上执行的角色列表。                                            |
| tasks                    | 定义要在主机上执行的任务列表。                                            |
| handlers                 | 定义处理程序任务列表，可以在触发特定事件时调用这些处理程序。                              |
| vars                     | 定义变量和值的键值对，可以在剧本中引用这些变量。                                   |
| environment              | 指定环境变量的键值对。                                               |
| pre_tasks                | 在角色或任务之前执行的任务列表。                                           |
| post_tasks               | 在角色或任务之后执行的任务列表。                                           |
| any_errors_fatal         | 如果任何任务错误，则设置所有任务都失败。                                      |
| ignore_errors            | 如果任务失败，则忽略错误并继续执行。                                         |
| max_parallel             | 并行执行任务的最大数量。                                              |
| serial                   | 一次在目标主机上执行的批处理数量。                                         |
| strategy                 | 允许您选择执行策略（linear、free、mitogen等）。见官方文档以获取其他可用选项。                       |
| tags                     | 标记将允许您选择要运行的特定任务或角色。                                        |
| skip_tags                | 如果标记匹配，则跳过运行特定任务或角色。                                        |
| check_mode               | 是否以检查模式运行剧本，不会对主机执行任何更改。只报告将做出什么更改而不实际执行它们。                    |
| gather_subset            | 选择要收集的特定子集，如`hardware`、`network`、`virtual`等。                           |
| diff_mode                | 是否启用差异模式，显示更改的文件内容。配合使用`register`模块来收集更改的文件列表。            |



### 2.1 Ansible的常用设置

```conf
# /etc/ansible/ansible.cfg

[defaults]
# Set the log_path
log_path = ~/ansible.log

# Additional default options for Ansible
forks = 20
host_key_checking = False
retry_files_enabled = False
retry_files_save_path = ~/ansible-installer-retries
nocows = True
remote_user = root
roles_path = roles/
gathering = smart
fact_caching = jsonfile
fact_caching_connection = $HOME/ansible/facts
fact_caching_timeout = 600
callback_whitelist = profile_tasks
inventory_ignore_extensions = secrets.py, .pyc, .cfg, .crt, .ini
# work around privilege escalation timeouts in ansible:
timeout = 30
host_key_checking = False

# Uncomment to use the provided example inventory
#inventory = inventory/hosts.example

ansible_managed = Ansible managed: {file} modified by {uid} on {host}

[inventory]
# fail more helpfully when the inventory file does not parse (Ansible 2.4+)
unparsed_is_failed=true

# Additional ssh options for OpenShift Ansible
[ssh_connection]
retries = 15
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=600s
timeout = 10
# shorten the ControlPath which is often too long; when it is,
# ssh connection reuse silently fails, making everything slower.
control_path = %(directory)s/%%h-%%r
```


### 2.2 设置免密登录

使用 ssh 秘钥连接主机

```shell
echo 'PubkeyAuthentication yes' >> /etc/ssh/sshd_config
systemctl restart sshd
```

配置远程主机秘钥
```shell
#生成SSH秘钥的连接

# 在主控端主机（SN2013-08-020）创建密钥，执行：ssh-keygen-t
# rsa，有询问直接按回车键即可，将在/root/.ssh/下生成一对密钥，其中
# id_rsa为私钥，id_rsa.pub为公钥（需要下发到被控主机用户.ssh目录，同时要求重命名成authorized_keys文件）

# ssh-keygen -t rsa
# ssh-copy-id root@<client_ip> -p 22

# 或者如下
# ssh-keygen -t rsa -P '' -b 4096 -f ~/.ssh/id_rsa


# 或者生成自定义的rsa key认证
ssh-keygen  -N "" -b 4096 -t rsa -C "stanley@magedu.com" -f /root/.ssh/stanley.rsa



# 为本机添加密钥认证
ssh-copy-id –i /root/.ssh/stanley.rsa root@localhost
ssh-copy-id –i /root/.ssh/stanley.rsa root@192.xx.xx.100
```


[Ansible Role: ssh keys](https://ansible.leops.cn/roles/env/ssh-keys/)


### 2.3 配置主机清单

示例

```
[k8s_cluster_work]
172.18.0.1
172.18.0.2
172.18.0.3
172.18.0.4
172.18.0.5

[k8s_cluster_master]
172.18.0.1
172.18.0.2
172.18.0.3

[k8s_cluster:children]
k8s_cluster_work
k8s_cluster_master

[k8s_cluster:vars]
ansible_ssh_user=root

[app]
172.18.0.15
172.18.0.13
172.18.0.12
172.18.0.14


[russia:children]
k8s_cluster
gitaly


[russia:vars]
ansible_ssh_user=root
ansible_ssh_pass='xxxx'
```


### 2.4 执行ansible命令

```shell
# 测试连接状态
ansible 192.168.77.135 -m ping

# 安装Nginx
ansible 192.168.77.135 -m yum -a 'name=nginx'

# 启动Nginx
ansible 192.168.77.135 -m yum -a 'name=nginx'
```



## 3.定义主机与组规则(Inventory)

Ansible通过定义好的主机与组规则（Inventory文件)指定了Ansible作用的主机列表，

Ansible默认读取/etc/ansible/hosts文件。

当然，这里也可以通过ANSIBLE_HOSTS环境变量来指定，或者在运行ansible-hoc及ansible-playbook时用“-i”参数指定临时主机列表文件。

下面是Inventory文件的一个例子：

```conf
mail.example.com

[webservers]
foo.example.com
bar.example.com

[dbservers]
one.example.com
two.example.com
Three.example.com

```
其中，中括号内的是组名称，一台主机可以属于多个组。
一台属于多个组的主机会读取多个组的变量文件，这样可能就会产生冲突，工作中尽量避免这样的写法。

定义好Inventory文件以后，就可以用下面的命令来验证主机列表内容了，代码如下所示：

```bash
ansible webservers --list-hosts
```
或者：

```bash
ansible dbserver --ilst-hosts
```

有一个主机会被Ansible默认自动添加到Inventory中，那就是localhost。
Ansible以为localhost就代表本地主机，所以在需要它的时候会直接在本机执行而不是通过SSH连接。


如果SSH采用的不是默认的22端口，那么可以在主机后面指定SSH端口，代码如下所示：
```bash
badwolf.example.com:5309
```

使用静态IP时，如果我们希望在hosts文件中使用别名或通过通道进行连接，则可以采用类似如下的方式，代码如下所示：
```bash
jumper ansible_ssh_port=5555 ansible_ssh_host=192.168.1.50
```


如果有很多类似的主机名称，则在没必要时不用一一列出，代码如下所示：
```conf
[webservers]
www[01:50].example.com
db-[a:f].example.com
```

其中，数字开头的0可以省略，中括号是闭合的。


也可以指定每个主机的连接类型和用户名：
```conf

[targets]
localhost ansible_connection=local
otherl.example.com ansible_connection=ssh ansible_ssh user=mpdehaan
other2.example.com ansible_connection=ssh ansible_ssh user=mdehaan
```

如上述代码所示，直接在Inventory文件中添加参数的方式并不是一个好的选择，后面会介绍更好的方法，那就是在单独的host_vars目录中定义参数。

### 3.1 定义主机变量

主机可以指定变量，以便后续供playbooks配置使用，例如下面的代码定义了主机host1和host2上面Apache的参数http_port及maxRequestsPerChild:

```conf
[atlanta]
host1 http_port=80 maxRequestsPerchild=808
host2 http_port=303 maxRequestsPerchild=909


#如果不配置SSH秘钥认证，可以这样对管理主机进行认证
; vim /etc/ansible/hosts
[wbservers]
192.168.1.110 ansible_ssh_user=root ansible_ssh_pass=123.com
```

### 3.2 定义组变量

组变量的作用是覆盖组中的所有成员，下面定义一个新块，块名由组名+"：vas"组成，示例代码如下所示：
```conf
[atlanta]
host1
host2

[atlanta:vars]
ntp server=ntp.atlanta.example.com
proxy=proxy.atlanta.example.com
```


组的组也可以称为组嵌套。


组嵌套是定义一个新块，块名由组名+"：children"组成，示例代码如下所示：

```conf
[atlanta]
hostl
host2

[raleigh]
host2
host3

[southeast:children]
atlanta
raleigh

[usa:children]
southeast
northeast
southwest
Northwest
```


### 3.3 分离主机和组变量

在ansible中更好的实践并不是把变量放到Inventory文件中，而是使用YAML格式保存到单独的文件中，不要与Inventory放置到一起。


假设Inventory文件的路径为/etc/ansible/hosts,其中有个主机名为foosbal,属于raleigh和webservers两个组，那么以下位置的YAML文件会对foosball主机有效：

```shell
/etc/ansible/group_vars/raleigh
/etc/ansible/group_vars/webservers
/etc/ansible/host_vars/foosball
```

例如，/etc/ansible/group_.vars/raleigh文件看起来可能类似于下面这样：

```shell
ntp server:acme.example.org
database server:storage.example.org
```

事实上，上面涉及的内容全部属于静态Inventory的范畴。

在实际运维自动化的工作中，动态Inventory文件应用得更多，主要用于要编写Python脚本（不一定局限于Python
语言，但推荐采用Python),以便从公司的CMDB(资产管理)系统提供的API拉取所有的主机信息，然后再使用Ansible来进行管理，这样就能很方便地将Ansible与其他运维系统
结合起来使用了。


!!!info "参考文献"


    [使用动态主机](https://ansible.leops.cn/advanced/dynamic-hosts/)


## 4.Ansible常用模块介绍

Ansible常用模块有很多，包括云计算、命令行、包管理、系统服务、用户管理等，可以通过[官方网站](https://docs.ansible.com/ansible/latest/module_plugin_guide/index.html)
查看相应的模块，也可以在命令行下通过`ansible--doc -l`命令查看模块，或者通过`ansible-doc -s`模块名查看具
体某个模块的使用方法。

示例

```shell
ansible-doc -l
ansible-doc -s yum
ansible-doc yum
```

官网的介绍比较详细，建议查看官网介绍。“ansible-doc -l”命令部分显示结果如下所示：

```shell
.....
purestorage.flashblade.purefb_s3user                                                     Create or delete FlashBlade Object Store account users
purestorage.flashblade.purefb_smtp                                                       Configure SMTP for Pure Storage FlashBlade
purestorage.flashblade.purefb_snap                                                       Manage filesystem snapshots on Pure Storage FlashBlades
purestorage.flashblade.purefb_snmp_agent                                                 Configure the FlashBlade SNMP Agent
purestorage.flashblade.purefb_snmp_mgr                                                   Configure FlashBlade SNMP Managers
purestorage.flashblade.purefb_subnet                                                     Manage network subnets in a Pure Storage FlashBlade
purestorage.flashblade.purefb_syslog                                                     Configure Pure Storage FlashBlade syslog settings
purestorage.flashblade.purefb_target                                                     Manage remote S3-capable targets for a FlashBlade
purestorage.flashblade.purefb_timeout                                                    Configure Pure Storage FlashBlade GUI idle timeout
purestorage.flashblade.purefb_user                                                       Modify FlashBlade local user account password
purestorage.flashblade.purefb_userpolicy                                                 Manage FlashBlade Object Store User Access Policies
purestorage.flashblade.purefb_virtualhost                                                Manage FlashBlade Object Store Virtual Hosts
raw                                                                                      Executes a low-down and dirty command
reboot                                                                                   Reboot a machine
replace                                                                                  Replace all instances of a particular string in a file using a back-referenced regular expression
rpm_key                                                                                  Adds or removes a gpg key from the rpm db
script                                                                                   Runs a local script on a remote node after transferring it
sensu.sensu_go.ad_auth_provider                                                          Manage Sensu AD authent
.....
```

下面介绍运维工作中经常用到的几个模块，其他模块不再逐一介绍，建议大家参考官文档。

+ setup模块
+ copy模块
+ synchronize模块
+ file模块
+ ping模块
+ group模块
+ user模块
+ shell模块
+ script模块
+ get url模块
+ yum模块
+ cron模块
+ service模块


Ansible命令行调用模块的语法格式如下所示：
```shell

ansible 操作目标 -m 模块名 -a 模块参数
```



### setup模块

(1)功能

setup 模块来收集主机的系统信息，这些 facts 信息可以直接以变量的形式使用，但是如果主机较多，会影响执行速度，可以使用gather_facts: no来禁止 Ansible 收集 facts 信息

`ansible-doc -s setup`



(2) 举例

```shell
# 查看已经安装的东西
ansible all  -m setup

# 查看所有节点的ansible_python的版本
ansible all  -m  setup -a 'filter=ansible_python_version'  
```



### copy模块

(1)功能


Ansible 中的copy模块用于实现文件复制和批量下发文件，src来定义本地源文件路径，使用dest定义被管理主机文件路径，使用content定义信息内容来生成目标文件

该模块可实现Ansible主机向客户端传送文件的功能，文件的变化是通过md5值来判断的，大家需要记住应提前关闭客户端机器的SELinux。

`ansible-doc -s copy`




(2) 举例

```shell 
src: # 源文件  指定拷贝文件的本地路径  (如果有/ 则拷贝目录内容,比拷贝目录本身)     
dest: # 指定目标路径     
mode: # 设置权限    
  backup: # 备份源文件  
  content: # 代替src  指定本机文件内容,生成目标主机文件
```

```shell
# 进行复制dest=/tmp/test.txt"
ansible webserver -m copy -a "content='test content\nxxx' dest=/tmp/test.txt"


# 进行查看
ansible webserver  -a "cat /tmp/test.txt" 



ansible webservers -m copy -a "src=/home/test.sh dest=/tmp/ owner=root group=root mode=0755"
ansible dbservers -m copy -a 'src=/etc/fstab dest=/tmp/fstab.ansible owner=root mode=640'

#将“Hello Ansible Hi Ansible”写入管理主机的/tmp/test.ansible文件中
ansible dbservers -m copy -a 'content="Hello Ansible Hi Ansible" dest=/tmp/test.ansible'

# 拷贝是设置权限，force强制覆盖，默认。 backup参考，拷贝覆盖前进行备份
ansible webserver -m copy -a "src=/usr/local/src/test.py dest=/tmp/owner=root group=root mode=0755 force=yes"

ansible web -m copy -a "src=/mine/ntp.conf dest=/etc/ntp.conf owner=root group=root mode=644 backup=yes force=yes"
```


### synchronize模块

(1)功能

由于synchronize模块会调用rsync命令，因此首先要记得提前安装好rsync软件包，不然执行的时候会出现`"msg":"[Errno2]No such file or directory'"`这种报错信息。

`ansible-doc -s synchronize`




(2)举例

synchronize模块用于将Ansible机器的指定目录推送(push)到客户机器的指定目录下，命令如下：

```shell
ansible 192.168.1.206 -m synchronize -a "src=/usr/local/src/ dest=/usr/local/ src/delete=yes compress=yes
```

其中，delete=-yes用来实现使两边的内容一样(即以push方式为主)，实现效果与`rsync-delete`一样，
如果是客户端不存在的文件或目录则增补，如果存在着不同的文件或目录则删除，以保证两边内容一致。

compress=yes用于开启压缩，默认为开启。

另外，由于synchronize模块调用的是rsync命令，因此如果路径使用“/”来结尾，则只复制目录里的内容，如果没有使用“/”来结尾，则包含目录在内的整个内容全部都要复
制过去(源目标目录作为目的目录的一个子目录存在)。




### file模块

(1)功能

Ansible中使用file模块来设置文件属性，path指定文件路径，sec指定源文件路径，使用name或dest来替换创建文件的符号链接

`ansible-doc -s file`




(2)举例

```shell
# 更改文件的用户及权限
ansible web -m file -a "dest=/tmp/a.txt mode=600 owner=user group=user"


# 创建目录，类似mkdir -p
ansible web -m file -a "dest=/tmp/test mode=755 owner=user group=user state=directory"


# 删除文件或者目录
ansible web -m file -a "dest=/tmp/test state=absent"


# 创建软连接，并设置所属用户和用户组
ansible web -m file -a  "src=/file/to/link/to dest=/path/to/symlink owner=user group=user state=link"


# touch 一个文件并添加用户读写权限，用户组去除写执行权限，其他组减去读写执行权限
ansible web -m file -a  "path=/etc/foo.conf state=touch mode='u+rw,g-wx,o-rwx'"


ansible webserver -m file -a 'path=/app/test.txt state=touch'       #创建文件   
ansible webserver -m file -a "path=/data/testdir state=directory"   #创建目录         
ansible webserver -m file -a "path=/root/test.sh owner=wang mode=755"  #设置权限755     
ansible webserver -m file -a 'src=/data/testfile dest=/data/testfile-link state=link' #创建软链接  
```


### ping模块

ping模块，其可用于检测与被控端机器的连通性，命令如下：

```shell
ansible all -m ping
```


### group模块


(1)功能

Ansible中的group模块用于对用户组进行管理

`ansible-doc -s group`



（2）例子

```shell
# 创建mysql组，将mysql用户添加到mysql组中
ansible dbservers -m group -a 'name=mysql gid=306 system=yes'
ansible dbservers -m user -a 'name=mysql uid=306 system=yes group=mysql'

# 创建一个组名为test gid为2018的组
ansible webserver -m group -a gid=2018 name='test'

# 查看创建的组 
ansible webserver -m shell -a 'cat /etc/group|grep test'

```

注意这里使用了shell模块，没有使用默认的command模块，

ansible的默认模块command，它不会通过shell进行处理，所以像`$HOME`和像`“<”，“>”，“|”，“;”`和`“＆”`将不工作。


### user模块

(1)功能

Ansible中的user模块用于创建新用户和更改、删除已存在的用户。其中name选项用来这么创建的用户名称。

远程主机系统用户管理。

`ansible-doc -s user`


(2)示例

```shell
#创建用户
ansible dbservers -m user -a 'name="user1"'

#该场景中我们可以掌握如下技能点。
# 1）groups设定：groups=用户组1，用户组2……
# 2）增量添加属组：append=yes
# 3）表明属组状态为新建：state=present

ansible db -m user -a "name=dba shell=/bin/bash groups=admins,dbagroup append=yes home=/home/dba/ state=present"

#设置系统用户tom的密码为redhat123。
ansible db -m user -a "name=tom shell=/bin/bash password=to46pW3GOukvA update_password=always"

#删除用户
ansible dbservers -m user -a 'name="user1" state=absent'
ansible db -m user -a "name=dba state=absent remove=yes"



######## windows 用户管理 ###########

#新增用户stanley，密码为magedu@123，属组为Administrators。
ansible windows -m win_user -a "name=stanley passwd=magedu@123 group=Administrators"

######## 应用层用户管理 ####################

#新增MySQL用户stanley，设置登录密码为magedu@bj，对zabbix.*表有ALL权限
ansible db -m mysql_user -a 'login_host=localhost login_password=magedu login_user=root name=stanley password=magedu@bj priv=zabbix.*:ALL state=present'
```


### shell模块

(1) 功能

command模块作为Ansible的默认模块，可以运行被控端机器权限范围内的所有shell命令，前面已多次提到，这里不再重复。

而shell模块用于执行被控端机器的Shell脚本文件，与另一个模块raw的功能类似，并且支持管道符。

`ansible-doc -s shell`

(2) 示例

获取web组里得eth0接口信息

```shell
ansible web -m shell -a "ifconfig eth0|grep addr"
```

### raw模块

如果说远程主机没有python 模块时，可以使用raw 模块执行命令

```shell
ansible web -m raw -a "ifconfig eth0|grep addr"
```


### scritp模块

(1) 功能
script模块用于在远程被控端主机执行本地Ansible机器中的Shell脚本文件，相当于“scp+shell”的组合命令。



(2) 示例
```shell
# 执行脚本
ansible web -m script -a ip.sh

ansible webserver -m script -a 'data/test.sh'
```


### get_url模块


(1) 功能

实现在远程主机下载指定URL到本地，支持sha256sum文件校验



(2) 例子

```shell
ansible webservers -m get_url -a "url=http://www.baidu.com dest=/tmp/index.html mode=0440 force=yes"
```


### yum模块

Ansible中的yum模块负责在被管理的主机数安装与卸载软件包，前提是在每个节点配置自己的YUM仓库，name指定要安装的软件包

带上软件包的版本号，state指定安装软件包的状态，present、latest用来表示安装，absent表示卸载

`ansible-doc -s yum`



(1) 功能

Linux平台软件包管理操作，常见有yum、apt管理方式。


(2) 例子

```shell
# 安装zsh软件包
ansible dbservers -m yum -a 'name=zsh'

# 卸载zsh软件包
ansible dbservers -m yum -a 'name=zsh,state=absent'

ansible webservers -m yum -a "name=curl state=latest"

#Redis安装命令：
ansible db-m yum -a "name=redis state=present"。

#Redis安装检查：
ansible db-m command -a "redis-cli--version"。

# 安装MariaDB-server
ansible db -m yum -a "name=MariaDB-server state=present"

# #安装MySQL-python和python-setuptools依赖包。
ansible app -m yum -a "name=MySQL-python state=present"
ansible app -m yum -a "name=python-setuptools state=present"
```

### apt模块

Ubuntu/Debian系统

```shell
# 更新仓库缓存，并安装"curl"
ansible webservers -m apt -a "name=curl update_cache=yes"

## 安装
ansible webservers -m apt -a "pkg=curl state=present"

# 安装最新得"curl"
ansible all -m apt -a "name=curl state=latest"

## 删除
ansible webservers -m apt -a "pkg=curl state=absent"
```



### cron模块

(1)功能

Ansible中的cron模块用于定义任务计划，其中有两种状态，(state):present表示添加(省略状态时默认使用),absent表示移除。


`ansible-doc -s cron`

(2) 例子

```shell
#添加计划任务
ansible dbservers -m cron -a 'minute="*/10" job="/bin/echo hello" name="test cron job"'
192.168.1.108 | CHANGED => {
    "changed": true,
    "envs": [],
    "jobs": [
        "test cron job"
    ]

#查看crontab计划任务
ansible dbservers -a 'crontab -l'
192.168.1.108 | CHANGED | rc=0 >>
#Ansible: test cron job
*/10 * * * * /bin/echo hello

#移除计划任务
ansible dbservers -m cron -a 'minute="*/10" job="/bin/echo hello" name="test cron job" state=absent'

```

### service模块


(1) 功能

远程主机系统服务管理。


`ansible-doc -s service`


在 Ansible中使用service模块来控制管理服务器的运行状态，enable表示是否开机自启动， 值为true或者false，

使用name来定义服务名称使用state指定服务状态，取值为started、stoped、restarted


(2) 示例

```shell
ansible webservers -m service -a "name=nginx state=stopped"
ansible webservers -m service -a "name=nginx state=restarted"
ansible webservers -m service -a "name=nginx state=reloaded"

#安装httpd服务
ansible webservers -m yum -a "name=httpd state=latest"

#查看httpd服务的状态
ansible dbservers -a 'service httpd status'
#查看http服务开机启动状态
ansible dbservers -a 'chkconfig httpd status'

#设置httpd服务为开机自启动
ansible dbservers -m service -a 'enable=ture name=httpd state=started'

ansible webservers -m service -a "name=nginx state=stopped"
ansible webservers -m service -a "name=nginx state=restarted"
ansible webservers -m service -a "name=nginx state=reloaded"
```



## 5.playbook介绍

playbook(也称为剧本)是一个不同于Ansible Ad-hoc命令行执行方式的模式，其功能更为强大灵活。

简而言之，它是一个非常简单的配置管理和多主机部署系统。playbook是由一个或多个“play”组成的列表。play的主要功能是将事先归为一组的主机装扮成通过
ansible中的task事先定义好的角色。

从根本上来讲，所谓的task就是调用Ansible的一个个module将多个play组织在一个playbook中，这样就可以让它们连通起来，并按事先编排的机制同唱一台大戏。

playbook的模板是使用Python的jinjaz2模块来处理的。

另外，playbook也是通过YAML格式来描述定义的，可以实现多台主机的应用部署，语法也并不复杂，大家可以对照官方案例学习其语法，官方提供了大量
的案例。



官方案例址为： https:/github.com/ansible/ansible-examples。



编写playbook

  - 一个剧本（即playbook），可以包含多个play
  - 每个play用于在指定的主机上，通过模块和参数执行相应的任务
  - 每个play可以包含多个任务。
  - 任务有模块和参数构成。


```yaml
---
- 名字: 猴王初问世
  职员表: 猴哥, 大马猴
  场景:
      - 名字: 石头裂开了
      
      - 名字: 天宫震颤了

- 名字: 官封弼马温
  职员表: 猴哥, 玉皇大帝
  场景:
      - 名字: 太白金星骗猴哥
      
      - 名字: 猴哥天宫放马
```


### 5.1 常用命令

#### 1. playbook的核心元素


```
hosts : playbook配置文件作用的主机
tasks: 任务列表
variables: 变量
templates:包含模板语法的文本文件
handlers :由特定条件触发的任务
roles :用于层次性、结构化地组织playbook。roles 能够根据层次型结构自动装载变量文件、tasks以及handlers等
```



#### 2. playbook运行方式

```shell
ansible-playbook first.yml -f 10  # 使用ansible-playbook命令执行playbook
ansible-playbook first.yml --syntax-check    #检查yaml文件的语法是否正确
ansible-playbook first.yml --list-task       #检查tasks任务
ansible-playbook first.yml --list-hosts      #检查生效的主机
ansible-playbook first.yml --start-at-task='Copy Nginx.conf'     #指定从某个task开始运行
ansible-playbook first.yml -k      #用来交互输入ssh密码
ansible-playbook first.yml -K      #用来交互输入sudo密码
ansible-playbook first.yml -u      #指定用户


ansible-playbook --check 只检测可能会发生的改变,但不真执行操作
ansible-playbook --list-hosts 列出运行任务的主机
ansible-playbook --syntax-check playbook.yaml 语法检测
ansible-playbook -t TAGS_NAME playbook.yaml 只执行TAGS_NAME任务


# 也可以使用ansible-lint 命令进行详细检查playbook文件
ansible-lint httpd.yml


# Ansible-playbook新增的功能参数如下：
·--list-tags：      # 列出所有可用的tags。
·--list-tasks：     # 列出所有即将被执行的任务。
·--skip-tags=SKIP_TAGS： # 跳过指定的tags任务。
·--start-at-task=START_AT_TASK：      # 从第几条任务开始执行。
·--step：                             # 逐步执行Playbook定义的任务，并经人工确认后继续执行下一步任务。
·--syntax-check：                     # 检查Playbook中的语法书写。
·-t TAGS，--tags=TAGS：               # 指定执行该tags的任务。


# 在yaml中打标签
# 最简洁的写法
tags: ['one', 'two', 'three']
# 最清晰的写法
tags:
    - one
    - two
    - three

#如果您只想运行一个非常长的剧本的"配置"和"包"部分，您可以在命令行上使用该选项：--tags
$ ansible-playbook example.yml --tags "configuration,packages"


#另一方面，如果要在没有某些标记任务的情况下运行playbook ，可以使用命令行选项：--skip-tags
$ ansible-playbook example.yml --skip-tags "packages"
ansible-playbook playbook.yaml


# Ansible-playbook：其他选项技巧
·--inventory=PATH（-i PATH）：指定inventory文件，默认文件是/etc/ansible/hosts。

·--verbose（-v）：显示详细输出，也可以使用-vvvv显示精确到每分钟的输出。

·--extra-vars=VARS（-e VARS）：定义在Playbook使用的变量，格式为："key=value，key=value"。

·--forks=NUM（-f NUM）：指定并发执行的任务数，默认为5，根据服务器性能，调大这个值可提高Ansible执行效率。

·--connection=TYPE（-c TYPE）：指定连接远程主机的方式，默认为SSH，设为local时，则只在本地执行Playbook，建议不做修改。

·--check：检测模式，Playbook中定义的所有任务将在每台远程主机上进行检测，但并不直正执行。
```

### 5.2 官方案例


Ansible官方案例。

apache.yml

```yml
---
- name: Deploy Apache
  hosts: localhost
  become: yes
  vars:
    http_port: 8001
    max_clients: 200
  tasks:
    - name: Install Apache
      apt:
        name: httpd
        state: latest
    - name: Write the Apache config file
      template:
        src: /srv/httpd.j2
        dest: /etc/httpd.conf
      notify: Restart Apache
    - name: Ensure Apache is running
      service:
        name: httpd
        state: started
  handlers:
    - name: Restart Apache
      service:
        name: httpd
        state: restarted

```

`httpd.conf.j2`模板


```conf
Listen {{ http_port }}

ServerName localhost

MaxClients {{ max_clients }}

<VirtualHost *:{{ http_port }}>
  DocumentRoot /var/www/html
  <Directory /var/www/html>
    AllowOverride All
    Require all granted
  </Directory>
</VirtualHost>
```


```shell
# 查看hosts和task
ansible-playbook apache.yml --list-hosts --list-task
playbook: apache.yml

  play #1 (localhost): localhost        TAGS: []
    pattern: ['localhost']
    hosts (1):
      localhost
    tasks:
      Install Apache    TAGS: []
      Write the Apache config file      TAGS: []
      Ensure Apache is running  TAGS: []

# 执行部署
ansible-playbook apache.yml -f 10
```

参数-f 10提高进程数，ansible默认并行进程是5(Ansible默认是同步阻塞模式，会等待所有机器执行完毕再在前台显示)


### 5.3 playbook的详细说明


#### 定义主机和用户

hosts 定义了主机清单的patterns 来确定哪些主机为执行目标。remote_user指定执行目标主机的执行用户。

```yml
- hosts: localhost
  remote_user: root
```
如果你想要为执行提升权限，可以设置become提权参数

```yaml
---
- hosts: webservers
  remote_user: git
  become: yes
```


当然，你也可以为每个task设置

```yml
---
- hosts: webservers
  remote_user: yourname
  tasks:
    - service:
        name: nginx
        state: started
      become: yes
      become_user: root
      become_method: sudo
```

#### 任务列表

每个play包含一组任务列表， 任务之间是按照从上往下顺序执行的，执行完上一个任务再去执行下一个任务。

运行从上到下运行的剧本时，任务失败的主机将从整个剧本的轮换中删除。 如果失败，只需更正剧本文件并重新运行即可。

- 使用service模块的命令如下

```yaml
tasks:
  - name: make sure apache is running
    service:
      name: httpd
      state: started
```

也可以使用key=value的形式表示模块参数

```yaml
tasks:
  - name: make sure apache is running
    service: name=httpd state=started
```


- 使用command模块的命令如下

command和shell模块只有一组参数，可以直接写在模块后面

```yaml
tasks:
  - name: enable selinux
    command: /sbin/setenforce 1
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand || /bin/true
```

如果想忽略模块的执行错误，可以为模块添加ignore_errors

```yml
tasks:
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand
    ignore_errors: True
```

如果行太长了，可以换行缩进表示

```yml
tasks:
  - name: Copy ansible inventory file to client
    copy: src=/etc/ansible/hosts dest=/etc/ansible/hosts
            owner=root group=root mode=0644
```



- 使用copy模块的命令如下

```yml
tasks:
  - name: Copy a new "ntp.conf" file into place, backing up the original if it differs from the copied version
    copy:
      src: /mine/ntp.conf
      dest: /etc/ntp.conf
      owner: root
      group: root
      mode: '0644'
      backup: yes
```


- 使用template模块的命令如下

也可以使用变量vhost

```yml
tasks:
  - name: create a virtual host file for {{ vhost }}
    template:
      src: somefile.j2
      dest: /etc/httpd/conf.d/{{ vhost }}
```


#### 事件处理Handlers

这些notify动作在play中每个任务块结束时触发，并且即使由多个不同的任务通知，也只会触发一次。

```yml
- name: template configuration file
  template:
    src: template.j2
    dest: /etc/foo.conf
  notify:
     - restart memcached
     - restart apache

handlers:
  - name: restart memcached
    service:
      name: memcached
      state: restarted
  - name: restart apache
    service:
      name: apache
      state: restarted
```
Handlers 也是任务列表，与常规任务没有什么不同，它们由全局惟一的名称引用，并由notify动作通知。
如果没有通知处理程序，它将不会运行。

不管有多少任务通知一个处理程序，它都将只运行一次，即在一个特定play中的所有任务完成之后。

Handlers 里的任务名称 不能使用 变量

在 ansible 2.2之后，handlers 支持listen 来实现监听一个通知程序来实现执行多个通知任务。

```yml
handlers:
    - name: restart memcached
      service:
        name: memcached
        state: restarted
      listen: "restart web services"
    - name: restart apache
      service:
        name: apache
        state: restarted
      listen: "restart web services"

tasks:
    - name: restart everything
      command: echo "this task will restart the web services"
      notify: "restart web services"
```

#### 条件when语句

ansible_os_family 是 facts 或 vars 的变量

```yml
#  若操作系统是 Debian 时就执行关机操作
tasks:
    - name: "shut down Debian flavored systems"
      command: /sbin/shutdown -t now
      when: ansible_os_family == "Debian"
```


failed_when: 满足给定的条件时，使任务失败


```yml
tasks:
    - command: echo faild.
      register: command_result
      failed_when: "'faild' in command_result.stdout"

    - debug: msg="echo test"
```


使用注册变量判断

将给定命令的结果存储在变量中， 并在后续的任务中使用。

```yml
- name: test play
  hosts: all

  tasks:
    - shell: cat /etc/motd
      register: motd_contents

    - shell: echo "motd contains the word hi"
      when: motd_contents.stdout.find('hi') != -1
```


一个使用when的示例


```yml
- name: Ensure docker history packages are removed.
  yum: "name={{ item }} state=removed"
  with_items: "{{ docker_old }}"

- name: Ensure docker packages are installed.
  yum: "name={{ docker_packages }} state=installed  update_cache=yes"
   
- name: Install docker repo.
  shell: "yum-config-manager --add-repo {{ docker_repo }}"
  
- name: Modify the docker software source for keda.
  replace:
    path: /etc/yum.repos.d/docker-ce.repo
    regexp: 'download\.docker\.com'
    replace: "mirrors.ustc.edu.cn/docker-ce"

- name: Create Docker config directory.
  file: path=/etc/docker state=directory

- name: Configure docker startup parameters.
  template:
    src: daemon.json.j2
    dest: "/etc/docker/daemon.json"

- name: Ensure docker-ce are installed.
  yum: "name={{ docker_ce_packages }} state=installed update_cache=yes enablerepo=docker-ce-stable"

- name: Set docker completion.
  copy: src=/usr/share/bash-completion/completions/docker dest=/etc/bash_completion.d/docker remote_src=yes

- name: Ensure docker is started and enabled at boot.
  systemd: name=docker state=started enabled=yes
  when: docker_start

- name: Check if docker-compose file is already.
  stat: path={{ docker_exec_path }}
  register: docker_compose_result

- name: Install docker-compose.
  get_url: url={{ docker_compose_url }} dest={{ docker_exec_path }} validate_certs=no mode=0755
  when: not docker_compose_result.stat.exists
  
- name: docker-compose version.
  command: docker-compose -version
  register: version_result
  changed_when: false
  ignore_errors: True

- debug: var=version_result.stdout
```


#### 循环语句

添加多个用户

```yml
- name: add several users
  user:
    name: "{{ item }}"
    state: present
    groups: "wheel"
  loop:
     - testuser1
     - testuser2
```

```yml
- name: Install Mysql package
  yum: name={{ item }} state=present
  with_items:
   - mysql-server
   - MySQL-python
   - libselinux-python
   - libsemanage-python
```

循环还支持列表，可以通过with_flattened语句实现

```yml
- name: Example with_flattened loop
  hosts: localhost
  gather_facts: false
  vars:
    my_list:
      - [1, 2, 3]
      - [4, 5, 6]
      - [7, 8, 9]
  tasks:
    - name: Print item
      debug:
        msg: "{{ item }}"
      with_flattened:
        - "{{ my_list }}"
```


```shell
ansible-playbook loop.yml -f 10
PLAY [Example with_flattened loop] ******************************************************************************************************************************************************

TASK [Print item] ***********************************************************************************************************************************************************************
Wednesday 09 August 2023  19:19:05 +0800 (0:00:00.018)       0:00:00.018 ******
ok: [localhost] => (item=1) => {
    "msg": 1
}
ok: [localhost] => (item=2) => {
    "msg": 2
}
ok: [localhost] => (item=3) => {
    "msg": 3
}
ok: [localhost] => (item=4) => {
    "msg": 4
}
ok: [localhost] => (item=5) => {
    "msg": 5
}
ok: [localhost] => (item=6) => {
    "msg": 6
}
ok: [localhost] => (item=7) => {
    "msg": 7
}
ok: [localhost] => (item=8) => {
    "msg": 8
}
ok: [localhost] => (item=9) => {
    "msg": 9
}
```


## 6.role角色

层次化，结构化地组织Playbook，使用角色（roles），可以根据层次结构自动装载变量文件，tasks以及handlers等 roles就是将变量、文件、任务、模块及处理器设置于单独的目录中，便捷地使用它们




### 6.1 创建role方式一


```shell
mkdir -p ansible_playbooks/roles/{websrvs,dbsrvs}/{tasks,files,templates,meta,handlers,vars}
mkdir -p ansible_playbooks/group_vars/
touch ansible_playbooks/group_vars/vars.yml
touch ansible_playbooks/hosts
``

一个大型项目级别的目录框架就创建完毕。如下：
```shell
[root@pxe-server ~]# tree ansible_playbooks/
ansible_playbooks/
├── group_vars
│    └── vars.yml                 // 全局变量
|   hosts
└── roles
    ├── dbsrvs                      // dbsrvs应用目录
    │    ├── files
    │    ├── handlers
    │    ├── meta
    │    ├── tasks
    │    ├── templates
    │    └── vars
    └── websrvs                     // websrvs应用目录
        ├── files                   // 安装包、配置文件、脚本文件目录
        ├── handlers                // 触发器配置文件目录
        ├── meta
        ├── tasks                   // 各项任务目录
        ├── templates               // 配置模板文件目录 支持j2格式
        └── vars                    //
17 directories, 0 files

# 注：files、templates、tasks：所有文件、模板都可以放在这里，放在这里最大的好处是不用指定绝对路径
```

### 6.2 创建role方式二

```shell

# - 创建roles目录
mkdir -p /ansible/roles
cd /ansible/roles
ansible-galaxy init backup
ansible-galaxy init nfs
ansible-galaxy init web
ansible-galaxy init lb
ansible-galaxy init db
ansible-galaxy init prometheus
ansible-galaxy init prometheus_db
ansible-galaxy init prometheus_web

# - 查看roles目录下的ansible文件路径
tree /ansible/roles/backup
/ansible/roles/backup/
├── defaults                    存放自定义的变量值
│   └── main.yml
├── files                       放置压缩包,使用文件
├── handlers                    执行剧本文件的目录
│   └── main.yml
├── meta
│   └── main.yml
├── README.md
├── tasks                       执行文件存放的目录
│   └── main.yml
├── templates                   分发的模板文件的目录,模板文件中可以设置变量信息
├── tests
│   ├── inventory
│   └── test.yml
└── vars
    └── main.yml

8 directories, 8 files
```



使用Roles标准目录结构如下（使用tree命令返回的结果）：


```shell
fab2ansible
├── group_vars
│   └── all
├── roles
│   ├── git
│   │   ├── files
│   │   │   └── main.yml
│   │   ├── tasks
│   │   │   ├── create_dir.yml
│   │   │   ├── git_checkout.yml
│   │   │   ├── main.yml
│   │   │   └── static_git_pull.yml
│   │   └── vars
│   │       └── main.yml
│   └── user
│       ├── tasks
│       │   ├── main.yml
│       │   └── user-config.yml
│       └── vars
│           └── main.yml
└── userconf.yml
```



!!!info "参考文献"


    [ansible剧本 一键执行负载均衡+Keepalived+web集群+mysql+redis+NFS+Rsync数据同步+Prometheus+Grafana监控数控库和web集群](https://blog.csdn.net/Yosigo_/article/details/117826510)



### 6.3 多重变量定义

变量除了可以在Inventory中一并定义，也可以独立于Inventory文件之外单独存储到YAML格式的配置文件中，这些文件通常以.yml、.yaml、.json为后缀或者无后缀。变量通常从如下4个位置检索：


```
- Inventory配置文件（默认/etc/ansible/hosts）

- Playbook中vars定义的区域

- Roles中vars目录下的文件

- Roles同级目录group_vars和hosts_vars目录下的文件
```
对于变量的读取，Ansible遵循如上优先级顺序，因此大家设置变量时尽量沿用同一种方式，以方便维护人员管理。




### 6.4 Ansible的内置变量参数

ansible内置了很多其他参数，用于指定其交互方式，如下列举了部分重要参数：

```shell
ansible_host：使用主机的名称去连接，可以使用别名
ansible_port：如果默认不是22的话，要定义ssh的端口号
ansible_user：默认ssh连接用户
ansible_ssh_pass：默认ssh 连接的passwd（不要在这里出现明文密码，而是要使用vault）
ansible_ssh_private_key_file：连接时使用私钥文件。如果不想使用ssh代理的话，可以有多个密钥
ansible_ssh_common_args：该设置将总是为sftp,scp,ssh附加到命令行，可用于为某个主机或组配置ProxyCommand
ansible_sftp_extra_args：该设置将sftp附加到命令行
ansible_scp_extra_args：该设置将scp附加到命令行
ansible_ssh_extra_args：该设置将ssh附件到命令行
ansible_ssh_pipelining：决定是否使用ssh 管道，它将覆盖ansible.cfg中的pipelining设置


# 2.2版本后的特性.
ansible_ssh_executable：这个设置将覆盖使用系统ssh的默认行为。它将覆盖ansible.cfg中的ssh_executable设置
使用特权命令（如sudo）

ansible_become：允许升级权限，相当于 ansible_sudo 或者 ansible_su
ansible_become_method：允许设置特殊权限的方法
ansible_become_user：允许设置特殊权限的用户，相当于 ansible_sudo_user 或者 ansible_su_user
ansible_become_pass：允许设置特殊权限的密码（不要在这里直接输入明文），相当于 ansible_sudo_pass 或者 ansible_su_pass
```


可以参考下面文献：

[使用内置变量](https://ansible.leops.cn/basic/Variables/#_7)



### 6.5 Roles技巧之Files


Files和Templates均用于Ansible文件处理，两者主要区别是：Files（不是file模块）目录下的文件无需写绝对路径即可将文件传输至远程主机；Templates目录下的文件以Jinja2渲染，且传输文件至远程主机的同时支持预定义变量替换


#### 步骤1 

编排目录结构如下:

```shell

file.yml
roles/example/
├── files
│   ├── MAGEDU.PPT
│   └── STANLEY.PPT
├── tasks
│   ├── file.yml
│   └── main.yml

```
./file.yml内容如下：

```yml
---
# 该playbook是整个项目的调度入口

- hosts: 192.168.37.142
  remote_user: root
  gather_facts: false

  roles:
    - role: example
```

./roles/example/tasks/file.yml内容如下：

```yml
---

- name: file change example
  # copy: src=MAGEDU.PPT  dest=/data/magedu.ppt owner=stanley group=stanley
  copy: src={{ item.src }}  dest=/data/{{ item.dest }} owner=stanley group=stanley
  with_items:
      - { src: 'MAGEDU.PPT', dest: 'magedu.ppt' }
      - { src: 'STANLEY.PPT', dest: 'stanley.ppt' }
```

./roles/example/tasks/main.yml内容如下：

```yml

---

- include: file.yml

```

#### 步骤2 

传输文件到远程主机并修改文件名为英文小写。

在roles目录同级目录下执行命令：

```shell
ansible-playbook file.yml
```


### 6.6 Roles技巧之Templates

Templates常被用作传输文件，同时支持预定义变量替换。因Templates由Jinja2渲染格式。


#### 步骤1

编排目录如下。

```shell

template.yml
roles/template/
├── tasks
│   ├── main.yml
│   └── template.yml
├── templates
│   └── order.j2
└── vars
    └── main.yml
```


#### 步骤2

依次编辑tempates.yml（和roles目录同级）任务总调度文件。

```yml
---
# 该playbook是整个项目的调度入口

- hosts: 192.168.37.142
  remote_user: root
  gather_facts: false

  roles:
    - role: template
```

#### 步骤3 

依次编辑roles/template/tasks/{main.yml，template.yml}任务定义文件。


编辑main.yml内容如下：

```yml
---

- include: template.yml
```

main.yml可通过Include灵活引用所需的功能组件，不仅是当前目录下的YML，也可以是其他Roles下的YML。


编辑template.yml内容如下：

```yml
---

- name: tempalte transfer example
  template: src=order.j2 dest=/data/{{ PROJECT }}/order.conf
```

`{{PROJECT}}`的变量引用方式即本节伊始提到的Jinja2格式。

源文件是order.j2，远程目录及目的文件名分别是`/data/{{PROJECT}}/`和`order.conf`。


#### 步骤4 

编辑roles/template/templates/order.j2，定义模板文件。

```conf
project: {{ PROJECT }}
switch: {{ SWITCH }}
dbport: {{ DBPORT }}
```

#### 步骤5 

编辑roles/template/vars/main.yml，定义变量。

```yml
---
PROJECT: "JAVA"
SWITCH: "ON"
DBPORT: "3306"
```

#### 步骤6 

我们来执行命令并看下返回及结果。

执行命令：

```shell
ansible-playbook template.yml
```


Roles中Files和Templates的区别

- Files：用于文件处理，文件无需写绝对路径即可将文件传输至远程主机


- Templates目录下文件以Jinja2渲染，且传输文件至远程主机的同时支持预定义变量替换。通常引用替换变量的的格式为 {{variable}}。



### 6.7 创建roles时的注意事项

```
（1） 目录名同角色名的定义


（2） 目录结构有固定格式

      1）files: 静态文件；

      2）templates: Jinja2模板文件；
      
      3）tasks: 至少有一个main.yml文件,定义各tasks；
      
      4）handlers: 至少有一个main.yml文件，定义各handlers；
      
      5）vars: 至少有一个main.yml文件，定义变量；
      
      6）meta: 定义依赖关系等信息

(3) 在roles之外，通过site.yml定义Playbook，额外也可以有其他的yml
```

### 6.8 案例-Ansible结合Jinja2生成Nginx配置
