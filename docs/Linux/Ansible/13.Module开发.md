# 13.Module开发

## 1.Module 开发说明

### 1.1 模块介绍
模块(也称为task插件或library插件)是可以从命令行或playbook任务中使用的独立单元。Ansible通常在远程目标节点上执行每个模块，并收集返回值。

可以使用下列命令执行模块
```sh
ansible webservers -m service -a "name=httpd state=started"
ansible webservers -m ping
ansible webservers -m command -a "/sbin/reboot -t now"
```

每个模块都支持采用参数。 几乎所有模块都采用key = value参数，以空格分隔。 一些模块不带任何参数，而command/shell模块仅采用要运行命令的字符串。

在playbook中使用模块

```yaml
- name: reboot the servers
  action: command /sbin/reboot -t now

- name: reboot the servers
  command: /sbin/reboot -t now

- name: restart webserver
  service:
    name: httpd
    state: restarted
```

获取模块的帮助信息

```sh
ansible-doc yum
```

获取可用的模块列表

```sh
ansible-doc -l
```

更多命令介绍见[ansible-doc](https://ansible.leops.cn/basic/Ansible-command/#ansible-doc)


### 1.2 开发模块前提

官方是否有提供的类似功能模块？ 可从下面两个连接确定官方提供的模块，以免重复造轮子

- 官方已发布的模块 http://docs.ansible.com/ansible/modules.html

- 官方正在开发的模块 https://github.com/ansible/ansible/labels/module

你需要开发一个action 插件么？ action插件是在ansible主机上运行，而不是在目标主机上运行的。

对于类似file/copy/template功能的模块，在模块执行前需要在ansible主机上做一些操作的。

明确几点

- 模块是传送到目标主机上运行的。
- 模块的返回值必须是json dumps的字符串。

> 模块的通用返回值见[模块返回值](https://ansible.leops.cn/dev/modules/module-return/)


### 1.3 本地添加模块
Ansible自动将在某些目录中找到的所有可执行文件作为模块加载，因此您可以在以下任意位置创建或添加本地模块：

使用环境变量ANSIBLE_LIBRARY定义的目录列表，使用逗号分隔。
```sh
~/.ansible/plugins/modules/
/usr/share/ansible/plugins/modules/
```

针对于playbook使用

- 保存在playbook当前目录library目录中的文件


针对于role使用

- 保存在role目录下library目录中的文件


也可以在配置文件中指定模块目录
Ansible 会在几个地方查找它的模块——首先它会查找config文件(`/etc/ansible/ansible.cfg`)中library键指定的位置，然后它会查找使用命令行中的`--module-path`参数指定的位置，然后它会在与 playbook 相同的目录中查找包含模块的library目录，最后它会在library目录中查找可能设置的任何角色。

```sh
[defaults]
library        = /usr/share/my_modules/
module_utils   = /usr/share/my_module_utils/
```


### 1.4 模块工具

Ansible提供了许多模块实用程序，它们提供了在开发自己的模块时可以使用的辅助功能。 
basic.py模块为程序提供访问Ansible库的主要入口点，所有Ansible模块必须至少从basic.py导入：

```python
from ansible.module_utils.basic import *
```



### 1.5 开发环境

```sh
$ sudo apt-get update
$ sudo apt-get install python-pip python-dev build-essential 
$ git clone https://github.com/ansible/ansible.git
$ cd ansible
$ python -m virtualenv moduledev
New python executable in /home/james/ansible/moduledev/bin/python
Installing setuptools, pip, wheel...done.
```




## 2.工具类
Ansible提供了许多模块实用类，或代码片段来帮助你在Python中快速构建ansible模块。 
这些模块工具类默认存放在 `/usr/lib/python2.7/site-packages/ansible/module_utils/` 中，basic.py模块类是ansible模块的主要入口，常见的工具类是AnsibleModule。

### 2.1 AnsibleModule
想要使用此功能，使用`from ansible.module_utils.basic import AnsibleModule`命令导入即可。

```python
class ansible.module_utils.basic.AnsibleModule(argument_spec, bypass_checks=False, no_log=False, check_invalid_arguments=None, mutually_exclusive=None, required_together=None, required_one_of=None, add_file_common_args=False, supports_check_mode=False, required_if=None, required_by=None)
```


使用此功能，可以在Python中快速构建ansible模块的通用代码(尽管您可以用任何可以返回JSON的东西来编写模块)。

```sh
add_path_info(kwargs)                           # 对于文件结果，请在返回路径中添加有关文件路径的统计信息，以补充有关文件的信息。
atomic_move(src, dest, unsafe_writes=False)     # 原子性的移动文件
backup_local(fn)                                # 对指定文件进行带日期标记的备份，成功或失败时返回True或False
boolean(arg)                                    # 将参数转换为布尔值
digest_from_file(filename, algorithm)           # 返回本地文件的十六进制摘要以获取由名称指定的digest_method；如果文件不存在，则返回None。
exit_json( **kwargs )                           # 以json数据的形式从模块返回
fail_json( **kwargs )                           # 以json数据的形式从模块返回，并带有错误信息。
run_command(args, check_rc=False, close_fds=True, executable=None, data=None, binary_data=False, path_prefix=None, cwd=None, use_unsafe_shell=False, prompt_regex=None, environ_update=None, umask=None, encoding='utf-8', errors='surrogate_or_strict', expand_user_and_vars=True, pass_fds=None, before_communicate_callback=None)                # 执行一个命令,返回rc、stdout和stderr。
get_bin_path(arg, required=False, opt_dirs=None) # 查找系统中的可执行文件的路径。
is_executable(path)                              # 判断给定的路径是否可执行
is_special_selinux_path(path)               # 如果给定的路径位于NFS或其他特殊的fs挂载点上，则返回一个包含(True, selinux上下文)的元组，否则返回将为(False, None)。
load_file_common_arguments(params)          # 封装了file模块的常见选项,以便可以多次利用。
md5(filename) 使用digest_from_file()        # 返回本地文件的MD5摘要
preserved_copy(src, dest)                   # 复制一个文件,保留所有权限
sha1(filename)                              # 使用digest_from_file()返回本地文件的SHA1摘要。
sha256(filename)                            # 使用digest_from_file()返回本地文件的SHA256摘要。
```
更多内容见basic文件：`/usr/lib/python2.7/site-packages/ansible/module_utils/basic.py`


最常用的方法:
- run_command：此方法用于启动外部命令并检索返回代码、stdout的输出以及stderr的输出。

- exit_json：此方法用于在模块成功完成时向 Ansible 返回数据。

- fail_json：此方法用于向 Ansible 发出失败信号，附带错误消息和返回代码。



### 2.2 asic
想要使用此功能，使用`import ansible.module_utils.basic`命令导入即可。
```sh
ansible.module_utils.basic.AnsibleFallbackNotFound 异常
ansible.module_utils.basic.env_fallback(*args, **kwargs) 从环境中加载值
ansible.module_utils.basic.heuristic_log_sanitize( data, no_log_values=None ) 从日志消息中删除类似密码的字符串
ansible.module_utils.basic.remove_values( value, no_log_strings) 从 value 中删除 no_log_strings 字符串中的字符串
```

更多内容见basic文件：/usr/lib/python2.7/site-packages/ansible/module_utils/basic.py

### 2.3 module 工具类的命名和查找

通常，您从名称或位置就可以知道模块工具类的功能。
```sh
lib/ansible/module_utils/urls.py 包含用于解析URL的共享代码
lib/ansible/module_utils/storage/emc/ 包含与EMC相关的共享代码
lib/ansible/modules/storage/emc/ 包含与EMC相关的模块
```
自定义的模块程序遵循此模式，可以很方便的查找和使用。



### 2.4 其他工具类

```sh
api.py - Supports generic API modules
basic.py - General definitions and helper utilities for Ansible modules
common/dict_transformations.py - Helper functions for dictionary transformations
common/file.py - Helper functions for working with files
common/text/ - Helper functions for converting and formatting text.
common/parameters.py - Helper functions for dealing with module parameters
common/sys_info.py - Functions for getting distribution and platform information
common/validation.py - Helper functions for validating module parameters against a module argument spec
facts/ - Directory of utilities for modules that return facts. See PR 23012 for more information
ismount.py - Single helper function that fixes os.path.ismount
json_utils.py - Utilities for filtering unrelated output around module JSON output, like leading and trailing lines
known_hosts.py - utilities for working with known_hosts file
network/common/config.py - Configuration utility functions for use by networking modules
network/common/netconf.py - Definitions and helper functions for modules that use Netconf transport
network/common/parsing.py - Definitions and helper functions for Network modules
network/common/network.py - Functions for running commands on networking devices
network/common/utils.py - Defines commands and comparison operators and other utilises for use in networking modules
powershell/ - Directory of definitions and helper functions for Windows PowerShell modules
pycompat24.py - Exception workaround for Python 2.4
service.py - Utilities to enable modules to work with Linux services (placeholder, not in use)
shell.py - Functions to allow modules to create shells and work with shell commands
six/__init__.py - Bundled copy of the Six Python library to aid in writing code compatible with both Python 2 and Python 3
splitter.py - String splitting and manipulation utilities for working with Jinja2 templates
urls.py - Utilities for working with http and https requests
```



## 3.自定义模块示例

### 3.1 Bash 模块

#### touch模块
https://ansible.leops.cn/dev/modules/module-outher-dev/


#### dir模块
https://ansible.leops.cn/dev/modules/module-shell-dir/

#### docker_facts模块
https://ansible.leops.cn/dev/modules/module-docker-facts/



### 3.2 Python 模块

#### check_user模块
我们需要在 Ansible 顶级目录的 `library` 文件夹中创建`check_user.py`文件。


```python
```

```python
#!/usr/bin/python
from ansible.module_utils.basic import AnsibleModule

def check_user(module, username):
    cmd = "id %s" % username
    rc, out, err = module.run_command(cmd)
    if rc == 0:
        return True
    else:
        return False

def main():
    module = AnsibleModule(
        argument_spec=dict(
            name=dict(required=True, type='str')
        ),
        supports_check_mode=True
    )

    username = module.params['name']
    exists = check_user(module, username)

    result = dict(
        changed=False,
        user_exists=exists
    )

    module.exit_json(**result)

if __name__ == '__main__':
    main()
```

为了验证一切按预期运行，我们可以在`playbooks/check_user_py.yaml`中创建一个新的行动手册，代码如下:


```yaml
---
- hosts: localhost
  connection: local
  vars:
    user_ok: root
    user_ko: this_user_does_not_exists
  tasks:
    - name: 'Check if user {{ user_ok }} exists'
      check_user_py2:
        user: '{{ user_ok }}'
      register: user_exists

    - debug:
        var: user_exists.stdout

    - name: 'Check if user {{ user_ko }} exists'
      check_user_py2:
        user: '{{ user_ko }}'
```



#### complex模块
https://fldop2.flygon.net/#/docs/ext-asb/ext-asb_3



#### get_process_ports模块

用 Python 实现根据进程名称查询进程的端口号的功能

`get_process_ports.py`

```python
#!/usr/bin/python
from ansible.module_utils.basic import AnsibleModule
import subprocess

def get_process_ports(process_name):
    try:
        # 使用 lsof 命令查询指定进程名称的端口号
        # command = 'netstat -tunlp l grep %s l awk \'ffprint $4}}\'| awk -f: \'ffprint $NF}}\'l sort -u'% process name
        command = f'lsof -i -n -P | grep LISTEN |  grep %s  | awk \'{{print $9}}\' | awk -F: \'{{print $NF}}\' | sort -u' % process name
        ports = subprocess.check_output(command, shell=True, universal_newlines=True)
        ports = ports.strip().split('\n')
        return ports
    except Exception as e:
        return str(e)

def main():
    module_args = dict(
        process_name=dict(type='str', required=True)
    )

    result = dict(
        changed=False,
        ports=[],
        error=''
    )

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

    process_name = module.params['process_name']

    # 查询进程端口号
    ports = get_process_ports(process_name)

    if isinstance(ports, list):
        result['ports'] = ports
        module.exit_json(**result)
    else:
        result['error'] = str(ports)
        module.fail_json(msg=f"Failed to get ports for process '{process_name}': {ports}", **result)

if __name__ == '__main__':
    main()
```

使用示例

```yaml
---
- name: Query process ports example
  hosts: localhost
  tasks:
    - name: Get ports for process 'sshd'
      get_process_ports:
        process_name: sshd
      register: process_ports

    - debug:
        var: process_ports
```


在这个示例中，我们调用了自定义模块 `get_process_ports` 并指定了要查询的进程名称为 sshd。

模块将返回包含端口号的 JSON 结果，我们将其注册到 process_ports 变量中，并使用 debug 模块来输出结果。



#### remote_filecopy模块
https://fldop2.flygon.net/#/docs/prac-asb/prac-asb_07


#### remote_copy模块


#### dmidecode模块
https://fldop2.flygon.net/#/docs/ext-asb/ext-asb_3


#### huawei switch模块
https://ansible.leops.cn/dev/modules/huawei-switch/


#### wechat模块
https://ansible.leops.cn/dev/modules/module-wechat/



#### 测试 Python 模块

正如您所看到的，您可以通过创建非常简单的行动手册来运行它们来测试您的模块。为此，我们需要克隆 Ansible 官方存储库(如果您还没有这样做的话):

```sh
git clone git://github.com/ansible/ansible.git --recursive
```
接下来，生成一个环境文件，如下所示:
```sh
source ansible/hacking/env-setup
```

我们现在可以使用test-module实用程序通过传递文件名作为命令行参数来运行脚本:
```sh
ansible/hacking/test-module -m library/check_user_id.py -a "user=root"
```

结果将类似于以下输出:
```sh
* including generated source, if any, saving to: /home/fale/.ansible_module_generated 
* ansiballz module detected; extracted module source to: /home/fale/debug_dir 
*********************************** 
RAW OUTPUT 

{"msg": "User root exists", "invocation": {"module_args": {"user": "root"}}, "gid": 0, "uid": 0, "changed": false} 

*********************************** 
PARSED OUTPUT 
{ 
    "changed": false, 
    "gid": 0, 
    "invocation": { 
        "module_args": { 
            "user": "root" 
        } 
    }, 
    "msg": "User root exists", 
    "uid": 0 
}
```





### 3.3 Ruby 模块



## 4.测试模块



## 5.Module 的帮助文档

https://ansible.leops.cn/dev/modules/module-doc/




## 6.模块架构
https://ansible.leops.cn/dev/modules/module-architecture/#aaction-plugins




## 参考文献

成就感源于创造：自己动手写Ansible模块

- https://junmajinlong.github.io/ansible/16_write_ansible_module/index.html


创建自定义模块

- https://github.com/apachecn/apachecn-devops-zh-pt2/blob/master/docs/learn-ansible-27/07.md
