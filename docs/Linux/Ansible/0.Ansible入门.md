# Ansible入门

## 1.Ansible介绍

Ansible 是2012年推出的一种通用自动化工具，可用于配置管理或工作流程自动化。配置管理是一种" 基础架构代码 "实践，它将事物编码，例如应该在系统上安装什么包和版本，或者应该运行什么守护进程。工作流自动化可能是从配置基础架构到部署软件的任何事情。Ansible 在2015年时被Redhat公司收购。

Ansible是用Python编写的，它使用SSH在不同的机器上执行命令。Ansible是无代理的，这使得入手更容易。您只需要在相关机器上安装SSH和Python。

Ansible使用声明式YAML语言"playbook"将一组主机（"hosts"）映射到定义明确的角色。

声明性用于指示Ansible如何设置或更改事物，Ansible才进行必要的更改。



### Ansible 的目标

一切自动化



### Ansible的使用范围

- 自动化部署应用 
- 自动化管理配置 
- 自动化的持续交付 
- 自动化的云服务管理 
- 自动化网络设备管理

更多信息请参考：

- Ansible官方地址：https://docs.ansible.com/

- GitHub地址：https://github.com/ansible/ansible/blob/devel/docsite/rst/index.rst

- Ansible中文权威地址：http://www.ansible.com.cn/


### Ansible是怎么工作的

![](https://ansible.leops.cn/images/basic/ansible-arch.png)

从上图可以看出，运行ansible的先决条件是，安装ansible到管理节点，定义主机清单，并有一些playbooks定义。

简要的步骤

- 在控制节点上安装ansible 
- 配置主机清单: 将被控节点的连接信息配置到主机清单中。 
- 定义playbook: 指定运行主机和执行任务



让我们来看看我们如何使用Ansible将我们的Ubuntu虚拟机转换为Web服务器。 

您在管理节点上运行Ansible Playbook，它查看您在playbook中定义的命令参数，并通知我们定位到网络组中的节点。 

Ansible然后读取主机清单以查找分配给Web组的节点。

在这一点上，Ansible已经准备好开始工作，所以它将通过ssh远程连接到定义的机器，通常你会想要通过预共享密钥建立一些类型的ssh信任，这样你就不必在进行ssh登陆的时候输入密码。然后Ansible将开始逐步执行playbook中的任务，一次一个任务，从顶部到底部的顺序遍历它们，就像你手动登录执行任务一样。所以，它安装软件包，更新配置文件，使用git部署我们的网站代码，最后启动我们的Web服务。当Ansible很愉快的把一切都按预期的完成，你会得到一个执行成功的状态报告。

可以用动图说明下此次过程。

![](https://ansible.leops.cn/images/basic/ansible-arch.gif)


### 对管理主机的要求
目前,只要机器上安装了 Python 2（版本2.6或2.7）或Python 3（版本3.5及更高版本）都可以运行Ansible (windows系统不可以做管理主机) 管理主机的系统可以是 Red Hat, Debian, CentOS, OS X, BSD的各种版本.



### 对节点主机的要求
通常我们使用 ssh 与节点通信，默认使用 sftp. 如果 sftp 不可用，可在 ansible.cfg 配置文件中配置成 scp 的方式. 

在节点上也需要安装Python 2（2.6或更高版本）或Python 3（3.5或更高版本）



### Ansible 概念

#### 控制节点(Control node)

任何装有Ansible的机器可称为**控制节点**。 您可以从任何控制节点运行命令和剧本，并调用`/usr/bin/ansible`或`/usr/bin/ansible-playbook`。 

您可以将任何安装了Python的计算机用作控制节点,笔记本电脑,共享桌面和服务器都可以运行Ansible。 
但是，不能将Windows计算机用作控制节点。您也可以有多个控制节点。


#### 管理节点(Managed nodes)

使用Ansible管理的网络设备或服务器可称为**管理节点**。 受管节点有时也称为**主机**。 受管节点上是不需要安装Ansible的。

#### 主机清单(Inventory)

托管节点的列表。库存文件有时也称为主机文件。您的目录可以为每个托管节点指定诸如IP地址之类的信息。库存还可以组织托管节点，创建和嵌套组，以便于扩展。要了解更多关于库存的信息，请参见使用主机清单一节。


#### 模块(Modules)

Ansible执行的具体代码。每个模块都有特定的用途，从管理特定类型数据库的用户到管理特定类型网络设备上的VLAN接口。您可以使用任务调用单个模块，也可以调用剧本中的几个不同模块。要了解Ansible包含多少个模块，请查看所有模块的列表。



#### 任务(Tasks)

Ansible的行动单位。tasks包含一组由module组成的任务列表, 您可以使用特别的命令一次性执行单个任务。


#### 剧本(Playbooks)

保存了已排序的任务列表，因此可以按此顺序重复运行这些任务。
剧本可以包括变量和任务。剧本是用 YAML 编写的，易于阅读、编写、共享和理解。
要了解更多关于剧本的信息，请查看剧本。


### 社区活跃

> 统计时间: 2020年04月06日

- Ansible releases 304 
- Ansible modules 3387 
- Galaxy Roles 24,251 
- Github Starts 42,547 
- Github Fork 18,764 
- Github Contributors 4,955




### ansible项目
Ansible Galaxy是一个用于查找，共享，使用Ansible role的在线社区。 https://galaxy.ansible.com/

Ansible Container是一个开源项目，旨在实现整个容器构建，部署和管理过程的自动化。 https://github.com/ansible/ansible-container

Ansible tower 商业项目，使用可视化仪表板，基于角色的访问控制，作业调度，集成通知和图形库存管理来集中和控制IT基础架构。 https://www.ansible.com/products/tower



### Ansible 证书

- AUTOMATION WITH ANSIBLE I (DO407) 了解如何安装和配置Ansible，创建和运行剧本以配置系统，并学习管理主机。
- AUTOMATION WITH ANSIBLE II: RED HAT ANSIBLE TOWER (DO409) 了解使用 Ansible Tower。
- RED HAT CERTIFICATE OF EXPERTISE IN ANSIBLE AUTOMATION (EX407) 测试您使用Ansible自动配置系统和应用程序的技能，知识和能力。 通过此考试，您将获得Ansible Automation的红帽认证证书。



###  Ansible 与其它配置管理的对比

笔者选择了目前几款主流的与 Ansible 功能类似的配置管理软件chef、 Puppet、Saltstack，这里所做的对比不针对各个软件的性能作比较，只是对各个软件的特性做个对比。

|                   | **Ansible**   | **Chef**         | **Puppet**        | **SaltStack**        |
| ----------------- | ------------- | ---------------- | ----------------- | -------------------- |
| **程序语言**      | Python        | Ruby，Erlang     | C++, Clojure      | Python2              |
| **配置文件语言**  | YAML，JSON    | Ruby             | Propfietary       | YAML                 |
| **数据库**        | 否            | PostgreSQL       | PuppetDB          | 无                   |
| **传输方式**      | Ssh           | RabbitMQ         | Mcollective       | ZeroMQ               |
| **发布方式**      | Push          | Pull             | Pull              | Push                 |
| **管理节点**      | A，B，L，O，S | Linux            | Linux             | L，B                 |
| **客户端**        | 否            | A，B，L，O，S，W | A，B，L，O，S，W  | A，B，L，O，S，W     |
| **无代理**        | 是            | 否               | 否                | 否                   |
| **公有云版本**    | AM            | AM/AZ/PR         | 否                | 否                   |
| **公有云管理**    | AM/AZ/OS/GCP  | Fog driver       | AM/AZ/VM/GCP      | salt Cloud           |
| **架构**          | Server        | server/client    | server/client     | server/client        |
| **逐步部署**      | 是            | 是               | 否                | 否                   |
| **企业版UI**      | Ansible Tower | opscode Manage   | Puppet Enterprise | SaltStack Enterprise |
| **开源版UI**      | Semaphore     | Chef Manage      | Foreman           | Slatpad，Saltshaker  |
| **企业版本**      | 是            | 是               | 是                | 是                   |
|                   |               |                  |                   |                      |
| **创建时间**      | 2012年3月6日 |   2009年1月16日  |  2010年9月15日    |  2011年2月21日       |
| **Github Starts** | 42,547        | 6,198            | 5,710             | 10,747                |
| **Github Forks**  | 18,764        | 2,417            | 2,138             | 4,815                |
| **Contributors**  | 4,955         | 586              | 536               | 2,078                |
| **Commits**       | 49,775       | 26,017           | 31,751            |  106,129               |


> 统计时间: 2020年04月06日


### 资源

- 源码：https://github.com/ansible/ansible
- 官方文档： http://docs.ansible.com/
- Jinja2 中文文档： http://docs.jinkan.org/docs/jinja2/
- yaml语法： http://www.yaml.org/
- ansible 电子书: https://www.ansible.com/resources/ebooks
- 白皮书: https://www.ansible.com/resources/whitepapers
- 用户案例: https://www.ansible.com/resources/case-studies


## 2.安装Ansible

学会一个软件的第一件事，就是要在各种环境上安装这个软件，安装好，我们才能进入下一步，跟着我一起来安装 `ansible` 吧

!!! note "对管理主机的要求"
    目前,只要机器上安装了 Python 2（版本2.6或2.7）或Python 3（版本3.5及更高版本）都可以运行Ansible (windows系统不可以做管理主机)
    管理主机的系统可以是 Red Hat, Debian, CentOS, macOS, BSD的各种版本.

!!! note "对节点主机的要求"
    通常我们使用 ssh 与节点通信，默认使用 sftp.  如果 sftp 不可用，可在 ansible.cfg 配置文件中配置成 scp 的方式. 在节点上也需要安装Python 2（2.6或更高版本）或Python 3（3.5或更高版本）

    如果节点启用了`selinux`, 在使用`copy`/`file`/`template`时需要安装 `libselinux-python` 包。

    如果想通过ansible给节点主机安装python模块，可以使用`raw`模块，命令如: 

    ```bash
    ansible myhost --become -m raw -a "yum install -y python2"
    ```
     `raw` 模块 可以原生执行shell命令


### 在管理节点上安装ansible

> 大家选择下面的一种方式进行安装 `ansible`

=== "CentOS/RHEL"
    ``` bash
    sed -e 's!^#baseurl=!baseurl=!g' \
           -e  's!^mirrorlist=!#mirrorlist=!g' \
           -e 's!mirror.centos.org!mirrors.aliyun.com!g' \
           -i  /etc/yum.repos.d/CentOS-Base.repo

    yum install -y epel-release

    sed -e 's!^mirrorlist=!#mirrorlist=!g' \
        -e 's!^metalink=!#metalink=!g' \
        -e 's!^#baseurl=!baseurl=!g' \
        -e 's!//download\.fedoraproject\.org/pub!//mirrors.aliyun.com!g' \
        -e 's!http://mirrors\.aliyun!https://mirrors.aliyun!g' \
        -i /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel-testing.repo

    yum install -y ansible
    ```
=== "Ubuntu"
    ``` bash
    $ sudo apt update
    $ sudo apt install software-properties-common
    $ sudo apt-add-repository --yes --update ppa:ansible/ansible
    $ sudo apt install ansible
    ```
=== "Debian"
    ``` bash
    deb http://ppa.launchpad.net/ansible/ansible/ubuntu trusty main
    $ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 93C4A3FD7BB9C367
    $ sudo apt update
    $ sudo apt install ansible
    ```

=== "FreeBSD"
    ``` bash
    $ sudo pkg install py27-ansible
    # or
    $ sudo pkg install py36-ansible
    ```

=== "dnf"
    ``` bash

    $ sudo dnf install ansible
    ```
    
=== "mac"
    ``` bash
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
    python get-pip.py
    sudo CFLAGS=-Qunused-arguments CPPFLAGS=-Qunused-arguments pip install ansible -i https://mirrors.ustc.edu.cn/pypi/web/simple
    # 通过此方式安装的没有生成/etc/ansible文件，可以手动生成，配置文件示例到https://github.com/ansible/ansible/tree/devel/examples
    ```
=== "pip"
    ``` bash
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
    python get-pip.py
    pip install ansible -i https://mirrors.ustc.edu.cn/pypi/web/simple

    # 通过此方式安装的没有生成/etc/ansible文件，可以手动生成，配置文件示例到https://github.com/ansible/ansible/tree/devel/examples
    ```

=== "Python3"
    ``` bash
    yum install -y python36 python36-tools
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
    python3.6 get-pip.py 
    pip3.6 install ansible -i https://mirrors.ustc.edu.cn/pypi/web/simple
    # 通过此方式安装的没有生成/etc/ansible文件，可以手动生成，配置文件示例到https://github.com/ansible/ansible/tree/devel/examples
    ```
=== "源码"
    ``` bash
    yum install -y  python-setuptools
    easy_install pip
    wget https://github.com/ansible/ansible/archive/v2.9.6.tar.gz
    tar zxf v2.9.6.tar.gz
    cd ./ansible-2.9.6
    pip install -r ./requirements.txt
    python setup.py install
    mkdir /etc/ansible/
    cp examples/{ansible.cfg,hosts} /etc/ansible/
    ```
=== "离线安装"
    ``` bash
    # 以目标主机centos7为测试
    # 1. 下载ansible及依赖系统包
    curl -sSL https://cdn.jsdelivr.net/gh/lework/script/shell/get_packages.sh | bash -s - centos7 ansible
    # 2. 下载好的离线包在当前目录的package_centos7_ansible
    ls package_centos7_ansible
    # 3. 将目录拷贝到目标主机,在当前目录安装
    yum localinstall *.rpm
    ```


### bash命令行自动补全

> 在Ansible 2.9之后，就支持了命令行参数补齐功能

=== "CentOS/RHEL"
    ``` bash
    yum install epel-release
    yum install python-argcomplete
    ```
=== "apt"
    ``` bash
    $ sudo apt install python-argcomplete
    ```
=== "pip"
    ``` bash
    pip install argcomplete
    ```

**将补全加入环境变量**

```bash
activate-global-python-argcomplete
source /etc/profile
```

在bash 小于4.2 时，使用下列命令注册

```bash
$ eval $(register-python-argcomplete ansible)
$ eval $(register-python-argcomplete ansible-config)
$ eval $(register-python-argcomplete ansible-console)
$ eval $(register-python-argcomplete ansible-doc)
$ eval $(register-python-argcomplete ansible-galaxy)
$ eval $(register-python-argcomplete ansible-inventory)
$ eval $(register-python-argcomplete ansible-playbook)
$ eval $(register-python-argcomplete ansible-pull)
$ eval $(register-python-argcomplete ansible-vault)
source /etc/profile
```

## 3.快速开始

跟着我，一步一步的开始 ansible 神奇之旅吧！

### 环境信息

control os:  `centos 7.7`

ansible version: `2.9.6`


### 任务

我们将要在目标主机上安装部署`nginx`服务


### 步骤


#### 0. 安装ansible

> 本次使用的是 `Centos 7.7 x64` 系统

```bash
yum install -y epel-release

sed -e 's!^metalink=!#metalink=!g' \
    -e 's!^#baseurl=!baseurl=!g' \
    -e 's!http://download\.fedoraproject\.org/pub/epel!https://mirrors.tuna.tsinghua.edu.cn/epel!g' \
    -e 's!http://download\.example/pub/epel!https://mirrors.tuna.tsinghua.edu.cn/epel!g' \
    -i /etc/yum.repos.d/epel*.repo
    
yum install -y ansible
yum update python-jinja2

```


#### 1. 定义主机清单

> 定义一个简单的通过ssh认证的主机清单，更多配置见

```
cat /etc/ansible/hosts

192.168.77.131 ansible_ssh_user=root ansible_ssh_pass=xxxx
```

主机清单中的配置含义

- `192.168.77.131`  定义远程主机ip地址
- `ansible_ssh_user` 连接远程主机的用户
- `ansible_ssh_pass` 连接远程主机的用户密码


#### 2. 执行ansible命令

**测试连接状态**

```bash
ansible 192.168.77.131 -m ping
```

命令中的含义
- `192.168.77.131`  用于匹配主机清单中的主机名称
- `-m ping` 指定 `ping` 模块，用于测试与远程主机的连接状态



**安装Nginx**

```bash
# 安装
ansible 192.168.77.131 -m yum -a 'name=nginx'
#卸载
ansible 192.168.77.131 -m yum -a 'name=nginx state=absent'
```

命令中的含义
- `192.168.77.131`  用于匹配主机清单中的主机名称
- `-m yum` 指定 `yum` 模块，用于安装软件
- `-a 'name=nginx'` 指定模块的参数，`name`是软件的名称，默认操作是安装。

**启动Nginx**

```bash

# 启动
ansible 192.168.77.131 -m systemd -a 'name=nginx state=started enabled=yes'


# 关闭
ansible 192.168.1.131 -m systemd -a 'name=nginx state=stopped enabled=yes'

```

命令中的含义
- `192.168.77.131`  用于匹配主机清单中的主机名称
- `-m systemd` 指定 `systemd` 模块，用于管理系统服务
- `-a 'name=nginx state=started enabled=yes'` 指定模块的参数，`name`是软件的名称，`state` 指定管理状态，`enabled` 是否开启自启动。

#### 3. 验证

```bash
curl http://192.168.77.131:80
```

#### 4. 执行ansible playbook


**定义 playbook**

> 也就是任务编排，将上面3个步骤合并在一起。

```shell
# File: install_nginx.yml

---
- hosts: 192.168.77.135
  tasks:
    - name: 安装 nginx.
      yum: name=nginx
    - name: 启动 nginx.
      systemd: name=nginx state=started enabled=yes
    - name: 检查 nginx.
      uri: url=http://127.0.0.1
      register: curl_result
      until: curl_result.status == 200
      retries: 5
      delay: 3
      changed_when: false
      check_mode: no

```

**执行 playbook**

```bash
ansible-playbook install_nginx.yml
```


卸载nginx：
```shell
# File: remove_nginx.yml
---
- hosts: 192.168.77.135
 
  tasks:
    - name: stop nginx
      service: name=nginx state=stopped enabled=no
    - name: remove nginx
      yum: name=nginx state=absent
    - name: remove user nginx
      user: name=nginx state=absent
    - name: remove group nginx
      group: name=nginx state=absent
    - name: web page
      file: 
        path: /usr/share/nginx/html/index.html 
        state: absent
```


恭喜你，你已经学会怎么使用ansible了。下面的课程会使你更加深入的了解 ansible 。



## 4.认识主机清单

Ansible 可同时操作属于一个组的多台主机, 组和主机之间的关系通过 `inventory` 文件配置. 默认的文件路径为 `/etc/ansible/hosts`, 
执行命令的时候使用 `-i` 参数即可指定主机清单。

### 主机清单示例

主机清单文件主要有 `ini` 和 `yaml` 格式两种语法格式

```ini
mail.example.com       # 定义主机fqdn地址, 且已经与控制节点ssh互信

[webservers]  # 方括号[]中是组名
host1  # 定义主机名称, 且已经与控制节点ssh互信
host2:5522  # 指定连接主机和端口号
localhost ansible_connection=local  # ansible_connection可以定义连接类型, local是在本地执行
host3 http_port=80 maxRequestsPerChild=808  # 定义主机变量, 除了ansible定义的特殊名称外，其他的都是主机变量
host4 ansible_host=192.168.1.50 ansible_port=2222 ansible_user=root ansible_password=12345 # 指定别名，定义主机ssh连接信息
www[1:50].example.com # 定义 1-50范围内的主机
www-[a:f].example.com # 定义 a-f 范围内内的主机

[dbservers]
three.example.com  ansible_python_interpreter=/usr/local/bin/python3  # 定义python执行ansible，这个是指定被控节点的。
192.168.77.123  ansible_ruby_interpreter=/usr/bin/ruby.1.9.3  # 定义ruby执行文件
 

[webservers:vars] # 定义webservers组的变量
ntp_server=ntp.example.com
proxy=proxy.example.com

[server:children] # 定义server组的子成员
webservers
dbservers

[server:vars] # 定义server组的变量
zabbix_server:192.168.77.121
```

!!! note
    注意！组名称中不要带`-`

上列配置的一些解释：

- 主机可以在多个组中配置。
- `ansible_connection` 是执行主机的连接类型，默认是smart
- `ansible_host` 主机ssh连接地址
- `ansible_port` 主机ssh连接端口
- `ansible_user` 主机ssh连接用户
- `ansible_password` 主机ssh连接用户密码
- `ansible_python_interpreter` 指定python的执行路径
- `[webservers:vars]`  定义webservers组的变量
- `[server:children]`  定义server组的子成员



也可使使用yaml格式来表示

```yaml

all:
  children:
    usa:
      children:
        southeast:
          children:
            atlanta:
              hosts:
                host1:
                host2:
            raleigh:
              hosts:
                host2:
                host3:
          vars:
            some_server: foo.southeast.example.com
            halon_system_timeout: 30
            self_destruct_countdown: 60
            escape_pods: 2
        northeast:
        northwest:
        southwest:
```


> yaml格式配置的还是挺复杂的，可读性也差，建议使用`ini`方式来设置主机清单。 


### 默认组

在主机清单中，ansible会自动的生成两个组。

- `all`  所有的主机。
- `ungrouped` 包含没有组的主机。

尽管这两个组是永远存在的，但也有可能是隐藏的，不会出现group_names之类的组列表中。


### 主机变量和组变量

如果你不想在主机清单中定义主机的变量或者组的变量，ansible还支持在特定的目录中定义变量。

变量文件必须以yaml语法定义。

如默认在`/etc/ansible/host_vars/` 目录中定义主机变量，文件名称以主机名称命名，结束可以用'.yml', '.yaml', '.json'三种格式。

```bash
cat /etc/ansible/host_vars/host1
---
ntp_server: acme.example.org
database_server: storage.example.org
```


如默认在`/etc/ansible/group_vars/` 目录中定义组变量，文件名称以组名称命名，结束可以用'.yml', '.yaml', '.json'三种格式。

```bash
cat /etc/ansible/group_vars/webservers
---
ntp_server: acme.example.org
database_server: storage.example.org
```


### 变量合并

我们可以通过多种方式给主机定义变量，如果在各个环节都设置了变量，到底哪个变量生效呢？这就要看ansible的变量优先级，优先级高的会覆盖优先级低的变量。

优先顺序，all最低，host最高

- all group
- parent group
- child group
- host

相同组时，默认情况下，按字母顺序后面组的定义会覆盖前面的。也可以使用ansible_group_priority调整优先级，数值越大优先级越高，默认为1，相同优先级时，后者优先。

```ini
[a_group:vars]
testvar=a
ansible_group_priority=10
[b_group]
testvar=b
```


### 使用多个主机清单

在命令参数中，使用多个 `-i` 就可以指定多个主机清单 

```bash
ansible all -i staging -i production -m ping
ansible all -i /tmp/staging -i /tmp/production -m ping
```

也可以指定一个目录

```
inventory/
  01-openstack.yml          # configure inventory plugin to get hosts from Openstack cloud
  02-dynamic-inventory.py   # add additional hosts with dynamic inventory script
  03-static-inventory       # add static hosts
  group_vars/
    all.yml                 # assign variables to all hosts
```

```bash
ansible all -i inventory -m ping
```


### 主机内置变量列表

**用于主机连接**

| 参数               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| ansible_connection | 与主机的连接类型.比如:local,  ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 'smart','smart'   方式会根据是否支持 ControlPersist, 来判断'ssh' 方式是否可行. |

**用于所有连接**

| 参数 |  描述                                          |
| ------------ | ------------------------------------------------------------ |
| ansible_host | 将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置. |
| ansible_port | 连接端口号，如果是ssh的话，默认是22           |
| ansible_user | 用于连接认证的用户名                                            |
| ansible_password | 用于连接认证的用户名密码                                            |

**ssh连接参数**

| 参数 |  描述                                          |
| ------------ | ------------------------------------------------------------ |
| ansible_ssh_private_key_file | ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况. |
| ansible_ssh_common_args      | 此设置附加到sftp，scp和ssh的缺省命令行                       |
| ansible_sftp_extra_args      | 此设置附加到默认sftp命令行。                                 |
| ansible_scp_extra_args       | 此设置附加到默认scp命令行。                                  |
| ansible_ssh_extra_args       | 此设置附加到默认ssh命令行。                                  |
| ansible_ssh_pipelining       | 确定是否使用SSH管道。这可以覆盖ansible.cfg中得设置。      |
| ansible_ssh_executable       | ssh可执行文件                                                |

**权限提升参数**



| 参数               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| ansible_become        | 开启提权，等同于`ansible_sudo`，`ansible_su`              |
| ansible_become_method | 提权方式                                                  |
| ansible_become_user   | 提权用户，等同于`ansible_sudo_user`，`ansible_su_user`    |
| ansible_become_password   | 提权密码,等同于`ansible_sudo_password`，`ansible_su_password` |
| ansible_become_exe    | 提权所用的可执行文件，等同于`ansible_sudo_exe`,`ansible_su_exe`  |
| ansible_become_flags  | 提权命令的参数，等同于`ansible_sudo_flags`,`ansible_su_flags` |

**远程主机环境参数**

| 参数                       | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| ansible_shell_type         | 目标系统的shell类型.默认情况下,命令的执行使用   'sh' 语法,可设置为 'csh' 或 'fish'. |
| ansible_python_interpreter | 目标主机的 python   路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是"/usr/bin/python",比如  \*BSD, 或者 /usr/bin/python |
| ansible_*_interpreter      | 这里的"*"可以是 ruby   或 perl 或其他语言的解释器，作用和ansible_python_interpreter 类似 |
| ansible_shell_executable   | 这将设置ansible控制器将在目标机器上使用的shell，覆盖ansible.cfg中的配置，默认为/bin/sh。 |

**非SSH连接类型参数**

ansible默认是使用 `ssh` 连接主机，但也不限制于这种方式，可以通过使用主机特定参数 `ansible_connection = <connector>`，来更改连接类型。以下是支持的连接类型。

| 参数 |  描述                   |
| ------ | -------------------- |
| local  | 在控制端本地执行     |
| docker | 使用本地Docker客户端 |
| ansible_host | 容器连接的主机 |
| ansible_port | 容器连接的端口 |
| ansible_become | 如果设置为true，则会使用begin_user在容器内进行操作。|
| ansible_docker_extra_args | Docker 的额外参数|

一个创建容器的小例子

```yaml
- name: create jenkins container
  docker_container:
    docker_host: myserver.net:4243
    name: my_jenkins
    image: jenkins

- name: add container to inventory
  add_host:
    name: my_jenkins
    ansible_connection: docker
    ansible_docker_extra_args: "--tlsverify --tlscacert=/path/to/ca.pem --tlscert=/path/to/client-cert.pem --tlskey=/path/to/client-key.pem -H=tcp://myserver.net:4243"
    ansible_user: jenkins
  changed_when: false

- name: create directory for ssh keys
  delegate_to: my_jenkins
  file:
    path: "/var/jenkins_home/.ssh/jupiter"
    state: directory
```

### 在运行的时候增加主机

使用 `add_host` 模块动态添加运行主机，此类主机只有在运行时才会向内存中添加，运行结束后，也不会添加到静态主机清单文件中。

```yaml
- name: add new node into runtime inventory
  add_host:
    hostname: webserver
    groups: web
​    ansible_host: 192.168.77.129
    ansible_port: 22
```

### 限定主机清单的运行主机

使用`--limit hostname`可以在运行任务的时候，只允许在此主机上运行。

```yaml
[root@master ansible]# ansible-playbook test.yml --list-hosts
 playbook: test.yml
  play #1 (test2): test2        TAGS: []
    pattern: [u'test2']
    hosts (3):
      node1
      node3
      node2
[root@master ansible]# ansible-playbook test.yml --list-hosts --limit node3,node2
playbook: test.yml
  play #1 (test2): test2        TAGS: []
    pattern: [u'test2']
    hosts (2):
      node3
      node2
```

### 示例

#### 连接本地主机

不需要在主机清单里定义，直接使用 `localhost` 或 `127.0.0.1` 就可以连接本地了

```bash
# ansible localhost -m ping
localhost | SUCCESS => {
    "changed": false, 
    "ping": "pong"
}

# ansible 127.0.0.1 -m ping
127.0.0.1 | SUCCESS => {
    "changed": false, 
    "ping": "pong"
}

```

#### 使用别名连接主机

**定义主机清单**
```bash
# cat /etc/ansible/hosts

alias_host ansible_host=192.168.77.131 ansible_port=22 ansible_user=root ansible_password=123456 # 指定别名，定义主机ssh连接信息
```
**测试连通性**
```bash
# ansible alias_host -m ping
alias_host | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}
```

#### 使用 ssh 秘钥连接主机
**开启远程主机秘钥认证**
```bash
# echo 'PubkeyAuthentication yes' >> /etc/ssh/sshd_config
# systemctl restart sshd
```

**配置远程主机秘钥**
```bash
# ssh-keygen -t rsa -P '' -b 4096 -f ~/.ssh/id_rsa
# cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
# chmod 600 ~/.ssh/authorized_keys
```

**将刚刚生成的私钥 `~/.ssh/id_rsa` 拷贝到 ansible 节点**
```bash
# mv id_rsa /opt/131.key
# chmod 600 /opt/131.key
```

**定义主机清单**
```bash
# cat /etc/ansible/hosts
192.168.77.131 ansible_ssh_private_key_file=/opt/131.key
```
> 不指定 `ansible_user` 则使用运行ansible命令的用户

!!! note
    如果 `private_key` 使用了 **passphrase** ，可使用下列命令，将密码保存在 ssh-agent 中。
    ```bash
    ssh-agent bash
    ssh-add /opt/131.key
    ```

**测试连通性**
```bash
# ansible 192.168.77.131 -m ping
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}

```

#### 使用 跳板机 连接主机

> 通过 192.168.77.132 连接192.168.77.131， 192.168.77.132 需安装`nc`

**添加132节点到kown_hosts**
```bash
# ssh 192.168.77.132
The authenticity of host '192.168.77.132 (192.168.77.132)' can't be established.
ECDSA key fingerprint is SHA256:2lWSIJMF9r8hnfLwlKONY07eQCeZaDVZ/xWZizr9wqs.
ECDSA key fingerprint is MD5:be:82:d9:23:45:18:f2:e3:fa:32:56:65:c9:b1:4b:07.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.77.132' (ECDSA) to the list of known hosts.
```

1. 使用ssh代理参数配置

**定义主机清单**
```bash
# cat /etc/ansible/hosts
192.168.77.131 ansible_ssh_private_key_file=/root/131.key ansible_ssh_common_args="-o ProxyCommand=\"sshpass -p '123456' ssh -qay -p 22 root@192.168.77.132 'nc %h %p'\""
```
> ansible_ssh_common_args 配置ssh连接的参数

**测试连通性**

```bash
# ansible 192.168.77.131 -m ping
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}
```


2. 使用本地ssh配置主机代理

**配置ssh**

```bash
# cat ~/.ssh/config 
Host 192.168.77.131
        User root
        Port 22
        TCPKeepAlive yes
        ForwardAgent yes
        ProxyCommand sshpass -p '123456' ssh -qaY -p 22 root@192.168.77.132 'nc %h %p'
```

**定义主机清单**
```bash
# cat /etc/ansible/hosts
192.168.77.131 ansible_ssh_private_key_file=/opt/131.key
```

**测试连通性**

```bash
# ansible 192.168.77.131 -m ping
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}

```

3. 使用ssh代理

> 不需要在192.168.77.132上安装nc软件了

**定义主机清单**
```bash
# cat /etc/ansible/hosts
192.168.77.131 ansible_ssh_private_key_file=/root/131.key ansible_ssh_common_args="-o ProxyCommand=\"sshpass -p '123456' ssh -W %h:%p -q -p 22 root@192.168.77.132\""
```
> ansible_ssh_common_args 配置ssh连接的参数

**测试连通性**

```bash
# ansible 192.168.77.131 -m ping
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}
```

#### 命令行指定主机清单

```bash
# ansible -i '192.168.77.131,192.168.77.132' 192.168.77.* -m ping -k
SSH password: 
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}
192.168.77.132 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}

```

通过 `-i` 参数， 指定用逗号分隔的主机列表即可。 

不过不能指定`ansible_*` 开头的变量，即不能定义连接密码。

### 动态主机清单

ansible 不仅可以使用`yaml`,`ini`等格式的静态文件配置主机清单，还可以使用动态的源作为主机清单，详细内容请见使用动态主机



## 5.Patterns 匹配
**Patterns** 是定义Ansible要执行的主机。Ansible Patterns 可以引用一个主机，一个IP地址，一个清单组，一个集合组或清单中的所有主机。 Patterns 具有高度的灵活性，您可以排除或要求主机的子集，使用 **通配符** 或 **正则表达式** 来定义 Patterns 。

**命令格式**

```
ansible <pattern> -m <module_name> -a "<module options>"

ansible-playbook -l <pattern>  [options] playbook.yml
```

**使用示例**

```
ansible * -m service -a "name=httpd state=restarted"

ansible-playbook  -l all playbook.yml
```



在 **playbook** 的剧本中，需要在每个 **play** 中`hosts: `行中定义

```
- name: <play_name>
  hosts: <pattern>
```

**使用示例**

```
- name: restart webservers
  hosts: webservers
```



### 常用匹配

| 描述               | Pattern(s)                      | Targets                                   |
| ------------------ | ------------------------------- | ----------------------------------------- |
| 所有主机           | `all` 或者 `*`                  | 主机清单中的所有主机                      |
| 一个主机(精确匹配) | `host1` 或者 `192.168.77.131`   | `host1` 或者 `192.168.77.131`             |
| 多个主机           | `host1:host2` 或者`host1,host2` | `host1:host2` 或者`host1,host2`           |
| 一个组             | `webservers`                    | `webservers`组中的主机                    |
| 多个组(或匹配)     | `webservers:dbservers`          | `webservers`和`dbservers`所有的主机       |
| 排除组(非模式匹配) | webservers:!atlanta             | `webservers`组中除`atlanta`之外的所有主机 |
| 交集组(交集匹配)   | webservers:&dbservers           | `webservers`和`dbservers`都存在的主机     |

 

**通配符匹配**

```
*.com
web*.com:dbserver
```

`*`表示所有字符

 

**组合匹配**

```
webservers:dbservers:&staging:!phoenix
```

在webservers 或者dbservers 组中，必须还存在于staging 组中，但是不在phoenix 组中



### 局限性

**Patterns** 依赖于 **主机清单** (inventory)，如果说匹配不到主机清单里的数据，则会返回如下警告

```bash
# ansible none -m ping 
[WARNING]: Could not match supplied host pattern, ignoring: none
[WARNING]: No hosts matched, nothing to do
```

### 高级特性

#### 使用变量

在ansible-palybook 命令中，你也可以使用变量来组成这样的表达式，但是你必须使用`-e`的选项来指定这个表达式

**playbook**

```bash
# cat  playbook.yml
---
- name: Using variables in patterns
  hosts: "{{ hosts }}"
  tasks:
    - name: ping
      ping:

```

**执行playbook**

```bash
ansible-playbook playbook.yml -e "hosts=192.168.77.131"
ansible-playbook playbook.yml -e "hosts=192.168.77.132"
```

#### 使用切片

可以使用下标来选择组中的各个主机或范围，类似python中的切片

```
webservers[0]
webservers[1:]
webservers[0:25]
```

- `[0]`表示组第一个成员

- `[1:]` 表示组内第2个含第2个之后的所有成员
- `[0:25] `表示组第1个到第24个成员

#### 正则表达式

在开头的地方使用“~”，表示这是一个正则表达式

```
~(web|db).*\.example\.com
```

#### 限定主机

可以使用命令行选项更改playbook中定义的Patterns 的行为

```
ansible-playbook site.yml -l 192.168.77.129

ansible-playbook site.yml -l @retry_hosts.txt
```

只执行`-l`后的主机, `@`开头指定文件



## 6.使用ad-hoc命令
Ansible ad-hoc 命令使用 `/usr/bin/ansible`命令行工具来自动化一个或多个受管节点上的单个任务。 临时命令既快速又简单，但不可重用。

### ad-hoc 命令

```bash
ansible [pattern] -m [module] -a "[module options]"
```
执行结果说明

rc:  命令返回码（0表示成功）

### ad-hoc 示例

#### 执行shell命令


##### command
```shell
#Execute commands on target 在目标主机上执行指令
 ARG：
	chdir 		#切换目录执行command
 
example：
	ansible all -m command -a 'whoami'

#command模块不能解析shell语句
```

重启服务器

```bash
ansible servers -a "reboot"
```

不指定`-m` 模块时，将使用ansible的默认模块command，它不会通过shell进行处理，所以像`$HOME`和像`“<”`，`“>”`，`“|”`，`“;” `和`“＆”`将不工作



默认情况下，Ansible使用5个并发进程。 如果你要扩大并发，使用`-f 10` 参数指定数量即可。

```bash
ansible servers -a "reboot" -f 10
```

默认情况下，Ansible连接远端用户是当前用户，使用`-u` 参数可以修改

```bash
ansible servers -a "reboot" -f 10 -u root
```

如果运行用户没有权限执行，使用`--become` 可以提升权限,默认是`sudo`方式

```bash
ansible servers -a "reboot" -f 10 -u root --become
ansible servers -a "reboot" -f 10 -u test --become --become-method sudo --become-user root --ask-become-pass
```

`--become-method` 指定提升方式，`--become-user` 指定提升用户 `--ask-become-pass` 告知提升密码



##### shell

```shell
#Execute shell commands on targets在目标主机上执行shell指令
 ARG：
 	chdir		#切换目录执行command
 	executable	#使用其他的shell解析
 
 example:
 	ansible all -m shell -a 'echo "123465"|passwd --stdin root'
```

获取web组里得eth0接口信息

```bash
ansible web -m shell -a "ifconfig eth0|grep addr"
```

##### raw

如果说远程主机没有`python` 模块时，可以使用`raw` 模块执行命令

```bash
ansible web -m raw -a "ifconfig eth0|grep addr"
```

##### script

```shell
#Runs a local script on a remote node after transferring it 在远程主机上执行本地脚本

example：
	ansible all -m script -a "/root/a.sh"		#直接指定本地脚本
```

执行脚本
```shell
ansible web -m script -a ip.sh
```

> 将本地脚本传送到远程节点上运行

 

#### 文件管理

##### copy 
```shell
#copy files to remote locations
ARG:
	backup
	content			#不指定src，由content生成的内容即为复制内容
	dest			#目标路径
	directory_mode	#
	src				#本机路径，如果复制目录，有"/"则表示复制目录下所有文件，否则递归复制整个目录
	remote_src		#从远程主机复制到另一个远程主机
	group			
	owner			#copy之后的属主，属组，权限
	mode

example：
	1.ansible all -m copy -a "src=/etc/passwd dest=/tmp/passwd.ansible mode=644"
	
	2.ansible all -m copy -a 'content="hello world\n" dest=/tmp/hello.txt mode=600'
	#用content生成的内容复制到目标主机名称为hello.txt
	
	3.ansible all -m copy -a 'src=/home/linxi dest=/tmp/'
	#复制改目录到指定目录下
	
#copy 可以创建文件
```


拷贝本地的/etc/hosts 文件到web组所有主机的/tmp/hosts（空目录除外）

```bash
ansible web -m copy -a "src=/etc/hosts dest=/tmp/hosts"
```

 拷贝本地的ntp文件到目的地址，设置其用户及权限，如果目标地址存在相同的文件，则备份源文件。

```bash
ansible web -m copy -a "src=/mine/ntp.conf dest=/etc/ntp.conf owner=root group=root mode=644 backup=yes force=yes"
```

##### fetch
```shell
#Fetch files from remote nodes 从远程主机获取文件
 ARG： 
	dest				#目标
	src					#源
	fail_on_missing		#由于任何原因无法读取远程文件，则任务将失败

example：
	ansible all -m fetch -a 'dest=/tmp/backup.ansible？ src=/etc/passwd'

#fetch复制文件时，会在本地创建目录，将多个主机上的文件都放在改目录下
```

从远端服务器拷贝到本机

```bash
ansible web -m fetch -a "src=/etc/hosts dest=/tmp/temp_hosts flat=yes"
```

##### file 

```shell
#Manage files and file properties管理文件和文件属性
ARG：
	state	#文件属性directory，file,link
	src		#在目标主机上创建符号链接
	path	#创建文件或目录路径
	mode
	owner
	group
	
example:
	ansible all -m file -a "path=/root/ansible state=directory mode=644 owner=root"
	#在目标主机上创建目录
	ansible all -m file -a "src=/etc/fstab path=/root/fatab.link state=link"
	#在目标主机创建链接

#不建议创建文件，
```

更改文件的用户及权限

```bash
ansible web -m file -a "dest=/tmp/a.txt mode=600 owner=user group=user"
```

创建目录，类似mkdir -p

```bash
ansible web -m file -a "dest=/tmp/test mode=755 owner=user group=user state=directory"
```

删除文件或者目录

```bash
ansible web -m file -a "dest=/tmp/test state=absent"
```

创建软连接，并设置所属用户和用户组

```bash
ansible web -m file -a  "src=/file/to/link/to dest=/path/to/symlink owner=user group=user state=link"
```

 touch 一个文件并添加用户读写权限，用户组去除写执行权限，其他组减去读写执行权限

```bash
ansible web -m file -a  "path=/etc/foo.conf state=touch mode='u+rw,g-wx,o-rwx'"
```

##### unarchive

将本地的压缩文件解压到目标主机

```bash
ansible web -m unarchive -a "src=foo.tgz dest=/opt/foo“
```


##### stat

获取远程文件状态信息，包括atime、ctime、mtime、md5、uid、gid等信息。


例子
```shell
ansible webservers -m stat -a "path=/etc/sysctl.conf"
```




##### get_url
```shell
功能：
用于从http、ftp、https服务器上下载文件（类似于wget）


参数：
sha256sum：下载完成后进行sha256 check；
timeout：下载超时时间，默认10s
url：下载的URL
url_password、url_username：主要用于需要用户名密码进行验证的情况
use_proxy：是事使用代理，代理需事先在环境变更中定义

例子：

get_url: url=http://example.com/path/file.conf dest=/etc/foo.conf mode=0440


get_url: url=http://example.com/path/file.conf dest=/etc/foo.conf sha256sum=b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c

ansible webservers -m get_url -a "url=http：//www.baidu.com dest=/tmp/index.html mode=0440 force=yes"
```



#### 管理软件包

apt、yum 模块分表用于管理Ubuntu 系列和RedHat 系列系统软件包

##### apt

更新仓库缓存，并安装"foo"

```bash
ansible web -m apt -a "name=foo update_cache=yes"
```

删除 "foo"
```bash
ansible web -m apt -a "name=foo state=absent"
```


安装  "foo"
```bash
ansible web -m apt -a "name=foo state=present"
```


安装  1.0版本的 "foo"
```bash
ansible web -m apt -a "name=foo=1.00 state=present"
```


安装最新得"foo"
```bash
ansible web -m apt -a "name=foo state=latest"
```


注释：Ansible 支持很多操作系统的软件包管理，使用时-m 指定相应的软件包管理工具模块，如果没有这样的模块，可以自己定义类似的模块或者使用command 模块来安装软件包

##### yum
```shell
#Manages packages with the `yum' package manager 使用yum管理程序包
ARG：
	name		#软件包名称
	state		#install(present or latest),remove(absten or removed)
	disable		#禁用某个安装仓库
	enable		#启用某个安装仓库
	disable_gpg_check	#是否使用gpgcheck

example:
	ansible all -m yum -a "name=nginx state=present"
```

安装 最新的 Apache
```bash
ansible web -m yum -a  "name=httpd state=latest"
```


删除apache
```bash
ansible web -m yum -a  "name=httpd state=absent"
```


从testing 仓库中安装最后一个版本得apache
```bash
ansible web -m yum -a  "name=httpd enablerepo=testing state=present"
```


更新所有的包
```bash
ansible web -m yum -a  "name=* state=latest"
```


安装远程的rpm包
```bash
ansible web -m yum -a  "name=http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm state=present"
```


安装  'Development tools' 包组
```bash
ansible web -m yum -a  "name='@Development tools' state=present"
```

##### package

使用远程主机的包管理器进行安装，卸载，更新软件。相对于`apt`,`yum`而言，兼容性更好。

安装ntpdate

```bash
ansible web -m package -a  "name=ntpdate stat=present"
```



#### 用户和用户组

##### user

```shell
#Manage user accounts,管理用户账户
ARG：
	comment		#描述信息
	expires		#过期时间
	group		#基本组
	groups		#附加组
	home		#家目录路径
	password	#密码
	shell		#用户的shell
	state		#present or absent 创建还是删除
	system		#系统用户
	uid			#用户id
	move_home	#两次创建一个用户，家目录不是同一路径，是否需要直接移动家目录
	generate_ssh_key	#创建用户时，是否同时生成一对秘钥
	create_home	#当创建用户或者家目录不存在时，是否为用户创建家目录
	
example：
	ansible all -m user -a "name=aa uid=5555 state=present shell=/sbin/nologin create_home=no"
```

添加用户 'user'并设置其 uid 和主要的组'admin'
```bash
ansible web -m user -a "name=user comment='I am user' uid=1040 group=admin"
```


添加用户 'user'并设置其登陆shell，并将其假如admins和developers组
```bash
ansible web -m user -a "name=user shell=/bin/bash groups=admins,developers append=yes"
```

删除用户 'user'
```bash
ansible web -m user -a "name=user state=absent remove=yes"
```


创建 user 用户得 2048-bit SSH key，并存放在 ~user/.ssh/id_rsa
```bash
ansible web -m user -a "name=user generate_ssh_key=yes ssh_key_bits=2048 ssh_key_file=.ssh/id_rsa"
```


设置用户过期日期
```bash
ansible web -m user -a "name=user shell=/bin/zsh groups=nobdy expires=1422403387"
```

##### group
```shell
#该模块用于添加或者删除一个group
ARG：
	gid			#set group id
	name=		#set group name
	state		#set group state;the values is "present" or "absent"
	system		#if "yes",indicates that the group create is system group

example:
	1.ansible all -m group -a "gid=3000 name=mygroup state=present system=no"
	#创建一个gid为3000 名称为mygroup的组
	
	2.ansible all -m group -a "gid=3000 name=mygroup state=absent system=no"
	#删除一个gid为3000 名称为mygroup的组

注意:带等号为必填
```

创建 test 组，并设置 gid 为1000
```bash
ansible web -m group -a "name=test gid=1000 state=present"
```

删除 test 组
```bash
ansible web -m group -a "name=test state=absent"
```




#### 版本控制

##### git

Ansible 模块能够通知变更，当代码更新时，可以告诉 Ansible 做一些特定的任务，比如从git 部署代码然后重启 apache 服务等
```bash
ansible web -m git -a "repo=https://github.com/Icinga/icinga2.git dest=/tmp/myapp   version=HEAD"
```

#### 服务管理

##### service
```shell
#Manage services
ARG：
	enable		#开机自启
	name		#服务名称
	pattern		#服务不支持status，无法获取服务状态信息时，可以使用pattern过滤关键字
	runlevel	#启动级别
	state		#设置服务是启动还是停止，reloaded, restarted, started, stopped
	
example：
	ansible all -m service -a "name=nginx state=started "
```

确保 web 组所有主机的 httpd 是启动的
```bash
ansible web -m service -a "name=httpd state=started"
```


重启 web 组所有主机的httpd 服务
```bash
ansible web -m service -a "name=httpd state=restarted"
```


确保web组所有主机的httpd 是关闭的
```bash
ansible web -m service -a "name=httpd state=stopped"
```

##### systemd

启动服务

```bash
ansible web -m systemd -a "state=started name=httpd"
```

重载配置

```bash
ansible web -m systemd -a "daemon_reload=yes"
```

#### 防火墙管理

##### iptables

允许tcp 22端口通过
```bash
ansible all -m iptables  -a "chain=INPUT destination_port=22 protocol=tcp jump=ACCEPT"
```


##### firewalld

运行https端口通过

```bash
ansible all -m firewalld -a "service=https permanent=yes state=enabled"
```


#### 文件内容操作

##### lineinfile

```shell
功能：
lineinfile模块用于替换文本内容和删除文本内容

参数：
path         指定要操作的文件对象 
dest         指定要操作的文件对象
regexp       使用正则表达式（匹配条件，用于替换文件内容使用）
state        当需要删除对应文本时，需要设置state值absent,absent为缺席之意，表示删除，默认值present
insertbefore 在某行之前插入
insertafter  在莫行之后插入
line         要写入文件的内容

例子：
# 在文件末行插入文件
ansible [清单] -m lineinfile -a 'path=/root/test.txt insertafter="EOF" line="1"'

# 在文件首行插入文件
ansible [清单] -m lineinfile -a 'path=/root/test.txt insertbefore="BOF" line="1" state=present'

# 替换某行内容
ansible [清单] -m lineinfile -a 'path=/root/test.txt regexp=5 line=1'

# 删除某行内容
ansible [清单] -m lineinfile -a 'path=/root/test.txt regexp="1" state=absent'
```


开启selinux， 替换以SELINUX=开头的行，如果没有匹配到，则新增一条数据。
```bash
ansible all -m lineinfile  -a "dest=/etc/selinux/config regexp=^SELINUX= line=SELINUX=enforcing"
```


删除以SELINUX=开头的行
```bash
ansible all -m lineinfile  -a "dest=/tmp/config regexp=^SELINUX= state=absent"
```


如果文件中, line值不存在，则向文件中添加line的内容
```bash
ansible all -m lineinfile  -a "dest=/tmp/config  line='test'"
```




##### replace

替换文件内容

```bash
ansible all -m  replace  -a "dest=/etc/selinux/config regexp=^SELINUX=disabled replace=SELINUX=enforcing"
```

#### 定时任务
```shell
 #Manage cron.d and crontab entries管理cron.d和contab条目
 ARG：
 	day			#天
 	hour		#小时
 	minute		#分钟
 	job			#执行指令
 	name		#任务名
 	state		#present or absent
 	user		#执行任务的用户
 	weekday		#星期
 
 example：
 	ansible all -m cron -a 'name="sync time" minute=*/1 job="/usr/sbin/ntpdate 192.168.10.11 &> /dev/null" state=present'
```

每天5点，2点得时候执行 ls -alh > /dev/null

```bash
ansible test -m cron -a "name='check dirs' minute='0' hour='5,2' job='ls -alh > /dev/null'"
```

#### 搜集系统信息

搜集主机的所有系统信息

```bash
ansible all -m setup
```

搜集系统信息并以主机名为文件名分别保存在/tmp/facts 目录

```bash
ansible all -m setup --tree /tmp/facts
```

搜集和内存相关的信息

```bash
ansible all -m setup -a 'filter=ansible_*_mb'
```

搜集网卡信息

```bash
ansible all -m setup -a 'filter=ansible_eth[0-2]'
```

#### 指定连接方式

```bash
ansible all -i 'centos,' -c docker -m shell -a 'ps aux'
ansible all -i 'centos,' -c local -m shell -a 'ifconfig'
```

#### 后台运行

长时间运行的操作可以放到后台执行，ansible 会检查任务的状态；在主机上执行的同一个任

务会分配同一个job ID

后台执行命令3600s，-B 表示后台执行的时间

```bash
ansible all -B 3600 -a "/usr/bin/long_running_operation --do-stuff"
```

**检查任务的状态**

```bash
ansible all -m async_status -a "jid=123456789"
```

后台执行命令最大时间是1800s 即30 分钟，-P 每60s 检查下状态默认15s

```bash
ansible all -B 1800 -P 60 -a "/usr/bin/long_running_operation --do-stuff"
```

### 练习

大家通过下列命令来查看帮助，练习下表格中常用模块的使用。

```bash
ansible-doc file
```


| 类型        | 模块                                                         |
| ----------- | ------------------------------------------------------------ |
| 文件操作    | stat   find   file   lineinfile   blockinfile   template   replace |
| 包管理      | apt   gem   npm   pip   yum   package   easy_install   rpm_key |
| 传输        | fetch   copy   unarchive   get_url                           |
| 用户组      | user   group                                                 |
| 文件包含    | import_tasks   include_tasks   include_vars                  |
| mysql数据库 | mysql_db   mysql_replication   mysql_user                    |
| 服务        | service   systemd   supervisorctl                            |
| 检查        | uri   wait_for                                               |
| 其他        | debug   fail   selinux   set_fact   sysctl   authorized_key  |


## 7.熟悉ansible命令

本文以 **Ansible** 版本 `2.9.6`为准

### ansible

`ansible`命令是 **Ansible** 的核心部分，其主要用于执行ad-hoc命令，即单条命令。默认后面需要跟主机和选项部分，默认不指定模块时，使用的是command模块。

```bash
# ansible --help
usage: ansible [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD]
               [--become-user BECOME_USER] [-K] [-i INVENTORY] [--list-hosts]
               [-l SUBSET] [-P POLL_INTERVAL] [-B SECONDS] [-o] [-t TREE] [-k]
               [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER]
               [-c CONNECTION] [-T TIMEOUT]
               [--ssh-common-args SSH_COMMON_ARGS]
               [--sftp-extra-args SFTP_EXTRA_ARGS]
               [--scp-extra-args SCP_EXTRA_ARGS]
               [--ssh-extra-args SSH_EXTRA_ARGS] [-C] [--syntax-check] [-D]
               [-e EXTRA_VARS] [--vault-id VAULT_IDS]
               [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
               [-f FORKS] [-M MODULE_PATH] [--playbook-dir BASEDIR]
               [-a MODULE_ARGS] [-m MODULE_NAME]
               pattern
```

**位置参数**

| 参数    | 说明     |
| ------- | -------- |
| pattern | 主机匹配 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --ask-vault-pass                                             | 提示输入vault 密码。                                         |
| --list-hosts                                                 | 输出匹配主机的列表。                                         |
| --playbook-dir BASEDIR                                       | 指定playbook目录，为`role`,`group_vars/etc`指定相对路径      |
| --syntax-check                                               | 对playbook进行语法检查，且不执行playbook。                   |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --version                                                    | 显示程序版本信息                                             |
| -B SECONDS, --background SECONDS                             | 异步运行时，多长时间超时。                                   |
| -C, --check                                                  | 只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化。 |
| -D, --diff                                                   | 当更改文件和模板时，显示这些文件得差异，比--check效果好。    |
| -M MODULE_PATH, --module-path MODULE_PATH                    | 要执行的模块的路径，默认路径`~/.ansible/plugins/modules:/usr/share/ansible/plu<br/>                        gins/modules)` |
| -P POLL_INTERVAL, --poll POLL_INTERVAL                       | 设置轮询间隔，默认15秒                                       |
| -a MODULE_ARGS, --args MODULE_ARGS                           | 指定模块参数                                                 |
| -e EXTRA_VARS, --extra-vars EXTRA_VARS                       | 添加附加变量，比如key=value，yaml，json格式。使用`@`指定文件 |
| -f FORKS, --forks FORKS                                      | 指定定要使用的并行进程数，默认为5个。                        |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -l SUBSET, --limit SUBSET                                    | 进一步限制所选主机/组模式，只执行`-l`后的主机和组。          |
| -m MODULE_NAME, --module-name MODULE_NAME                    | 要执行的模块，默认为command。                                |
| -o, --one-line                                               | 压缩输出，尝试将所有内容都在一行上输出。                     |
| -t TREE, --tree                                              | 指定tree的输出目录                                           |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |

**特权升级选项**

| 参数                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| --become-method=BECOME_METHOD | 权限升级方法使用 ，默认为sudo，有效选择：[sudo \| su \| pbrun \| pfexec   \| runas \|    doas \| dzdo] |
| --become-user=BECOME_USER     | 使用哪个用户运行，默认为root                                 |
| -K, --ask-become-pass         | 提供权限提升密码                                             |
| -b, --become                  | 运行权限提升                                                 |

**连接选项**

| 参数                                                         | 说明                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| --private-key=PRIVATE_KEY_FILE,   --key-file=PRIVATE_KEY_FILE | 私钥路径，使用这个文件来验证连接                            |
| --scp-extra-args SCP_EXTRA_ARGS                              | 指定额外的参数传递给`scp` ，例如`-l`                        |
| --sftp-extra-args SFTP_EXTRA_ARGS                            | 指定额外的参数传递给`sftp` ，例如`-f`                       |
| --ssh-common-args SSH_COMMON_ARGS                            | 指定要传递给sftp / scp / ssh的通用参数（例如 ProxyCommand） |
| --ssh-extra-args SSH_EXTRA_ARGS                              | 指定额外的参数传递给`ssh` ，例如`-R`                        |
| -T TIMEOUT,   --timeout=TIMEOUT                              | 指定默认超时时间，默认是10S                                 |
| -c CONNECTION,   --connection=CONNECTION                     | 指定连接类型，默认smart                                     |
| -k, --ask-pass                                               | 要求用户输入请求连接密码                                    |
| -u REMOTE_USER,   --user=REMOTE_USER                         | 指定连接用户                                                |

**示例**：

```bash
ansible all -m ping

ansible 192.168.77.* -m ping

ansible all -m command -a ifconfig

ansible all -m shell -a "ifconfig eth0 |grep 'inet addr' "

ansible -i "192.168.77.129,192.168.77.130" 192.168.77.129  -m ping

ansible -i hosts  all --list-host

ansible -i hosts -l 192.168.77.130 all -m ping -t /tmp -vvvv

ansible web -l @retry_hosts.txt --list-hosts

ansible all -i 192.168.77.133, -m ping -k
```



### ansible-console

交互式命令执行界面

```bash
# ansible-console --help
usage: ansible-console [-h] [--version] [-v] [-b]
                       [--become-method BECOME_METHOD]
                       [--become-user BECOME_USER] [-K] [-i INVENTORY]
                       [--list-hosts] [-l SUBSET] [-k]
                       [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER]
                       [-c CONNECTION] [-T TIMEOUT]
                       [--ssh-common-args SSH_COMMON_ARGS]
                       [--sftp-extra-args SFTP_EXTRA_ARGS]
                       [--scp-extra-args SCP_EXTRA_ARGS]
                       [--ssh-extra-args SSH_EXTRA_ARGS] [-C] [--syntax-check]
                       [-D] [--vault-id VAULT_IDS]
                       [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
                       [-f FORKS] [-M MODULE_PATH] [--playbook-dir BASEDIR]
                       [--step]
                       [pattern]
```

**位置参数**

| 参数    | 说明     |
| ------- | -------- |
| pattern | 主机匹配 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --ask-vault-pass                                             | 提示输入vault 密码。                                         |
| --list-hosts                                                 | 输出匹配主机的列表。                                         |
| --playbook-dir BASEDIR                                       | 指定playbook目录，为`role`,`group_vars/etc`指定相对路径      |
| --step                                                       | 一步一步的运行，每个任务都会循环是否执行                     |
| --syntax-check                                               | 对playbook进行语法检查，且不执行playbook。                   |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --version                                                    | 显示程序版本信息                                             |
| -C, --check                                                  | 只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化。 |
| -D, --diff                                                   | 当更改文件和模板时，显示这些文件得差异，比--check效果好。    |
| -M MODULE_PATH, --module-path MODULE_PATH                    | 要执行的模块的路径，默认路径`~/.ansible/plugins/modules:/usr/share/ansible/plu<br/>                        gins/modules)` |
| -f FORKS, --forks FORKS                                      | 指定定要使用的并行进程数，默认为5个。                        |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -l SUBSET, --limit SUBSET                                    | 进一步限制所选主机/组模式，只执行`-l`后的主机和组。          |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |

**特权升级选项**

| 参数                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| --become-method=BECOME_METHOD | 权限升级方法使用 ，默认为sudo，有效选择：[sudo \| su \| pbrun \| pfexec   \| runas \|    doas \| dzdo] |
| --become-user=BECOME_USER     | 使用哪个用户运行，默认为root                                 |
| -K, --ask-become-pass         | 提供权限提升密码                                             |
| -b, --become                  | 运行权限提升                                                 |

 **连接选项**

| 参数                                                         | 说明                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| --private-key=PRIVATE_KEY_FILE,   --key-file=PRIVATE_KEY_FILE | 私钥路径，使用这个文件来验证连接                            |
| --scp-extra-args SCP_EXTRA_ARGS                              | 指定额外的参数传递给`scp` ，例如`-l`                        |
| --sftp-extra-args SFTP_EXTRA_ARGS                            | 指定额外的参数传递给`sftp` ，例如`-f`                       |
| --ssh-common-args SSH_COMMON_ARGS                            | 指定要传递给sftp / scp / ssh的通用参数（例如 ProxyCommand） |
| --ssh-extra-args SSH_EXTRA_ARGS                              | 指定额外的参数传递给`ssh` ，例如`-R`                        |
| -T TIMEOUT,   --timeout=TIMEOUT                              | 指定默认超时时间，默认是10S                                 |
| -c CONNECTION,   --connection=CONNECTION                     | 指定连接类型，默认smart                                     |
| -k, --ask-pass                                               | 要求用户输入请求连接密码                                    |
| -u REMOTE_USER,   --user=REMOTE_USER                         | 指定连接用户                                                |

 

**示例：**

```bash
ansible-console all -i 192.168.77.133, -m ping -k

root@all (1)[f:5]$ ping

192.168.77.133 | SUCCESS => {
    "changed": false, 
    "ping": "pong"

}
```

 

### ansible-doc

该指令用于查看模块信息，常用参数有两个-l 和 -s 

```bash
# ansible-doc --help
usage: ansible-doc [-h] [--version] [-v] [-M MODULE_PATH]
                   [--playbook-dir BASEDIR]
                   [-t {become,cache,callback,cliconf,connection,httpapi,inventory,lookup,netconf,shell,module,strategy,vars}]
                   [-j] [-F | -l | -s | --metadata-dump]
                   [plugin [plugin ...]]

```

 **位置参数**

| 参数   | 说明 |
| ------ | ---- |
| plugin | 插件 |

**选项参数**

| 参数                                                         | 说明                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| --metadata-dump                                              | 获取所有插件的metadata json数据                         |
| --playbook-dir BASEDIR                                       | 指定playbook目录，为`role`,`group_vars/etc`指定相对路径 |
| --version                                                    | 显示程序版本信息                                        |
| -F, --list_files                                             | 显示插件名称及其源文件，不显示摘要                      |
| -h, --help                                                   | 显示帮助文件                                            |
| -j, --json                                                   | 使用json格式输出                                        |
| -l, --list                                                   | 列出可用的插件                                          |
| -s, --snippet                                                | 显示指定插件的`playbook`摘要                            |
| -t {become,cache,callback,<br />cliconf,connection,httpapi,<br />inventory,lookup,netconf,<br />shell,module,strategy,vars},<br /> --type {become,cache,callback,<br />cliconf,connection,httpapi,<br />inventory,lookup,netconf,<br />shell,module,strategy,vars} | 指定插件类型，默认`module`                              |

 

**示例：**

```bash
ansible-doc -l
ansible-doc yum
ansible-doc yum -s
ansible-doc -t cache -l
ansible-doc -t become -l
```

### ansible-galaxy

ansible-galaxy 指令用于方便的从https://galaxy.ansible.com/ 站点下载第三方扩展模块，我们可以形象的理解其类似于centos下的yum、python下的pip或easy_install

```bash
# ansible-galaxy --help
usage: ansible-galaxy [-h] [--version] [-v] TYPE ...
```

 **位置参数**

| 参数       | 说明                      |
| ---------- | ------------------------- |
| collection | 管理Ansible Galaxy。      |
| role       | 管理Ansible Galaxy role。 |

 **选项参数**

| 参数          | 说明                                            |
| ------------- | ----------------------------------------------- |
| --version     | 显示程序版本号                                  |
| -h, --help    | 显示此帮助信息                                  |
| -v, --verbose | 详细模式（-vvv表示更多，-vvvv表示启用连接调试） |

 

**示例：**

```bash
ansible-galaxy search tomcat  # 搜索角色
ansible-galaxy install aeriscloud.docker #下载角色

ansible-galaxy list ragingbal.tomcat  

ansible-galaxy info ragingbal.tomcat

ansible-galaxy init abc  # 创建角色模板
# 安装的role在 /root/.ansible/roles/
```

 

###  ansible-playbook

对于需反复执行的、较为复杂的任务，我们可以通过定义 Playbook 来搞定。Playbook 是 Ansible 真正强大的地方，它允许使用变量、条件、循环、以及模板，也能通过角色 及包含指令来重用既有内容。

```bash
# ansible-playbook --help
usage: ansible-playbook [-h] [--version] [-v] [-k]
                        [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER]
                        [-c CONNECTION] [-T TIMEOUT]
                        [--ssh-common-args SSH_COMMON_ARGS]
                        [--sftp-extra-args SFTP_EXTRA_ARGS]
                        [--scp-extra-args SCP_EXTRA_ARGS]
                        [--ssh-extra-args SSH_EXTRA_ARGS] [--force-handlers]
                        [--flush-cache] [-b] [--become-method BECOME_METHOD]
                        [--become-user BECOME_USER] [-K] [-t TAGS]
                        [--skip-tags SKIP_TAGS] [-C] [--syntax-check] [-D]
                        [-i INVENTORY] [--list-hosts] [-l SUBSET]
                        [-e EXTRA_VARS] [--vault-id VAULT_IDS]
                        [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
                        [-f FORKS] [-M MODULE_PATH] [--list-tasks]
                        [--list-tags] [--step] [--start-at-task START_AT_TASK]
                        playbook [playbook ...]
```

 

**位置参数**

| 参数     | 说明         |
| -------- | ------------ |
| playbook | playbook文件 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --ask-vault-pass                                             | 提示输入vault 密码。                                         |
| --flush-cache                                                | 清除fact缓存                                                 |
| --force-handlers                                             | 如果任务失败，也要运行handlers                               |
| --list-hosts                                                 | 输出匹配主机的列表。                                         |
| --list-tags                                                  | 列出所有可用的标签                                           |
| --list-tasks                                                 | 列出将要执行的所有任务                                       |
| --skip-tags=SKIP_TAGS                                        | 跳过运行标记此标签的任务                                     |
| -start-at-task=START_AT_TASK                                 | 在此任务处开始运行                                           |
| --step                                                       | 一步一步的执行：在运行之前确认每个任务                       |
| --syntax-check                                               | 对playbook进行语法检查，且不执行playbook。                   |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --version                                                    | 显示程序版本信息                                             |
| -C, --check                                                  | 只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化。 |
| -D, --diff                                                   | 当更改文件和模板时，显示这些文件得差异，比--check效果好。    |
| -M MODULE_PATH, --module-path MODULE_PATH                    | 要执行的模块的路径，默认路径`~/.ansible/plugins/modules:/usr/share/ansible/plu<br/>                        gins/modules)` |
| -e EXTRA_VARS, --extra-vars EXTRA_VARS                       | 添加附加变量，比如key=value，yaml，json格式。使用`@`指定文件 |
| -f FORKS, --forks FORKS                                      | 指定定要使用的并行进程数，默认为5个。                        |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -l SUBSET, --limit SUBSET                                    | 进一步限制所选主机/组模式，只执行`-l`后的主机和组。          |
| -t TAGS, --tags TAGS                                         | 运行指定的带有tags任务                                       |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |

**特权升级选项**

| 参数                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| --become-method=BECOME_METHOD | 权限升级方法使用 ，默认为sudo，有效选择：[sudo \| su \| pbrun \| pfexec   \| runas \|    doas \| dzdo] |
| --become-user=BECOME_USER     | 使用哪个用户运行，默认为root                                 |
| -K, --ask-become-pass         | 提供权限提升密码                                             |
| -b, --become                  | 运行权限提升                                                 |

 **连接选项**

| 参数                                                         | 说明                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| --private-key=PRIVATE_KEY_FILE,   --key-file=PRIVATE_KEY_FILE | 私钥路径，使用这个文件来验证连接                            |
| --scp-extra-args SCP_EXTRA_ARGS                              | 指定额外的参数传递给`scp` ，例如`-l`                        |
| --sftp-extra-args SFTP_EXTRA_ARGS                            | 指定额外的参数传递给`sftp` ，例如`-f`                       |
| --ssh-common-args SSH_COMMON_ARGS                            | 指定要传递给sftp / scp / ssh的通用参数（例如 ProxyCommand） |
| --ssh-extra-args SSH_EXTRA_ARGS                              | 指定额外的参数传递给`ssh` ，例如`-R`                        |
| -T TIMEOUT,   --timeout=TIMEOUT                              | 指定默认超时时间，默认是10S                                 |
| -c CONNECTION,   --connection=CONNECTION                     | 指定连接类型，默认smart                                     |
| -k, --ask-pass                                               | 要求用户输入请求连接密码                                    |
| -u REMOTE_USER,   --user=REMOTE_USER                         | 指定连接用户                                                |

**示例：**

```bash
ansible-playbook -i hosts ssh-addkey.yml   # 指定主机清单文件

ansible-playbook -i hosts ssh-addkey.yml  --list-tags   # 列出tags

ansible-playbook -i hosts ssh-addkey.yml  -t install  # 执行install标签的任务

ansible-playbook -i hosts ssh-addkey.yml  -t install -e a=1  # 指定变量
```



### ansible-pull 

pull模式在被配置的机器上运行，速度很快。在这种模式下，你需要提供一个git仓库来供Ansible下载来配置你的机器。

```bash
# ansible-pull --help
usage: ansible-pull [-h] [--version] [-v] [-k]
                    [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER]
                    [-c CONNECTION] [-T TIMEOUT]
                    [--ssh-common-args SSH_COMMON_ARGS]
                    [--sftp-extra-args SFTP_EXTRA_ARGS]
                    [--scp-extra-args SCP_EXTRA_ARGS]
                    [--ssh-extra-args SSH_EXTRA_ARGS] [--vault-id VAULT_IDS]
                    [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
                    [-e EXTRA_VARS] [-t TAGS] [--skip-tags SKIP_TAGS]
                    [-i INVENTORY] [--list-hosts] [-l SUBSET] [-M MODULE_PATH]
                    [-K] [--purge] [-o] [-s SLEEP] [-f] [-d DEST] [-U URL]
                    [--full] [-C CHECKOUT] [--accept-host-key]
                    [-m MODULE_NAME] [--verify-commit] [--clean]
                    [--track-subs] [--check] [--diff]
                    [playbook.yml [playbook.yml ...]]
```

**位置参数**

| 参数     | 说明         |
| -------- | ------------ |
| playbook | playbook文件 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --accept-host-key                                            | 指定仓库的主机秘钥                                           |
| --ask-vault-pass                                             | 提示输入vault 密码。                                         |
| --check                                                      | 只做检查，不做更改                                           |
| --clean                                                      | 工作存储库中的已修改文件将被删除                             |
| --diff                                                       | 更改（小的）文件和模板时，显示这些文件中的差异               |
| --full                                                       | 完整克隆                                                     |
| --list-hosts                                                 | 输出匹配主机列表                                             |
| --purge                                                      | 运行后清除                                                   |
| --skip-tags SKIP_TAGS                                        | 跳过运行标记此标签的任务                                     |
| --track-subs                                                 | 模块将跟踪最新的变化。   这相当于指定--remote标志来git子模块更新 |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --verify-commit                                              | 验证已检出提交的GPG签名，如果失败则中止运行剧本。            |
| --version                                                    | 显示程序版本信息                                             |
| -C CHECKOUT,   --checkout=CHECKOUT                           | 指定克隆的分支                                               |
| -M MODULE_PATH, --module-path MODULE_PATH                    | 要执行的模块的路径，默认路径`~/.ansible/plugins/modules:/usr/share/ansible/plu<br/>                        gins/modules)` |
| -U URL, --url URL                                            | playbook仓库的地址                                           |
| -d DEST, --directory DEST                                    | 指定检出目录                                                 |
| -e EXTRA_VARS, --extra-vars EXTRA_VARS                       | 添加附加变量，比如key=value，yaml，json格式。使用`@`指定文件 |
| -f FORKS, --forks FORKS                                      | 指定定要使用的并行进程数，默认为5个。                        |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -l SUBSET, --limit SUBSET                                    | 进一步限制所选主机/组模式，只执行`-l`后的主机和组。          |
| -m MODULE_NAME, --module-name MODULE_NAME                    | 仓库模块名称，可选值('git', 'subversion', 'hg', 'bzr')默认为git。 |
| -o, --only-if-changed                                        | 当存储库已更新时才运行剧本                                   |
| -s SLEEP, --sleep SLEEP                                      | 指定睡眠时间                                                 |
| -t TAGS, --tags TAGS                                         | 运行指定的带有tags任务                                       |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |

**特权升级选项**

| 参数                  | 说明             |
| --------------------- | ---------------- |
| -K, --ask-become-pass | 提供权限提升密码 |

 **连接选项**

| 参数                                                         | 说明                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| --private-key=PRIVATE_KEY_FILE,   --key-file=PRIVATE_KEY_FILE | 私钥路径，使用这个文件来验证连接                            |
| --scp-extra-args SCP_EXTRA_ARGS                              | 指定额外的参数传递给`scp` ，例如`-l`                        |
| --sftp-extra-args SFTP_EXTRA_ARGS                            | 指定额外的参数传递给`sftp` ，例如`-f`                       |
| --ssh-common-args SSH_COMMON_ARGS                            | 指定要传递给sftp / scp / ssh的通用参数（例如 ProxyCommand） |
| --ssh-extra-args SSH_EXTRA_ARGS                              | 指定额外的参数传递给`ssh` ，例如`-R`                        |
| -T TIMEOUT,   --timeout=TIMEOUT                              | 指定默认超时时间，默认是10S                                 |
| -c CONNECTION,   --connection=CONNECTION                     | 指定连接类型，默认smart                                     |
| -K, --ask-become-pass                                        | 要求用户输入请求连接密码                                    |
| -u REMOTE_USER,   --user=REMOTE_USER                         | 指定连接用户                                                |

**示例：**

```bash
ansible-pull -o -C master -d /tmp/pull -i /tmp/pull/hosts -U https://github.com/lework/Ansible-Pull-Example.git
```



### ansible-config

编辑管理ansible配置

```bash
# ansible-config --help
usage: ansible-config [-h] [--version] [-v] {list,dump,view} ...
```

**位置参数**

| 参数 | 说明               |
| ---- | ------------------ |
| list | 显示所有的参数配置 |
| dump | dump配置           |
| view | 查看配置文件       |

 **选项参数**

| 参数          | 说明                                            |
| ------------- | ----------------------------------------------- |
| --version     | 显示程序版本号                                  |
| -h, --help    | 显示此帮助信息                                  |
| -v, --verbose | 详细模式（-vvv表示更多，-vvvv表示启用连接调试） |

 

**示例：**

```bash
ansible-config view

ansible-config  list

ansible-config  dump
```





 

### ansible-inventory

查看主机清单信息

```bash
# ansible-inventory --help 
usage: ansible-inventory [-h] [--version] [-v] [-i INVENTORY]
                         [--vault-id VAULT_IDS]
                         [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
                         [--playbook-dir BASEDIR] [--list] [--host HOST]
                         [--graph] [-y] [--toml] [--vars] [--export]
                         [--output OUTPUT_FILE]
                         [host|group]
```

 **位置参数**

| 参数       | 说明        |
| ---------- | ----------- |
| host/group | 主机/主机组 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --accept-host-key                                            | 指定仓库的主机秘钥                                           |
| --export                                                     | 导出信息，与--list或--graph一起使用                          |
| --output OUTPUT_FILE                                         | 导出信息到文件，与--list或--graph一起使用                    |
| --playbook-dir BASEDIR                                       | 指定playbook目录，为`role`,`group_vars/etc`指定相对路径      |
| --toml                                                       | 使用toml格式输出,默认是json格式                              |
| --vars                                                       | 输出变量信息，与--list或--graph一起使用                      |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --version                                                    | 显示程序版本信息                                             |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |
| -y, --yaml                                                   | 使用yaml格式输出,默认是json格式                              |

**动作选项**

| 参数        | 说明                             |
| ----------- | -------------------------------- |
| --graph     | 创建主机清单图                   |
| --host HOST | 输出主机清单信息                 |
| --list      | 以json的格式输出所有主机清单信息 |



**示例：**

```bash
ansible-inventory --export --graph

ansible-inventory -i /etc/ansible/hosts --export --list

ansible-inventory --host=192.168.1.100

ansible-inventory --vars --list
 ```



### ansible-vault

ansible-vault主要应用于配置文件中含有敏感信息，又不希望他能被人看到，vault可以帮你加密/解密这个配置文件。这种playbook文件在执行时，需要加上 `--ask-vault-pass`参数，同样需要输入密码后才能正常执行。

```bash
# ansible-vault --help
usage: ansible-vault [-h] [--version] [-v]
                     {create,decrypt,edit,view,encrypt,encrypt_string,rekey}
                     ...
```

**位置参数**

| 参数           | 说明           |
| -------------- | -------------- |
| create         | 创建加密文件   |
| decrypt        | 解密文件       |
| edit           | 编辑加密文件   |
| view           | 查看加密文件   |
| encrypt        | 加密文件       |
| encrypt_string | 输出加密字符串 |
| rekey          | 重新加密文件   |

**选项参数**

| 参数          | 说明                                            |
| ------------- | ----------------------------------------------- |
| --version     | 显示程序版本号                                  |
| -h, --help    | 显示此帮助信息                                  |
| -v, --verbose | 详细模式（-vvv表示更多，-vvvv表示启用连接调试） |

**示例：**

```bash
ansible-vault create # /tmp/123 创建加密文件

ansible-vault view  # /tmp/123 查看加密文件

ansible-vault encrypt  # /tmp/abc 加密文件

ansible-vault decrypt  # /tmp/abc 解密文件

ansible-vault edit  # /tmp/abc 编辑加密文件

ansible-vault encrypt_string '123'  # 输出加密字符串
```


## 8.使用 Playbook


**Playbook**（剧本） 是 **Ansible** 指令的集合，其利用 YAML 语言编写，自上而下按顺序一次执行。

如果Ansible模块是你的车间的工具，那playbook则是你的指导手册，你的主机清单(inventory)是你的原材料。

play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲所谓task无非是调用ansible的一个module。将多个play组织在一个playbook中即可以让它们联同起来按事先编排的机制同唱一台大戏。其主要有以下四部分构成:



- Target section：   定义将要执行 playbook 的远程主机组

- Variable section： 定义 playbook 运行时需要使用的变量

- Task section：     定义将要在远程主机上执行的任务列表

- Handler section：  定义 task 执行完成以后需要调用的任务

 

### Playbook 示例

> centos7 环境

开始书写我们第一个playbook

**第一步：** 定义我们得主机清单

```ini
[web]
192.168.77.129 ansible_ssh_pass=123456
192.168.77.130 ansible_ssh_pass=123456
```

>  注：这里如果做了ssh免密码登陆，可以去掉ansible_ssh_pass

**第二步：** 明确playbook做哪些任务

web组的主机完成下列任务

1. 远程执行用户为root
2. 安装httpd
3. apache配置文件实现自定义http端口和客户端连接数
4. 在配置文件变更的时候，重启httpd
5. 启动httpd，并设置其开机自启动

**第三步：** 书写playbook

> playbook 使用 YAML 标记语言 (see [YAML Syntax](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html#yaml-syntax))  来描述任务的编排

```yaml
---
- hosts: web                 # Target section
  remote_user: root
  vars:                      # Variable section
    http_port: 80
    max_clients: 200
  tasks:                     # Task section
  - name: ensure apache is at the latest version
    yum:
      name: httpd
      state: latest
  - name: write the apache config file
    template:
      src: httpd.j2
      dest: /etc/httpd/conf/httpd.conf
    notify:
    - restart apache
  - name: ensure apache is running
    service:
      name: httpd
      state: started
  handlers:                 # Handler section
    - name: restart apache
      service:
        name: httpd
        state: restarted
```

> `remote_user` `vars` 等等这些都是ansible的playbook对象的关键字, 全部可用的关键字列表见 [Ansible 关键字](/basic/Reference/Keywords/)


当前目录下的 `httpd.j2` 文件内容

```jinja2
ServerRoot "/etc/httpd"
Listen {{ http_port }}

Include conf.modules.d/*.conf

User apache
Group apache

ServerAdmin root@localhost

<Directory />
    AllowOverride none
    Require all denied
</Directory>

DocumentRoot "/var/www/html"

<Directory "/var/www">
    AllowOverride None
    Require all granted
</Directory>

<Directory "/var/www/html">
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
</Directory>

<IfModule dir_module>
    DirectoryIndex index.html
</IfModule>

<Files ".ht*">
    Require all denied
</Files>

ErrorLog "logs/error_log"
LogLevel warn

<IfModule log_config_module>
    LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
    LogFormat "%h %l %u %t \"%r\" %>s %b" common
    <IfModule logio_module>
      LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" %I %O" combinedio
    </IfModule>
    CustomLog "logs/access_log" combined
</IfModule>

<IfModule alias_module>
    ScriptAlias /cgi-bin/ "/var/www/cgi-bin/"
</IfModule>

<Directory "/var/www/cgi-bin">
    AllowOverride None
    Options None
    Require all granted
</Directory>

<IfModule mime_module>
    TypesConfig /etc/mime.types
    AddType application/x-compress .Z
    AddType application/x-gzip .gz .tgz
    AddType text/html .shtml
    AddOutputFilter INCLUDES .shtml
</IfModule>

AddDefaultCharset UTF-8
<IfModule mime_magic_module>
    MIMEMagicFile conf/magic
</IfModule>

<IfModule mpm_prefork_module>
    ServerLimit        256
    StartServers         5
    MinSpareServers      5
    MaxSpareServers     10
    MaxClients          {{ max_clients }}
    MaxRequestsPerChild  0
</IfModule>

EnableSendfile on
IncludeOptional conf.d/*.conf
```

题外：一个playbook文件可以拥有多个play, 比如我们在加一个`databases`组的数据库安装操作

```yaml
---
- hosts: webservers
  remote_user: root

  tasks:
  - name: ensure apache is at the latest version
    yum:
      name: httpd
      state: latest
  - name: write the apache config file
    template:
      src: httpd.j2
      dest: /etc/httpd/conf/httpd.conf

- hosts: databases
  remote_user: root

  tasks:
  - name: ensure postgresql is at the latest version
    yum:
      name: postgresql
      state: latest
  - name: ensure that postgresql is started
    service:
      name: postgresql
      state: started
```



**第四步：** 运行playbok

```bash
ansible-playbook -i hosts test.yml
```

!!! note "注：还有一种运行方式"

    在yml文件头部加入
    
    ```
    #!/bin/env ansible-playbook
    ```
    
    在给yml文件执行权限
    
    ```bash
    chmod +x t.yml
    ```
    
    运行playbook
    
    ```bash
    ./t.yml
    ```



### 主机和用户

对于每个playbok的play,都会有一个主机和远程用户来确定哪些主机为目标

```yaml
---
- hosts: webservers
  remote_user: root
```

`hosts` 定义了主机清单的`patterns` 来确定哪些主机为执行目标。`remote_user`指定执行目标主机的执行用户。

`remote_user` 也可以为每个`task`设置

```yaml
---
- hosts: webservers
  remote_user: root
  tasks:
    - name: test connection
      ping:
      remote_user: yourname
```

如果你想要为执行提升权限，可以设置`become`提权参数

```yaml
---
- hosts: webservers
  remote_user: yourname
  become: yes
```

当然，你也可以为每个`task`设置

```yaml
---
- hosts: webservers
  remote_user: yourname
  tasks:
    - service:
        name: nginx
        state: started
      become: yes
      become_user: root
      become_method: sudo
```

become 相关参数

- `become`是否开启提权 

- `become_method` 指定提升方式

- `become_user` 指定提升用户
- `become_flags`  提权命令的参数



#### 主机的执行顺序

```yaml
---
- name: exec order
  hosts: all
  order: sorted
  gather_facts: False
  tasks:
    - debug:
        var: inventory_hostname
```

> `play` 也可以加上`name`来标识名称, `gather_facts` 定义不获取主机fact数据

 `order` 参数可以控制主机的 **运行顺序**， 默认是`inventory` 按主机清单的从上到下顺序依次执行，其他的可选值如下表：

| 可选值            | 说明                                     |
| ----------------- | ---------------------------------------- |
| inventory         | 默认值，按主机清单的从上到下顺序依次执行 |
| reverse_inventory | 按主机清单的从下到上顺序依次执行         |
| sorted            | 以主机名称按字母顺序排序                 |
| reverse_sorted    | 以主机名称按字母顺序反序排序             |
| shuffle           | 随机排序                                 |

 

### 任务列表

每个play包含一组任务列表， 任务之间是按照从上往下顺序执行的，执行完上一个任务再去执行下一个任务。

运行从上到下运行的剧本时，任务失败的主机将从整个剧本的轮换中删除。 如果失败，只需更正剧本文件并重新运行即可。

每个任务(task)的目标是执行带有特定参数的模块。 变量可以在模块的参数中使用。

模块应该是幂等的，也就是说，在一个序列中多次运行一个模块应该与只运行它一次具有相同的效果。实现幂等性的一种方法是让一个模块检查它所期望的最终状态是否已经实现，如果已经实现，则退出而不执行任何操作。如果playbook使用的所有模块都是幂等的，那么playbook本身可能也是幂等的，所以重新运行playbook应该是安全的。

每个任务都应该有一个名称(names)，它包含在运行剧本的输出中。这是人类可读的输出，因此提供每个任务步骤的良好描述非常有用。但是，如果没有提供名称，那么将使用提供给 ‘action’ 的字符串作为输出。



任务示例

```yaml
tasks:
  - name: make sure apache is running
    service:
      name: httpd
      state: started
```

也可以使用`key=value`的形式表示模块参数

```yaml
tasks:
  - name: make sure apache is running
    service: name=httpd state=started
```

`command`和`shell`模块只有一组参数，可以直接写在模块后面

```yaml
tasks:
  - name: enable selinux
    command: /sbin/setenforce 1
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand || /bin/true
```

如果想忽略模块的执行错误，可以为模块添加`ignore_errors`

```yaml
tasks:
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand
    ignore_errors: True
```

如果行太长了，可以换行缩进表示

```yaml
tasks:
  - name: Copy ansible inventory file to client
    copy: src=/etc/ansible/hosts dest=/etc/ansible/hosts
            owner=root group=root mode=0644
```

也可以使用变量`vhost`

```yaml
tasks:
  - name: create a virtual host file for {{ vhost }}
    template:
      src: somefile.j2
      dest: /etc/httpd/conf.d/{{ vhost }}
```

task还有一种古老的标记方法，不建议使用这类形式来标记任务。

```yaml
action: template src=templates/foo.j2 dest=/etc/foo.conf
```

### 事件处理Handlers

这些`notify`动作在play中每个任务块结束时触发，并且即使由多个不同的任务通知，也只会触发一次。

```yaml
- name: template configuration file
  template:
    src: template.j2
    dest: /etc/foo.conf
  notify:
     - restart memcached
     - restart apache
```

>  `notify` 定义的时handlers里的任务名称列表

Handlers 也是任务列表，与常规任务没有什么不同，它们由全局惟一的名称引用，并由`notify`动作通知。如果没有通知处理程序，它将不会运行。不管有多少任务通知一个处理程序，它都将只运行一次，即在一个特定`play`中的所有任务完成之后。

```yaml
handlers:
  - name: restart memcached
    service:
      name: memcached
      state: restarted
  - name: restart apache
    service:
      name: apache
      state: restarted
```

Handlers  里的任务名称 **不能使用** 变量

在 ansible 2.2之后，handlers 支持`listen` 来实现监听一个通知程序来实现执行多个通知任务。

```yaml
handlers:
    - name: restart memcached
      service:
        name: memcached
        state: restarted
      listen: "restart web services"
    - name: restart apache
      service:
        name: apache
        state: restarted
      listen: "restart web services"

tasks:
    - name: restart everything
      command: echo "this task will restart the web services"
      notify: "restart web services"
```



### 执行 Playbook

使用`ansible-playbook`命令执行`playbook`

```bash
ansible-playbook playbook.yml -f 10
```

在执行playbook前，可以做些检查

1. 检查palybook语法

   ```bash
   ansible-playbook -i hosts httpd.yml --syntax-check
   ```

2. 列出要执行的主机

   ```bash
   ansible-playbook -i hosts httpd.yml --list-hosts
   ```

3. 列出要执行得任务

   ```bash
   ansible-playbook -i hosts httpd.yml --list-tasks
   ```



也可以使用`ansible-lint` 命令进行详细检查playbook文件

```bash
ansible-lint httpd.yml
```

 [ansible-lint 默认规则](https://docs.ansible.com/ansible-lint/rules/default_rules.html) 页面描述了每一个错误信息。



#### playbook执行顺序

一个playbook的内容，是按照下列表依次执行的

1. Variable loading  变量加载

2. Fact gatherin      是否获取fact数据

3. The pre_tasks execution  执行pre_tasks任务

4. Handlers notified from the pre_tasks execution  执行pre_tasks任务里的事件通知

5. Roles execution  执行roles角色

6. Tasks execution  执行tasks任务

7. Handlers notified from roles or tasks execution 执行tasks任务里的事件通知

8. The post_tasks execution 执行post_tasks任务

9. Handlers notified from post_tasks execution 执行post_tasks任务里的事件通知


## 9.包含和角色

虽然可以在一个非常大的文件中编写 playbook (您可能以这种方式开始学习 palybook)，但最终您将希望重用文件并开始组织工作。在Ansible中，有三种方法可以做到这一点: `includes`, `imports`, and`roles`。

`includes` 和`imports`（在Ansible 2.4版中添加）允许用户将大型playbook拆分成较小的文件，这些文件可以在多个父级playbook中使用，甚至可以在同一Playbook中多次使用。



### 动态和静态

对于可重用的内容，Ansible有两种操作模式: **动态** 和 **静态** 。

在Ansible 2.0中，引入了动态包含的概念。由于以这种方式实现`all include`的一些限制，Ansible 2.1中引入了将`force include`设置为静态的能力。因为`include`任务被重载，包含了静态和动态语法，而且由于`include`的默认行为可能会根据任务上设置的其他选项而更改，所以Ansible 2.4引入了`include`与`import`的概念。



### 静态导入

- 使用`import_tasks`模块来导入`tasks`文件

- 使用`import_role`模块来导入`role`

```yaml
tasks:
  - import_tasks: tasks/foo.yml
  - import_role:
      name: example
```

`import_tasks`还允许 传递变量

```yaml
- import_tasks: wordpress.yml wp_user=timmy

- import_tasks: wordpress.yml
  vars:
    wp_user: timmy
    ssh_keys:
      - keys/one.txt
      - keys/two.txt
```

### 动态包含

- 使用`include_tasks`模块来包含`tasks`文件

- 使用`include_role`模块来包含`role`

 动态包含可以用作循环引用

```yaml
- include_tasks: foo.yml param={{item}}
  with_items: # 循环引用3次
   - 1
   - 2
   - 3
- include_role:
    name: example
```

还可以使用变量引入task文件

```yaml
- include_tasks: "{{inventory_hostname}}.yml"
```

**变量包含**

`include_vars` 在 **task** 中动态加载 **yaml** 或 **json** 文件类型中的变量

 ```yaml
- include_vars: myvars.yml
 ```

根据操作系统类型加载变量文件，如果找不到，则为默认值。

```yaml
- include_vars: "{{ item }}"
  with_first_found:
    - "{{ ansible_distribution }}.yml"
    - "{{ ansible_os_family }}.yml"
    - "default.yml"
```



### 动态与静态两者的区别

- Ansible在Playbook解析时间预处理所有 **静态导入** 。在执行前导入配置文件，出现错误会立即停止
- **动态包含** 是在运行期间遇到该任务时处理的。在执行时导入配置文件，出现错误不会立即停止

当涉及Ansible任务选项时，例如`tags`和条件语句`when`：

- 对于 **动态包含**，任务选项将仅在评估动态任务时应用于该任务，而不会复制到子任务。
- 对于 **静态导入**，父任务选项将被复制到导入中包含的所有子任务。

使用`include*` vs.` import*`有一些优点，也有一些缺点，用户在选择使用它们时应该加以考虑

使用`include*`语句的主要优点是 **循环**。 当 **循环与包含** 一起使用时，将对循环中的 **每个项目执行一次包含的task或role** 。



**与静态导入相比，动态包含的一些限制**

- 您不能使用`notify`来触发来自动态包含的处理程序名称。
- 您不能使用`--start-at-task`在动态包含内的任务开始执行。
- 仅存在于动态包含内的标记不会显示在`-list-tags`输出中。
- 只存在于动态包含内的任务将不会显示在`-list-tasks`输出中。



**与动态包含相比, 静态导入的一些限制**

- 静态导入 **不能用循环**

- 当使用目标文件或角色名称的变量时，不能使用主机清单中的 **变量**
- **handlers** 使用 `import` 导入的处理程序在被其名称通知时不会被触发，因为`import`会用导入的任务列表覆盖 **handler’s**  的指定任务。

 

###  角色ROLE

角色是基于已知文件结构自动加载某些`vars_files`，`tasks`和`handlers`的方法。 按角色分组的内容还允许与其他用户轻松共享角色。

### 角色目录结构

文件结构如下

```bash
webservers.yml
fooservers.yml

group_vars/
   all.yml
   group1.yml
   group2.yml
host_vars/
   hostname1.yml
   hostname2.yml

library/
module_utils/
filter_plugins/

roles/
    common/
        tasks/
        handlers/
        files/
        templates/
        vars/
        defaults/
        meta/
    webservers/
        tasks/
        defaults/
        meta/ 
```

角色必须包含至少一个这样的目录，但是完全可以排除任何没有使用的目录。在使用时，每个目录必须包含一个`main.yml`文件，其中包含相关内容:

- `tasks` - 包含角色要执行的主要任务列表。
- `handlers` - 包含处理程序，可以由此角色使用，甚至可以在此角色以外的任何地方使用。
- `defaults`- 角色的默认变量（有关更多信息，请参阅变量）。
- `vars`- 角色的其他变量（有关更多信息，请参阅变量）。
- `files` - 包含可以通过此角色部署的文件。
- `templates` - 包含可以通过此角色部署的模板。
- `meta` - 为这个角色定义了一些元数据。
- `library`- 如果有任何自定义模块，将其放在这里（可选）
- `filter_plugins` -  如果有任何自定义过滤器插件，将其放在这里（可选）
- `group_var/all` - 如果`group_var/all`存在，其中列出的变量将被添加到所有的主机组中
- `group_var/groupname1` - 如果`group_var/groupname1`存在，其中列出的变量将被添加到groupname1主机组中
- `host_vars/hostname1` - 如果`host_vars/hostname1`存在，其中列出的变量将被添加到hostname1主机组中



除了特定的文件和目录外，也可以包含自定义的文件和目录，比如下面的为每个操作系统设置一个文件

```yaml
# roles/example/tasks/main.yml
- name: added in 2.4, previously you used 'include'
  import_tasks: redhat.yml
  when: ansible_facts['os_family']|lower == 'redhat'
- import_tasks: debian.yml
  when: ansible_facts['os_family']|lower == 'debian'

# roles/example/tasks/redhat.yml
- yum:
    name: "httpd"
    state: present

# roles/example/tasks/debian.yml
- apt:
    name: "apache2"
    state: present
```

### 角色使用

在`play`中使用`roles:` 来定义使用哪些role

```yaml
---
- hosts: webservers
  roles:
    - common
    - webservers
```

这个 playbook 为一个角色 ‘x’ 指定了如下的行为

- 如果 `roles/x/tasks/main.yml` 存在, 其中列出的 tasks 将被添加到 play 中

- 如果 `roles/x/handlers/main.yml` 存在, 其中列出的 handlers 将被添加到 play 中

- 如果 `roles/x/vars/main.yml` 存在, 其中列出的 变量将被添加到 play 中

- 如果  `roles/ x/defaults/main.yml`存在，其中列出的角色默认变量将被添加到play 中

- 如果 `roles/x/meta/main.yml` 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中

- 所有 `copy` tasks 可以引用 `roles/x/files/` 中的文件，不需要指明文件的全路径。

- 所有 `script` tasks 可以引用 `roles/x/files/ `中的脚本，不需要指明文件的全路径。

- 所有 `template` tasks 可以引用 `roles/x/templates/` 中的文件，不需要指明文件的全路径。

- 所有 `include` tasks 可以引用 `roles/x/tasks/` 中的文件，不需要指明文件的全路径。如果 roles 目录下有文件不存在，这些文件将被忽略。

当以这种方式使用时，playbook 的执行顺序如下:

- `pre_tasks` 定义的所有任务
- 到目前触发的`handlers`任务
- `roles`中列出的每个角色将依次执行。 角色`meta/main.yml`中定义的任何角色依赖关系都将首先运行，但要遵循标签过滤和条件。
- `tasks` 定义的所有任务
- 到目前触发的`handlers`任务
- `post_tasks` 定义的所有任务
- 到目前触发的`handlers`任务



从Ansible 2.4开始，您现在可以使用`import role`或`include role`将角色内联到任何其他任务中

```yaml
---
- hosts: webservers
  tasks:
    - debug:
        msg: "before we run our role"
    - import_role:
        name: example
    - include_role:
        name: example
    - debug:
        msg: "after we ran our role"
```

使用角色可以用简单的名称，也可以使用绝对路径引入

```yaml
- hosts: webservers
  roles:
    - role: '/path/to/my/roles/common'
```

`roles` 也可以接受其他关键字

```yaml
---
- hosts: webservers
  roles:
    - common
    - role: foo_app_instance
      vars:
        dir: '/opt/a'
        app_port: 5000
    - role: foo_app_instance
      vars:
        dir: '/opt/b'
        app_port: 5001
```

也可以换种语法书写

```yaml
---
- hosts: webservers
  tasks:
    - include_role:
        name: foo_app_instance
      vars:
        dir: '/opt/a'
        app_port: 5000
  ...
```

可以有条件的导入role

```yaml
---
- hosts: webservers
  tasks:
    - include_role:
        name: some_role
      when: "ansible_facts['os_family'] == 'RedHat'"
```

也可以为角色内的任务分配标签

```yaml
---
- hosts: webservers
  roles:
    - role: foo
      tags:
        - bar
        - baz
    # using YAML shorthand, this is equivalent to the above:
    - { role: foo, tags: ["bar", "baz"] }
```

换一种语法书写

```yaml
---
- hosts: webservers
  tasks:
    - import_role:
        name: foo
      tags:
        - bar
        - baz
```

如果你想只给这个角色本身打上标记

```yaml
---
- hosts: webservers
  tasks:
    - include_role:
        name: bar
      tags:
        - foo
```

> 本例中的标记不会被添加到include角色中的任务中

### 角色重复执行

 Ansible只允许一个角色执行一次，即使定义了多次，如果角色上定义的参数对于每个定义都是相同的。例如

```yaml
---
- hosts: webservers
  roles:
    - foo
    - foo
```

鉴于以上所述，角色foo将只运行一次。

要使角色多次运行，有两种选择：

- 在每个角色定义中传递不同的参数。

  ```yaml
  ---
  - hosts: webservers
    roles:
      - role: foo
        vars:
          message: "first"
      - { role: foo, vars: { message: "second" } }
  ```

- 在角色的 `meta/main.yml` 文件中添加 `allow_duplicates：true`。

  ```yaml
  # playbook.yml
  ---
  - hosts: webservers
    roles:
      - foo
      - foo
  
  # roles/foo/meta/main.yml
  ---
  allow_duplicates: true
  ```


### 角色默认变量

定义角色默认变量，只需在角色目录中添加一个`defaults/main.yml`文件。角色默认变量优先级最低,很容易被其他变量覆盖掉。

 

### 角色依赖

角色依赖性使您可以在使用角色时 **自动导入** 其他角色。 角色相关性存储在角色目录中包含的`meta/main.yml`文件中，如上所述。 该文件应包含要在指定角色之前插入的角色和参数的列表，例如在`role/myapp/meta/main.yml`示例中的以下内容：

```yaml
---
dependencies:
  - role: common
    vars:
      some_parameter: 3
  - role: apache
    vars:
      apache_port: 80
  - role: postgres
    vars:
      dbname: blarg
      other_parameter: 12
```

> 角色依赖项必须使用经典的角色定义样式。

角色依赖项始终在包含它们的角色之前执行，并且可能是递归的。 依赖性也遵循上面指定的复制规则。 如果另一个角色也将其列为依赖项，则不会根据上述相同规则再次运行它。

> 永远记住，当使用`allow_duplicates：true`时，它必须位于从属角色的`meta/main.yml`中，而不是父角色中。

例如，一个名为car的角色依赖于一个名为wheel的角色，如下所示

```yaml
---
dependencies:
  - role: wheel
    vars:
      n: 1
  - role: wheel
    vars:
      n: 2
  - role: wheel
    vars:
      n: 3
  - role: wheel
    vars:
      n: 4
```

`wheel`角色又依赖两个角色：`tire`和`brake`。 wheel的`meta/main.yml`包含以下内容：

```yaml
---
dependencies:
  - role: tire
  - role: brake
```

`tire`和`brake`的`meta/main.yml`将包含以下内容：

```yaml
---
allow_duplicates: true
```

产生的执行顺序如下：

```yaml
tire(n=1)
brake(n=1)
wheel(n=1)
tire(n=2)
brake(n=2)
wheel(n=2)
...
car
```

> 注意，我们在wheel可以不必使用`allow duplicate: true` ，因为car定义的每个role使用不同的参数值。

### 嵌入模块和插件

如果您编写了自定义模块或插件，您可能希望将其作为角色的一部分进行分享。

除了角色的`tasks`和`handlers`结构之外，还要添加一个名为`library`的目录。在这个库目录中，然后将模块直接包含在其中。

比如下面这样

```yaml
roles/
    my_custom_modules/
        library/
            module1
            module2
```

该自定义的模块在角色本身以及在此角色之后调用的任何角色中都是可用的

```yaml
---
- hosts: webservers
  roles:
    - my_custom_modules
    - some_other_role_using_my_custom_modules
    - yet_another_role_using_my_custom_modules
```

相同的情况，如果开发自定义的插件，需要放在`filter_plugins`目录中，角色就可以使用了

```
roles/
    my_custom_filter/
        filter_plugins
            filter1
            filter2
```

如果说模块和插件需要给多个role使用，那就可以放置在ansible的插件目录中，这样，任何role都可以使用了。

```
/etc/ansible/roles/
    filter_plugins
        filter1
    library/
        module1
    my_custom_filter/
    my_custom_modules/
```

### 角色搜索路径

- 位于playbook目录下的`roles/`目录
- 默认情况下的`/etc/ansible/roles`目录

在Ansible 1.4和更高版本中，您可以配置其他`role_path`来搜索角色。 使用此功能可以将所有常见角色签到一个位置，并在多个剧本项目之间轻松共享它们。 有关如何在`ansible.cfg`中进行设置的详细信息，请参见配置Ansible。


### Ansible Galaxy

Ansible Galaxy是一个免费的网站，可以找到，下载，评级，并审查各种社区开发的Ansible角色，可以是一个伟大的方式来启动你的自动化项目。


可以使用`ansible-galaxy` 初始化一个角色基础目录结构

```bash
# ansible-galaxy init demo
- Role demo was created successfully
# tree demo
demo
├── defaults
    └── main.yml
├── files
├── handlers
    └── main.yml
├── meta
    └── main.yml
├── README.md
├── tasks
    └── main.yml
├── templates
├── tests
    ├── inventory
    └── test.yml
└── vars
    └── main.yml

8 directories, 8 files
```



### 角色示例参考

https://galaxy.ansible.com/

https://github.com/ansible/ansible-examples 

https://github.com/lework/Ansible-roles

https://github.com/geerlingguy

https://github.com/debops


## 10.使用变量

虽然自动化的存在是为了让事情更容易重复，但并非所有的系统都是完全相同的;有些可能需要的配置与其他的稍有不同。在某些情况下，所观察到的一个系统的行为或状态可能会影响您配置其他系统的方式。例如，您可能需要找到一个系统的IP地址，并将其用作另一个系统上的配置值。

Ansible使用 **变量(*variables* )** 来帮助处理系统之间的差异。



### 创建有效的变量名

在使用变量之前，你要先知道什么是 **有效** 的变量名称, 以下是变量名的遵循规则

- 变量名称应为 **字母**，**数字** 和 **下划线**。 

- 变量应始终 **以字母开头**。

- 变量名不应与python属性和方法名冲突。

 YAML还支持将键映射到值的字典

```yaml
foo:
  field1: one
  field2: two
```

然后，您可以使用方括号符号或点符号来引用字典中的特定字段

```yaml
foo['field1']
foo.field2
```

!!! note
	如果选择使用点表示法，请注意某些键可能会引起问题，因为它们与python词典的属性和方法冲突。 如果您使用以两个下划线开头和结尾的键（这些键在python中保留了特殊含义）或为任何已知的公共属性，则应使用方括号而不是点符号。add`, `append`, `as_integer_ratio`, `bit_length`, `capitalize`, `center`, `clear`, `conjugate`, `copy`, `count`, `decode`, `denominator`, `difference`, `difference_update`, `discard`, `encode`, `endswith`, `expandtabs`, `extend`, `find`, `format`, `fromhex`, `fromkeys`, `get`, `has_key`, `hex`, `imag`, `index`, `insert`, `intersection`, `intersection_update`, `isalnum`, `isalpha`, `isdecimal`, `isdigit`, `isdisjoint`, `is_integer`, `islower`, `isnumeric`, `isspace`, `issubset`, `issuperset`, `istitle`, `isupper`, `items`, `iteritems`, `iterkeys`, `itervalues`, `join`, `keys`, `ljust`, `lower`, `lstrip`, `numerator`, `partition`, `pop`, `popitem`, `real`, `remove`, `replace`, `reverse`, `rfind`, `rindex`, `rjust`, `rpartition`, `rsplit`, `rstrip`, `setdefault`, `sort`, `split`, `splitlines`, `startswith`, `strip`, `swapcase`, `symmetric_difference`, `symmetric_difference_update`, `title`, `translate`, `union`, `update`, `upper`, `values`, `viewitems`, `viewkeys`, `viewvalues`, `zfill

 

### 变量使用

#### 通过命令行传递变量(extra vars)

通过`--extra-vars`或`-e`选项来传递`key=value`变量

```bash
ansible-playbook release.yml -e "user=starbuck"
```

当然，也可以传递字典

```bash
ansible-playbook arcade.yml -e '{"pacman":"mrs","ghosts":["inky","pinky","clyde","sue"]}'
```

变量文件的话，也是可以的

```bash
ansible-playbook test.yml -e @variables.yaml
```

yaml格式的变量，也是可以传递的

```bash
ansible-playbook arcade.yml --extra-vars '
pacman: mrs
ghosts:
  - inky
  - pinky
  - clyde
  - sue'
```

#### 在inventory 中定义变量（inventory vars)

通常，您需要为单个主机或清单中的一组主机设置变量。

```ini
host3 http_port=80                        # 定义主机变量
[webservers:vars]                        # 定义组的变量
ntp_server= ntp.example.com
```

#### 在play中定义变量（play vars）

你可以通过`play`的`vars` 关键字来定义变量

```yaml
- hosts: webservers
  vars:
    http_port: 80
```

#### 在角色和文件包含中定义变量(play include_vars)

通过在playbook中定义`include_vars` 模块，来包含变量文件

```yaml
- hosts: webservers
  tasks:
    include_vars: myvars.yml
```

#### 在play中包含变量文件(play vars_files)

你可以通过`play`的`vars_files` 关键字来定义变量的文件

```yaml
- hosts: webservers
  vars_files:
    - /vars/external_vars.yml
```

#### 定义角色默认变量（role defaults vars）

在角色目录中添加一个`defaults/main.yml`文件。文件里存储着`yaml`或`json`格式的数据。

```yaml
# file: roles/x/defaults/main.yml
http_port: 80

```

#### 定义角色变量（role  vars）

在角色目录中添加一个`vars/main.yml`文件。文件里存储着`yaml`或`json`格式的数据。

```yaml
# file: roles/x/vars/main.yml
http_port: 80
```

#### 以交互方式获取变量值( play vars_prompt)

```yaml
---
- hosts: server
  vars_prompt:
    - name: web
      prompt: 'Please input the web server:'
      private: no
```

#### 定义角色变量（role and include vars)

在引入角色的时候，可以像角色传递一些变量

```yaml
roles:
  - { role: app_user, name: Ian    }
```

> `name` 就是传递给角色的变量

#### 注册变量（registered vars）

变量的另一个主要用途是运行命令并将该命令的结果注册为变量。当您执行一个任务并将返回值保存在一个变量中供以后的任务使用时，您将创建一个已注册的变量。

```yaml
---
- hosts: all 
  tasks:

    - shell: uptime
      register: result

    - name: show uptime
      debug: var=result
```

> 此选项将任务的结果存储在变量中，结果参数可以用在模版中。名称为result，使用debug来输出result的信息。也可以使用 `{{ hostvars[inventory_hostname].result.stdout }}` 可以获得注册变量的

结果因模块而异。 每个模块的文档都包含一个`RETURN`部分，描述该模块的返回值。 要查看特定任务的值，请使用`-v`运行您的剧本。

注册变量仅存储在内存中, 当您用循环在任务中注册一个变量时，已注册的变量包含循环中每个项的值。在循环期间放置在变量中的数据结构将包含一个results属性，它是来自模块的所有响应的列表。



以下是一些重要的注册变量的组件：

- changed: 显示是否已更改
- cmd:  执行的命令
- rc: 命令的返回码
- stdout:命令的输出
- stdout_lines: 逐行输出
- stderr: 如果有错误，则输出错误的信息
- stderr_lines: 逐行输出错误信息


#### 动态创建fact变量

使用`set_fact` 在运行中设置 facts 变量

```yaml
tasks:
  - command: whoami
    register: result
  - set_fact: w={{result.stdout}}
  - debug: var=w
```



### 变量优先级

上面列出了大部分的变量定义位置，这些不同位置的变量都是有优先级的，在不同位置上同时设置时，高优先级的会覆盖掉低优先级的变量，

下面是优先级从最小到最大的顺序(最后列出的变量是最高优先级)

1. command line values (eg “-u user”)  
2. role defaults 
3. inventory file or script group vars
4. inventory group_vars/all
5. playbook group_vars/all
6. inventory group_vars/*
7. playbook group_vars/* 
8. inventory file or script host vars
9. inventory host_vars/* 
10. playbook host_vars/* 
11. host facts / cached set_facts 
12. play vars
13. play vars_prompt
14. play vars_files
15. role vars (defined in role/vars/main.yml)
16. block vars (only for tasks in block)
17. task vars (only for the task)
18. include_vars
19. set_facts / registered vars
20. role (and include_role) params
21. include params
22. extra vars (always win precedence) 命令行变量

 

!!! note
	上述描述的是默认规则变量覆盖`hash_behaviour=replace`, 使用`merge` 可以更改为合并。



### 变量范围

您可以根据希望的范围来决定在何处设置变量。Ansible有三个主要的范围 

- 全局：这是由config，环境变量和命令行设置的

- play：每个play和包含的结构，vars条目(vars; vars_files; vars_prompt)，角色默认变量和vars。

- 主机：直接与主机相关联的变量，像inventory, include_vars, facts or registered 

 

### 使用变量

#### 在jinja2中使用

一旦定义了变量，就可以在使用Jinja2模板系统的剧本中使用它们。这是一个简单的Jinja2模板

```jinja2
My amp goes to {{ max_amp_value }}
```

这个表达式提供了最基本的变量替换形式。

您可以在剧本中使用相同的语法。例如

```yaml
template: src=foo.cfg.j2 dest={{ remote_install_path }}/foo.cfg
```

#### 使用Jinja2过滤器转换变量

Jinja2过滤器允许您在模板表达式中转换变量的值。例如，`capitalize`过滤器将传递给它的任何值都大写;`to_yaml`和`to_json`过滤器会更改变量值的格式。



YAML语法要求，如果您以`{{foo}}`开始一个值，则必须 **用引号包裹整行**，因为它希望确保您没有试图启动YAML字典。YAML语法文档对此进行了介绍。

下面这个时错误的写法

```yaml
- hosts: app_servers
  vars:
      app_path: {{ base_path }}/22
```

这样写，才是对的。

```yaml
- hosts: app_servers
  vars:
       app_path: "{{ base_path }}/22"
```

#### 从系统中发现变量:Facts

还有其他地方可以使用变量，但是这些是被发现的变量类型，不是由用户设置的。

`Facts`是通过与远程系统对话而获得的信息。数据存储在`ansible_facts`变量中，你可以通过下列示例来获取变量中的信息

```yaml
- debug: var=ansible_facts
```

或者使用`setup`模块

```bash
ansible hostname -m setup
```

#### 访问复杂变量数据

使用嵌套数据结构访问变量

```jinja2
{{ ansible_facts["eth0"]["ipv4"]["address"] }}
```

或者使用`.`符号

```jinja2
{{ ansible_facts.eth0.ipv4.address }}
```

类似地，这是我们访问数组的第一个元素的方式

```jinja2
{{ foo[0] }}
```

#### 使用内置变量

ansible 提供了许多内置变量，来帮助大家获取当前运行的诸多信息，通过内置变量，我们可以做更多的事情，比如获取主机的自定义fact，获取当前运行的主机等等。

##### 魔术变量

| 变量名称                                   | 说明                                                         | 使用                                                         |
| ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ansible_check_mode                         | 是否处于检查模式，返回布尔值                                 | `{{ ansible_check_mode }}`                                   |
| ansible_dependent_role_names               | 当前剧本依赖的角色名称                                       | `{{ ansible_dependent_role_names}}`                          |
| ansible_diff_mode                          | 是否处于对比模式，返回布尔值                                 | `{{ ansible_diff_mode }}`                                    |
| ansible_forks                              | 返回最大并行运行的数量                                       | `{{ ansible_forks }}`                                        |
| ansible_inventory_sources                  | 用作主机清单的资源列表                                       | `{{ ansible_inventory_sources }}`                            |
| ansible_limit                              | CLI选项`--limit`的内容                                       | `{{ ansible_limit }}`                                        |
| ansible_loop                               | 通过`loop_control.extended`启用时，包含扩展循环信息的字典/映射 | `{{ ansible_loop }}`                                         |
| ansible_loop_var                           | 提供给`loop_control.loop_var`的值的名称                      | `{{ ansible_loop_var }}`                                     |
| ansible_index_var                          | 提供给`loop_control.index_var`的值的名称                     | `{{ ansible_index_var }}`                                    |
| ansible_parent_role_paths                  | 当通过`include_role`或`import_role`操作执行当前角色时，此变量包含所有父角色的列表，而最新角色（即包含/导入该角色的角色）是列表中的第一项。 | `{{ ansible_parent_role_paths }}`                            |
| ansible_play_hosts<br />ansible_play_batch | 包含当前运行的主机列表，受serial参数影响                     | `{{ ansible_play_hosts }}`<br />`{{ ansible_play_batch }}`   |
| ansible_play_hosts_all                     | 所有执行主机的列表                                           | `{{ ansible_play_hosts_all }}`                               |
| ansible_play_role_names                    | 当前导入到当前剧本中的角色的名称                             | `{{ ansible_play_role_names }}`                              |
| ansible_playbook_python                    | 控制器上Ansible使用的python解释器的路径                      | `{{ ansible_playbook_python }}`                              |
| ansible_role_names                         | 当前导入角色的名称                                           | `{{ ansible_role_names }}`                                   |
| ansible_run_tags                           | `--tags` CLI选项的内容，该选项指定当前运行将包括哪些标签。   | `{{ ansible_run_tags}}`                                      |
| ansible_search_path                        | `action`插件`lookups`的当前搜索路径                          | `{{ ansible_search_path}}`                                   |
| ansible_skip_tags                          | `--skip`标记CLI选项的内容，该选项指定在当前运行中将跳过哪些标记。 | `{{ ansible_skip_tags}}`                                     |
| ansible_verbosity                          | Ansible的详细版本信息                                        | `{{ ansible_verbosity }}`                                    |
| ansible_version                            | ansible版本信息                                              | `{{ ansible_version }}`                                      |
| ansible_playbook_python                    | ansible的python可执行路径                                    | `{{ ansible_playbook_python }}`                              |
| groups_name                                | 当前主机所在组的主机列表                                     | `{% if   'webserver' in group_names %}      # some part of a configuration file that   only applies to webservers   {% endif   %}` |
| groups                                     | 包含设备清单组内的所有主机                                   | `{% for  host in groups[‘db_servers’] %}   {{ host   }}   {% endfor   %}` |
| hostvars                                   | 包含运行的所有变量信息                                       | `{{   hostvars['db.example.com'].ansible_eth0.ipv4.address }}` |
| inventory_hostname                         | 当前运行主机的库存配置名称                                   | `{{ inventory_hostname }}`<br />`{{ hostvars[inventory_hostname] }}` |
| inventory_hostname_short                   | `inventory_hostname`的简短版本                               | `{{ inventory_hostname_short }}`                             |
| inventory_dir                              | 存放主机清单的目录                                           | `{{ inventory_dir }}`                                        |
| inventory_file                             | 主机清单的文件名                                             | `{{ inventory_file }}`                                       |
| omit                                       | 允许您忽略某个选项的特殊变量                                 | `- user: name=bob home={{ bobs_home`                         |
| ansible_play_name                          | 当前正在执行的`play` name                                    | `{{ ansible_play_name }}`                                    |
| playbook_dir                               | playbook的路径                                               | `{{ playbook_dir }}`                                         |
| role_name                                  | 当前正在执行的角色名称。                                     | `{{ role_name }}`                                            |
| role_path                                  | 返回的当前角色路径，只在role中起作用                         | `{{ role_path }}`                                            |

##### Facts 变量

| 变量名称      | 说明                                          | 使用                  |
| ------------- | --------------------------------------------- | --------------------- |
| ansible_facts | 包含所有运行的主机收集数据                    | `{{ ansible_facts }}` |
| ansible_local | `inventory_hostname` 主机自定义的本地fact变量 | `{{ ansible_local }}` |

##### 连接变量

| 变量名称                   | 说明                              | 使用                               |
| -------------------------- | --------------------------------- | ---------------------------------- |
| ansible_become_user        | 权限提升的用户                    | `{{ ansible_become_user }}`        |
| ansible_connection         | 使用的连接插件                    | `{{ ansible_connection }}`         |
| ansible_host               | 当前使用的远端主机的`ip/name`名称 | `{{ ansible_host }}`               |
| ansible_python_interpreter | ansible在远端的python可执行路径   | `{{ ansible_python_interpreter }}` |
| ansible_user               | 使用ansible登录远端的用户         | `{{ ansible_user }}`               |


## 11.Facts 数据
Facts主要是用来采集目标系统信息的，采集到信息存储在`ansible_facts`变量中，也有许多信息存储在以`ansible_`开头的变量。


### 获取Facts信息
#### 使用setup模块来获取目标系统信息

可以使用`setup`模块手动的获取目标系统信息

```bash
ansible hostname -m setup
```

向`setup`模块传递`filter`选项，就可以选择获取哪些内容，例如仅显示与ansible相关的内存信息

```bash
ansible all -m setup -a 'filter=ansible_*_mb'
```

#### 使用playbook来获取目标系统信息

默认情况下，playbook的第一个任务就是`Facts`信息，显示的结果如下:

```yaml
PLAY [192.168.77.130] ******************************************
TASK [Gathering Facts] ****************************************************************
ok: [192.168.77.130]
TASK [test] ****************************************************
changed: [192.168.77.130]
```

如果要关闭playbook的这一操作，就需要为play添加`gather_facts`关键字

```yaml
# 关闭关闭自动采集Facts
- hosts: whatever
  gather_facts: no
```

默认情况下，是收集所有的facts信息，可以通过修改ansible配置文件来达到只获取某一类型的信息

```ini
# /etc/ansible/ansible.cfg

# all - 收集所有子集，默认
# network - 收集网络信息子集
# hardware - 收集硬件信息子集
# virtual - 收集虚拟相关的信息
# facter - 收集自定义的fact信息
# ohai -  收集ohai信息
# 可以使用多个子集 (ex: network,virtual)
# 可以排除子集 (ex: !hardware,!facter,!ohai)
gather_subset = all
```



#### 在task中设置facts信息

可以使用`set_fact` 来设置当前运行主机的facts信息

```yaml
- hosts: hostname
  tasks:
    - command: whoami
      register: result
    - set_fact:
        one: "{{ result.stdout }}"
        two: true
    - debug: var=one
    - debug: var=two
```

#### 自定义目标系统facts

在远程主机/etc/ansible/facts.d/目录下创建.fact 结尾的文件，也可以是json、ini 或者返回json 格式数据的可执行文件，这些将被作为远程主机本地的facts 执行

 **在远程主机上操作**

```bash
mkdir -p /etc/ansible/facts.d
cat << EOF > /etc/ansible/facts.d/hello.fact
[test]
h=hello
p=world
EOF
```

**在ansible控制节点上操作**

远程主机的自定义facts信息，存储在`ansible_local`变量中，可以通过`setup`模块过滤获取

```bash
ansible 192.168.77.130 -m setup -a "filter=ansible_local" 
192.168.77.130 | SUCCESS => {
    "ansible_facts": {
        "ansible_local": {
            "hello": {
                "test": {
                    "h": "hello", 
                    "p": "world"
                }
            }
        }, 
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false
}
```

也可以通过在任务中使用`{{ ansible_local.hello }}`的方式访问该变量

```bash
---
- hosts: 192.168.77.130
  tasks:
    - debug: var=ansible_local.hello
    - debug: var=ansible_local.hello.test.h
```



当然，我们可以把上面的步骤，通过playbook来实现

>  运用playbook 定义远端facts.d，并加载到fact中

```yaml
- hosts: node1
  tasks:
     - name: create directory for ansible custom facts
       file: state=directory recurse=yes path=/etc/ansible/facts.d
     - name: install custom test fact
       copy:
         content: |
           [test]
           h=hello
           p=world
         dest: /etc/ansible/facts.d/test.fact
     - name: re-read facts after adding custom fact
       setup: filter=ansible_local
     - name: ansible_local vars
       debug: var=ansible_local
```

#### Facts 返回的信息

以`ansible 2.9.1`版本返回`centos 7`系统的Facts信息

```json
"ansible_facts": {
    "ansible_all_ipv4_addresses": [
        "192.168.77.130", 
        "172.17.0.1"
    ], 
    "ansible_all_ipv6_addresses": [
        "fe80::6d73:3667:2ed6:a7c2", 
        "fe80::4d03:8744:2f0d:2085"
    ], 
    "ansible_apparmor": {
        "status": "disabled"
    }, 
    "ansible_architecture": "x86_64", 
    "ansible_bios_date": "07/29/2019", 
    "ansible_bios_version": "6.00", 
    "ansible_cmdline": {
        "BOOT_IMAGE": "/vmlinuz-5.1.11-1.el7.elrepo.x86_64", 
        "crashkernel": "auto", 
        "quiet": true, 
        "rhgb": true, 
        "ro": true, 
        "root": "UUID=a7d49533-e756-4a71-a977-5efb174eb09c", 
        "user_namespace.enable": "1"
    }, 
    "ansible_date_time": {
        "date": "2020-03-31", 
        "day": "31", 
        "epoch": "1585627320", 
        "hour": "12", 
        "iso8601": "2020-03-31T04:02:00Z", 
        "iso8601_basic": "20200331T120200260891", 
        "iso8601_basic_short": "20200331T120200", 
        "iso8601_micro": "2020-03-31T04:02:00.260966Z", 
        "minute": "02", 
        "month": "03", 
        "second": "00", 
        "time": "12:02:00", 
        "tz": "CST", 
        "tz_offset": "+0800", 
        "weekday": "星期二", 
        "weekday_number": "2", 
        "weeknumber": "13", 
        "year": "2020"
    }, 
    "ansible_default_ipv4": {
        "address": "192.168.77.130", 
        "alias": "ens33", 
        "broadcast": "192.168.77.255", 
        "gateway": "192.168.77.2", 
        "interface": "ens33", 
        "macaddress": "00:0c:29:88:01:c0", 
        "mtu": 1500, 
        "netmask": "255.255.255.0", 
        "network": "192.168.77.0", 
        "type": "ether"
    }, 
    "ansible_default_ipv6": {}, 
    "ansible_device_links": {
        "ids": {
            "sr0": [
                "ata-VMware_Virtual_IDE_CDROM_Drive_10000000000000000001"
            ]
        }, 
        "labels": {}, 
        "masters": {}, 
        "uuids": {
            "sda1": [
                "93556f71-6dad-4761-9207-edee35d47129"
            ], 
            "sda2": [
                "0c0f8a5a-58dd-4fc6-a49e-fc5e63f5d8a3"
            ], 
            "sda3": [
                "a7d49533-e756-4a71-a977-5efb174eb09c"
            ]
        }
    }, 
    "ansible_devices": {
        "sda": {
            "holders": [], 
            "host": "SCSI storage controller: LSI Logic / Symbios Logic 53c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI (rev 01)", 
            "links": {
                "ids": [], 
                "labels": [], 
                "masters": [], 
                "uuids": []
            }, 
            "model": "VMware Virtual S", 
            "partitions": {
                "sda1": {
                    "holders": [], 
                    "links": {
                        "ids": [], 
                        "labels": [], 
                        "masters": [], 
                        "uuids": [
                            "93556f71-6dad-4761-9207-edee35d47129"
                        ]
                    }, 
                    "sectors": "409600", 
                    "sectorsize": 512, 
                    "size": "200.00 MB", 
                    "start": "2048", 
                    "uuid": "93556f71-6dad-4761-9207-edee35d47129"
                }, 
                "sda2": {
                    "holders": [], 
                    "links": {
                        "ids": [], 
                        "labels": [], 
                        "masters": [], 
                        "uuids": [
                            "0c0f8a5a-58dd-4fc6-a49e-fc5e63f5d8a3"
                        ]
                    }, 
                    "sectors": "20971520", 
                    "sectorsize": 512, 
                    "size": "10.00 GB", 
                    "start": "411648", 
                    "uuid": "0c0f8a5a-58dd-4fc6-a49e-fc5e63f5d8a3"
                }, 
                "sda3": {
                    "holders": [], 
                    "links": {
                        "ids": [], 
                        "labels": [], 
                        "masters": [], 
                        "uuids": [
                            "a7d49533-e756-4a71-a977-5efb174eb09c"
                        ]
                    }, 
                    "sectors": "62502912", 
                    "sectorsize": 512, 
                    "size": "29.80 GB", 
                    "start": "21383168", 
                    "uuid": "a7d49533-e756-4a71-a977-5efb174eb09c"
                }
            }, 
            "removable": "0", 
            "rotational": "1", 
            "sas_address": null, 
            "sas_device_handle": null, 
            "scheduler_mode": "mq-deadline", 
            "sectors": "83886080", 
            "sectorsize": "512", 
            "size": "40.00 GB", 
            "support_discard": "0", 
            "vendor": "VMware,", 
            "virtual": 1
        }, 
        "sr0": {
            "holders": [], 
            "host": "IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)", 
            "links": {
                "ids": [
                    "ata-VMware_Virtual_IDE_CDROM_Drive_10000000000000000001"
                ], 
                "labels": [], 
                "masters": [], 
                "uuids": []
            }, 
            "model": "VMware IDE CDR10", 
            "partitions": {}, 
            "removable": "1", 
            "rotational": "1", 
            "sas_address": null, 
            "sas_device_handle": null, 
            "scheduler_mode": "mq-deadline", 
            "sectors": "2097151", 
            "sectorsize": "512", 
            "size": "1024.00 MB", 
            "support_discard": "0", 
            "vendor": "NECVMWar", 
            "virtual": 1
        }
    }, 
    "ansible_distribution": "CentOS", 
    "ansible_distribution_file_parsed": true, 
    "ansible_distribution_file_path": "/etc/redhat-release", 
    "ansible_distribution_file_variety": "RedHat", 
    "ansible_distribution_major_version": "7", 
    "ansible_distribution_release": "Core", 
    "ansible_distribution_version": "7.6", 
    "ansible_dns": {
        "nameservers": [
            "192.168.77.2"
        ]
    }, 
    "ansible_docker0": {
        "active": false, 
        "device": "docker0", 
        "features": {
            "esp_hw_offload": "off [fixed]", 
            "esp_tx_csum_hw_offload": "off [fixed]", 
            "fcoe_mtu": "off [fixed]", 
            "generic_receive_offload": "on", 
            "generic_segmentation_offload": "on", 
            "highdma": "on", 
            "hw_tc_offload": "off [fixed]", 
            "l2_fwd_offload": "off [fixed]", 
            "large_receive_offload": "off [fixed]", 
            "loopback": "off [fixed]", 
            "netns_local": "on [fixed]", 
            "ntuple_filters": "off [fixed]", 
            "receive_hashing": "off [fixed]", 
            "rx_all": "off [fixed]", 
            "rx_checksumming": "off [fixed]", 
            "rx_fcs": "off [fixed]", 
            "rx_gro_hw": "off [fixed]", 
            "rx_udp_tunnel_port_offload": "off [fixed]", 
            "rx_vlan_filter": "off [fixed]", 
            "rx_vlan_offload": "off [fixed]", 
            "rx_vlan_stag_filter": "off [fixed]", 
            "rx_vlan_stag_hw_parse": "off [fixed]", 
            "scatter_gather": "on", 
            "tcp_segmentation_offload": "on", 
            "tls_hw_record": "off [fixed]", 
            "tls_hw_rx_offload": "off [fixed]", 
            "tls_hw_tx_offload": "off [fixed]", 
            "tx_checksum_fcoe_crc": "off [fixed]", 
            "tx_checksum_ip_generic": "on", 
            "tx_checksum_ipv4": "off [fixed]", 
            "tx_checksum_ipv6": "off [fixed]", 
            "tx_checksum_sctp": "off [fixed]", 
            "tx_checksumming": "on", 
            "tx_esp_segmentation": "on", 
            "tx_fcoe_segmentation": "on", 
            "tx_gre_csum_segmentation": "on", 
            "tx_gre_segmentation": "on", 
            "tx_gso_partial": "on", 
            "tx_gso_robust": "on", 
            "tx_ipxip4_segmentation": "on", 
            "tx_ipxip6_segmentation": "on", 
            "tx_lockless": "on [fixed]", 
            "tx_nocache_copy": "off", 
            "tx_scatter_gather": "on", 
            "tx_scatter_gather_fraglist": "on", 
            "tx_sctp_segmentation": "on", 
            "tx_tcp6_segmentation": "on", 
            "tx_tcp_ecn_segmentation": "on", 
            "tx_tcp_mangleid_segmentation": "on", 
            "tx_tcp_segmentation": "on", 
            "tx_udp_segmentation": "on", 
            "tx_udp_tnl_csum_segmentation": "on", 
            "tx_udp_tnl_segmentation": "on", 
            "tx_vlan_offload": "on", 
            "tx_vlan_stag_hw_insert": "on", 
            "udp_fragmentation_offload": "off", 
            "vlan_challenged": "off [fixed]"
        }, 
        "hw_timestamp_filters": [], 
        "id": "8000.024238d96cf4", 
        "interfaces": [], 
        "ipv4": {
            "address": "172.17.0.1", 
            "broadcast": "172.17.255.255", 
            "netmask": "255.255.0.0", 
            "network": "172.17.0.0"
        }, 
        "macaddress": "02:42:38:d9:6c:f4", 
        "mtu": 1500, 
        "promisc": false, 
        "stp": false, 
        "timestamping": [
            "rx_software", 
            "software"
        ], 
        "type": "bridge"
    }, 
    "ansible_domain": "", 
    "ansible_effective_group_id": 0, 
    "ansible_effective_user_id": 0, 
    "ansible_ens33": {
        "active": true, 
        "device": "ens33", 
        "features": {
            "esp_hw_offload": "off [fixed]", 
            "esp_tx_csum_hw_offload": "off [fixed]", 
            "fcoe_mtu": "off [fixed]", 
            "generic_receive_offload": "on", 
            "generic_segmentation_offload": "on", 
            "highdma": "off [fixed]", 
            "hw_tc_offload": "off [fixed]", 
            "l2_fwd_offload": "off [fixed]", 
            "large_receive_offload": "off [fixed]", 
            "loopback": "off [fixed]", 
            "netns_local": "off [fixed]", 
            "ntuple_filters": "off [fixed]", 
            "receive_hashing": "off [fixed]", 
            "rx_all": "off", 
            "rx_checksumming": "off", 
            "rx_fcs": "off", 
            "rx_gro_hw": "off [fixed]", 
            "rx_udp_tunnel_port_offload": "off [fixed]", 
            "rx_vlan_filter": "on [fixed]", 
            "rx_vlan_offload": "on", 
            "rx_vlan_stag_filter": "off [fixed]", 
            "rx_vlan_stag_hw_parse": "off [fixed]", 
            "scatter_gather": "on", 
            "tcp_segmentation_offload": "on", 
            "tls_hw_record": "off [fixed]", 
            "tls_hw_rx_offload": "off [fixed]", 
            "tls_hw_tx_offload": "off [fixed]", 
            "tx_checksum_fcoe_crc": "off [fixed]", 
            "tx_checksum_ip_generic": "on", 
            "tx_checksum_ipv4": "off [fixed]", 
            "tx_checksum_ipv6": "off [fixed]", 
            "tx_checksum_sctp": "off [fixed]", 
            "tx_checksumming": "on", 
            "tx_esp_segmentation": "off [fixed]", 
            "tx_fcoe_segmentation": "off [fixed]", 
            "tx_gre_csum_segmentation": "off [fixed]", 
            "tx_gre_segmentation": "off [fixed]", 
            "tx_gso_partial": "off [fixed]", 
            "tx_gso_robust": "off [fixed]", 
            "tx_ipxip4_segmentation": "off [fixed]", 
            "tx_ipxip6_segmentation": "off [fixed]", 
            "tx_lockless": "off [fixed]", 
            "tx_nocache_copy": "off", 
            "tx_scatter_gather": "on", 
            "tx_scatter_gather_fraglist": "off [fixed]", 
            "tx_sctp_segmentation": "off [fixed]", 
            "tx_tcp6_segmentation": "off [fixed]", 
            "tx_tcp_ecn_segmentation": "off [fixed]", 
            "tx_tcp_mangleid_segmentation": "off", 
            "tx_tcp_segmentation": "on", 
            "tx_udp_segmentation": "off [fixed]", 
            "tx_udp_tnl_csum_segmentation": "off [fixed]", 
            "tx_udp_tnl_segmentation": "off [fixed]", 
            "tx_vlan_offload": "on [fixed]", 
            "tx_vlan_stag_hw_insert": "off [fixed]", 
            "udp_fragmentation_offload": "off", 
            "vlan_challenged": "off [fixed]"
        }, 
        "hw_timestamp_filters": [], 
        "ipv4": {
            "address": "192.168.77.130", 
            "broadcast": "192.168.77.255", 
            "netmask": "255.255.255.0", 
            "network": "192.168.77.0"
        }, 
        "ipv6": [
            {
                "address": "fe80::6d73:3667:2ed6:a7c2", 
                "prefix": "64", 
                "scope": "link"
            }, 
            {
                "address": "fe80::4d03:8744:2f0d:2085", 
                "prefix": "64", 
                "scope": "link"
            }
        ], 
        "macaddress": "00:0c:29:88:01:c0", 
        "module": "e1000", 
        "mtu": 1500, 
        "pciid": "0000:02:01.0", 
        "promisc": false, 
        "speed": 1000, 
        "timestamping": [
            "tx_software", 
            "rx_software", 
            "software"
        ], 
        "type": "ether"
    }, 
    "ansible_env": {
        "HOME": "/root", 
        "LANG": "zh_CN.UTF-8", 
        "LESSOPEN": "||/usr/bin/lesspipe.sh %s", 
        "LOGNAME": "root", 
        "LS_COLORS": "rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:", 
        "MAIL": "/var/mail/root", 
        "PATH": "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin", 
        "PWD": "/root", 
        "SHELL": "/bin/bash", 
        "SHLVL": "2", 
        "SSH_CLIENT": "192.168.77.128 46964 22", 
        "SSH_CONNECTION": "192.168.77.128 46964 192.168.77.130 22", 
        "SSH_TTY": "/dev/pts/1", 
        "TERM": "linux", 
        "USER": "root", 
        "XDG_RUNTIME_DIR": "/run/user/0", 
        "XDG_SESSION_ID": "22", 
        "_": "/usr/bin/python"
    }, 
    "ansible_fibre_channel_wwn": [], 
    "ansible_fips": false, 
    "ansible_form_factor": "Other", 
    "ansible_fqdn": "node130", 
    "ansible_hostname": "node130", 
    "ansible_hostnqn": "", 
    "ansible_interfaces": [
        "lo", 
        "docker0", 
        "ens33"
    ], 
    "ansible_is_chroot": false, 
    "ansible_iscsi_iqn": "", 
    "ansible_kernel": "5.1.11-1.el7.elrepo.x86_64", 
    "ansible_kernel_version": "#1 SMP Mon Jun 17 15:51:08 EDT 2019", 
    "ansible_lo": {
        "active": true, 
        "device": "lo", 
        "features": {
            "esp_hw_offload": "off [fixed]", 
            "esp_tx_csum_hw_offload": "off [fixed]", 
            "fcoe_mtu": "off [fixed]", 
            "generic_receive_offload": "on", 
            "generic_segmentation_offload": "on", 
            "highdma": "on [fixed]", 
            "hw_tc_offload": "off [fixed]", 
            "l2_fwd_offload": "off [fixed]", 
            "large_receive_offload": "off [fixed]", 
            "loopback": "on [fixed]", 
            "netns_local": "on [fixed]", 
            "ntuple_filters": "off [fixed]", 
            "receive_hashing": "off [fixed]", 
            "rx_all": "off [fixed]", 
            "rx_checksumming": "on [fixed]", 
            "rx_fcs": "off [fixed]", 
            "rx_gro_hw": "off [fixed]", 
            "rx_udp_tunnel_port_offload": "off [fixed]", 
            "rx_vlan_filter": "off [fixed]", 
            "rx_vlan_offload": "off [fixed]", 
            "rx_vlan_stag_filter": "off [fixed]", 
            "rx_vlan_stag_hw_parse": "off [fixed]", 
            "scatter_gather": "on", 
            "tcp_segmentation_offload": "on", 
            "tls_hw_record": "off [fixed]", 
            "tls_hw_rx_offload": "off [fixed]", 
            "tls_hw_tx_offload": "off [fixed]", 
            "tx_checksum_fcoe_crc": "off [fixed]", 
            "tx_checksum_ip_generic": "on [fixed]", 
            "tx_checksum_ipv4": "off [fixed]", 
            "tx_checksum_ipv6": "off [fixed]", 
            "tx_checksum_sctp": "on [fixed]", 
            "tx_checksumming": "on", 
            "tx_esp_segmentation": "off [fixed]", 
            "tx_fcoe_segmentation": "off [fixed]", 
            "tx_gre_csum_segmentation": "off [fixed]", 
            "tx_gre_segmentation": "off [fixed]", 
            "tx_gso_partial": "off [fixed]", 
            "tx_gso_robust": "off [fixed]", 
            "tx_ipxip4_segmentation": "off [fixed]", 
            "tx_ipxip6_segmentation": "off [fixed]", 
            "tx_lockless": "on [fixed]", 
            "tx_nocache_copy": "off [fixed]", 
            "tx_scatter_gather": "on [fixed]", 
            "tx_scatter_gather_fraglist": "on [fixed]", 
            "tx_sctp_segmentation": "on", 
            "tx_tcp6_segmentation": "on", 
            "tx_tcp_ecn_segmentation": "on", 
            "tx_tcp_mangleid_segmentation": "on", 
            "tx_tcp_segmentation": "on", 
            "tx_udp_segmentation": "off [fixed]", 
            "tx_udp_tnl_csum_segmentation": "off [fixed]", 
            "tx_udp_tnl_segmentation": "off [fixed]", 
            "tx_vlan_offload": "off [fixed]", 
            "tx_vlan_stag_hw_insert": "off [fixed]", 
            "udp_fragmentation_offload": "off", 
            "vlan_challenged": "on [fixed]"
        }, 
        "hw_timestamp_filters": [], 
        "ipv4": {
            "address": "127.0.0.1", 
            "broadcast": "host", 
            "netmask": "255.0.0.0", 
            "network": "127.0.0.0"
        }, 
        "ipv6": [
            {
                "address": "::1", 
                "prefix": "128", 
                "scope": "host"
            }
        ], 
        "mtu": 65536, 
        "promisc": false, 
        "timestamping": [
            "tx_software", 
            "rx_software", 
            "software"
        ], 
        "type": "loopback"
    }, 
    "ansible_local": {
        "hello": {
            "test": {
                "h": "hello", 
                "p": "world"
            }
        }, 
        "test": {
            "test": {
                "h": "hello", 
                "p": "world"
            }
        }
    }, 
    "ansible_lsb": {}, 
    "ansible_machine": "x86_64", 
    "ansible_machine_id": "c6e2cb0cdbad41f19c30d690896aabe0", 
    "ansible_memfree_mb": 476, 
    "ansible_memory_mb": {
        "nocache": {
            "free": 695, 
            "used": 265
        }, 
        "real": {
            "free": 476, 
            "total": 960, 
            "used": 484
        }, 
        "swap": {
            "cached": 0, 
            "free": 10239, 
            "total": 10239, 
            "used": 0
        }
    }, 
    "ansible_memtotal_mb": 960, 
    "ansible_mounts": [
        {
            "block_available": 10389, 
            "block_size": 4096, 
            "block_total": 50345, 
            "block_used": 39956, 
            "device": "/dev/sda1", 
            "fstype": "xfs", 
            "inode_available": 83285, 
            "inode_total": 83624, 
            "inode_used": 339, 
            "mount": "/boot", 
            "options": "rw,relatime,attr2,inode64,noquota", 
            "size_available": 42553344, 
            "size_total": 206213120, 
            "uuid": "93556f71-6dad-4761-9207-edee35d47129"
        }, 
        {
            "block_available": 7234718, 
            "block_size": 4096, 
            "block_total": 7809050, 
            "block_used": 574332, 
            "device": "/dev/sda3", 
            "fstype": "xfs", 
            "inode_available": 15558107, 
            "inode_total": 15625728, 
            "inode_used": 67621, 
            "mount": "/", 
            "options": "rw,relatime,attr2,inode64,noquota", 
            "size_available": 29633404928, 
            "size_total": 31985868800, 
            "uuid": "a7d49533-e756-4a71-a977-5efb174eb09c"
        }
    ], 
    "ansible_nodename": "node130", 
    "ansible_os_family": "RedHat", 
    "ansible_pkg_mgr": "yum", 
    "ansible_proc_cmdline": {
        "BOOT_IMAGE": "/vmlinuz-5.1.11-1.el7.elrepo.x86_64", 
        "crashkernel": "auto", 
        "quiet": true, 
        "rhgb": true, 
        "ro": true, 
        "root": "UUID=a7d49533-e756-4a71-a977-5efb174eb09c", 
        "user_namespace.enable": "1"
    }, 
    "ansible_processor": [
        "0", 
        "GenuineIntel", 
        "Intel(R) Core(TM) i3-4160 CPU @ 3.60GHz"
    ], 
    "ansible_processor_cores": 1, 
    "ansible_processor_count": 1, 
    "ansible_processor_threads_per_core": 1, 
    "ansible_processor_vcpus": 1, 
    "ansible_product_name": "VMware Virtual Platform", 
    "ansible_product_serial": "VMware-56 4d 4b f0 c3 97 be 18-aa c9 56 08 cb 88 01 c0", 
    "ansible_product_uuid": "f04b4d56-97c3-18be-aac9-5608cb8801c0", 
    "ansible_product_version": "None", 
    "ansible_python": {
        "executable": "/usr/bin/python", 
        "has_sslcontext": true, 
        "type": "CPython", 
        "version": {
            "major": 2, 
            "micro": 5, 
            "minor": 7, 
            "releaselevel": "final", 
            "serial": 0
        }, 
        "version_info": [
            2, 
            7, 
            5, 
            "final", 
            0
        ]
    }, 
    "ansible_python_version": "2.7.5", 
    "ansible_real_group_id": 0, 
    "ansible_real_user_id": 0, 
    "ansible_selinux": {
        "status": "disabled"
    }, 
    "ansible_selinux_python_present": true, 
    "ansible_service_mgr": "systemd", 
    "ansible_ssh_host_key_ecdsa_public": "AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBK2zovckFKduH7EsvGaWar2mA+LdC4kTjgFG4h9RQlxZ1v5kEPx8Bs7jWnj94Cd8lY8BGb7RU7akUFpq3V59WIY=", 
    "ansible_ssh_host_key_ed25519_public": "AAAAC3NzaC1lZDI1NTE5AAAAIEgM8JK59UtnryS0IhtNoPJHbOSqy7Xy2jExPYMvAex5", 
    "ansible_ssh_host_key_rsa_public": "AAAAB3NzaC1yc2EAAAADAQABAAABAQDfNgNsUWXmYOD7Iz94nO98XRmw4dWKREbxWz6rZBP2QHYFN38nzdo9h5UT4HMuUM/FraPwwbfPubznNgn0/cXfMkqu8JIssxizpIRBZv82HFqwHTYRvkFAEII8ftkHs2RVlq64+ljPZzWvGL14nkfU7P+kc8Ym4jZGtorKRBoHFCeu67fycmZSCLFJxkKSumOaZ9TbNzP6bziyfmdDIGfj8UgzJRSuBW+B5XNeJp/QtsQZTjgpxSZZ9QRf/FeRx1NDR5Si91Fkd0NILIgoOSz536lP+aCCUOx7ukaoV1T/kyUKOj8a3wpBGiBWWZUGZa6O02Ig0eHnx8F4lZ2iOnNN", 
    "ansible_swapfree_mb": 10239, 
    "ansible_swaptotal_mb": 10239, 
    "ansible_system": "Linux", 
    "ansible_system_capabilities": [
        "cap_chown", 
        "cap_dac_override", 
        "cap_dac_read_search", 
        "cap_fowner", 
        "cap_fsetid", 
        "cap_kill", 
        "cap_setgid", 
        "cap_setuid", 
        "cap_setpcap", 
        "cap_linux_immutable", 
        "cap_net_bind_service", 
        "cap_net_broadcast", 
        "cap_net_admin", 
        "cap_net_raw", 
        "cap_ipc_lock", 
        "cap_ipc_owner", 
        "cap_sys_module", 
        "cap_sys_rawio", 
        "cap_sys_chroot", 
        "cap_sys_ptrace", 
        "cap_sys_pacct", 
        "cap_sys_admin", 
        "cap_sys_boot", 
        "cap_sys_nice", 
        "cap_sys_resource", 
        "cap_sys_time", 
        "cap_sys_tty_config", 
        "cap_mknod", 
        "cap_lease", 
        "cap_audit_write", 
        "cap_audit_control", 
        "cap_setfcap", 
        "cap_mac_override", 
        "cap_mac_admin", 
        "cap_syslog", 
        "35", 
        "36", 
        "37+ep"
    ], 
    "ansible_system_capabilities_enforced": "True", 
    "ansible_system_vendor": "VMware, Inc.", 
    "ansible_uptime_seconds": 4004, 
    "ansible_user_dir": "/root", 
    "ansible_user_gecos": "root", 
    "ansible_user_gid": 0, 
    "ansible_user_id": "root", 
    "ansible_user_shell": "/bin/bash", 
    "ansible_user_uid": 0, 
    "ansible_userspace_architecture": "x86_64", 
    "ansible_userspace_bits": "64", 
    "ansible_virtualization_role": "guest", 
    "ansible_virtualization_type": "VMware", 
    "gather_subset": [
        "all"
    ], 
    "module_setup": true
}
```

其中较为常用的变量

- ansible_distribution   

- ansible_distribution_release

- ansible_distribution_version  

- ansible_fqdn

- ansible_hostname

- ansible_os_family

- ansible_pkg_mgr

- ansible_default_ipv4.address

- ansible_default_ipv6.address

 

### 缓存Facts信息

Facts信息默认存储在内存中，即每次运行后，信息就不会存在了，这样会导致我们每次都需要重新去获取主机的所有Facts信息，浪费了很多时间，Facts给了几种缓存方式。



####  使用文件作为缓存

创建缓存存放的目录

```bash
mkdir /tmp/facts_cache
```

修改ansible配置文件

```ini
# /etc/ansible/ansible.cfg

gathering = smart
fact_caching = jsonfile
fact_caching_timeout = 86400
fact_caching_connection = /tmp/facts_cache
```

获取主机的Facts信息

```bash
ansible 192.168.77.130 -m setup
```

查看缓存目录

```bash
ll /tmp/facts_cache/
总用量 28
-rw-r--r-- 1 root root 25241 3月  31 11:39 192.168.77.130
```

> 上述文件中存储着json序列化的facts数据

#### 使用redis作为缓存

 安装redis

```bash
# centos 7
yum -y install redis
easy_install pip
pip install redis
```

配置redis，使用密码登陆

```bash
echo 'requirepass "admin"' > /etc/redis.conf
```

启动redis

```bash
systemctl enable --now redis
```

修改ansible配置文件

```ini
# /etc/ansible/ansible.cfg

gathering = smart
fact_caching = redis
fact_caching_timeout = 86400
fact_caching_connection = localhost:6379:0:admin
```

获取主机的Facts信息

```bash
ansible 192.168.77.130 -m setup
```

查看redis内容

```bash
# redis-cli
127.0.0.1:6379> auth admin
OK
127.0.0.1:6379> keys *
1) "ansible_cache_keys"
2) "ansible_facts192.168.77.130"
127.0.0.1:6379> get ansible_facts192.168.77.130
.....
```

#### 使用memcached作为缓存

安装  memcached

```bash
# centos 7
yum install memcached

easy_install pip
pip install python-memcached
```

启动memcached

```bash
systemctl enable --now memcached
```

修改ansible配置文件

```ini
# /etc/ansible/ansible.cfg

gathering = smart
fact_caching = memcached
fact_caching_timeout = 86400
fact_caching_connection = localhost:11211
```


获取主机的Facts信息

```bash
ansible 192.168.77.130 -m setup
```


查看memcached内容

```bash
# telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
stats items
STAT items:3:number 1
STAT items:3:age 135
STAT items:3:evicted 0
STAT items:3:evicted_nonzero 0
STAT items:3:evicted_time 0
STAT items:3:outofmemory 0
STAT items:3:tailrepairs 0
STAT items:3:reclaimed 0
STAT items:3:expired_unfetched 0
STAT items:3:evicted_unfetched 0
STAT items:21:number 1
STAT items:21:age 135
STAT items:21:evicted 0
STAT items:21:evicted_nonzero 0
STAT items:21:evicted_time 0
STAT items:21:outofmemory 0
STAT items:21:tailrepairs 0
STAT items:21:reclaimed 0
STAT items:21:expired_unfetched 0
STAT items:21:evicted_unfetched 0
END
stats cachedump 3 0
ITEM ansible_cache_keys [46 b; 1585626688 s]
END
stats cachedump 21 0
ITEM ansible_facts192.168.77.130 [8349 b; 1585713251 s]
END
```

#### 刷新缓存

默认情况下，缓存的生存时间是`fact_caching_timeout`控制的，如果我们想强制刷新缓存的话，可以使用`--flush-cache`选项

```bash
ansible-playbook --flush-cache /etc/ansible/test3.yaml
```


## 12.Jinja2 模板语法

Ansible使用 [Jinja2](https://jinja.palletsprojects.com/) 模板来启用动态表达式和对变量的访问。

!!! note
    Jinja2 是一个 Python 的功能齐全的模板引擎。它有完整的 unicode 支持，一个可选 的集成沙箱执行环境，被广泛使用，以 BSD 许可证授权。
    
    
### jinja2 模版中的一些语法

> 关于 Jinja2 完整的中文说明 请移步：http://docs.jinkan.org/docs/jinja2/

#### 变量

可以使用点`.`来访问变量的属性，作为替代，也可以使用下标语法`[] `, 下面2种方式效果是一样的

```jinja2
{{ foo.bar }}

{{ foo['bar'] }}
```

如果变量或属性不存在，会返回一个未定义值。

#### 注释

要把模板中一行的部分注释掉，默认使用 `{# ... #} `注释语法。

#### 转义

简单的使用单引号进行转义

对于较大的段落，使用raw进行转义
```jinja2
{% raw %}
     <ul>
     {% for item in seq %}
         <li>{{ item }}</li>
     {% endfor %}
     </ul>
 {% endraw %}
```


包含 > 、 < 、 & 或 " 字符的变量，必须要手动转义, 使用`e` 顾虑器可以转义这些。

```
{{ user.username | e }} 
```

#### 空白控制

在开始或结束放置一个减号（ `-` ），可以移除块前或块后的空白。

```jinja2 
{% for item in seq -%}
    {{ item }}
{%- endfor %}

{%- if foo -%}...{% endif %}
```

#### 控制结构

控制结构指的是所有的那些可以控制程序流的东西 —— 条件（比如 if/elif/ekse ）、 for 循环、以及宏和块之类的东西。控制结构在默认语法中以 {% .. %} 块的形式 出现。

##### For

遍历序列
```jinja2
{% for user in users %}
  <li>{{ user.username|e }}</li>
{% endfor %}
```


迭代字典
```jinja2
{% for key, value in my_dict.iteritems() %}
    <dt>{{ key|e }}</dt>
    <dd>{{ value|e }}</dd>
{% endfor %}
```


循环 10 次迭代之后会终止处理
```jinja2
{% for user in users %}

    {%- if loop.index >= 10 %}{% break %}{% endif %}

{%- endfor %}
```


条件过滤
```jinja2
{% for dir in data_dirs if dir != "/" %}
data_dir = {{ dir }}
{% else %}
# no data dirs found
{% endfor %}

```

在一个 for 循环块中你可以访问这些特殊的变量:

| 变量               | 描述                                               |
| :----------------- | :------------------------------------------------- |
| loop.index         | 当前循环迭代的次数（从 1 开始）                    |
| loop.index0        | 当前循环迭代的次数（从 0 开始）                    |
| loop.revindex      | 到循环结束需要迭代的次数（从 1 开始）              |
| loop.revindex0     | 到循环结束需要迭代的次数（从 0 开始）              |
| loop.first         | 如果是第一次迭代，为 True 。                       |
| loop.last          | 如果是最后一次迭代，为 True 。                     |
| loop.length        | 序列中的项目数。                                   |
| loop.cycle         | 在一串序列间期取值的辅助函数                       |
| loop.depth         | 指示当前渲染在递归循环中的深度。 从1开始           |
| loop.depth0        | 指示当前渲染在递归循环中的深度。 从0开始           |
| loop.previtem      | 循环的上一个迭代中的项目。 在第一次迭代中未定义。  |
| loop.nextitem      | 循环的以下迭代中的项目。 在上一次迭代期间未定义。  |
| loop.changed(*val) | 如果以前使用其他值调用（或根本未调用），则为true。 |

##### if 语句

Jinja 中的 if 语句可比 Python 中的 if 语句。
```jinja2
{% if kenny.sick %}
     Kenny is sick.
 {% elif kenny.dead %}
     You killed Kenny!  You bastard!!!
 {% else %}
     Kenny looks okay --- so far
 {% endif %}
```

##### 过滤器

变量可以通过 过滤器 修改。过滤器与变量用管道符号（ `|` ）分割，并且也 可以用圆括号传递可选参数。多个过滤器可以链式调用，前一个过滤器的输出会被作为 后一个过滤器的输入。

```jinj2
{{ name | striptags | title }} 
```

过滤器段允许你在一块模板数据上应用常规 Jinja2 过滤器。只需要把代码用 filter 节包裹起来:

```jinja2
{% filter upper %}
    This text becomes uppercase
{% endfilter %}
```

##### 赋值

在代码块中，你也可以为变量赋值。在顶层的（块、宏、循环之外）赋值是可导出的，即 可以从别的模板中导入。

赋值使用 set 标签，并且可以为多个变量赋值:


```jinja2
{% set navigation = [('index.html', 'Index'), ('about.html', 'About')] %}

{% set key, value = call_something() %}
```

#### 表达式

`{% ... %}`   用于执行诸如 for 循环 或赋值的语句

`{{ ... }}`   把表达式的结果打印到模板上


**if 表达式**

一般的语法是` <do something> if <something is true> else <do something else> `。

```jinja2
{{ '[%s]' % page.title if page.title is defined else 'undefined' }}
```

#### 字面量

表达式最简单的形式就是字面量。字面量表示诸如字符串和数值的 Python 对象。下面 的字面量是可用的:

| 值                                       | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| "Hello World"                            | 双引号或单引号中间的一切都是字符串。无论何时你需要在模板中使用一个字   符串（比如函数调用、过滤器或只是包含或继承一个模板的参数），它们都是 有用的。 |
| 42/42.23                                 | 直接写下数值就可以创建整数和浮点数。如果有小数点，则为浮点数，否则为   整数。记住在 Python 里， 42 和 42.0 是不一样的。 |
| ['list','of','objects']                  | 一对中括号括起来的东西是一个列表。列表用于存储和迭代序列化的数据。 |
| ('tuple','of','values')                  | 元组与列表类似，只是你不能修改元组。如果元组中只有一个项，你需要以逗号   结尾它。元组通常用于表示两个或更多元素的项。更多细节见上面的例子。 |
| {dict':'of','key':'and','value':'pairs'} | Python   中的字典是一种关联键和值的结构。键必须是唯一的，并且键必须只有一个 值。字典在模板中很少使用，罕用于诸如 [xmlattr()](http://docs.jinkan.org/docs/jinja2/templates.html#xmlattr) 过滤器之类。 |
| true/false                               | true 永远是 true ，而   false 始终是 false 。                |

!!! note 提示
    特殊常量 true 、 false 和 none 实际上是小写的。因为这在过去会导致 混淆，过去 True扩展为一个被认为false 的未定义的变量。所有的这三个 常量也可以被写成首字母大写（ True 、 False 和 None ）。尽管如此， 为了一致性（所有的 Jinja 标识符是小写的），你应该使用小写的版本。

 

#### 算术

Jinja 允许你用计算值。这在模板中很少用到，但是为了完整性允许其存在。支持下面的 运算符:

| 运算符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| +      | 把两个对象加到一起。通常对象是素质，但是如果两者是字符串或列表，你可以用这   种方式来衔接它们。无论如何这不是首选的连接字符串的方式！连接字符串见 ~ 运算符。 {{ 1 + 1 }} 等于 2 。 |
| -      | 用第一个数减去第二个数。 {{ 3 - 2 }} 等于 1 。               |
| /      | 对两个数做除法。返回值会是一个浮点数。 {{ 1 / 2 }} 等于 {{ 0.5 }} 。 |
| //     | 对两个数做除法，返回整数商。 {{ 20 // 7 }} 等于 2 。         |
| %      | 计算整数除法的余数。 {{ 11 % 7 }} 等于 4 。                  |
| *      | 用右边的数乘左边的操作数。 {{ 2 * 2 }} 会返回 4 。也可以用于重   复一个字符串多次。 {{ ‘=’ * 80 }} 会打印 80 个等号的横条。 |
| **     | 取左操作数的右操作数次幂。 {{ 2**3 }} 会返回 8 。            |

**比较运算符**  

| 运算符 | 说明                               |
| ------ | ---------------------------------- |
| ==     | 比较两个对象是否相等。             |
| !=     | 比较两个对象是否不等。             |
| >      | 如果左边大于右边，返回 true 。     |
| >=     | 如果左边大于等于右边，返回 true 。 |
| <      | 如果左边小于右边，返回 true 。     |
| <=     | 如果左边小于等于右边，返回 true 。 |

**逻辑运算符**

对于 if 语句，在 for 过滤或 if 表达式中，它可以用于联合多个表达式:

| 运算符 | 说明                                             |
| ------ | ------------------------------------------------ |
| and    | 如果左操作数和右操作数同为真，返回   true 。     |
| or     | 如果左操作数和右操作数有一个为真，返回   true 。 |
| not    | 对一个表达式取反（见下）。                       |
| (expr) | 表达式组。                                       |

!!! note 提示
    is 和 in 运算符同样支持使用中缀记法: foo is not bar 和 foo not in bar 而不是 not foo is bar 和 not foo in bar 。所有的 其它表达式需要前缀记法 not (foo and bar) 。

 **其它运算符**

下面的运算符非常有用，但不适用于其它的两个分类:

| 运算符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| in     | 运行序列/映射包含检查。如果左操作数包含于右操作数，返回   true 。比如 {{ 1 in[1,2,3] }} 会返回 true 。 |
| is     | 运行一个 [测试](http://docs.jinkan.org/docs/jinja2/templates.html#tests) 。 |
| \|     | 应用一个 [过滤器](http://docs.jinkan.org/docs/jinja2/templates.html#filters) 。 |
| ~      | 把所有的操作数转换为字符串，并且连接它们。 {{ "Hello " ~ name ~ "!" }} 会返回（假设 name 值为 ''John' ） Hello John! 。 |
| ()     | 调用一个可调用量:{{ post.render() }} 。在圆括号中，你可以像在   python   中一样使用位置参数和关键字参数: {{ post.render(user, full=true) }} 。 |
| . / [] | 获取一个对象的属性。                                         |

 

####  Python对象方法

在模板中，也是可以使用python的对象方法

字符串方法

- endswith: 用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False
- startswith: 用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。
- split: 指定分隔符对字符串进行切片，默认为空格
- rsplit: 与split相同，但从字符串的末尾开始切片
- splitlines: 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表
- upper: 返回全部大写的字符串
- lower: 返回全部小写的字符串
- capitalize: 将字符串的第一个字母变成大写,其他字母变小写

 列表方法

- index 返回提供值的第一个索引位置

- count  统计某个元素在列表中出现的次数

**python 版本处理**

在python2中，使用`dict.keys()`, `dict.values()`, `dict.items()` 返回字典的列表形式。但是在python3中，这些方法则返回字典形式

```jinja2
# Only works with Python 2
{{ hosts.keys() }}
# Works with both Python 2 and Python 3
{{ hosts.keys() | list }}
```

在python2中，字典有`iterkeys()`, `itervalues()`, and `iteritems()`方法，但是在python3中这些方法被删除，python3则使用 `dict.keys()`, `dict.values()`,  `dict.items()` 

```jinja2
# Only works with Python 2
{{ hosts.iteritems() }}

# Works with both Python 2 and Python 3
{{ hosts.items() | list }}
```

### 在 ansible 中使用Jinja2

#### 获取当前时间

使用 `now()` jinja2 函数可以获取当前的时间

```yaml
ansible localhost -m debug -a "msg={{ now(utc='True',fmt='%H-%m-%d %T') }}"
```

> utc 参数可以开启utc时间， fmt参数为时间的格式化输出。

> `{{ }}` 代表把表达式的结果打印到模板上


#### 过滤器

Ansible中的过滤器来自`Jinja2`，用于在模板表达式中转换数据。

过滤器与变量用管道符号 `|` 分割

##### 格式化数据过滤器

更改数据格式，其结果是对应的字符串

```jinj2
{{ some_variable | to_json }} 

{{ some_variable | to_yaml }}
```

对于人类可读得输出

```jinja2
{{ some_variable | to_nice_json }} 

{{ some_variable | to_nice_yaml }}
```

 还可以增加参数( new in 2.2)

```jinja2
{{ some_variable | to_nice_json(indent=2) }}

{{ some_variable | to_nice_yaml(indent=8) }}

{{ some_variable | to_nice_yaml(indent=8, width=1337) }}
```

> indent 指定缩进字符数， width限制行数宽度



从json字符串读取，其结果为json类型

```jinja2
{{ some_variable | from_json }}
```

 从yaml字符串读取，其结果为yaml类型

```jinja2
{{ some_variable | from_yaml }}
```

示例：将json文件内容赋值给变量

```jinja2
tasks:
  - shell: cat /some/path/to/file.json
    register: result

  - set_fact:
      myvar: "{{ result.stdout | from_json }}"
```

使用`from_yaml_all 解析多段yaml字符串

```yaml
tasks:
  - shell: cat /some/path/to/multidoc-file.yaml
    register: result
  - debug:
      msg: '{{ item }}'
    loop: '{{ result.stdout | from_yaml_all | list }}'
```



##### 强制定义变量

如果变量未定义，则来自 **ansible** 和 **ansible.cfg** 的默认行为为失败，但您可以将其关闭。

```jinja2
{{ variable | mandatory }}
```

 

##### 未定义的变量默认值

```jinja2
{{ result.cmd|default(5) }}

{{ lookup('env', 'MY_USER') | default('admin', true) }}

{{ lookup('env', 'MY_USER') | default('admin', false) }}
```

如果变量未定义，则将默认值赋值给变量，如果希望变量值为空的时候也赋值，需将 **default** 第二个值为`true`



##### 省略参数

```yaml
- name: touch files with an optional mode
  file:
    dest: "{{ item.path }}"
    state: touch
    mode: "{{ item.mode | default(omit) }}"
  loop:
    - path: /tmp/foo
    - path: /tmp/bar
    - path: /tmp/baz
      mode: "0444"
```

对于列表中的前两个文件，默认mode将由系统的umask确定，因为 `mode=parameter` 不会发送到文件模块，而最后得文件将接收`mode=0444`选项。

 

##### 列表过滤

取最小的值
```jinja2
{{ list1 | min }}
```


取最大的值
```jinja2
{{ [3, 4, 2] | max }}
```


展平列表
```jinja2
{{ [3, [4, 2] ] | flatten }}

{{ [3, [4, [2]] ] | flatten(levels=1) }}  # 展平第一级
```

##### 数据集过滤

对列表唯一过滤
```jinja2
{{ list1 | unique }}
```


对两个列表去重合并
```jinja2
{{ list1 | union(list2) }}
```


对两个列表做交集
```jinja2
{{ list1 | intersect(list2) }}
```


找到两个列表差异部分(在list1 不在list2 的差异)
```jinja2
{{ list1 | difference(list2) }}
```


找到两个列表都互相不在对方列表的部分
```jinja2
{{ list1 | symmetric_difference(list2) }}
```

##### 字典过滤

将字典变为列表

```jinja2
{{ dict | dict2items }}
```

返回的列表

```yaml
- key: Application
  value: payment
- key: Environment
  value: dev
```

可指定列表`key/vaule`的名字

```jinja2
{{ files | dict2items(key_name='file', value_name='path') }}
```

将列表转换为字典

```jinja2
{{ tags | items2dict }}
```

返回的字典

```yaml
Application: payment
Environment: dev
```

可指定列表`key/vaule`的名字

```jinja2
{{ tags | items2dict(key_name='key', value_name='value') }}
```

##### zip 过滤

使用 `zip` 来合并其他列表

```yaml
- name: give me list combo of two lists
  debug:
   msg: "{{ [1,2,3,4,5] | zip(['a','b','c','d','e','f']) | list }}"

- name: give me shortest combo of two lists
  debug:
    msg: "{{ [1,2,3] | zip(['a','b','c','d','e','f']) | list }}"
```

使用 `zip_longest` 以元素最多为合并对象

```yaml
- name: give me longest combo of three lists , fill with X
  debug:
    msg: "{{ [1,2,3] | zip_longest(['a','b','c','d','e','f'], [21, 22, 23], fillvalue='X') | list }}"
```

zip 也可以用于构造字典

```jinja2
{{ dict(keys_list | zip(values_list)) }}
```

变量

```yaml
keys_list:
  - one
  - two
values_list:
  - apple
  - orange
```

转换后

```yaml
one: apple
two: orange
```

##### 子元素过滤器

使用`subelements` 过滤对象的子元素

```jinja2
{{ users | subelements('groups', skip_missing=True) }}
```

变量

```yaml
users:
- name: alice
  authorized:
  - /tmp/alice/onekey.pub
  - /tmp/alice/twokey.pub
  groups:
  - wheel
  - docker
- name: bob
  authorized:
  - /tmp/bob/id_rsa.pub
  groups:
  - docker
```

转换后

```yaml
-
  - name: alice
    groups:
    - wheel
    - docker
    authorized:
    - /tmp/alice/onekey.pub
    - /tmp/alice/twokey.pub
  - wheel
-
  - name: alice
    groups:
    - wheel
    - docker
    authorized:
    - /tmp/alice/onekey.pub
    - /tmp/alice/twokey.pub
  - docker
-
  - name: bob
    authorized:
    - /tmp/bob/id_rsa.pub
    groups:
    - docker
  - docker
```

一个在循环中使用的例子

```yaml
- name: Set authorized ssh key, extracting just that data from 'users'
  authorized_key:
    user: "{{ item.0.name }}"
    key: "{{ lookup('file', item.1) }}"
  loop: "{{ users | subelements('authorized') }}"
```



##### 随机Mac地址过滤器

从一个以`52:54:00`开头的字符串前缀中获取一个随机的MAC地址

```jinja2
"{{ '52:54:00' | random_mac }}"
# => '52:54:00:ef:1c:03'
```

使用因子，创建随机但幂等的MAC地址

```jinja2
"{{ '52:54:00' | random_mac(seed=inventory_hostname) }}"
```



##### 随机数过滤

从列表中随机获取元素
```jinja2
{{ ['a','b','c','d','e','f']|random }}
```


从0-59 的整数中随机获取一个数
```jinja2
{{ 59 | random}}
```


从0-100 中随机获取能被10 整除的数（可以理解为0 10 20 30 40 50 ...100 的随机数）
```jinja2
{{ 100 |random(step=10) }}
```

从0-100 中随机获取1 开始步长为10 的数（可以理解为1 11 21 31 41...91 的随机数）
```jinja2
{{ 100 |random(1, 10) }}

{{ 100 |random(start=1, step=10) }}
```

使用因子创建随机数

```jinj2
"{{ 60 | random(seed=inventory_hostname) }} * * * * root /script/from/cron"
```



##### 随机列表过滤

给已存在的列表随机排序
```jinja2
{{ ['a','b','c']|shuffle }} => ['c','a','b']

{{ ['a','b','c']|shuffle }} => ['b','c','a']
```

使用因子生成随机列表

```jinj2
{{ ['a','b','c'] | shuffle(seed=inventory_hostname) }}
# => ['b','a','c']
```



##### 数学

获取对数, 默认`e`
```jinja2
{{ myvar | log }}

{{ myvar | log(10) }}
```


获取n次幂
```jinja2
{{ myvar | pow(2) }}

{{ myvar | pow(5) }}
```


获取平方根
```jinja2
{{ myvar | root }}

{{ myvar | root(5) }}
```



##### JSON查询过滤

> 该过滤器基于jmespath构建 更多的示例 [jmespath examples](http://jmespath.org/examples.html).

json过滤器，可以对复杂的json数据体提取一部分数据。



json结构体


```json
{
    "domain_definition": {
        "domain": {
            "cluster": [
                {
                    "name": "cluster1"
                },
                {
                    "name": "cluster2"
                }
            ],
            "server": [
                {
                    "name": "server11",
                    "cluster": "cluster1",
                    "port": "8080"
                },
                {
                    "name": "server12",
                    "cluster": "cluster1",
                    "port": "8090"
                }
            ],
            "library": [
                {
                    "name": "lib1",
                    "target": "cluster1"
                },
                {
                    "name": "lib2",
                    "target": "cluster2"
                }
            ]
        }
    }
}
```

要从这个结构中提取所有`cluster`，可以使用以下查询

```yaml
- name: "Display all cluster names"
  debug:
    var: item
  loop: "{{ domain_definition | json_query('domain.cluster[*].name') }}"
```

提取所有`server` 的 `name`

```yaml
- name: "Display all server names"
  debug:
    var: item
  loop: "{{ domain_definition | json_query('domain.server[*].name') }}"
```

提取 `cluster1` 的 `port`

```yaml
- name: "Display all ports from cluster1"
  debug:
    var: item
  loop: "{{ domain_definition | json_query(server_name_cluster1_query) }}"
  vars:
    server_name_cluster1_query: "domain.server[?cluster=='cluster1'].port"
```

使用字符串来连接端口

```yaml
- name: "Display all ports from cluster1 as a string"
  debug:
    msg: "{{ domain_definition | json_query('domain.server[?cluster==`cluster1`].port') | join(', ') }}"
```

> 这里使用反引号来避免转义

可以使用单引号转义

```yaml
- name: "Display all ports from cluster1"
  debug:
    var: item
  loop: "{{ domain_definition | json_query('domain.server[?cluster==''cluster1''].port') }}"
```



##### ip地址过滤

测试字符串是有效的ip地址不

```jinja2
{{ myvar | ipaddr }}
```


字符串转ip协议地址

```jinja2
{{ myvar | ipv4 }}

{{ myvar | ipv6 }}
```


从cidr中获取地址信息

```jinja2
{{ '192.0.2.1/24' | ipaddr('address') }}
```



##### Network CLI 过滤器

使用`parse_cli`过滤器将网络设备CLI命令的输出转换为JSON输出

```jinja2
{{ output | parse_cli('path/to/spec') }}
```



还支持使用TextFSM库解析CLI命令的输出

```jinja2
{{ output | parse_cli_textfsm('path/to/fsm') }}
```



##### Network XML 过滤器

使用`parse_xml`过滤器将网络设备CLI命令的输出转换为XML输出

```jinja2
{{ output | parse_xml('path/to/spec') }}
```



##### Network VLAN 过滤器

```jinja2
{{ [3003, 3004, 3005, 100, 1688, 3002, 3999] | vlan_parser }}
```

输出

```jinj2
['100,1688,3002-3005,3999']
```

另一个jinja2模板例子

```jinja2
{% set parsed_vlans = vlans | vlan_parser %}
switchport trunk allowed vlan {{ parsed_vlans[0] }}
{% for i in range (1, parsed_vlans | count) %}
switchport trunk allowed vlan add {{ parsed_vlans[i] }}
```


##### 哈希过滤器

获取字符串得hash值
```jinja2
{{ 'test1'|hash('sha1') }}

{{ 'test1'|hash('md5') }}
```


获取字符串校验和
```jinja2
{{ 'test2'|checksum }}
```


获取sha512密码哈希
```jinja2
{{ 'passwordsaresecret'|password_hash('sha512') }}

{{ 'secretpassword'|password_hash('sha256', 'mysecretsalt') }}
```

##### 合并散列


```jinja2
{{ {'a':1, 'b':2}|combine({'b':3}) }}
```
结果
```
{'a':1, 'b':3}
```


支持递归合并
```jinja2
{{ {'a':{'foo':1, 'bar':2}, 'b':2}|combine({'a':{'bar':3, 'baz':4}}, recursive=True) }}
```


结果
```jinja2
{'a':{'foo':1, 'bar':3, 'baz':4}, 'b':2}
```



##### 提取过滤器

使用 `map`  `extract`筛选器将索引列表映射到容器中的值作为列表返回


```jinja2
{{ [0,2]|map('extract', ['x','y','z'] )| list }}

# ['x', 'z']
```

```jinja2
{{ ['x','y']|map('extract', {'x': 42, 'y': 31})|list }}

# [42, 31]
```

```jinja2
{{ groups['x']|map('extract', hostvars, 'ec2_ip_address')|list }}
```

这需要组'x'中的主机列表，在主机中查找主机，然后查找结果的ec2_ip_address。 最后的结果是组'x'中的主机的IP地址列表。
```jinja2
{{ groups['test'] | map('extract', hostvars, 'ansible_default_ipv4.address')|list }}
```


过滤器的第三个参数也可以是一个列表，用于容器内的递归查找：

```jinja2
{{ ['a']|map('extract', b, ['x','y'])|list }}

#  b['a']['x']['y']
```

map中也可以使用其他过滤器

```jinja2
# 更改列表中的文件目录
{{ ['/test/t.gz'] | map('basename')| map('regex_replace', '(.*)', '/tmp/\\1') | list )}}
```


##### 注释过滤

`comment` 过滤器允许用选择的注释样式装饰文本。

```jinja2
{{ "Plain style (default)" | comment }}
```
输出
```
#
# Plain style (default)
#
```



**指定特定的注释字符**

```yaml
{{ "My Special Case" | comment(decoration="! ") }}
```

输出

```
!
! My Special Case
!
```

**输出各种语言的注释风格**

```jinja2
{{ "C style" | comment('c') }}
{{ "C block style" | comment('cblock') }}
{{ "Erlang style" | comment('erlang') }}
{{ "XML style" | comment('xml') }}
```


还可以自定义
```jinja2
{{ "Custom style" | comment('plain', prefix='#######\n#', postfix='#\n#######\n   ###\n    #') }}
```

输出

```
#######
#
# Custom style
#
#######
   ###
    #
```



##### url 分割过滤器

使用 `urlsplit` 过滤器从url字符串中取其中的一个片段

```jinja2
{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('hostname') }}
# => 'www.acme.com'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('netloc') }}
# => 'user:password@www.acme.com:9000'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('username') }}
# => 'user'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('password') }}
# => 'password'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('path') }}
# => '/dir/index.html'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('port') }}
# => '9000'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('scheme') }}
# => 'http'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('query') }}
# => 'query=term'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('fragment') }}
# => 'fragment'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit }}
# =>
#   {
#       "fragment": "fragment",
#       "hostname": "www.acme.com",
#       "netloc": "user:password@www.acme.com:9000",
#       "password": "password",
#       "path": "/dir/index.html",
#       "port": 9000,
#       "query": "query=term",
#       "scheme": "http",
#       "username": "user"
#   }
```



##### 正则匹配

```jinja2
# search for "foo" in "foobar"
{{ 'foobar' | regex_search('(foo)') }}

# will return empty if it cannot find a match
{{ 'ansible' | regex_search('(foobar)') }}

# case insensitive search in multiline mode
{{ 'foo\nBAR' | regex_search("^bar", multiline=True, ignorecase=True) }}
```

搜索所有匹配的regex

```jinja2
# Return a list of all IPv4 addresses in the string
{{ 'Some DNS servers are 8.8.8.8 and 8.8.4.4' | regex_findall('\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b') }}
```

正则替换

```jinja2
# convert "ansible" to "able"
{{ 'ansible' | regex_replace('^a.*i(.*)$', 'a\\1') }}

# convert "foobar" to "bar"
{{ 'foobar' | regex_replace('^f.*o(.*)$', '\\1') }}

# convert "localhost:80" to "localhost, 80" using named groups
{{ 'localhost:80' | regex_replace('^(?P<host>.+):(?P<port>\\d+)$', '\\g<host>, \\g<port>') }}

# convert "localhost:80" to "localhost"
{{ 'localhost:80' | regex_replace(':80') }}
```

转义特殊字符

```jinja
# convert '^f.*o(.*)$' to '\^f\.\*o\(\.\*\)\$'
{{ '^f.*o(.*)$' | regex_escape() }}

# convert '^f.*o(.*)$' to '\^f\.\*o(\.\*)\$'
{{ '^f.*o(.*)$' | regex_escape('posix_basic') }}
```



##### Kubernetes 过滤器

使用`k8s_config_resource_name`过滤器来获取Kubernetes ConfigMap或Secret的名称

```jinja2
{{ configmap_resource_definition | k8s_config_resource_name }}
```



##### 其他的常用过滤

 为shell增加双引号

```yaml
- shell: echo {{ string_value | quote }}
```

根据True，False来返回值

```jinja2
{{ ('name' == 'John') | ternary('Mr','Ms') }}

{{ enabled | ternary('no shutdown', 'shutdown', omit) }} # null 使用第三个值
```

列表转换字符
```jinja2
{{ list | join(" ") }}
```


获取路径的文件名
```jinja2
{{ path | basename }}
```


获取文件的绝对路径
```jinja2
{{ '~/.ssh/id_rsa' | expanduser }}
```


windows平台下获取路径的文件名
```jinja2
{{ path | win_basename }}
```


获取路径中的目录
```jinja2
{{ path | dirname }}
```

展开包含环境变量的路径

```jinja2
{{ path | expandvars }}
```

获取软连接的真实路径

```jinja2
{{ path | realpath }}

{{ path | relpath('/etc') }}  # 指定启点
```


获取文件名的名称和扩展名
```jinja2
{{ path | splitext }}
```


base64编码
```jinja2
{{ encoded | b64decode }}
{{ decoded | string | b64encode }}

{{ encoded | b64decode(encoding='utf-16-le') }}
{{ decoded | string | b64encode(encoding='utf-16-le') }}
```


从字符串创建UUID（1.9版中的新功能）
```jinja2
{{ hostname | to_uuid }}
```


将转换为布尔类型，如"True" 字符串转换为True
```
- debug: msg=test
 when: some_string_value | bool
```


日期
```jinja2
# Get total amount of seconds between two dates. Default date format is %Y-%m-%d %H:%M:%S but you can pass your own format
{{ (("2016-08-14 20:00:12" | to_datetime) - ("2015-12-25" | to_datetime('%Y-%m-%d'))).total_seconds() }}

# Get remaining seconds after delta has been calculated. NOTE: This does NOT convert years, days, hours, etc to seconds. For that, use total_seconds()
{{ (("2016-08-14 20:00:12" | to_datetime) - ("2016-08-14 18:00:00" | to_datetime)).seconds }}
# This expression evaluates to "12" and not "132". Delta is 2 hours, 12 seconds

# get amount of days between two dates. This returns only number of days and discards remaining hours, minutes, and seconds
{{ (("2016-08-14 20:00:12" | to_datetime) - ("2015-12-25" | to_datetime('%Y-%m-%d'))).days }}
```

格式化日期

```jinja2
# Display year-month-day
{{ '%Y-%m-%d' | strftime }}

# Display hour:min:sec
{{ '%H:%M:%S' | strftime }}

# Use ansible_date_time.epoch fact
{{ '%Y-%m-%d %H:%M:%S' | strftime(ansible_date_time.epoch) }}

# Use arbitrary epoch value
{{ '%Y-%m-%d' | strftime(0) }}          # => 1970-01-01
{{ '%Y-%m-%d' | strftime(1441357287) }} # => 2015-09-04
```

查看变量的python类型

```jinja2
{{ myvar | type }}
```



##### 组合过滤器

```yaml
- name: give me largest permutations (order matters)
  debug:
    msg: "{{ [1,2,3,4,5] | permutations | list }}"

- name: give me permutations of sets of three
  debug:
    msg: "{{ [1,2,3,4,5] | permutations(3) | list }}"
    
- name: give me combinations for sets of two
  debug:
    msg: "{{ [1,2,3,4,5] | combinations(2) | list }}"
```



##### Product  过滤器

`product`过滤器返回输入迭代的笛卡尔积。

```yaml
- name: generate multiple hostnames
  debug:
    msg: "{{ ['foo', 'bar'] | product(['com']) | map('join', '.') | join(',') }}"
```

输出

```json
{ "msg": "foo.com,bar.com" }
```



##### debug 过滤器

```jinja2
{{ myvar | type_debug }}
```



##### 字节转换

将数字转换为人类可读的字符串

```yaml
- name: "Human Readable"
  assert:
    that:
      - '"1.00 Bytes" == 1|human_readable'
      - '"1.00 bits" == 1|human_readable(isbits=True)'
      - '"10.00 KB" == 10240|human_readable'
      - '"97.66 MB" == 102400000|human_readable'
      - '"0.10 GB" == 102400000|human_readable(unit="G")'
      - '"0.10 Gb" == 102400000|human_readable(isbits=True, unit="G")'
```

返回

```json
{ "changed": false, "msg": "All assertions passed" }
```



以字节格式返回给定的字符串。

```yaml
- name: "Human to Bytes"
  assert:
    that:
      - "{{'0'|human_to_bytes}}        == 0"
      - "{{'0.1'|human_to_bytes}}      == 0"
      - "{{'0.9'|human_to_bytes}}      == 1"
      - "{{'1'|human_to_bytes}}        == 1"
      - "{{'10.00 KB'|human_to_bytes}} == 10240"
      - "{{  '11 MB'|human_to_bytes}} == 11534336"
      - "{{ '1.1 GB'|human_to_bytes}} == 1181116006"
      - "{{'10.00 Kb'|human_to_bytes(isbits=True)}} == 10240"
```

返回
```json
{ "changed": false, "msg": "All assertions passed" }
```



#### 测试



除了过滤器，所谓的“测试”也是可用的。测试可以用于对照普通表达式测试一个变量。 要测试一个变量或表达式，你要在变量后加上一个 is 以及测试的名称。例如，要得出 一个值是否定义过，你可以用 name is defined ，这会根据 name 是否定义返回 true 或 false 。


##### 测试语法

```
variable is test_name
```

例如

```
result is failed
```

测试也可以接受参数。如果测试只接受一个参数，你可以省去括号来分组它们。例如， 下面的两个表达式做同样的事情:


```jinja2
{% if loop.index is divisibleby 3 %}
{% if loop.index is divisibleby(3) %}
```


##### 测试字符串

```
vars:
  url: "http://example.com/users/foo/resources/bar"

tasks:
    - debug:
        msg: "matched pattern 1"
      when: url is match("http://example.com/users/.*/resources/.*")

    - debug:
        msg: "matched pattern 2"
      when: url is search("/users/.*/resources/.*")

    - debug:
        msg: "matched pattern 3"
      when: url is search("/users/")

    - debug:
        msg: "matched pattern 4"
      when: url is regex("example.com/\w+/foo")
```

`match`需要在字符串中完全匹配，而`search`只需要匹配字符串的子集。匹配成功返回`True`，任务则执行。

 

##### 版本比较

检查ansible_distribution_version版本是否大于或等于'12 .04'，条件成立返回True。
```jinja2
{{ ansible_distribution_version is version_compare('12.04', '>=') }}
```


进行严格的版本检查
```jinja2
{{ sample_version_var is version_compare('1.0', operator='lt', strict=True) }}
```
可接受的运算符
```
<, lt, <=, le, >, gt, >=, ge, ==, =, eq, !=, <>, ne
```



##### 包含测试

测试一个列表是否包含另一个列表。

```yaml
vars:
    a: [1,2,3,4,5]
    b: [2,3]
tasks:
    - debug:
        msg: "A includes B"
      when: a is superset(b)

    - debug:
        msg: "B is included in A"
      when: b is subset(a)
```

测试列表是否包含值

```yaml
vars:
  lacp_groups:
    - master: lacp0
      network: 10.65.100.0/24
      gateway: 10.65.100.1
      dns4:
        - 10.65.100.10
        - 10.65.100.11
      interfaces:
        - em1
        - em2

    - master: lacp1
      network: 10.65.120.0/24
      gateway: 10.65.120.1
      dns4:
        - 10.65.100.10
        - 10.65.100.11
      interfaces:
          - em3
          - em4

tasks:
  - debug:
      msg: "{{ (lacp_groups|selectattr('interfaces', 'contains', 'em1')|first).master }}"
```

您可以使用`any ` 和 ` all`来检查列表中的任何元素或所有元素是否为真

```yaml
vars:
  mylist:
      - 1
      - "{{ 3 == 3 }}"
      - True
  myotherlist:
      - False
      - True
tasks:

  - debug:
      msg: "all are true!"
    when: mylist is all

  - debug:
      msg: "at least one is true"
    when: myotherlist is any
```

##### 路径测试

```yaml
- debug:
    msg: "path is a directory"
  when: mypath is directory

- debug:
    msg: "path is a file"
  when: mypath is file

- debug:
    msg: "path is a symlink"
  when: mypath is link

- debug:
    msg: "path already exists"
  when: mypath is exists

- debug:
    msg: "path is {{ (mypath is abs)|ternary('absolute','relative')}}"

- debug:
    msg: "path is the same file as path2"
  when: mypath is same_file(path2)

- debug:
    msg: "path is a mount"
  when: mypath is mount
```

##### 测试命令结果

以下playbook是检查任务状态的测试。

```
tasks:

- shell: /usr/bin/foo
  register: result
  ignore_errors: True

- debug: msg="it failed"
  when: result is failed
  
- debug: msg="it changed"
  when: result is changed

- debug: msg="it succeeded in Ansible >= 2.1"
  when: result is succeeded

- debug: msg="it succeeded"
  when: result is success

- debug: msg="it was skipped"
  when: result is skipped
```

#### lookup 插件

`lookup` 插件允许访问外部数据源。

```yaml
# 获取文件内容
vars:
  motd_value: "{{ lookup('file', '/etc/motd') }}"
tasks:
  - debug:
      msg: "motd value is {{ motd_value }}"
```

lookup 更多的插件使用请看 [lookup 插件](/basic/Playbook-features/#lookup)

#### if 语句

ad-hoc
```bash
ansible localhost -m debug -a "msg={%- if ansible_play_hosts.index(inventory_hostname) < 3 -%}master{%- else -%}slave{%- endif -%}" 
```

playbook

```yaml
- debug:
      msg: >-
        {%- if ansible_play_hosts.index(inventory_hostname) < 3 -%}
          master
        {%- else -%}
          slave
        {%- endif -%}
```

#### for 语句

ad-hoc

```bash
ansible localhost -m debug -a "msg={%- for t in [1,2,3] -%}{{ t }}{%- endfor -%}"
```

playbook

```yaml
- debug:
    msg: |-
      {%- for t in [1,2,3] -%}
        {{ t }}
      {%- endfor -%}
```

#### 在 when 里使用 jinja2 表达式

```yaml
- hosts: target_host
  tasks:
  - name: Show debug
    debug: msg='条件满足你就会看到我。'
    when: '{% if def_a_var|d("abc") == "abc" %}{{ foo | d("true") }}{% endif %}'
```


## 13.条件判断与循环

### 条件判断

ansible 使用`when`语句后的表达式来判断该步骤是否执行。 


#### When 语句

在when 后面使用没有`{{ }}` 的 `Jinja2` 表达式，结果为True则执行任务。

>  不需要使用 {{}} 来在条件语句中使用变量

```yaml
#  若操作系统是 Debian 时就执行关机操作
tasks:
    - name: "shut down Debian flavored systems"
      command: /sbin/shutdown -t now
      when: ansible_os_family == "Debian"
```

>  ansible_os_family  是 facts 或 vars 的变量

您还可以使用括号对条件进行分组

```YAML
tasks:
  - name: "shut down CentOS 6 and Debian 7 systems"
    command: /sbin/shutdown -t now
    when: (ansible_facts['distribution'] == "CentOS" and ansible_facts['distribution_major_version'] == "6") or
          (ansible_facts['distribution'] == "Debian" and ansible_facts['distribution_major_version'] == "7")
```

可以使用列表形式来表示条件为 **and** 的关系

```yaml
tasks:
  - name: "shut down CentOS 6 systems"
    command: /sbin/shutdown -t now
    when:
      - ansible_facts['distribution'] == "CentOS"
      - ansible_facts['distribution_major_version'] == "6"
```

许多Jinja2测试和过滤器也可以用于when语句，其中一些是唯一的，由Ansible提供。

```yaml
tasks:
  - command: /bin/false
    register: result
    ignore_errors: True

  - command: /bin/something
    when: result is failed

  # 忽略一个语句的错误，然后决定基于成功或失败有条件地做一些事情。
  - command: /bin/something_else
    when: result is succeeded

  - command: /bin/still/something_else
    when: result is skipped
```

 字符串转换为数字型再去比较

```yaml
tasks:
  - shell: echo "only on Red Hat 6, derivatives, and later"
    when: ansible_facts['os_family'] == "RedHat" and ansible_facts['lsb']['major_release']|int >= 6
```

也可以使用定义的变量，注意字符串(类似:"yes", "on", "1","true")需要用`|bool` 转成布尔值。

```yaml
- hosts: node
  vars:
    epic: true
    monumental: "yes"
  tasks:
    - shell: echo "This certainly is epic!"
      when: epic or monumental | bool
    - shell: echo "This certainly isn't epic!"
      when: not epic
```

如果未设置所需的变量，则可以使用 Jinja2 定义的测试跳过或失败。例如:

```yaml
tasks:
    - shell: echo "I've got '{{ foo }}' and am not afraid to use it!"
      when: foo is defined

    - fail: msg="Bailing out. this play requires 'bar'"
      when: bar is undefined
```

#### 与循环一起使用

依次遍历列表，当列表里得数字大于5时执行任务

```yaml
tasks:
    - command: echo {{ item }}
      loop: [ 0, 2, 4, 6, 8, 10 ]
      when: item > 5
```

 当变量不存在时，直接跳过

```yaml
- command: echo {{ item }}
  loop: "{{ mylist | default([]) }}"
  when: item > 5
```

如果变量是字典

```yaml
- command: echo {{ item.key }}
  loop: "{{ query('dict', mydict|default({})) }}"
  when: item.value > 5
```

#### 使用自定义的facts值做判断

你可以开发一个模块来设置facts数据，并将其作为变量结果返回，后续的任务就可以使用这个变量了。

```yaml
tasks:
    - name: gather site specific fact data
      action: site_facts
    - command: /usr/bin/thingy
      when: my_custom_fact_just_retrieved_from_the_remote_system == '1234'
```

#### 角色包含使使用when

 如果您有多个任务都共享同一个条件语句，则可以将该条件附加到task include语句上，如下：

```yaml
- import_tasks: tasks/sometasks.yml
  when: "'reticulating splines' in output"
```

使用在角色上

```yaml
- hosts: webservers
  roles:
     - role: debian_stock_config
       when: ansible_facts['os_family'] == 'Debian'
```

>  当条件句与`include*`任务一起使用时，它仅应用于包含任务本身，而不应用于包含文件中的任何其他任务。 

#### 有条件的导入

 有时你会想要根据特定的标准在剧本中做一些不同的事情 。拥有一个适用于多个平台和操作系统版本的剧本就是一个很好的例子。 

 例如，Apache包的名称在CentOS和Debian之间不同，但是在Ansible Playbook中， 你可以用最简洁的语法来处理这个

```yaml
---
# for vars/RedHat.yml
apache: httpd
somethingelse: 42
---
# for vars/Debian.yml
apache: apache2
somethingelse: 42

---
# for playbook.yml
- hosts: all
  remote_user: root
  vars_files:
    - "vars/common.yml"
    - [ "vars/{{ ansible_facts['os_family'] }}.yml", "vars/os_defaults.yml" ]
  tasks:
  - name: make sure apache is started
    service: name={{ apache }} state=started
```

> ansible_facts['os_family'] 来确定执行的主机系统

#### 基于变量选择文件和模板

```yaml
- name: template a file
  template:
      src: "{{ item }}"
      dest: /etc/myapp/foo.conf
  loop: "{{ query('first_found', { 'files': myfiles, 'paths': mypaths}) }}"
  vars:
    myfiles:
      - "{{ansible_facts['distribution']}}.conf"
      -  default.conf
    mypaths: ['search_location_one/somedir/', '/opt/other_location/somedir/']
```

 

#### 使用注册变量判断

 将给定命令的结果存储在变量中， 并在后续的任务中使用。

```yaml
- name: test play
  hosts: all

  tasks:

      - shell: cat /etc/motd
        register: motd_contents

      - shell: echo "motd contains the word hi"
        when: motd_contents.stdout.find('hi') != -1
```

 如果注册的结果被转换为列表(或者已经是列表)，则可以在任务的循环中使用 。

```yaml
- name: registered variable usage as a loop list
  hosts: all
  tasks:

    - name: retrieve the list of home directories
      command: ls /home
      register: home_dirs

    - name: add home dirs to the backup spooler
      file:
        path: /mnt/bkspool/{{ item }}
        src: /home/{{ item }}
        state: link
      loop: "{{ home_dirs.stdout_lines }}"
      # same as loop: "{{ home_dirs.stdout.split() }}"### 
```

#### failed_when

满足给定的条件时，使任务失败

```yaml
tasks:
    - command: echo faild.
      register: command_result
      failed_when: "'faild' in command_result.stdout"
    
    - debug: msg="echo test"
```

还可以写成这样

```yaml
tasks:
    - command: echo faild.
      register: command_result
      ignore_errors: True

    - name: fail the echo
      fail: msg="the command failed"
      when: "'faild' in command_result.stdout"

    - debug: msg="echo test"
```

> fail 模块是产生一个错误信息

#### changed_when

如果说一个命令没有更改任何事物，就可以为其设置为没有更改状态

```yaml
tasks:
    - name: Install dependencies via Composer.
      command: "/usr/local/bin/composer global require phpunit/phpunit --prefer-dist"
      register: composer
      changed_when: "'Nothing to install or update' not in composer.stdout"
```

### 循环

有时你想要重复一个任务多次。在计算机编程中，这叫做循环， Ansible提供了两个用于创建循环的关键字：`loop`和`with_<lookup>`。 

-  我们在Ansible 2.5中添加了`loop`。它还不是`with_<lookup>`的完整替代品，但是我们建议在大多数用例中使用它。 
- 我们并没有反对使用`with_<lookup>`—在可预见的将来，该语法仍然有效。
- 我们一直在改进`loop`语法，请注意修改日志。

#### 比较`loop` 和 `with_*`

- `with_<lookup>`关键字依赖于`Lookup`插件
- `loop`关键字相当于`with_list`，是简单循环的最佳选择。
- `loop`关键字不会接受字符串作为输入 
- 一般来说, 所有`with_*`的使用，都可以使用`loop`替代
- 使用` with_items `时要注意， 因为`with_items`会执行隐式单级展平。 您可能需要使用带有循环的flatten(1)来匹配确切的结果。

```
with_items:
  - 1
  - [2,3]
  - 4
```

使用loop表达

```yaml
loop: "{{ [1, [2,3] ,4] | flatten(1) }}"
```

- 在使用查找的功能时, 都不应该将`with_*`转换成`loop`

```yaml
loop: "{{ lookup('fileglob', '*.txt', wantlist=True) }}"
```

使用`with_*`可以很简洁的表达

```yaml
with_fileglob: '*.txt'
```

 

#### 标准循环

##### 遍历列表

添加多个用户

```yaml
- name: add several users
  user:
    name: "{{ item }}"
    state: present
    groups: "wheel"
  loop:
     - testuser1
     - testuser2
```

也可以直接引用变量列表

```yaml
loop: "{{ somelist }}"
```

这两个例子等价于

```yaml
- name: add user testuser1
  user:
    name: "testuser1"
    state: present
    groups: "wheel"

- name: add user testuser2
  user:
    name: "testuser2"
    state: present
    groups: "wheel"
```

有时，如果模块可以接受列表的话，就不需要使用循环来传递。例如yum包管理的

```yaml
- name: optimal yum
  yum:
    name: "{{  list_of_packages  }}"
    state: present

- name: non-optimal yum, slower and may cause issues with interdependencies
  yum:
    name: "{{  item  }}"
    state: present
  loop: "{{  list_of_packages  }}"
```

#####  遍历散列列表

如果你有一个散列列表，可以在循环中引用子键。

```yaml
- name: add several users
  user:
    name: "{{ item.name }}"
    state: present
    groups: "{{ item.groups }}"
  loop:
    - { name: 'testuser1', groups: 'wheel' }
    - { name: 'testuser2', groups: 'root' }
```

> 添加多个用户，并将用户加入不同的组内。

##### 遍历字典

要遍历字典，请使用`dict2items`过滤器将字典转换成散列：

```yaml
- name: create a tag dictionary of non-empty tags
  set_fact:
    tags_dict: "{{ (tags_dict|default({}))|combine({item.key: item.value}) }}"
  loop: "{{ tags|dict2items }}"
  vars:
    tags:
      Environment: dev
      Application: payment
      Another: "{{ doesnotexist | default() }}"
  when: item.value != ""
```

> default() 可以在变量未定义的时候为其设置一个默认值。

#####  循环中注册变量 

```yaml
- shell: "echo {{ item }}"
  loop:
    - "one"
    - "two"
  register: echo
```

当您在循环中使用register时，放在变量中的数据结构将包含一个results属性，该属性是来自模块的所有执行的列表。这与不使用循环使用register时返回的数据结构不同

```json
{
    "changed": true, 
    "msg": "All items completed", 
    "results": [
        {
            "ansible_loop_var": "item", 
            "changed": true, 
            "cmd": "echo one", 
            "delta": "0:00:00.003978", 
            "end": "2020-03-30 21:13:24.329114", 
            "failed": false, 
            "invocation": {
                "module_args": {
                    "_raw_params": "echo one", 
                    "_uses_shell": true, 
                    "argv": null, 
                    "chdir": null, 
                    "creates": null, 
                    "executable": null, 
                    "removes": null, 
                    "stdin": null, 
                    "stdin_add_newline": true, 
                    "strip_empty_ends": true, 
                    "warn": true
                }
            }, 
            "item": "one", 
            "rc": 0, 
            "start": "2020-03-30 21:13:24.325136", 
            "stderr": "", 
            "stderr_lines": [], 
            "stdout": "one", 
            "stdout_lines": [
                "one"
            ]
        }, 
        {
            "ansible_loop_var": "item", 
            "changed": true, 
            "cmd": "echo two", 
            "delta": "0:00:00.003879", 
            "end": "2020-03-30 21:13:24.621379", 
            "failed": false, 
            "invocation": {
                "module_args": {
                    "_raw_params": "echo two", 
                    "_uses_shell": true, 
                    "argv": null, 
                    "chdir": null, 
                    "creates": null, 
                    "executable": null, 
                    "removes": null, 
                    "stdin": null, 
                    "stdin_add_newline": true, 
                    "strip_empty_ends": true, 
                    "warn": true
                }
            }, 
            "item": "two", 
            "rc": 0, 
            "start": "2020-03-30 21:13:24.613500", 
            "stderr": "", 
            "stderr_lines": [], 
            "stdout": "two", 
            "stdout_lines": [
                "two"
            ]
        }
    ]
}
```

后续使用注册变量来检查命令执行情况

```yaml
- name: Fail if return code is not 0
  fail:
    msg: "The command ({{ item.cmd }}) did not have a 0 return code"
  when: item.rc != 0
  loop: "{{ echo.results }}"
```

在循环过程中，也可以使用当前的模块结果

```yaml
- shell: echo "{{ item }}"
  loop:
    - one
    - two
  register: echo
  changed_when: echo.stdout != "one"
```



#### 复杂循环

##### 遍历嵌套列表

您可以使用Jinja2表达式迭代复杂的列表。例如， 分别给用户授予3个数据库的所有权限

```yaml
- name: give users access to multiple databases
  mysql_user:
    name: "{{ item[0] }}"
    priv: "{{ item[1] }}.*:ALL"
    append_privs: yes
    password: "foo"
  loop: "{{ ['alice', 'bob'] | product(['clientdb', 'employeedb', 'providerdb'])|list }}"
```

##### 在满足条件之前重试任务

 可以使用`until`关键字重试任务，直到满足特定条件。 

```yaml
- shell: /usr/bin/foo
  register: result
  until: result.stdout.find("all systems go") != -1
  retries: 5
  delay: 10
```

> 此任务最多运行5次，每次尝试之间的延迟为10秒。如果标准输出中有`all systems go`字符串，则任务成功。重试的默认值是3，延迟是5。 

##### 循环主机清单

```yaml
# 输出所有主机信息
- debug:
    msg: "{{ item }}"
  loop: "{{ groups['all'] }}"

# 输出当前play运行的主机信息
- debug:
    msg: "{{ item }}"
  loop: "{{ ansible_play_batch }}"
  
# 显示清单中的所有主机
- debug:
    msg: "{{ item }}"
  loop: "{{ query('inventory_hostnames', 'all') }}"

# 除组www外的所有主机
- debug:
    msg: "{{ item }}"
  loop: "{{ query('inventory_hostnames', 'all:!www') }}"
```

##### 使用`query`还是`lookup`

loop关键字需要一个列表作为输入，默认情况下，`lookup`关键字返回一个逗号分隔的值字符串 ,而`query`返回的是一个列表。

如果使用`lookup`返回列表，则可以添加` wantlist=True  `强制返回列表。

```yaml
loop: "{{ query('inventory_hostnames', 'all') }}"

loop: "{{ lookup('inventory_hostnames', 'all', wantlist=True) }}"
```

##### 循环控制

使用`loop_control`关键字来管理循环。

###### 使用`label`限制loop的输出

```yaml
- name: create servers
  digital_ocean:
    name: "{{ item.name }}"
    state: present
  loop:
    - name: server1
      disks: 3gb
      ram: 15Gb
      network:
        nic01: 100Gb
        nic02: 10Gb
        ...
  loop_control:
    label: "{{ item.name }}"
```

 这个任务的输出将只显示每个项目的名称字段，而不是多行`{{item}}`变量的整个内容。 

> 这是为了使控制台输出更具可读性，而不是为了保护敏感数据。如果循环中有敏感数据，则设置`no_log: yes`，以防止泄漏。 

###### 循环间隔时间

使用`pause`指令控制循环中每个项执行之间的时间(以秒为单位)

```yaml
- name: create servers, pause 3s before creating next
  digital_ocean:
    name: "{{ item }}"
    state: present
  loop:
    - server1
    - server2
  loop_control:
    pause: 3
```

###### 循环索引

使用` index_var` 指令来跟踪当前循环的索引

```yaml
- name: count our fruit
  debug:
    msg: "{{ item }} with index {{ my_idx }}"
  loop:
    - apple
    - banana
    - pear
  loop_control:
    index_var: my_idx
```

###### 更改循环的变量名称

循环的默认变量名称为`item`,可以通过`loop_var`来修改此项,从而避免覆盖`include_tasks`任务里的循环变量

```yaml
# main.yml
- include_tasks: inner.yml
  loop:
    - 1
    - 2
    - 3
  loop_control:
    loop_var: outer_item

# inner.yml
- debug:
    msg: "outer item={{ outer_item }} inner item={{ item }}"
  loop:
    - a
    - b
    - c
```

###### 扩展变量

从Ansible 2.8开始，你可以使用扩展选项来获取扩展循环信息。此选项将公开以下信息。

| 变量                     | 描述                                           |
| ------------------------ | ---------------------------------------------- |
| `ansible_loop.allitems`  | 循环中所有项的列表                             |
| `ansible_loop.index`     | 循环的当前迭代次数。(从1开始)                  |
| `ansible_loop.index0`    | 循环的当前迭代次数。(从0开始)                  |
| `ansible_loop.revindex`  | 循环结束后的迭代次数。(从1开始)                |
| `ansible_loop.revindex0` | 循环结束后的迭代次数。(从0开始)                |
| `ansible_loop.first`     | 如果是第一次迭代，返回`True`                   |
| `ansible_loop.last`      | 如果是最后一次迭代，返回`True`                 |
| `ansible_loop.length`    | 循环中的项数                                   |
| `ansible_loop.previtem`  | 循环前一次迭代的项。在第一次迭代中未定义。     |
| `ansible_loop.nextitem`  | 循环的后续迭代中的项。在最后一次迭代中未定义。 |

```
loop_control:
  extended: yes
```

##### 获取`loop_var`的名称

从ansible2.8开始，你可以通过` ansible_loop_var` 来获取 ` loop_control.loop_var `的值

```yaml
"{{ lookup('vars', ansible_loop_var) }}"
```

#### 从with_*迁移到loop

随着Ansible 2.5的发布，执行循环的推荐方法是使用`loop`关键字，而不是`with_*`样式的循环。 

在许多情况下，`loop`语法使用过滤器更好地表达，而不是使用更复杂的`query`或`lookup`。 

下面的示例将展示如何将许多常见的`with_`样式循环转换为`loop`。

##### with_list

遍历列表

```yaml
- name: with_list
  debug:
    msg: "{{ item }}"
  with_list:
    - one
    - two

- name: with_list -> loop
  debug:
    msg: "{{ item }}"
  loop:
    - one
    - two
```

##### with_items

遍历列表

```yaml
- name: with_items
  debug:
    msg: "{{ item }}"
  with_items: "{{ items }}"

- name: with_items -> loop
  debug:
    msg: "{{ item }}"
  loop: "{{ items | flatten(levels=1) }}"
  

- name: with_items with muliti lists within a list
  debug: msg={{ item }}
  with_items: 
    - "{{ foo }}"
    - "{{ bar }}"
        
- name: loop with a list within lists of list  ( {{ list | union(list) }} )
  debug: msg={{ item }}
  loop: "{{ foo | union(bar) }}"

- name: loop with a list within lists of list  ( {{ list + list }} )
  debug: msg={{ item }}
  loop: "{{ foo + bar }}"
```

##### with_indexed_items

遍历列表和索引

```yaml
- name: with_indexed_items
  debug:
    msg: "{{ item.0 }} - {{ item.1 }}"
  with_indexed_items: "{{ items }}"

- name: with_indexed_items -> loop
  debug:
    msg: "{{ index }} - {{ item }}"
  loop: "{{ items | flatten(levels=1) }}"
  loop_control:
    index_var: index
```

##### with_flattened

合并列表

```yaml
- name: with_flattened
  debug:
    msg: "{{ item }}"
  with_flattened: "{{ items }}"

- name: with_flattened -> loop
  debug:
    msg: "{{ item }}"
  loop: "{{ items | flatten }}"
```

##### with_together

并行遍历列表

```yaml
- name: with_together
  debug:
    msg: "{{ item.0 }} - {{ item.1 }}"
  with_together:
    - "{{ list_one }}"
    - "{{ list_two }}"

- name: with_together -> loop
  debug:
    msg: "{{ item.0 }} - {{ item.1 }}"
  loop: "{{ list_one|zip(list_two)|list }}"
```

##### with_dict

遍历字典

```yaml
- name: with_dict
  debug:
    msg: "{{ item.key }} - {{ item.value }}"
  with_dict: "{{ dictionary }}"

- name: with_dict -> loop (option 1)
  debug:
    msg: "{{ item.key }} - {{ item.value }}"
  loop: "{{ dictionary|dict2items }}"

- name: with_dict -> loop (option 2)
  debug:
    msg: "{{ item.0 }} - {{ item.1 }}"
  loop: "{{ dictionary|dictsort }}"
  
- name: with_dict lookup
  debug:
    msg: "with_dict_lookup: item.key is '{{ item.key }}' and item.value is '{{ item.value }}'"
  loop: "{{ lookup('dict', dictionary) }}"

- name: with_dict query
  debug:
    msg: "with_dict_query: item.key is '{{ item.key }}' and item.value is '{{ item.value }}'"
  loop: "{{ query('dict', dictionary) }}"
```

##### with_sequence

以递增的数字顺序生成项序列

```yaml
- name: with_sequence
  debug:
    msg: "{{ item }}"
  with_sequence: start=0 end=4 stride=2 format=testuser%02x

- name: with_sequence -> loop
  debug:
    msg: "{{ 'testuser%02x' | format(item) }}"
  # range is exclusive of the end point
  loop: "{{ range(0, 4 + 1, 2)|list }}"
  
- name: with sequence loop and lookup
  debug:
    msg: "sequence_lookup: item is '{{ item }}'"
  # end is inclusive of the end point
  loop: "{{ lookup('sequence', 'start=0 end=4 stride=2 format=testuser%02x', wantlist=True) }}"

- name: with sequence loop and query
  debug:
    msg: "sequence_query: item is '{{ item }}'"
  # end is inclusive of the end point
  loop: "{{ query('sequence', 'start=0 end=4 stride=2 format=testuser%02x') }}"
```

##### with_subelements

遍历子元素

```yaml
- name: with_nested
  debug:
    msg: "{{ item.0 }} - {{ item.1 }}"
  with_nested:
    - "{{ list_one }}"
    - "{{ list_two }}"

- name: with_nested -> loop
  debug:
    msg: "{{ item.0 }} - {{ item.1 }}"
  loop: "{{ list_one|product(list_two)|list }}"
```

##### with_random_choice

随机选择列表中得一个值

```yaml
- name: with_random_choice
  debug:
    msg: "{{ item }}"
  with_random_choice: "{{ my_list }}"

- name: with_random_choice -> loop (No loop is needed here)
  debug:
    msg: "{{ my_list|random }}"
  tags: random
```

## 14.Blocks


`Blocks`允许任务的逻辑分组和`play`中的错误处理。您可以应用于单个任务的大部分内容(循环除外)都可以应用于块级别，这也使得设置任务通用的数据或指令变得更加容易。这并不意味着指令影响块本身，而是由块所包含的任务继承。例如，一个`when`将应用于任务，而不是块本身。

```yaml

 tasks:
   - name: Install, configure, and start Apache
     block:
       - name: install httpd and memcached
         yum:
           name:
           - httpd
           - memcached
           state: present

       - name: apply the foo config template
         template:
           src: templates/src.j2
           dest: /etc/foo.conf
       - name: start service bar and enable it
         service:
           name: bar
           state: started
           enabled: True
     when: ansible_facts['distribution'] == 'CentOS'
     become: true
     become_user: root
     ignore_errors: yes
```

 在上面的例子中，这3个任务都是在从块中继承`when`条件并在任务上判断之后执行的。它们还继承了特权升级指令，使`become`能够应用到block所包含的所有任务。最后，`ignore_errors: yes`即使有任务失败了，也将继续执行剧本。



### 块的错误处理

块还引入了以类似于大多数编程语言中的异常的方式处理错误的能力。块只处理任务的失败状态。错误的任务定义或无法访问的主机是不能触发块的错误处理。

```yaml
- name: Attempt and graceful roll back demo
  block:
    - debug:
        msg: 'I execute normally'
    - name: i force a failure
      command: /bin/false
    - debug:
        msg: 'I never execute, due to the above task failing, :-('
  rescue:
    - debug:
        msg: 'I caught an error'
    - name: i force a failure in middle of recovery! >:-)
      command: /bin/false
    - debug:
        msg: 'I also never execute :-('
  always:
    - debug:
        msg: "This always executes"
```

block中的任务在执行中，如果有任何错误，将执行**rescue**中的任务。 无论在block和rescue中发生或没有发生错误，**always**部分都运行。

需要注意的是，如果**rescue**部分成功完成，那么`play`将继续进行，因为它将擦除错误状态(但不包括报告),这意味着它不会触发`max_fail_percentage`或`any_errors_fatal`的配置，但将出现在playbook统计。



  发生错误后，依然运行handlers

```yaml
tasks:
   - name: Attempt and graceful roll back demo
     block:
       - debug:
           msg: 'I execute normally'
         changed_when: yes
         notify: run me even after an error
       - command: /bin/false
     rescue:
       - name: make sure all handlers run
         meta: flush_handlers
 handlers:
    - name: run me even after an error
      debug:
        msg: 'This handler runs even on error'
```



Ansible还为block的rescue部分的任务提供了两个变量

- ansible_failed_task 返回触发`rescue` 的失败任务。例如，要获取名称，请使用`ansible_failed_task.name`。
- ansible_failed_result  返回触发`rescue` 的失败任务的返回结果。这相当于在失败任务中添加 `register: ansible_failed_result `


## 15.Playbook高级特性 

### 权限提升

Ansible使用现有的权限升级系统来执行具有`root`权限或其他用户权限的任务。因为这个特性允许您成为另一个用户，与登录到机器的用户(远程用户)不同，所以我们将其称为`become`。`become`关键字利用现有的权限升级工具，如`sudo`、`su`、`pfexec`、`doas`、`pbrun`、`dzdo`、`ksu`、`runas`、`machinectl`等。 

#### 使用become

你可以在 `play`或 `task` 上使用`become`，同时使用时，优先级规则会决定哪个生效。



##### become 指令

- become  设置`yes`即开启提升权限
- become_user  指定提升权限的用户
- become_method  指定提升权限的方式，有sudo，su，runas等。
- become_flags 传给可执行文件的参数

例如，启动服务需要`root`权限

```yaml
- name: Ensure the httpd service is running
  service:
    name: httpd
    state: started
  become: yes
```

以apache用户身份运行命令

```yaml
- name: Run a command as the apache user
  command: somecommand
  become: yes
  become_user: apache
```

当shell为nologin时，作为nobody用户执行某些操作

```yaml
- name: Run a command as nobody
  command: somecommand
  become: yes
  become_method: su
  become_user: nobody
  become_flags: '-s /bin/sh'
```

##### become 变量

在主机清单中可以为节点定义不同的`become`选项，使用下列变量

- ansible_become 开启提升权限
- ansible_become_method  提升权限的方式，有sudo，su，runas等。
- ansible_become_user  提升权限的用户
- ansible_become_pass 提升权限的用户密码

例如，如果您希望在一个名为webserver的服务器上以root身份运行所有任务，但是您只能作为manager用户连接，那么您可以使用类似这样的库存条目 

```ini
webserver ansible_user=manager ansible_become=yes
```

##### become 命令行选项

- --become，-b
- --ask-become-pass, -K  告诉程序提升权限的用户密码
- --become-method  提升权限的方式，有sudo，su，runas等。
- --become-user  提升权限的用户


```bash
ansible -i hosts node1 -m shell -a "whoami" --become  --become-method=su --become-user=root --ask-become-pass

ansible-playbook -i hosts test.yml --become  --become-method=su --become-user=root --ask-become-pass
```

##### become的一些限制和风险

- 成为无特权用户的风险
- 不是所有的连接插件都支持特权升级
- 每个主机只能启用一个特权升级模式(su,sudo...)
- 特权升级不能限制某些命令能升级，这样会导致ansible执行时出现错误。
- 不能访问由` pam_systemd `填充的环境变量

#### 网络模块使用become

从2.6版开始，Ansible在所有支持enable模式的网络设备上进行特权升级(进入enable模式或特权EXEC模式) 

你必须将连接类型设置为`connection: network_cli`或`connection: httpapi`，才能在网络设备上使用`become`进行权限升级。 



若要设置特定任务的`enable`模式，请在任务级别上添加`become`

```yaml
- name: Gather facts (eos)
  eos_facts:
    gather_subset:
      - "!hardware"
  become: yes
  become_method: enable
```

若要为单个play中的所有任务设置`enable`模式，请在play级别上添加`become `

```yaml
- hosts: eos-switches
  become: yes
  become_method: enable
  tasks:
    - name: Gather facts (eos)
      eos_facts:
        gather_subset:
          - "!hardware"
```

##### 设置所有任务的`enable`模式

通常，您希望所有play中的所有任务都使用特权模式运行，这最好通过使用组变量来实现

```yaml
ansible_connection: network_cli
ansible_network_os: eos
ansible_user: myuser
ansible_become: yes
ansible_become_method: enable
```

#####  enable模式的密码

如果需要密码才能进入`enable`模式，可以通过以下两种方式之一进行指定

- 提供 `--ask-become-pass`命令行选项 
- 设置` ansible_become_password ` 连接变量 

##### authorize 和 auth_pass

ansible 依然支持 ` connection: local ` 连接下的`enable`模式

```yaml
- hosts: eos-switches
  ansible_connection: local
  tasks:
    - name: Gather facts (eos)
      eos_facts:
        gather_subset:
          - "!hardware"
      provider:
        authorize: yes
        auth_pass: " {{ secret_auth_pass }}"
```



#### windows 使用become

从Ansible 2.3开始，可以通过`runas`方法在Windows主机上使用`become`。在Windows上的Become使用与在非Windows主机上相同的库存设置和调用参数，因此设置和变量名与本文档中定义的相同。 

Windows中的许多任务需要管理权限才能完成。当使用runas become方法时，Ansible将尝试使用远程用户可用的全部特权运行模块。如果未能提升用户令牌，则在执行期间将继续使用有限的令牌。 



用户必须具有`SeDebugPrivilege`才能运行具有提升特权的成为进程。这个特权默认分配给管理员。如果调试特权不可用，则become进程将使用一组有限的特权和组运行。 

```yaml
- win_whoami:
  become: yes
```

在返回的`label.account_name`中体现了是否获取特权

- `Medium`: Ansible未能得到提升的令牌，并运行在一个有限的令牌。 

- `High`: 获得了提升的令牌，并在任务中使用

- ` System`:  `NT AUTHORITY\System`帐户被使用，并且具有最高级别的可用特权。

  

如果在大于2.5的Ansible版本上运行或正常的runas升级过程失败，可以通过 

- 将`become_user`设置为`System` 以便拥有最高权限

- 为WinRM连接用户授予`SeTcbPrivilege`权限， `SeTcbPrivilege`是一种高级特权，它授予对操作系统的完全控制。您可以使用下面的任务在Windows主机上设置此特权

 ```yaml
  - name: grant the ansible user the SeTcbPrivilege right
    win_user_right:
      name: SeTcbPrivilege
      users: '{{ansible_user}}'
      action: add
 ```

-  关闭主机上的UAC并重启主机, UAC是一种安全协议，它被设计为使用最少特权原则运行帐户。您可以通过运行以下任务来关闭UAC 

 ```yaml
  - name: turn UAC off
    win_regedit:
      path: HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\policies\system
      name: EnableLUA
      data: 0
      type: dword
      state: present
    register: uac_result
  
  - name: reboot after disabling UAC
    win_reboot:
    when: uac_result is changed
 ```

> 授予`SeTcbPrivilege`或关闭UAC可能会导致Windows安全漏洞，如果采取了这些步骤，应该谨慎对待。 


##### LocalService账号

在Ansible 2.5版本之前，become只能在本地或域用户帐户的Windows上工作。在这些旧版本中，像`System`或`NetworkService`这样的本地服务帐户不能用作用户。自Ansible 2.5发布以来，这一限制已经解除。可以在成为用户下面设置的三个服务帐户是 

- System
- NetworkService
- LocalService

由于本地服务帐户没有密码，所以`ansible_become_password`参数不是必需的，如果指定了该参数也会被被忽略。

##### 无需为become设置密码

从Ansible 2.8开始，become可以被用来成为一个Windows本地或域帐户，而不需要该帐户的密码。要使此方法工作，必须满足以下要求



- 该连接用户拥有` SeDebugPrivilege`权限

- 该连接用户属于` BUILTIN\Administrators `组

- 该连接用户拥有`SeBatchLogonRight`或`SeNetworkLogonRight`用户权限

  

通过两种不同的方法之一可以使用使用无密码方式：

- 复制现有的登录会话令牌(如果帐户已经登录)

- 使用S4U生成仅在远程主机上有效的登录令牌


##### 没有密码的帐户

Ansible可以使用一个没有密码的Windows帐户(像Guest帐户)。要成为一个没有密码的帐户，必须设置` ansible_become_password: '' `。

要想实现无密码登录，还需要将本地策略帐户:将本地帐户使用空白密码限制为仅用于控制台登录禁用。这可以通过组策略对象(GPO)完成，也可以通过这个可能的任务完成 

```yaml
- name: allow blank password on become
  win_regedit:
    path: HKLM:\SYSTEM\CurrentControlSet\Control\Lsa
    name: LimitBlankPasswordUse
    data: 0
    type: dword
    state: present
```

##### become的参数

windows支持的`ansible_become_flags`有两个` logon_type` ,  ` logon_flags `

` logon_type`  是指定登录操作类型，有以下可选项:

-  interactive:  默认登录类型。该流程将在与本地运行流程相同的上下文中运行。这绕过了所有的WinRM限制，是推荐使用的方法。 

-  batch: 在类似于设置了密码的调度任务的批处理上下文中运行该进程。

-  new_credentials:  在与调用用户相同的凭据下运行

-  network:  在没有任何缓存凭据的网络上下文中运行进程。

-  network_cleartext: 与网络登录类型类似，但缓存凭据以便它可以访问网络资源。

` logon_flags `指定在创建新进程时，Windows将如何记录用户的登录。 有以下可选项:

-  with_profile：  默认值。 该过程会将HKEY_USERS注册表项中的用户个人资料加载到HKEY_CURRENT_USER。 
-  netcredentials_only：  该过程将使用与调用方相同的令牌，但是在访问远程资源时将使用begin_user和begin_password。 

一些例子

```yaml
- name: copy a file from a fileshare with custom credentials
  win_copy:
    src: \\server\share\data\file.txt
    dest: C:\temp\file.txt
    remote_src: yes
  vars:
    ansible_become: yes
    ansible_become_method: runas
    ansible_become_user: DOMAIN\user
    ansible_become_password: Password01
    ansible_become_flags: logon_type=new_credentials logon_flags=netcredentials_only

- name: run a command under a batch logon
  win_whoami:
  become: yes
  become_flags: logon_type=batch

- name: run a command and not load the user profile
  win_whomai:
  become: yes
  become_flags: logon_flags=
```

##### 限制

- 仅当使用Ansible 2.7或更高版本时，`async`和`become`任务才能在Windows Server 2008、2008 R2和Windows 7上运行。

-  默认情况下，` become`用户使用交互式会话登录，因此它必须有权在Windows主机上进行登录。 如果它不继承SeAllowLogOnLocally特权或继承SeDenyLogOnLocally特权，则提权过程将失败。 添加特权或设置logon_type标志以更改使用的登录类型。 

- 在Ansible version 2.3之前，只有当 `ansible_winrm_transport`是basic或credssp时，become才能工作。这个限制已经被解除，自从2.4版的Ansible为所有主机除了Windows Server 2008(非R2版本)。

- 二级登录服务` seclogon `必须运行才能使用` ansible_become_method: runas `

  

### 异步操作和轮询

默认情况下playbook中的任务执行时会一直保持连接,直到该任务在每个节点都执行完毕.有时这是不必要的,比如有些操作运行时间比SSH超时时间还要长.解决该问题最简单的方式是异步执行它们,然后轮询直到任务执行完毕.

你也可以对执行时间非常长（有可能遭遇超时）的操作使用异步模式.

为了异步启动一个任务,可以指定其最大超时时间以及轮询其状态的频率.如果你没有为  poll 指定值,那么默认的轮询频率是15秒钟。

例如下面的palybook

```yaml
---
- hosts: 192.168.77.131

  tasks:
    - shell: sleep 100 && hostname
      async: 100
      poll: 0
      register: result
      
    - debug: var=result

    - async_status: jid={{  result.ansible_job_id }}
      register: job_result
      until: job_result.finished
      retries: 30
```

> poll指定任务的轮训值，poll=0时，任务执行后，会立即执行下一条任务。poll>0时，会阻塞任务，直到任务执行完毕或超时。没有设置的时候，取默认值`DEFAULT_POLL_INTERVAL`

- 第一个任务，指定shell任务为异步执行，100秒后任务失败。
- 第二个任务，获取异步任务的返回值，其目的是获取jid。
- 第三个任务，检查jid异步任务的状态，当异步任务的finished不为0时，异步任务执行成功。检查次数为30次，间隔5秒。

运行playbook的结果信息
```bash
# ansible-playbook  asynctest.yml -vv
ansible-playbook 2.9.6
  config file = /etc/ansible/ansible.cfg
  configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python2.7/site-packages/ansible
  executable location = /usr/bin/ansible-playbook
  python version = 2.7.5 (default, Aug  4 2017, 00:39:18) [GCC 4.8.5 20150623 (Red Hat 4.8.5-16)]
Using /etc/ansible/ansible.cfg as config file

PLAYBOOK: asynctest.yaml ******************************************************************************************************************
1 plays in asynctest.yaml

PLAY [192.168.77.131] *********************************************************************************************************************

TASK [Gathering Facts] ********************************************************************************************************************
task path: /etc/ansible/asynctest.yaml:2
ok: [192.168.77.131]
META: ran handlers

TASK [shell] ******************************************************************************************************************************
task path: /etc/ansible/asynctest.yaml:5
changed: [192.168.77.131] => {"ansible_job_id": "965275577324.14846", "changed": true, "finished": 0, "results_file": "/root/.ansible_async/965275577324.14846", "started": 1}

TASK [debug] ******************************************************************************************************************************
task path: /etc/ansible/asynctest.yaml:9
ok: [192.168.77.131] => {
    "result": {
        "ansible_job_id": "965275577324.14846", 
        "changed": true, 
        "failed": false, 
        "finished": 0, 
        "results_file": "/root/.ansible_async/965275577324.14846", 
        "started": 1
    }
}

TASK [async_status] ***********************************************************************************************************************
task path: /etc/ansible/asynctest.yaml:11
FAILED - RETRYING: async_status (30 retries left).
FAILED - RETRYING: async_status (29 retries left).
FAILED - RETRYING: async_status (28 retries left).
FAILED - RETRYING: async_status (27 retries left).
FAILED - RETRYING: async_status (26 retries left).
FAILED - RETRYING: async_status (25 retries left).
FAILED - RETRYING: async_status (24 retries left).
FAILED - RETRYING: async_status (23 retries left).
FAILED - RETRYING: async_status (22 retries left).
FAILED - RETRYING: async_status (21 retries left).
FAILED - RETRYING: async_status (20 retries left).
FAILED - RETRYING: async_status (19 retries left).
FAILED - RETRYING: async_status (18 retries left).
FAILED - RETRYING: async_status (17 retries left).
FAILED - RETRYING: async_status (16 retries left).
FAILED - RETRYING: async_status (15 retries left).
FAILED - RETRYING: async_status (14 retries left).
FAILED - RETRYING: async_status (13 retries left).
FAILED - RETRYING: async_status (12 retries left).
FAILED - RETRYING: async_status (11 retries left).
changed: [192.168.77.131] => {"ansible_job_id": "965275577324.14846", "attempts": 21, "changed": true, "cmd": "sleep 100 && hostname", "delta": "0:01:40.069235", "end": "2020-04-03 21:59:52.442879", "finished": 1, "rc": 0, "start": "2020-04-03 21:58:12.373644", "stderr": "", "stderr_lines": [], "stdout": "node131", "stdout_lines": ["node131"]}
META: ran handlers
META: ran handlers

PLAY RECAP ********************************************************************************************************************************
192.168.77.131             : ok=4    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

```

使用ansible来执行异步

```bash
# ansible 192.168.77.131 -B 3600 -P 0 -o -m shell -a "sleep 30" -vv
ansible 2.9.6
  config file = /etc/ansible/ansible.cfg
  configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python2.7/site-packages/ansible
  executable location = /usr/bin/ansible
  python version = 2.7.5 (default, Aug  4 2017, 00:39:18) [GCC 4.8.5 20150623 (Red Hat 4.8.5-16)]
Using /etc/ansible/ansible.cfg as config file
META: ran handlers
192.168.77.131 | CHANGED => {"ansible_facts": {"discovered_interpreter_python": "/usr/bin/python"}, "ansible_job_id": "71761724165.16525", "changed": true, "finished": 0, "results_file": "/root/.ansible_async/71761724165.16525", "started": 1}
META: ran handlers
META: ran handlers

```
 使用`async_status`来获取异步状态信息
```bash
# ansible 192.168.77.131 -m  async_status -a "jid=71761724165.16525"
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "ansible_job_id": "71761724165.16525", 
    "changed": false, 
    "finished": 0, 
    "started": 1
}

# .... 等待任务执行完成

# ansible 192.168.77.131 -m  async_status -a "jid=71761724165.16525"
192.168.77.131 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "ansible_job_id": "71761724165.16525", 
    "changed": true, 
    "cmd": "sleep 30", 
    "delta": "0:00:30.059717", 
    "end": "2020-04-03 22:09:37.777453", 
    "finished": 1, 
    "rc": 0, 
    "start": "2020-04-03 22:09:07.717736", 
    "stderr": "", 
    "stderr_lines": [], 
    "stdout": "", 
    "stdout_lines": []
}
```

- 注意：在使用'command',  'win_command', 'shell', 'win_shell', 'raw'模块时，是不会返回信息的。



限制并发运行的任务数量的同时运行多个异步任务

```yaml
#####################
# main.yml
#####################
- name: Run items asynchronously in batch of two items
  vars:
    sleep_durations:
      - 1
      - 2
      - 3
      - 4
      - 5
    durations: "{{ item }}"
  include_tasks: execute_batch.yml
  loop: "{{ sleep_durations | batch(2) | list }}"

#####################
# execute_batch.yml
#####################
- name: Async sleeping for batched_items
  command: sleep {{ async_item }}
  async: 45
  poll: 0
  loop: "{{ durations }}"
  loop_control:
    loop_var: "async_item"
  register: async_results

- name: Check sync status
  async_status:
    jid: "{{ async_result_item.ansible_job_id }}"
  loop: "{{ async_results.results }}"
  loop_control:
    loop_var: "async_result_item"
  register: async_poll_results
  until: async_poll_results.finished
  retries: 30
```

一个重启服务器的playbook
```yaml
---
- hosts: 192.168.77.131
  gather_facts: no
  become: yes

  tasks:
   - name: Check the uptime prior reboot
     shell: uptime
     register: UPTIME_PRE_REBOOT

   - debug: msg={{UPTIME_PRE_REBOOT.stdout}}

   - name: Reboot node and stop polling.
     shell: reboot
     async: 10 # Do not care for 10 sec
     poll: 0 # Fire & Forget

   - name: wait for host to finish reboot
     wait_for:
      port: "{{ (ansible_port|default(ansible_ssh_port))|default(22) }}"
      host: '{{ (ansible_ssh_host|default(ansible_host))|default(inventory_hostname) }}'
      search_regex: OpenSSH
      delay: 10  # Do not check for at least 10 sec
     connection: local

   - name: Check the uptime post reboot
     shell: uptime
     register: UPTIME_POST_REBOOT

   - debug: msg={{UPTIME_POST_REBOOT.stdout}}
```



#### 异步任务的状态文件

异步任务的状态文件以jid命名的方式存放在远端主机的用户目录下的.ansible_async目录，本次使用的是root连接远端，所以目录是/root/.ansible_async。

查看状态文件

```bash
# cat /root/.ansible_async/71761724165.16525
{"started": 1, "finished": 0, "ansible_job_id": "71761724165.16525"}

# 任务结束后

# cat /root/.ansible_async/71761724165.16525
{"changed": true, "end": "2020-04-03 22:09:37.777453", "stdout": "", "cmd": "sleep 30", "start": "2020-04-03 22:09:07.717736", "delta": "0:00:30.059717", "stderr": "", "rc": 0, "invocation": {"module_args": {"warn": true, "executable": null, "_uses_shell": true, "strip_empty_ends": true, "_raw_params": "sleep 30", "removes": null, "argv": null, "creates": null, "chdir": null, "stdin_add_newline": true, "stdin": null}}}
```



#### 异步任务的返回值

```json
{
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "ansible_job_id": "662217446295.16055",
    "changed": true,
    "finished": 0,
    "results_file": "/root/.ansible_async/662217446295.16055",
    "started": 1
}
```

> ansible_job_id 异步任务id， results_file异步任务的状态文件



#### 异步任务状态的返回值

可通过 async_status 获取，async_status 是读取远端的异步任务状态文件来获得任务状态，如果async设置的时间太短，可能会导致获取不到状态文件，因为还没生成这个文件。



执行中的返回值

```bash
{
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "ansible_job_id": "71761724165.16525", 
    "changed": false, 
    "finished": 0, 
    "started": 1
}
```

执行完成后的返回值

```bash
{
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "ansible_job_id": "71761724165.16525", 
    "changed": true, 
    "cmd": "sleep 30", 
    "delta": "0:00:30.059717", 
    "end": "2020-04-03 22:09:37.777453", 
    "finished": 1, 
    "rc": 0, 
    "start": "2020-04-03 22:09:07.717736", 
    "stderr": "", 
    "stderr_lines": [], 
    "stdout": "", 
    "stdout_lines": []
}
```



### 检查模式

当ansible-playbook执行时加上`--check`选项时，它不会对远程系统做任何更改。支持检查模式的模块将报告它们将进行的更改，而不是进行更改。不支持检查模式的其他模块也将不采取任何操作，只是不报告它们可能做了哪些更改。

执行例子

```bash
ansible-playbook foo.yml --check 
```

也可以在任务中使用检查模式

```yaml
tasks:
  - name: this task will make changes to the system even in check mode
    command: /something/to/run --even-in-check-mode
    check_mode: no

  - name: this task will always run under checkmode and not change the system
    lineinfile:
        line: "important config"
        dest: /path/to/myconfig.conf
        state: present
    check_mode: yes
```

`ansible_check_mode`变量是用来存储当前是否是检查模式的布尔类型

```yaml
tasks:

  - name: this task will be skipped in check mode
    git:
      repo: ssh://git@github.com/mylogin/hello.git
      dest: /home/mylogin/hello
    when: not ansible_check_mode

  - name: this task will ignore errors in check mode
    git:
      repo: ssh://git@github.com/mylogin/hello.git
      dest: /home/mylogin/hello
    ignore_errors: "{{ ansible_check_mode }}"
```

diff模块

ansible-playbook的`--diff`选项可与`--check`配合使用（如上详述），但也可以单独使用。 提供此标志且模块支持此标志时，Ansible将报告所做的更改，或者如果与`--check`一起使用，则将报告所做的更改。

```yaml
- hosts: localhost
  tasks:
  - name: debug.
    debug: msg=123
    check_mode: no
  - name: add hosts.
    lineinfile:
      line: "127.0.0.2 localhost"
      dest: /etc/hosts
      state: present
      check_mode: yes
  - name: add hosts.
    lineinfile:
      line: "127.0.0.2 localhost"
      dest: /etc/hosts
      state: present
      diff: no
```

> diff:  no 禁止对比

检查并对比更改

```bash
ansible-playbook  foo.yml --check --diff
```



### debug 功能

Ansible把一个`debugger `作为`strategy `插件的一部分。此调试器使您能够作为任务进行调试，这个过程是阻塞运行的。但使用`debug`模块也可以调试变量或表达式，而不必阻塞playbook。

有多种使用调试器的方法。

#### 使用 debugger 关键字

debugger提供几个值

| 可选值       | 说明  |
| -------------- | -------------------------------- |
| always         | 总是调用调试器，而不管结果如何   |
| never          | 不管结果如何，都不要调用调试器   |
| on_failed      | 只有在任务失败时才调用调试器     |
| on_unreachable | 只有在主机无法访问时才调用调试器 |
| on_skipped     | 只有在任务被跳过时才调用调试器   |

在play中使用

```yaml
- name: Play
  hosts: all
  debugger: on_skipped
  tasks:
    - name: Execute a command
      command: true
      when: False
```

在task中使用

```yaml
- name: Execute a command
  command: false
  debugger: on_failed
```

当play和task同时使用`debugger`时，task的生效

```yaml
- name: Play
  hosts: all
  debugger: never
  tasks:
    - name: Execute a command
      command: false
      debugger: on_failed
```

#### 配置或环境变量

在`ansible.cfg`上配置

```ini
[defaults]
enable_task_debugger = True
```

或者设置环境变量

```bash
ANSIBLE_ENABLE_TASK_DEBUGGER=True ansible-playbook -i hosts site.yml
```

#### 使用 strategy 插件

使用 `strategy` 插件`debug`

```yaml
- hosts: test
  strategy: debug
  tasks:
  ...
```

或者修改配置和环境变量

```ini
[defaults]
strategy = debug
```

环境变量

```bash
ANSIBLE_STRATEGY=debug
```



#### 调试 debugger

使用以下例子

```yaml
- hosts: 192.168.77.131
  debugger: on_failed
  gather_facts: no
  vars:
    var1: value1
  tasks:
    - name: wrong variable
      ping: data={{ wrong_var }}
```

以上playbook，在执行到错误的任务时，会进入debug模式下

```bash
# ansible-playbook debuger.yaml

PLAY [192.168.77.131] *****************************************************************************************

TASK [wrong variable] *****************************************************************************************
fatal: [192.168.77.131]: FAILED! => {"msg": "The task includes an option with an undefined variable. The error was: 'wrong_var' is undefined\n\nThe error appears to be in '/etc/ansible/debuger.yaml': line 7, column 7, but may\nbe elsewhere in the file depending on the exact syntax problem.\n\nThe offending line appears to be:\n\n  tasks:\n    - name: wrong variable\n      ^ here\n"}
[192.168.77.131] TASK: wrong variable (debug)> p result._result
{'_ansible_no_log': False,
 'failed': True,
 'msg': u"The task includes an option with an undefined variable. The error was: 'wrong_var' is undefined\n\nThe error appears to be in '/etc/ansible/debuger.yaml': line 7, column 7, but may\nbe elsewhere in the file depending on the exact syntax problem.\n\nThe offending line appears to be:\n\n  tasks:\n    - name: wrong variable\n      ^ here\n"}
[192.168.77.131] TASK: wrong variable (debug)> p task.args
{u'data': u'{{ wrong_var }}'}
[192.168.77.131] TASK: wrong variable (debug)> task.args['data'] = '{{ var1 }}'
[192.168.77.131] TASK: wrong variable (debug)> p task.args
{u'data': '{{ var1 }}'}
[192.168.77.131] TASK: wrong variable (debug)> redo
ok: [192.168.77.131]

PLAY RECAP *****************************************************************************************
192.168.77.131             : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

通过调试，我们使playbook以成功运行完毕。

`debugger`模式下的可用指令


| 指令                         | 说明     |
| ------------------------- | ---------------------- |
| p                         | 显示此次失败的原因     |
| p task                    | 显示此次任务的名称     |
| p task.args            | 显示模块的参数         |
| p task_vars            | 显示任务的可用变量     |
| p host                    | 显示执行此次任务的主机 |
| p result                  | 显示此次任务的结果     |
| p vars                    | 显示当前的变量         |
| vars[key] = value         | 更新vars中的值         |
| task.args[key] =    value | 更新模块的参数。       |
| u(pdate_task) | 从原始任务数据结构和带有更新的task_vars的模板中重新创建任务 |
| r(edo)                    | 再次执行此任务         |
| c(ontinue)           | 继续执行               |
| q(uit)                  | 退出debug模式          |

#### 与`free`策略一起使用

当`debugger`与`free`策略一起使用时，在调试器处于活动状态时，不会导致其他任务排队或执行。但使用`redo`时，可能回导致当前任务在其他任务之后执行

#### 使用 debug 模块

在执行期间打印语句，使用`debug`模块可以调试变量或表达式，而不必阻塞playbook。

打印自定义的信息

```yaml
tasks:
  - debug: msg="System {{ inventory_hostname }} has uuid {{ ansible_product_uuid  }}"
```

调试变量

```yaml
tasks:
  - debug: var=result  verbosity=2
```



### 滚动执行

默认情况下，Ansible会并行地管理一个剧本中引用的所有机器。对于滚动更新用例，可以使用`serial`关键字定义Ansible并行执行多少台主机

```yaml
---
- name: test play
  hosts: webservers
  serial: 3
  gather_facts: False

  tasks:
    - name: task one
      command: hostname
    - name: task two
      command: hostname
```

在上面的例子中，如果我们有100个主机，组“webservers”中的3个主机将完成playbook，然后再移动到接下来的3个主机。

还可以使用百分比

```yaml
serial: "30%"
```

从Ansible 2.2开始，可以指定一个列表作为批量执行的依据

```yaml
---
- name: test play
  hosts: webservers
  serial:
    - 1
    - 5
    - 10
```

在上面的例子中，第一批执行将包含一个主机，下一批将包含5个主机，并且(如果还剩下任何主机)，接下来的每一批将包含10个主机，直到所有可用的主机都被使用。

可以在列表中使用百分比

```yaml
---
- name: test play
  hosts: webservers
  serial:
    - "10%"
    - "20%"
    - "100%"
```

也可以混合使用

```yaml
---
- name: test play
  hosts: webservers
  serial:
    - 1
    - 5
    - "20%"
```



### 指定最大失败数目

默认情况下，只要组中有尚未失败的主机，Ansible将继续执行操作。  在一些情况下，例如利用上述滚动更新，可能希望在达到失败的特定阈值时中止任务。

```yaml
---
- hosts: webservers
  max_fail_percentage: 30
  serial: 10
```

在上面的示例中，如果组中的10台服务器中有3台以上发生故障，则将终止其余的操作。



### 委托

在任务上使用`delegate_to`关键字,可以将任务委托给指定主机去执行。

```yaml
---
- hosts: webservers
  serial: 5

  tasks:
    - name: take out of load balancer pool
      command: /usr/bin/take_out_of_pool {{ inventory_hostname }}
      delegate_to: 127.0.0.1

    - name: actual steps would go here
      yum:
        name: acme-web-stack
        state: latest

    - name: add back to load balancer pool
      command: /usr/bin/add_back_to_pool {{ inventory_hostname }}
      delegate_to: 127.0.0.1
```

` delegate_to: 127.0.0.1` 是将任务委派到ansible本地去执行，你可以使用简写的`local_action` 去执行

```yaml
---
# ...

  tasks:
    - name: take out of load balancer pool
      local_action: command /usr/bin/take_out_of_pool {{ inventory_hostname }}

# ...

    - name: add back to load balancer pool
      local_action: command /usr/bin/add_back_to_pool {{ inventory_hostname }}
```

一个例子

```yaml
- hosts: db_servers
  tasks:
  -  name: ifconfig
     command: fconfig
     delegate_to: 127.0.0.1
     
  -  name: ifconfig
     local_action: command ifconfig

- hosts: app_servers
  tasks:
  - name: gather facts from db servers
    setup:
    delegate_to: "{{item}}"
    delegate_facts: True
    with_items:  "{{groups['dbservers']}}"
```

> delegate_facts 指定收集委托主机的facts数据

以上将为`dbservers`组中的机器收集`facts`，并将`facts`分配给这些机器，而不是`app_servers`。



### 任务只运行一次

通过在任务上配置`run_once`来实现当前任务在`play`中只执行一次

```yaml
- tasks:
  - command: ifconfig
    run_once: true
```

上面的例子，将只会在第一个执行主机上执行，其余的主机则不执行。

有点类似于使用when条件判断

```yaml
- command: /opt/application/upgrade_db.py
  when: inventory_hostname == webservers[0]
```



### 本地执行

为playbook指定`connection=local`将会使任务在本地执行，而不是使用ssh连接远端。

执行playbook

```bash
ansible-playbook  playbook.yml --connection=local
```

在play中指定

```yaml
---
- hosts: 127.0.0.1
  connection: local
```


### 设置环境变量

为运行程序指定环境变量，需指定`environment`关键字

```yaml
- tasks:
  - apt:  name=cobbler state=installed
    environment:
      http_proxy: http://proxy.example.com:8080
      PATH: /var/local/nvm/versions/node/v4.2.1/bin:{{  ansible_env.PATH }}
```

也可以在play级别使用

```yaml
- hosts: testhost
  roles:
    - php
    - nginx
  environment:
    http_proxy: http://proxy.example.com:8080
```

### 错误处理

#### 忽略错误

`ignore_errors` 模块可以在任务执行错误时，忽略错误并继续执行任务。

```yaml
- tasks:
  - command: /bin/false
    ignore_errors: true

  - debug: msg="false"
```

#### 重置无法访问的主机

连接远端主机失败时，ansible会将主机设置为不可到达，这将从运行的活动主机列表中删除它们。要从这些问题中恢复，需执行下列动作恢复主机。

```yaml
-  meta: clear_host_errors
```



#### 即使任务失败，handlers也执行

以下3中方法均可使用


- 命令行加上` --force-handlers` 参数
- 配置文件加上 `force_handlers = True`
- playbook里设置  `force_handlers: True`



#### 控制任务失败

使用`failed_when`选项时，当条件为真时，可使当前任务以失败返回

您可以通过在命令的输出中搜索一个单词或短语来检查是否命令执行是否失败

```yaml
- name: Fail task when the command error output prints FAILED
  command: /usr/bin/example-command -x -y -z
  register: command_result
  failed_when: "'FAILED' in command_result.stderr"
```

或者根据返回值

```yaml
- name: Fail task when both files are identical
  raw: diff foo/file1 bar/file2
  register: diff_cmd
  failed_when: diff_cmd.rc == 0 or diff_cmd.rc >= 2
```

在以前的版本中，可以使用以下完成上述操作

```yaml
- name: this command prints FAILED when it fails
  command: /usr/bin/example-command -x -y -z
  register: command_result
  ignore_errors: True

- name: fail the play if the previous command did not succeed
  fail:
    msg: "the command failed"
  when: "'FAILED' in command_result.stderr"
```

可以使用多个并行条件，这些条件之间是`and`关系

```yaml
- name: Check if a file exists in temp and fail task if it does
  command: ls /tmp/this_should_not_be_here
  register: result
  failed_when:
    - result.rc == 0
    - '"No such" not in result.stdout'
```

使用`or`条件

```yaml
failed_when: result.rc == 0 or "No such" not in result.stdout
```

如果一行写不下，可以使用多行表示

```yaml
- name: example of many failed_when conditions with OR
  shell: "./myBinary"
  register: ret
  failed_when: >
    ("No such file or directory" in ret.stdout) or
    (ret.stderr != '') or
    (ret.rc == 10)
```

#### 更改任务changed状态

指定`changed_when` 条件时，当条件为真，任务的`changed`为真，即表示当前任务做了更改。

```yaml
tasks:

  - shell: /usr/bin/billybass --mode="take me to the river"
    register: bass_result
    changed_when: "bass_result.rc != 2"

  # this will never report 'changed' status
  - shell: wall 'beep'
    changed_when: False
```

使用多个条件

```yaml
- command: /bin/fake_command
  register: result
  ignore_errors: True
  changed_when:
    - '"ERROR" in result.stderr'
    - result.rc == 2
```

#### 出现错误时立即中断执行

使用`any_errors_fatal`选项时，只要playbook中出现一个错误任务,ansible立即停止运行。已保证所有任务的正确运行。

```yaml
---
- hosts: load_balancers_dc_a
  any_errors_fatal: True

  tasks:
    - name: 'shutting down datacenter [ A ]'
      command: /usr/bin/disable-dc

- hosts: frontends_dc_a

  tasks:
    - name: 'stopping service'
      command: /usr/bin/stop-software
    - name: 'updating software'
      command: /usr/bin/upgrade-software

- hosts: load_balancers_dc_a

  tasks:
    - name: 'Starting datacenter [ A ]'
      command: /usr/bin/enable-dc
```

#### 使用blocks

使用`blocks`的`rescue`来实现对错误任务的处理

```yaml
tasks:
- name: Handle the error
  block:
    - debug:
        msg: 'I execute normally'
    - name: i force a failure
      command: /bin/false
    - debug:
        msg: 'I never execute, due to the above task failing, :-('
  rescue:
    - debug:
        msg: 'I caught an error, can do stuff here to fix it, :-)'
```

### YAML 语法

YAML 语法见[详细介绍](/basic/Reference/Yaml/)


### Prompts: 运行时，提示输入内容

在运行playbook时，您可能希望提示用户输入某些内容，可以通过`vars_prompt`实现这一点。

```yaml
- hosts: test
  gather_facts: no
  vars_prompt:
    - name: "name"
      prompt: "what is your name?"
      default: "user"
      private: yes
      confirm: yes

  tasks:
    - debug: msg={{ name }}
```

`vars_prompt`的参数


- name: 定义变量名称，即输入的内容赋值给此变量
- prompt：输入得提示信息
- default： 输入的默认值，没有输入任何内容的时候，把此值赋值给变量
- private：是否隐藏输入得内容
- confirm：是否要再次确认输入
- unsafe:  不校验输入的字符串，如果输入特殊字符，可开启此选项

如果安装了`Passlib`, `vars_prompt`还可以对输入的值进行加密

```yaml
- hosts: test
  gather_facts: no
  vars_prompt:
    - name: "pass"
      prompt: "Enter password2"
      private: yes
      encrypt: "sha512_crypt"
      confirm: yes
      salt_size: 7
      
  tasks:
    - debug: msg={{ pass }}
```

可以使用的加密方案

- *des_crypt* - DES Crypt
- *bsdi_crypt* - BSDi Crypt
- *bigcrypt* - BigCrypt
- *crypt16* - Crypt16
- *md5_crypt* - MD5 Crypt
- *bcrypt* - BCrypt
- *sha1_crypt* - SHA-1 Crypt
- *sun_md5_crypt* - Sun MD5 Crypt
- *sha256_crypt* - SHA-256 Crypt
- *sha512_crypt* - SHA-512 Crypt
- *apr_md5_crypt* - Apache’s MD5-Crypt variant
- *phpass* - PHPass’ Portable Hash
- *pbkdf2_digest* - Generic PBKDF2 Hashes
- *cta_pbkdf2_sha1* - Cryptacular’s PBKDF2 hash
- *dlitz_pbkdf2_sha1* - Dwayne Litzenberger’s PBKDF2 hash
- *scram* - SCRAM Hash
- *bsd_nthash* - FreeBSD’s MCF-compatible nthash encoding


### 标记

如果你有一个大型剧本，但你只希望运行它的一个特定的部分，而不是运行剧本中的所有任务。这时候，你可以为运行的任务指定一个共同的`tags`

#### 标记任务

```yaml
tasks:
- yum:
    name:
    - httpd
    - memcached
    state: present
  tags:
  - packages

- template:
    src: templates/src.j2
    dest: /etc/foo.conf
  tags:
  - configuration
```

> 标签名称可以重名

显示playbook中的所有标记任务

```bash
ansible-playbook  example.yml --list-tags
```

执行所有标记名称为packages和configuration的任务

```bash
ansible-playbook  example.yml --tags "configuration,packages"
```

跳过所有标记名称为configuration的任务

```bash
ansible-playbook  example.yml --skip-tags "configuration"
```

#### 标记playbook

```yaml
- hosts: all
  tags:
    - bar
  tasks:
   ...

- hosts: all
  tags: ['foo']
  tasks:
  ...
```

> play里的所有tasks将会继承play的tags

#### 标记role

```yaml
- roles:
  - { role: webserver, port: 5000, tags: [  'web', 'foo' ] }
```

> role里的tasks将会继承role的tags

#### 标记包含

```yaml
- import_role:
    name: myrole
  tags: [ web, foo ]

- import_tasks: foo.yml
  tags: [ web, foo ]
```

> 包含的role和tasks中的任务将会继承tags，动态包含则不继承tag

#### 特殊标记

使用`always`标签可以始终运行标记的任务

```yaml
tasks:
- debug:
    msg: "Always runs"
  tags:
  - always

- debug:
    msg: "runs when you use tag1"
  tags:
  - tag1
```

还有另外4个特殊关键字用于标签，

- `never` 阻止任务运行
- `tagged` 仅运行已标记
- `untagged` 运行只有未标记
- `all`运行所有任务

默认情况下ansible运行就像指定了`-tags all`

### Vault 加密

Vault 加密使用方法见[详细介绍](/basic/Reference/Vaults/)



### 从某个任务开始执行

为ansible-playbook指定`--start-at-task`，就可以从这个任务开始执行

```bash
ansible-playbook  playbook.yml --start-at-task="install packages"
```

### 一步一步的执行

ansible也可以一步一步交互的执行，执行每一步都需要确认是否继续

```bash
ansible-playbook  playbook.yml --step
```

### 模块默认值

你可以为多个相同的模块指定默认值,而不必重复填写。

```yaml
- hosts: localhost
  module_defaults:
    file:
      owner: root
      group: root
      mode: 0755
  tasks:
    - file:
        state: touch
        path: /tmp/file1
    - file:
        state: touch
        path: /tmp/file2
    - file:
        state: touch
        path: /tmp/file3
```

可以在play、block和task级别使用module_defaults属性。

```yaml
- block:
    - debug:
        msg: "a different message"
  module_defaults:
    debug:
      msg: "a default message"
      
- file:
    state: touch
    path: /tmp/file1
  module_defaults:
    file: {}
```

在playbook中，您可以为整个模块组设置模块默认值，例如设置一个公共AWS区域。

```yaml
# example_play.yml
- hosts: localhost
  module_defaults:
    group/aws:
      region: us-west-2
  tasks:
  - aws_s3_bucket_info:
  # now the region is shared between both info modules
  - ec2_ami_info:
      filters:
        name: 'RHEL*7.5*'
```

可用于group的模块

| Group | Purpose               | Ansible Version |
| ----- | --------------------- | --------------- |
| aws   | Amazon Web Services   | 2.7             |
| azure | Azure                 | 2.7             |
| gcp   | Google Cloud Platform | 2.7             |
| k8s   | Kubernetes            | 2.8             |
| os    | OpenStack             | 2.8             |



### 等待

使用`wait_for`模块，可以等待任务执行完毕后，才可继续执行后续的任务。

等待端口可用,才能继续执行任务

```yaml
- wait_for: port=8000 delay=10
```

等待直到锁定文件被删除

```yaml
wait_for: path=/var/lock/file.lock state=absent
```

### Playbook 关键字

Playbook 可用的关键字见[详细列表](basic/Reference/Keywords/)

### lookup 插件

`lookup`插件允许访问外部数据源。与所有模板一样，这些插件是在Ansible control节点上执行的。

#### 使用 `file` 获取文件内容

```yaml
---

- hosts: all
  vars:
     contents: "{{ lookup('file',  '/etc/foo.txt') }}"

  tasks:
    - debug: msg="the value of foo.txt is {{  contents }}"
```

#### 使用 `env` 获取变量

```yaml
---

- hosts: all
  vars:
    local_home: "{{ lookup('env','HOME')  }}"
  tasks:
    - debug: var=local_home
```

#### 使用 `password` 生成密码字符串


```yaml
---
- hosts: all

  tasks:
    #  使用只有ascii字母且长度为8的随机密码创建一个mysql用户:
    - mysql_user: name={{ client  }}
                  password="{{  lookup('password', '/tmp/passwordfile chars=ascii_letters length=8') }}"
                  priv={{ client }}_{{  tier }}_{{ role }}.*:ALL

    # 使用只有数字的随机密码创建一个mysql用户:
    - mysql_user: name={{ client  }}
                  password="{{  lookup('password', '/tmp/passwordfile chars=digits') }}"
                  priv={{ client }}_{{  tier }}_{{ role }}.*:ALL

    # 使用许多不同的字符集使用随机密码创建一个mysql用户：
    - mysql_user: name={{ client  }}
                  password="{{  lookup('password', '/tmp/passwordfile  chars=ascii_letters,digits,hexdigits,punctuation') }}"
                  priv={{ client }}_{{  tier }}_{{ role }}.*:ALL
```


如果文件已存在，则不会向其写入任何数据。  如果文件有内容，那些内容将作为密码读入。 空文件导致密码以空字符串返回。

 

#### 使用 `csvfile` 读取csv文件


```
# f.csv 

Symbol,Atomic  Number,Atomic Mass
H,1,1.008
He,2,4.0026
Li,3,6.94
Be,4,9.012
B,5,10.81
```

```yaml
- debug:  msg="The atomic number of Lithium is {{ lookup('csvfile', 'Li  file=elements.csv delimiter=,') }}"
- debug:  msg="The atomic mass of Lithium is {{ lookup('csvfile', 'Li  file=elements.csv delimiter=, col=2') }}"
```

参数描述


| 参数      | 默认值          | 描述                                                   |
| --------- | --------------- | ------------------------------------------------------ |
| file      | ansible.csv     | 要加载的文件名称                                       |
| col       | 1               | 要输出的列，索引从0开始                                |
| delimiter | TAB             | 文件的分隔符                                           |
| default   | empty    string | 如果key不在csv文件中，则为默认返回值                   |
| encoding  | utf-8           | 使用的CSV文件的编码（字符集）(added    in version 2.1) |

 

#### 使用 `ini`  读取ini文件

在section下查找以key1  = value1的格式来读取文件的内容。


```ini
# users.ini

[production]
# My production information
user=robert
pass=somerandompassword

[integration]
# My  integration information
user=gertrude
pass=anotherpassword
```



```yaml
tasks:
  - debug: msg="User in integration is {{  lookup('ini', 'user section=integration file=users.ini') }}"

  - debug: msg="User in production  is {{ lookup('ini', 'pass section=production  file=users.ini')  }}"
```


ini 参数格式
```yaml
lookup('ini',  'key [type=<properties|ini>] [section=section] [file=file.ini] [re=true]  [default=<defaultvalue>]')
```


第一个值必须是ini文件里的key

参数描述

| 字段    | 默认值          | 描述                                                         |
| ------- | --------------- | ------------------------------------------------------------ |
| type    | ini             | 文件类型。    可以是ini或properties （对于javaproperties ）。 |
| file    | ansible.ini     | 要加载的文件名称                                             |
| section | global          | 在哪里查找key                                                |
| re      | False           | 开启正则匹配                                                 |
| default | empty    string | 如果key不在文件中，则为默认返回值                            |

#### 使用 `dig` dns查询

此模块依赖 `dnspython`  库


```yaml
tasks:
  - debug:  msg="The IPv4 address for example.com. is {{ lookup('dig',  'example.com.')}}"

  - debug:  msg="The TXT record for example.org. is {{ lookup('dig', 'example.org.',  'qtype=TXT') }}"

  - debug:  msg="The TXT record for example.org. is {{ lookup('dig',  'example.org./TXT') }}"
```


其他插件
```yaml
tasks:

- debug: msg="{{ lookup('env','HOME') }} is an  environment variable"

- debug: msg="{{ lookup('pipe','date') }} is the  raw result of running this command"

# redis_kv lookup requires the  Python redis package
- debug: msg="{{  lookup('redis_kv', 'redis://localhost:6379,somekey') }} is value in Redis for  somekey"

# dnstxt lookup requires the Python  dnspython package
- debug: msg="{{  lookup('dnstxt', 'example.com') }} is a DNS TXT record for example.com"

- debug: msg="{{ lookup('template',  './some_template.j2') }} is a value from evaluation of this template"

# loading a json file from a  template as a string
- debug: msg="{{  lookup('template', './some_json.json.j2', convert_data=False) }} is a value  from evaluation of this template"

- debug: msg="{{ lookup('etcd', 'foo') }} is a  value from a locally running etcd"

# shelvefile lookup retrieves a  string value corresponding to a key inside a Python shelve file
- debug: msg="{{  lookup('shelvefile', 'file=path_to_some_shelve_file.db key=key_to_retrieve')  }}
```

