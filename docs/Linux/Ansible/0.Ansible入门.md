# Ansible入门

## 1.Ansible介绍

Ansible 是2012年推出的一种通用自动化工具，可用于配置管理或工作流程自动化。配置管理是一种" 基础架构代码 "实践，它将事物编码，例如应该在系统上安装什么包和版本，或者应该运行什么守护进程。工作流自动化可能是从配置基础架构到部署软件的任何事情。Ansible 在2015年时被Redhat公司收购。

Ansible是用Python编写的，它使用SSH在不同的机器上执行命令。Ansible是无代理的，这使得入手更容易。您只需要在相关机器上安装SSH和Python。

Ansible使用声明式YAML语言"playbook"将一组主机（"hosts"）映射到定义明确的角色。

声明性用于指示Ansible如何设置或更改事物，Ansible才进行必要的更改。



### Ansible 的目标

一切自动化



### Ansible的使用范围

- 自动化部署应用 
- 自动化管理配置 
- 自动化的持续交付 
- 自动化的云服务管理 
- 自动化网络设备管理

更多信息请参考：

- Ansible官方地址：https://docs.ansible.com/

- GitHub地址：https://github.com/ansible/ansible/blob/devel/docsite/rst/index.rst

- Ansible中文权威地址：http://www.ansible.com.cn/


### Ansible是怎么工作的

![](https://ansible.leops.cn/images/basic/ansible-arch.png)

从上图可以看出，运行ansible的先决条件是，安装ansible到管理节点，定义主机清单，并有一些playbooks定义。

简要的步骤

- 在控制节点上安装ansible 
- 配置主机清单: 将被控节点的连接信息配置到主机清单中。 
- 定义playbook: 指定运行主机和执行任务



让我们来看看我们如何使用Ansible将我们的Ubuntu虚拟机转换为Web服务器。 

您在管理节点上运行Ansible Playbook，它查看您在playbook中定义的命令参数，并通知我们定位到网络组中的节点。 

Ansible然后读取主机清单以查找分配给Web组的节点。

在这一点上，Ansible已经准备好开始工作，所以它将通过ssh远程连接到定义的机器，通常你会想要通过预共享密钥建立一些类型的ssh信任，这样你就不必在进行ssh登陆的时候输入密码。然后Ansible将开始逐步执行playbook中的任务，一次一个任务，从顶部到底部的顺序遍历它们，就像你手动登录执行任务一样。所以，它安装软件包，更新配置文件，使用git部署我们的网站代码，最后启动我们的Web服务。当Ansible很愉快的把一切都按预期的完成，你会得到一个执行成功的状态报告。

可以用动图说明下此次过程。

![](https://ansible.leops.cn/images/basic/ansible-arch.gif)


### 对管理主机的要求
目前,只要机器上安装了 Python 2（版本2.6或2.7）或Python 3（版本3.5及更高版本）都可以运行Ansible (windows系统不可以做管理主机) 管理主机的系统可以是 Red Hat, Debian, CentOS, OS X, BSD的各种版本.



### 对节点主机的要求
通常我们使用 ssh 与节点通信，默认使用 sftp. 如果 sftp 不可用，可在 ansible.cfg 配置文件中配置成 scp 的方式. 

在节点上也需要安装Python 2（2.6或更高版本）或Python 3（3.5或更高版本）



### Ansible 概念

#### 控制节点(Control node)

任何装有Ansible的机器可称为**控制节点**。 您可以从任何控制节点运行命令和剧本，并调用`/usr/bin/ansible`或`/usr/bin/ansible-playbook`。 

您可以将任何安装了Python的计算机用作控制节点,笔记本电脑,共享桌面和服务器都可以运行Ansible。 
但是，不能将Windows计算机用作控制节点。您也可以有多个控制节点。


#### 管理节点(Managed nodes)

使用Ansible管理的网络设备或服务器可称为**管理节点**。 受管节点有时也称为**主机**。 受管节点上是不需要安装Ansible的。

#### 主机清单(Inventory)

托管节点的列表。库存文件有时也称为主机文件。您的目录可以为每个托管节点指定诸如IP地址之类的信息。库存还可以组织托管节点，创建和嵌套组，以便于扩展。要了解更多关于库存的信息，请参见使用主机清单一节。


#### 模块(Modules)

Ansible执行的具体代码。每个模块都有特定的用途，从管理特定类型数据库的用户到管理特定类型网络设备上的VLAN接口。您可以使用任务调用单个模块，也可以调用剧本中的几个不同模块。要了解Ansible包含多少个模块，请查看所有模块的列表。



#### 任务(Tasks)

Ansible的行动单位。tasks包含一组由module组成的任务列表, 您可以使用特别的命令一次性执行单个任务。


#### 剧本(Playbooks)

保存了已排序的任务列表，因此可以按此顺序重复运行这些任务。
剧本可以包括变量和任务。剧本是用 YAML 编写的，易于阅读、编写、共享和理解。
要了解更多关于剧本的信息，请查看剧本。


### 社区活跃

> 统计时间: 2020年04月06日

- Ansible releases 304 
- Ansible modules 3387 
- Galaxy Roles 24,251 
- Github Starts 42,547 
- Github Fork 18,764 
- Github Contributors 4,955




### ansible项目
Ansible Galaxy是一个用于查找，共享，使用Ansible role的在线社区。 https://galaxy.ansible.com/

Ansible Container是一个开源项目，旨在实现整个容器构建，部署和管理过程的自动化。 https://github.com/ansible/ansible-container

Ansible tower 商业项目，使用可视化仪表板，基于角色的访问控制，作业调度，集成通知和图形库存管理来集中和控制IT基础架构。 https://www.ansible.com/products/tower



### Ansible 证书

- AUTOMATION WITH ANSIBLE I (DO407) 了解如何安装和配置Ansible，创建和运行剧本以配置系统，并学习管理主机。
- AUTOMATION WITH ANSIBLE II: RED HAT ANSIBLE TOWER (DO409) 了解使用 Ansible Tower。
- RED HAT CERTIFICATE OF EXPERTISE IN ANSIBLE AUTOMATION (EX407) 测试您使用Ansible自动配置系统和应用程序的技能，知识和能力。 通过此考试，您将获得Ansible Automation的红帽认证证书。



###  Ansible 与其它配置管理的对比

笔者选择了目前几款主流的与 Ansible 功能类似的配置管理软件chef、 Puppet、Saltstack，这里所做的对比不针对各个软件的性能作比较，只是对各个软件的特性做个对比。

|                   | **Ansible**   | **Chef**         | **Puppet**        | **SaltStack**        |
| ----------------- | ------------- | ---------------- | ----------------- | -------------------- |
| **程序语言**      | Python        | Ruby，Erlang     | C++, Clojure      | Python2              |
| **配置文件语言**  | YAML，JSON    | Ruby             | Propfietary       | YAML                 |
| **数据库**        | 否            | PostgreSQL       | PuppetDB          | 无                   |
| **传输方式**      | Ssh           | RabbitMQ         | Mcollective       | ZeroMQ               |
| **发布方式**      | Push          | Pull             | Pull              | Push                 |
| **管理节点**      | A，B，L，O，S | Linux            | Linux             | L，B                 |
| **客户端**        | 否            | A，B，L，O，S，W | A，B，L，O，S，W  | A，B，L，O，S，W     |
| **无代理**        | 是            | 否               | 否                | 否                   |
| **公有云版本**    | AM            | AM/AZ/PR         | 否                | 否                   |
| **公有云管理**    | AM/AZ/OS/GCP  | Fog driver       | AM/AZ/VM/GCP      | salt Cloud           |
| **架构**          | Server        | server/client    | server/client     | server/client        |
| **逐步部署**      | 是            | 是               | 否                | 否                   |
| **企业版UI**      | Ansible Tower | opscode Manage   | Puppet Enterprise | SaltStack Enterprise |
| **开源版UI**      | Semaphore     | Chef Manage      | Foreman           | Slatpad，Saltshaker  |
| **企业版本**      | 是            | 是               | 是                | 是                   |
|                   |               |                  |                   |                      |
| **创建时间**      | 2012年3月6日 |   2009年1月16日  |  2010年9月15日    |  2011年2月21日       |
| **Github Starts** | 42,547        | 6,198            | 5,710             | 10,747                |
| **Github Forks**  | 18,764        | 2,417            | 2,138             | 4,815                |
| **Contributors**  | 4,955         | 586              | 536               | 2,078                |
| **Commits**       | 49,775       | 26,017           | 31,751            |  106,129               |


> 统计时间: 2020年04月06日


### 资源

- 源码：https://github.com/ansible/ansible
- 官方文档： http://docs.ansible.com/
- Jinja2 中文文档： http://docs.jinkan.org/docs/jinja2/
- yaml语法： http://www.yaml.org/
- ansible 电子书: https://www.ansible.com/resources/ebooks
- 白皮书: https://www.ansible.com/resources/whitepapers
- 用户案例: https://www.ansible.com/resources/case-studies


## 2.安装Ansible

学会一个软件的第一件事，就是要在各种环境上安装这个软件，安装好，我们才能进入下一步，跟着我一起来安装 `ansible` 吧

!!! note "对管理主机的要求"
    目前,只要机器上安装了 Python 2（版本2.6或2.7）或Python 3（版本3.5及更高版本）都可以运行Ansible (windows系统不可以做管理主机)
    管理主机的系统可以是 Red Hat, Debian, CentOS, macOS, BSD的各种版本.

!!! note "对节点主机的要求"
    通常我们使用 ssh 与节点通信，默认使用 sftp.  如果 sftp 不可用，可在 ansible.cfg 配置文件中配置成 scp 的方式. 在节点上也需要安装Python 2（2.6或更高版本）或Python 3（3.5或更高版本）

    如果节点启用了`selinux`, 在使用`copy`/`file`/`template`时需要安装 `libselinux-python` 包。

    如果想通过ansible给节点主机安装python模块，可以使用`raw`模块，命令如: 

    ```bash
    ansible myhost --become -m raw -a "yum install -y python2"
    ```
     `raw` 模块 可以原生执行shell命令


### 在管理节点上安装ansible

> 大家选择下面的一种方式进行安装 `ansible`

=== "CentOS/RHEL"
    ``` bash
    sed -e 's!^#baseurl=!baseurl=!g' \
           -e  's!^mirrorlist=!#mirrorlist=!g' \
           -e 's!mirror.centos.org!mirrors.aliyun.com!g' \
           -i  /etc/yum.repos.d/CentOS-Base.repo

    yum install -y epel-release

    sed -e 's!^mirrorlist=!#mirrorlist=!g' \
        -e 's!^metalink=!#metalink=!g' \
        -e 's!^#baseurl=!baseurl=!g' \
        -e 's!//download\.fedoraproject\.org/pub!//mirrors.aliyun.com!g' \
        -e 's!http://mirrors\.aliyun!https://mirrors.aliyun!g' \
        -i /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel-testing.repo

    yum install -y ansible
    ```
=== "Ubuntu"
    ``` bash
    $ sudo apt update
    $ sudo apt install software-properties-common
    $ sudo apt-add-repository --yes --update ppa:ansible/ansible
    $ sudo apt install ansible
    ```
=== "Debian"
    ``` bash
    deb http://ppa.launchpad.net/ansible/ansible/ubuntu trusty main
    $ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 93C4A3FD7BB9C367
    $ sudo apt update
    $ sudo apt install ansible
    ```

=== "FreeBSD"
    ``` bash
    $ sudo pkg install py27-ansible
    # or
    $ sudo pkg install py36-ansible
    ```

=== "dnf"
    ``` bash

    $ sudo dnf install ansible
    ```
    
=== "mac"
    ``` bash
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
    python get-pip.py
    sudo CFLAGS=-Qunused-arguments CPPFLAGS=-Qunused-arguments pip install ansible -i https://mirrors.ustc.edu.cn/pypi/web/simple
    # 通过此方式安装的没有生成/etc/ansible文件，可以手动生成，配置文件示例到https://github.com/ansible/ansible/tree/devel/examples
    ```
=== "pip"
    ``` bash
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
    python get-pip.py
    pip install ansible -i https://mirrors.ustc.edu.cn/pypi/web/simple

    # 通过此方式安装的没有生成/etc/ansible文件，可以手动生成，配置文件示例到https://github.com/ansible/ansible/tree/devel/examples
    ```

=== "Python3"
    ``` bash
    yum install -y python36 python36-tools
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
    python3.6 get-pip.py 
    pip3.6 install ansible -i https://mirrors.ustc.edu.cn/pypi/web/simple
    # 通过此方式安装的没有生成/etc/ansible文件，可以手动生成，配置文件示例到https://github.com/ansible/ansible/tree/devel/examples
    ```
=== "源码"
    ``` bash
    yum install -y  python-setuptools
    easy_install pip
    wget https://github.com/ansible/ansible/archive/v2.9.6.tar.gz
    tar zxf v2.9.6.tar.gz
    cd ./ansible-2.9.6
    pip install -r ./requirements.txt
    python setup.py install
    mkdir /etc/ansible/
    cp examples/{ansible.cfg,hosts} /etc/ansible/
    ```
=== "离线安装"
    ``` bash
    # 以目标主机centos7为测试
    # 1. 下载ansible及依赖系统包
    curl -sSL https://cdn.jsdelivr.net/gh/lework/script/shell/get_packages.sh | bash -s - centos7 ansible
    # 2. 下载好的离线包在当前目录的package_centos7_ansible
    ls package_centos7_ansible
    # 3. 将目录拷贝到目标主机,在当前目录安装
    yum localinstall *.rpm
    ```


### bash命令行自动补全

> 在Ansible 2.9之后，就支持了命令行参数补齐功能

=== "CentOS/RHEL"
    ``` bash
    yum install epel-release
    yum install python-argcomplete
    ```
=== "apt"
    ``` bash
    $ sudo apt install python-argcomplete
    ```
=== "pip"
    ``` bash
    pip install argcomplete
    ```

**将补全加入环境变量**

```bash
activate-global-python-argcomplete
source /etc/profile
```

在bash 小于4.2 时，使用下列命令注册

```bash
$ eval $(register-python-argcomplete ansible)
$ eval $(register-python-argcomplete ansible-config)
$ eval $(register-python-argcomplete ansible-console)
$ eval $(register-python-argcomplete ansible-doc)
$ eval $(register-python-argcomplete ansible-galaxy)
$ eval $(register-python-argcomplete ansible-inventory)
$ eval $(register-python-argcomplete ansible-playbook)
$ eval $(register-python-argcomplete ansible-pull)
$ eval $(register-python-argcomplete ansible-vault)
source /etc/profile
```

## 3.快速开始

跟着我，一步一步的开始 ansible 神奇之旅吧！

### 环境信息

control os:  `centos 7.7`

ansible version: `2.9.6`


### 任务

我们将要在目标主机上安装部署`nginx`服务


### 步骤


#### 0. 安装ansible

> 本次使用的是 `Centos 7.7 x64` 系统

```bash
yum install -y epel-release

sed -e 's!^metalink=!#metalink=!g' \
    -e 's!^#baseurl=!baseurl=!g' \
    -e 's!http://download\.fedoraproject\.org/pub/epel!https://mirrors.tuna.tsinghua.edu.cn/epel!g' \
    -e 's!http://download\.example/pub/epel!https://mirrors.tuna.tsinghua.edu.cn/epel!g' \
    -i /etc/yum.repos.d/epel*.repo
    
yum install -y ansible
yum update python-jinja2

```


#### 1. 定义主机清单

> 定义一个简单的通过ssh认证的主机清单，更多配置见

```
cat /etc/ansible/hosts

192.168.77.131 ansible_ssh_user=root ansible_ssh_pass=xxxx
```

主机清单中的配置含义

- `192.168.77.131`  定义远程主机ip地址
- `ansible_ssh_user` 连接远程主机的用户
- `ansible_ssh_pass` 连接远程主机的用户密码


#### 2. 执行ansible命令

**测试连接状态**

```bash
ansible 192.168.77.131 -m ping
```

命令中的含义
- `192.168.77.131`  用于匹配主机清单中的主机名称
- `-m ping` 指定 `ping` 模块，用于测试与远程主机的连接状态



**安装Nginx**

```bash
# 安装
ansible 192.168.77.131 -m yum -a 'name=nginx'
#卸载
ansible 192.168.77.131 -m yum -a 'name=nginx state=absent'
```

命令中的含义
- `192.168.77.131`  用于匹配主机清单中的主机名称
- `-m yum` 指定 `yum` 模块，用于安装软件
- `-a 'name=nginx'` 指定模块的参数，`name`是软件的名称，默认操作是安装。

**启动Nginx**

```bash

# 启动
ansible 192.168.77.131 -m systemd -a 'name=nginx state=started enabled=yes'


# 关闭
ansible 192.168.1.131 -m systemd -a 'name=nginx state=stopped enabled=yes'

```

命令中的含义
- `192.168.77.131`  用于匹配主机清单中的主机名称
- `-m systemd` 指定 `systemd` 模块，用于管理系统服务
- `-a 'name=nginx state=started enabled=yes'` 指定模块的参数，`name`是软件的名称，`state` 指定管理状态，`enabled` 是否开启自启动。

#### 3. 验证

```bash
curl http://192.168.77.131:80
```

#### 4. 执行ansible playbook


**定义 playbook**

> 也就是任务编排，将上面3个步骤合并在一起。

```shell
# File: install_nginx.yml

---
- hosts: 192.168.77.135
  tasks:
    - name: 安装 nginx.
      yum: name=nginx
    - name: 启动 nginx.
      systemd: name=nginx state=started enabled=yes
    - name: 检查 nginx.
      uri: url=http://127.0.0.1
      register: curl_result
      until: curl_result.status == 200
      retries: 5
      delay: 3
      changed_when: false
      check_mode: no

```

**执行 playbook**

```bash
ansible-playbook install_nginx.yml
```


卸载nginx：
```shell
# File: remove_nginx.yml
---
- hosts: 192.168.77.135
 
  tasks:
    - name: stop nginx
      service: name=nginx state=stopped enabled=no
    - name: remove nginx
      yum: name=nginx state=absent
    - name: remove user nginx
      user: name=nginx state=absent
    - name: remove group nginx
      group: name=nginx state=absent
    - name: web page
      file: 
        path: /usr/share/nginx/html/index.html 
        state: absent
```


恭喜你，你已经学会怎么使用ansible了。下面的课程会使你更加深入的了解 ansible 。



## 4.认识主机清单

Ansible 可同时操作属于一个组的多台主机, 组和主机之间的关系通过 `inventory` 文件配置. 默认的文件路径为 `/etc/ansible/hosts`, 
执行命令的时候使用 `-i` 参数即可指定主机清单。

### 主机清单示例

主机清单文件主要有 `ini` 和 `yaml` 格式两种语法格式

```ini
mail.example.com       # 定义主机fqdn地址, 且已经与控制节点ssh互信

[webservers]  # 方括号[]中是组名
host1  # 定义主机名称, 且已经与控制节点ssh互信
host2:5522  # 指定连接主机和端口号
localhost ansible_connection=local  # ansible_connection可以定义连接类型, local是在本地执行
host3 http_port=80 maxRequestsPerChild=808  # 定义主机变量, 除了ansible定义的特殊名称外，其他的都是主机变量
host4 ansible_host=192.168.1.50 ansible_port=2222 ansible_user=root ansible_password=12345 # 指定别名，定义主机ssh连接信息
www[1:50].example.com # 定义 1-50范围内的主机
www-[a:f].example.com # 定义 a-f 范围内内的主机

[dbservers]
three.example.com  ansible_python_interpreter=/usr/local/bin/python3  # 定义python执行ansible，这个是指定被控节点的。
192.168.77.123  ansible_ruby_interpreter=/usr/bin/ruby.1.9.3  # 定义ruby执行文件
 

[webservers:vars] # 定义webservers组的变量
ntp_server=ntp.example.com
proxy=proxy.example.com

[server:children] # 定义server组的子成员
webservers
dbservers

[server:vars] # 定义server组的变量
zabbix_server:192.168.77.121
```

!!! note
    注意！组名称中不要带`-`

上列配置的一些解释：

- 主机可以在多个组中配置。
- `ansible_connection` 是执行主机的连接类型，默认是smart
- `ansible_host` 主机ssh连接地址
- `ansible_port` 主机ssh连接端口
- `ansible_user` 主机ssh连接用户
- `ansible_password` 主机ssh连接用户密码
- `ansible_python_interpreter` 指定python的执行路径
- `[webservers:vars]`  定义webservers组的变量
- `[server:children]`  定义server组的子成员



也可使使用yaml格式来表示

```yaml

all:
  children:
    usa:
      children:
        southeast:
          children:
            atlanta:
              hosts:
                host1:
                host2:
            raleigh:
              hosts:
                host2:
                host3:
          vars:
            some_server: foo.southeast.example.com
            halon_system_timeout: 30
            self_destruct_countdown: 60
            escape_pods: 2
        northeast:
        northwest:
        southwest:
```


> yaml格式配置的还是挺复杂的，可读性也差，建议使用`ini`方式来设置主机清单。 


### 默认组

在主机清单中，ansible会自动的生成两个组。

- `all`  所有的主机。
- `ungrouped` 包含没有组的主机。

尽管这两个组是永远存在的，但也有可能是隐藏的，不会出现group_names之类的组列表中。


### 主机变量和组变量

如果你不想在主机清单中定义主机的变量或者组的变量，ansible还支持在特定的目录中定义变量。

变量文件必须以yaml语法定义。

如默认在`/etc/ansible/host_vars/` 目录中定义主机变量，文件名称以主机名称命名，结束可以用'.yml', '.yaml', '.json'三种格式。

```bash
cat /etc/ansible/host_vars/host1
---
ntp_server: acme.example.org
database_server: storage.example.org
```


如默认在`/etc/ansible/group_vars/` 目录中定义组变量，文件名称以组名称命名，结束可以用'.yml', '.yaml', '.json'三种格式。

```bash
cat /etc/ansible/group_vars/webservers
---
ntp_server: acme.example.org
database_server: storage.example.org
```


### 变量合并

我们可以通过多种方式给主机定义变量，如果在各个环节都设置了变量，到底哪个变量生效呢？这就要看ansible的变量优先级，优先级高的会覆盖优先级低的变量。

优先顺序，all最低，host最高

- all group
- parent group
- child group
- host

相同组时，默认情况下，按字母顺序后面组的定义会覆盖前面的。也可以使用ansible_group_priority调整优先级，数值越大优先级越高，默认为1，相同优先级时，后者优先。

```ini
[a_group:vars]
testvar=a
ansible_group_priority=10
[b_group]
testvar=b
```


### 使用多个主机清单

在命令参数中，使用多个 `-i` 就可以指定多个主机清单 

```bash
ansible all -i staging -i production -m ping
ansible all -i /tmp/staging -i /tmp/production -m ping
```

也可以指定一个目录

```
inventory/
  01-openstack.yml          # configure inventory plugin to get hosts from Openstack cloud
  02-dynamic-inventory.py   # add additional hosts with dynamic inventory script
  03-static-inventory       # add static hosts
  group_vars/
    all.yml                 # assign variables to all hosts
```

```bash
ansible all -i inventory -m ping
```


### 主机内置变量列表

**用于主机连接**

| 参数               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| ansible_connection | 与主机的连接类型.比如:local,  ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 'smart','smart'   方式会根据是否支持 ControlPersist, 来判断'ssh' 方式是否可行. |

**用于所有连接**

| 参数 |  描述                                          |
| ------------ | ------------------------------------------------------------ |
| ansible_host | 将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置. |
| ansible_port | 连接端口号，如果是ssh的话，默认是22           |
| ansible_user | 用于连接认证的用户名                                            |
| ansible_password | 用于连接认证的用户名密码                                            |

**ssh连接参数**

| 参数 |  描述                                          |
| ------------ | ------------------------------------------------------------ |
| ansible_ssh_private_key_file | ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况. |
| ansible_ssh_common_args      | 此设置附加到sftp，scp和ssh的缺省命令行                       |
| ansible_sftp_extra_args      | 此设置附加到默认sftp命令行。                                 |
| ansible_scp_extra_args       | 此设置附加到默认scp命令行。                                  |
| ansible_ssh_extra_args       | 此设置附加到默认ssh命令行。                                  |
| ansible_ssh_pipelining       | 确定是否使用SSH管道。这可以覆盖ansible.cfg中得设置。      |
| ansible_ssh_executable       | ssh可执行文件                                                |

**权限提升参数**



| 参数               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| ansible_become        | 开启提权，等同于`ansible_sudo`，`ansible_su`              |
| ansible_become_method | 提权方式                                                  |
| ansible_become_user   | 提权用户，等同于`ansible_sudo_user`，`ansible_su_user`    |
| ansible_become_password   | 提权密码,等同于`ansible_sudo_password`，`ansible_su_password` |
| ansible_become_exe    | 提权所用的可执行文件，等同于`ansible_sudo_exe`,`ansible_su_exe`  |
| ansible_become_flags  | 提权命令的参数，等同于`ansible_sudo_flags`,`ansible_su_flags` |

**远程主机环境参数**

| 参数                       | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| ansible_shell_type         | 目标系统的shell类型.默认情况下,命令的执行使用   'sh' 语法,可设置为 'csh' 或 'fish'. |
| ansible_python_interpreter | 目标主机的 python   路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是"/usr/bin/python",比如  \*BSD, 或者 /usr/bin/python |
| ansible_*_interpreter      | 这里的"*"可以是 ruby   或 perl 或其他语言的解释器，作用和ansible_python_interpreter 类似 |
| ansible_shell_executable   | 这将设置ansible控制器将在目标机器上使用的shell，覆盖ansible.cfg中的配置，默认为/bin/sh。 |

**非SSH连接类型参数**

ansible默认是使用 `ssh` 连接主机，但也不限制于这种方式，可以通过使用主机特定参数 `ansible_connection = <connector>`，来更改连接类型。以下是支持的连接类型。

| 参数 |  描述                   |
| ------ | -------------------- |
| local  | 在控制端本地执行     |
| docker | 使用本地Docker客户端 |
| ansible_host | 容器连接的主机 |
| ansible_port | 容器连接的端口 |
| ansible_become | 如果设置为true，则会使用begin_user在容器内进行操作。|
| ansible_docker_extra_args | Docker 的额外参数|

一个创建容器的小例子

```yaml
- name: create jenkins container
  docker_container:
    docker_host: myserver.net:4243
    name: my_jenkins
    image: jenkins

- name: add container to inventory
  add_host:
    name: my_jenkins
    ansible_connection: docker
    ansible_docker_extra_args: "--tlsverify --tlscacert=/path/to/ca.pem --tlscert=/path/to/client-cert.pem --tlskey=/path/to/client-key.pem -H=tcp://myserver.net:4243"
    ansible_user: jenkins
  changed_when: false

- name: create directory for ssh keys
  delegate_to: my_jenkins
  file:
    path: "/var/jenkins_home/.ssh/jupiter"
    state: directory
```

### 在运行的时候增加主机

使用 `add_host` 模块动态添加运行主机，此类主机只有在运行时才会向内存中添加，运行结束后，也不会添加到静态主机清单文件中。

```yaml
- name: add new node into runtime inventory
  add_host:
    hostname: webserver
    groups: web
​    ansible_host: 192.168.77.129
    ansible_port: 22
```

### 限定主机清单的运行主机

使用`--limit hostname`可以在运行任务的时候，只允许在此主机上运行。

```yaml
[root@master ansible]# ansible-playbook test.yml --list-hosts
 playbook: test.yml
  play #1 (test2): test2        TAGS: []
    pattern: [u'test2']
    hosts (3):
      node1
      node3
      node2
[root@master ansible]# ansible-playbook test.yml --list-hosts --limit node3,node2
playbook: test.yml
  play #1 (test2): test2        TAGS: []
    pattern: [u'test2']
    hosts (2):
      node3
      node2
```

### 示例

#### 连接本地主机

不需要在主机清单里定义，直接使用 `localhost` 或 `127.0.0.1` 就可以连接本地了

```bash
# ansible localhost -m ping
localhost | SUCCESS => {
    "changed": false, 
    "ping": "pong"
}

# ansible 127.0.0.1 -m ping
127.0.0.1 | SUCCESS => {
    "changed": false, 
    "ping": "pong"
}

```

#### 使用别名连接主机

**定义主机清单**
```bash
# cat /etc/ansible/hosts

alias_host ansible_host=192.168.77.131 ansible_port=22 ansible_user=root ansible_password=123456 # 指定别名，定义主机ssh连接信息
```
**测试连通性**
```bash
# ansible alias_host -m ping
alias_host | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}
```

#### 使用 ssh 秘钥连接主机
**开启远程主机秘钥认证**
```bash
# echo 'PubkeyAuthentication yes' >> /etc/ssh/sshd_config
# systemctl restart sshd
```

**配置远程主机秘钥**
```bash
# ssh-keygen -t rsa -P '' -b 4096 -f ~/.ssh/id_rsa
# cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
# chmod 600 ~/.ssh/authorized_keys
```

**将刚刚生成的私钥 `~/.ssh/id_rsa` 拷贝到 ansible 节点**
```bash
# mv id_rsa /opt/131.key
# chmod 600 /opt/131.key
```

**定义主机清单**
```bash
# cat /etc/ansible/hosts
192.168.77.131 ansible_ssh_private_key_file=/opt/131.key
```
> 不指定 `ansible_user` 则使用运行ansible命令的用户

!!! note
    如果 `private_key` 使用了 **passphrase** ，可使用下列命令，将密码保存在 ssh-agent 中。
    ```bash
    ssh-agent bash
    ssh-add /opt/131.key
    ```

**测试连通性**
```bash
# ansible 192.168.77.131 -m ping
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}

```

#### 使用 跳板机 连接主机

> 通过 192.168.77.132 连接192.168.77.131， 192.168.77.132 需安装`nc`

**添加132节点到kown_hosts**
```bash
# ssh 192.168.77.132
The authenticity of host '192.168.77.132 (192.168.77.132)' can't be established.
ECDSA key fingerprint is SHA256:2lWSIJMF9r8hnfLwlKONY07eQCeZaDVZ/xWZizr9wqs.
ECDSA key fingerprint is MD5:be:82:d9:23:45:18:f2:e3:fa:32:56:65:c9:b1:4b:07.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.77.132' (ECDSA) to the list of known hosts.
```

1. 使用ssh代理参数配置

**定义主机清单**
```bash
# cat /etc/ansible/hosts
192.168.77.131 ansible_ssh_private_key_file=/root/131.key ansible_ssh_common_args="-o ProxyCommand=\"sshpass -p '123456' ssh -qay -p 22 root@192.168.77.132 'nc %h %p'\""
```
> ansible_ssh_common_args 配置ssh连接的参数

**测试连通性**

```bash
# ansible 192.168.77.131 -m ping
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}
```


2. 使用本地ssh配置主机代理

**配置ssh**

```bash
# cat ~/.ssh/config 
Host 192.168.77.131
        User root
        Port 22
        TCPKeepAlive yes
        ForwardAgent yes
        ProxyCommand sshpass -p '123456' ssh -qaY -p 22 root@192.168.77.132 'nc %h %p'
```

**定义主机清单**
```bash
# cat /etc/ansible/hosts
192.168.77.131 ansible_ssh_private_key_file=/opt/131.key
```

**测试连通性**

```bash
# ansible 192.168.77.131 -m ping
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}

```

3. 使用ssh代理

> 不需要在192.168.77.132上安装nc软件了

**定义主机清单**
```bash
# cat /etc/ansible/hosts
192.168.77.131 ansible_ssh_private_key_file=/root/131.key ansible_ssh_common_args="-o ProxyCommand=\"sshpass -p '123456' ssh -W %h:%p -q -p 22 root@192.168.77.132\""
```
> ansible_ssh_common_args 配置ssh连接的参数

**测试连通性**

```bash
# ansible 192.168.77.131 -m ping
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}
```

#### 命令行指定主机清单

```bash
# ansible -i '192.168.77.131,192.168.77.132' 192.168.77.* -m ping -k
SSH password: 
192.168.77.131 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}
192.168.77.132 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": false, 
    "ping": "pong"
}

```

通过 `-i` 参数， 指定用逗号分隔的主机列表即可。 

不过不能指定`ansible_*` 开头的变量，即不能定义连接密码。

### 动态主机清单

ansible 不仅可以使用`yaml`,`ini`等格式的静态文件配置主机清单，还可以使用动态的源作为主机清单，详细内容请见使用动态主机



## 5.Patterns 匹配
**Patterns** 是定义Ansible要执行的主机。Ansible Patterns 可以引用一个主机，一个IP地址，一个清单组，一个集合组或清单中的所有主机。 Patterns 具有高度的灵活性，您可以排除或要求主机的子集，使用 **通配符** 或 **正则表达式** 来定义 Patterns 。

**命令格式**

```
ansible <pattern> -m <module_name> -a "<module options>"

ansible-playbook -l <pattern>  [options] playbook.yml
```

**使用示例**

```
ansible * -m service -a "name=httpd state=restarted"

ansible-playbook  -l all playbook.yml
```



在 **playbook** 的剧本中，需要在每个 **play** 中`hosts: `行中定义

```
- name: <play_name>
  hosts: <pattern>
```

**使用示例**

```
- name: restart webservers
  hosts: webservers
```



### 常用匹配

| 描述               | Pattern(s)                      | Targets                                   |
| ------------------ | ------------------------------- | ----------------------------------------- |
| 所有主机           | `all` 或者 `*`                  | 主机清单中的所有主机                      |
| 一个主机(精确匹配) | `host1` 或者 `192.168.77.131`   | `host1` 或者 `192.168.77.131`             |
| 多个主机           | `host1:host2` 或者`host1,host2` | `host1:host2` 或者`host1,host2`           |
| 一个组             | `webservers`                    | `webservers`组中的主机                    |
| 多个组(或匹配)     | `webservers:dbservers`          | `webservers`和`dbservers`所有的主机       |
| 排除组(非模式匹配) | webservers:!atlanta             | `webservers`组中除`atlanta`之外的所有主机 |
| 交集组(交集匹配)   | webservers:&dbservers           | `webservers`和`dbservers`都存在的主机     |

 

**通配符匹配**

```
*.com
web*.com:dbserver
```

`*`表示所有字符

 

**组合匹配**

```
webservers:dbservers:&staging:!phoenix
```

在webservers 或者dbservers 组中，必须还存在于staging 组中，但是不在phoenix 组中



### 局限性

**Patterns** 依赖于 **主机清单** (inventory)，如果说匹配不到主机清单里的数据，则会返回如下警告

```bash
# ansible none -m ping 
[WARNING]: Could not match supplied host pattern, ignoring: none
[WARNING]: No hosts matched, nothing to do
```

### 高级特性

#### 使用变量

在ansible-palybook 命令中，你也可以使用变量来组成这样的表达式，但是你必须使用`-e`的选项来指定这个表达式

**playbook**

```bash
# cat  playbook.yml
---
- name: Using variables in patterns
  hosts: "{{ hosts }}"
  tasks:
    - name: ping
      ping:

```

**执行playbook**

```bash
ansible-playbook playbook.yml -e "hosts=192.168.77.131"
ansible-playbook playbook.yml -e "hosts=192.168.77.132"
```

#### 使用切片

可以使用下标来选择组中的各个主机或范围，类似python中的切片

```
webservers[0]
webservers[1:]
webservers[0:25]
```

- `[0]`表示组第一个成员

- `[1:]` 表示组内第2个含第2个之后的所有成员
- `[0:25] `表示组第1个到第24个成员

#### 正则表达式

在开头的地方使用“~”，表示这是一个正则表达式

```
~(web|db).*\.example\.com
```

#### 限定主机

可以使用命令行选项更改playbook中定义的Patterns 的行为

```
ansible-playbook site.yml -l 192.168.77.129

ansible-playbook site.yml -l @retry_hosts.txt
```

只执行`-l`后的主机, `@`开头指定文件



## 6.使用ad-hoc命令
Ansible ad-hoc 命令使用 `/usr/bin/ansible`命令行工具来自动化一个或多个受管节点上的单个任务。 临时命令既快速又简单，但不可重用。

### ad-hoc 命令

```bash
ansible [pattern] -m [module] -a "[module options]"
```
执行结果说明

rc:  命令返回码（0表示成功）

### ad-hoc 示例

#### 执行shell命令

##### command

重启服务器

```bash
ansible servers -a "reboot"
```

不指定`-m` 模块时，将使用ansible的默认模块command，它不会通过shell进行处理，所以像`$HOME`和像`“<”`，`“>”`，`“|”`，`“;” `和`“＆”`将不工作



默认情况下，Ansible使用5个并发进程。 如果你要扩大并发，使用`-f 10` 参数指定数量即可。

```bash
ansible servers -a "reboot" -f 10
```

默认情况下，Ansible连接远端用户是当前用户，使用`-u` 参数可以修改

```bash
ansible servers -a "reboot" -f 10 -u root
```

如果运行用户没有权限执行，使用`--become` 可以提升权限,默认是`sudo`方式

```bash
ansible servers -a "reboot" -f 10 -u root --become
ansible servers -a "reboot" -f 10 -u test --become --become-method sudo --become-user root --ask-become-pass
```

`--become-method` 指定提升方式，`--become-user` 指定提升用户 `--ask-become-pass` 告知提升密码



##### shell

获取web组里得eth0接口信息

```bash
ansible web -m shell -a "ifconfig eth0|grep addr"
```

##### raw

如果说远程主机没有`python` 模块时，可以使用`raw` 模块执行命令

```bash
ansible web -m raw -a "ifconfig eth0|grep addr"
```

##### script

执行脚本

```
ansible web -m script -a ip.sh
```

> 将本地脚本传送到远程节点上运行

 

#### 文件管理

##### copy 

 拷贝本地的/etc/hosts 文件到web组所有主机的/tmp/hosts（空目录除外）

```bash
ansible web -m copy -a "src=/etc/hosts dest=/tmp/hosts"
```

 拷贝本地的ntp文件到目的地址，设置其用户及权限，如果目标地址存在相同的文件，则备份源文件。

```bash
ansible web -m copy -a "src=/mine/ntp.conf dest=/etc/ntp.conf owner=root group=root mode=644 backup=yes force=yes"
```

##### fetch

从远端服务器拷贝到本机

```bash
ansible web -m fetch -a "src=/etc/hosts dest=/tmp/temp_hosts flat=yes"
```

##### file 

更改文件的用户及权限

```bash
ansible web -m file -a "dest=/tmp/a.txt mode=600 owner=user group=user"
```

创建目录，类似mkdir -p

```bash
ansible web -m file -a "dest=/tmp/test mode=755 owner=user group=user state=directory"
```

删除文件或者目录

```bash
ansible web -m file -a "dest=/tmp/test state=absent"
```

创建软连接，并设置所属用户和用户组

```bash
ansible web -m file -a  "src=/file/to/link/to dest=/path/to/symlink owner=user group=user state=link"
```

 touch 一个文件并添加用户读写权限，用户组去除写执行权限，其他组减去读写执行权限

```bash
ansible web -m file -a  "path=/etc/foo.conf state=touch mode='u+rw,g-wx,o-rwx'"
```

##### unarchive

将本地的压缩文件解压到目标主机

```bash
ansible web -m unarchive -a "src=foo.tgz dest=/opt/foo“
```



#### 管理软件包

apt、yum 模块分表用于管理Ubuntu 系列和RedHat 系列系统软件包

##### apt

更新仓库缓存，并安装"foo"

```bash
ansible web -m apt -a "name=foo update_cache=yes"
```

删除 "foo"
```bash
ansible web -m apt -a "name=foo state=absent"
```


安装  "foo"
```bash
ansible web -m apt -a "name=foo state=present"
```


安装  1.0版本的 "foo"
```bash
ansible web -m apt -a "name=foo=1.00 state=present"
```


安装最新得"foo"
```bash
ansible web -m apt -a "name=foo state=latest"
```


注释：Ansible 支持很多操作系统的软件包管理，使用时-m 指定相应的软件包管理工具模块，如果没有这样的模块，可以自己定义类似的模块或者使用command 模块来安装软件包

##### yum

安装 最新的 Apache
```bash
ansible web -m yum -a  "name=httpd state=latest"
```


删除apache
```bash
ansible web -m yum -a  "name=httpd state=absent"
```


从testing 仓库中安装最后一个版本得apache
```bash
ansible web -m yum -a  "name=httpd enablerepo=testing state=present"
```


更新所有的包
```bash
ansible web -m yum -a  "name=* state=latest"
```


安装远程的rpm包
```bash
ansible web -m yum -a  "name=http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm state=present"
```


安装  'Development tools' 包组
```bash
ansible web -m yum -a  "name='@Development tools' state=present"
```

##### package

使用远程主机的包管理器进行安装，卸载，更新软件。相对于`apt`,`yum`而言，兼容性更好。

安装ntpdate

```bash
ansible web -m package -a  "name=ntpdate stat=present"
```



#### 用户和用户组

##### user

添加用户 'user'并设置其 uid 和主要的组'admin'
```bash
ansible web -m user -a "name=user comment='I am user' uid=1040 group=admin"
```


添加用户 'user'并设置其登陆shell，并将其假如admins和developers组
```bash
ansible web -m user -a "name=user shell=/bin/bash groups=admins,developers append=yes"
```

删除用户 'user'
```bash
ansible web -m user -a "name=user state=absent remove=yes"
```


创建 user 用户得 2048-bit SSH key，并存放在 ~user/.ssh/id_rsa
```bash
ansible web -m user -a "name=user generate_ssh_key=yes ssh_key_bits=2048 ssh_key_file=.ssh/id_rsa"
```


设置用户过期日期
```bash
ansible web -m user -a "name=user shell=/bin/zsh groups=nobdy expires=1422403387"
```


创建 test 组，并设置 gid 为1000
```bash
ansible web -m group -a "name=test gid=1000 state=present"
```

删除 test 组
```bash
ansible web -m group -a "name=test state=absent"
```

#### 版本控制

##### git

Ansible 模块能够通知变更，当代码更新时，可以告诉 Ansible 做一些特定的任务，比如从git 部署代码然后重启 apache 服务等
```bash
ansible web -m git -a "repo=https://github.com/Icinga/icinga2.git dest=/tmp/myapp   version=HEAD"
```

#### 服务管理

##### service

确保 web 组所有主机的 httpd 是启动的
```bash
ansible web -m service -a "name=httpd state=started"
```


重启 web 组所有主机的httpd 服务
```bash
ansible web -m service -a "name=httpd state=restarted"
```


确保web组所有主机的httpd 是关闭的
```bash
ansible web -m service -a "name=httpd state=stopped"
```

##### systemd

启动服务

```bash
ansible web -m systemd -a "state=started name=httpd"
```

重载配置

```bash
ansible web -m systemd -a "daemon_reload=yes"
```

#### 防火墙管理

##### iptables

允许tcp 22端口通过
```bash
ansible all -m iptables  -a "chain=INPUT destination_port=22 protocol=tcp jump=ACCEPT"
```

##### firewalld

运行https端口通过

```bash
ansible all -m firewalld -a "service=https permanent=yes state=enabled"
```

#### 文件内容操作

##### lineinfile

开启selinux， 替换以SELINUX=开头的行，如果没有匹配到，则新增一条数据。
```bash
ansible all -m lineinfile  -a "dest=/etc/selinux/config regexp=^SELINUX= line=SELINUX=enforcing"
```


删除以SELINUX=开头的行
```bash
ansible all -m lineinfile  -a "dest=/tmp/config regexp=^SELINUX= state=absent"
```


如果文件中, line值不存在，则向文件中添加line的内容
```bash
ansible all -m lineinfile  -a "dest=/tmp/config  line='test'"
```

##### replace

替换文件内容

```bash
ansible all -m  replace  -a "dest=/etc/selinux/config regexp=^SELINUX=disabled replace=SELINUX=enforcing"
```

#### 定时任务

每天5点，2点得时候执行 ls -alh > /dev/null

```bash
ansible test -m cron -a "name='check dirs' minute='0' hour='5,2' job='ls -alh > /dev/null'"
```

#### 搜集系统信息

搜集主机的所有系统信息

```bash
ansible all -m setup
```

搜集系统信息并以主机名为文件名分别保存在/tmp/facts 目录

```bash
ansible all -m setup --tree /tmp/facts
```

搜集和内存相关的信息

```bash
ansible all -m setup -a 'filter=ansible_*_mb'
```

搜集网卡信息

```bash
ansible all -m setup -a 'filter=ansible_eth[0-2]'
```

#### 指定连接方式

```bash
ansible all -i 'centos,' -c docker -m shell -a 'ps aux'
ansible all -i 'centos,' -c local -m shell -a 'ifconfig'
```

#### 后台运行

长时间运行的操作可以放到后台执行，ansible 会检查任务的状态；在主机上执行的同一个任

务会分配同一个job ID

后台执行命令3600s，-B 表示后台执行的时间

```bash
ansible all -B 3600 -a "/usr/bin/long_running_operation --do-stuff"
```

**检查任务的状态**

```bash
ansible all -m async_status -a "jid=123456789"
```

后台执行命令最大时间是1800s 即30 分钟，-P 每60s 检查下状态默认15s

```bash
ansible all -B 1800 -P 60 -a "/usr/bin/long_running_operation --do-stuff"
```

### 练习

大家通过下列命令来查看帮助，练习下表格中常用模块的使用。

```bash
ansible-doc file
```


| 类型        | 模块                                                         |
| ----------- | ------------------------------------------------------------ |
| 文件操作    | stat   find   file   lineinfile   blockinfile   template   replace |
| 包管理      | apt   gem   npm   pip   yum   package   easy_install   rpm_key |
| 传输        | fetch   copy   unarchive   get_url                           |
| 用户组      | user   group                                                 |
| 文件包含    | import_tasks   include_tasks   include_vars                  |
| mysql数据库 | mysql_db   mysql_replication   mysql_user                    |
| 服务        | service   systemd   supervisorctl                            |
| 检查        | uri   wait_for                                               |
| 其他        | debug   fail   selinux   set_fact   sysctl   authorized_key  |


## 7.熟悉ansible命令

本文以 **Ansible** 版本 `2.9.6`为准

### ansible

`ansible`命令是 **Ansible** 的核心部分，其主要用于执行ad-hoc命令，即单条命令。默认后面需要跟主机和选项部分，默认不指定模块时，使用的是command模块。

```bash
# ansible --help
usage: ansible [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD]
               [--become-user BECOME_USER] [-K] [-i INVENTORY] [--list-hosts]
               [-l SUBSET] [-P POLL_INTERVAL] [-B SECONDS] [-o] [-t TREE] [-k]
               [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER]
               [-c CONNECTION] [-T TIMEOUT]
               [--ssh-common-args SSH_COMMON_ARGS]
               [--sftp-extra-args SFTP_EXTRA_ARGS]
               [--scp-extra-args SCP_EXTRA_ARGS]
               [--ssh-extra-args SSH_EXTRA_ARGS] [-C] [--syntax-check] [-D]
               [-e EXTRA_VARS] [--vault-id VAULT_IDS]
               [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
               [-f FORKS] [-M MODULE_PATH] [--playbook-dir BASEDIR]
               [-a MODULE_ARGS] [-m MODULE_NAME]
               pattern
```

**位置参数**

| 参数    | 说明     |
| ------- | -------- |
| pattern | 主机匹配 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --ask-vault-pass                                             | 提示输入vault 密码。                                         |
| --list-hosts                                                 | 输出匹配主机的列表。                                         |
| --playbook-dir BASEDIR                                       | 指定playbook目录，为`role`,`group_vars/etc`指定相对路径      |
| --syntax-check                                               | 对playbook进行语法检查，且不执行playbook。                   |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --version                                                    | 显示程序版本信息                                             |
| -B SECONDS, --background SECONDS                             | 异步运行时，多长时间超时。                                   |
| -C, --check                                                  | 只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化。 |
| -D, --diff                                                   | 当更改文件和模板时，显示这些文件得差异，比--check效果好。    |
| -M MODULE_PATH, --module-path MODULE_PATH                    | 要执行的模块的路径，默认路径`~/.ansible/plugins/modules:/usr/share/ansible/plu<br/>                        gins/modules)` |
| -P POLL_INTERVAL, --poll POLL_INTERVAL                       | 设置轮询间隔，默认15秒                                       |
| -a MODULE_ARGS, --args MODULE_ARGS                           | 指定模块参数                                                 |
| -e EXTRA_VARS, --extra-vars EXTRA_VARS                       | 添加附加变量，比如key=value，yaml，json格式。使用`@`指定文件 |
| -f FORKS, --forks FORKS                                      | 指定定要使用的并行进程数，默认为5个。                        |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -l SUBSET, --limit SUBSET                                    | 进一步限制所选主机/组模式，只执行`-l`后的主机和组。          |
| -m MODULE_NAME, --module-name MODULE_NAME                    | 要执行的模块，默认为command。                                |
| -o, --one-line                                               | 压缩输出，尝试将所有内容都在一行上输出。                     |
| -t TREE, --tree                                              | 指定tree的输出目录                                           |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |

**特权升级选项**

| 参数                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| --become-method=BECOME_METHOD | 权限升级方法使用 ，默认为sudo，有效选择：[sudo \| su \| pbrun \| pfexec   \| runas \|    doas \| dzdo] |
| --become-user=BECOME_USER     | 使用哪个用户运行，默认为root                                 |
| -K, --ask-become-pass         | 提供权限提升密码                                             |
| -b, --become                  | 运行权限提升                                                 |

**连接选项**

| 参数                                                         | 说明                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| --private-key=PRIVATE_KEY_FILE,   --key-file=PRIVATE_KEY_FILE | 私钥路径，使用这个文件来验证连接                            |
| --scp-extra-args SCP_EXTRA_ARGS                              | 指定额外的参数传递给`scp` ，例如`-l`                        |
| --sftp-extra-args SFTP_EXTRA_ARGS                            | 指定额外的参数传递给`sftp` ，例如`-f`                       |
| --ssh-common-args SSH_COMMON_ARGS                            | 指定要传递给sftp / scp / ssh的通用参数（例如 ProxyCommand） |
| --ssh-extra-args SSH_EXTRA_ARGS                              | 指定额外的参数传递给`ssh` ，例如`-R`                        |
| -T TIMEOUT,   --timeout=TIMEOUT                              | 指定默认超时时间，默认是10S                                 |
| -c CONNECTION,   --connection=CONNECTION                     | 指定连接类型，默认smart                                     |
| -k, --ask-pass                                               | 要求用户输入请求连接密码                                    |
| -u REMOTE_USER,   --user=REMOTE_USER                         | 指定连接用户                                                |

**示例**：

```bash
ansible all -m ping

ansible 192.168.77.* -m ping

ansible all -m command -a ifconfig

ansible all -m shell -a "ifconfig eth0 |grep 'inet addr' "

ansible -i "192.168.77.129,192.168.77.130" 192.168.77.129  -m ping

ansible -i hosts  all --list-host

ansible -i hosts -l 192.168.77.130 all -m ping -t /tmp -vvvv

ansible web -l @retry_hosts.txt --list-hosts

ansible all -i 192.168.77.133, -m ping -k
```



### ansible-console

交互式命令执行界面

```bash
# ansible-console --help
usage: ansible-console [-h] [--version] [-v] [-b]
                       [--become-method BECOME_METHOD]
                       [--become-user BECOME_USER] [-K] [-i INVENTORY]
                       [--list-hosts] [-l SUBSET] [-k]
                       [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER]
                       [-c CONNECTION] [-T TIMEOUT]
                       [--ssh-common-args SSH_COMMON_ARGS]
                       [--sftp-extra-args SFTP_EXTRA_ARGS]
                       [--scp-extra-args SCP_EXTRA_ARGS]
                       [--ssh-extra-args SSH_EXTRA_ARGS] [-C] [--syntax-check]
                       [-D] [--vault-id VAULT_IDS]
                       [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
                       [-f FORKS] [-M MODULE_PATH] [--playbook-dir BASEDIR]
                       [--step]
                       [pattern]
```

**位置参数**

| 参数    | 说明     |
| ------- | -------- |
| pattern | 主机匹配 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --ask-vault-pass                                             | 提示输入vault 密码。                                         |
| --list-hosts                                                 | 输出匹配主机的列表。                                         |
| --playbook-dir BASEDIR                                       | 指定playbook目录，为`role`,`group_vars/etc`指定相对路径      |
| --step                                                       | 一步一步的运行，每个任务都会循环是否执行                     |
| --syntax-check                                               | 对playbook进行语法检查，且不执行playbook。                   |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --version                                                    | 显示程序版本信息                                             |
| -C, --check                                                  | 只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化。 |
| -D, --diff                                                   | 当更改文件和模板时，显示这些文件得差异，比--check效果好。    |
| -M MODULE_PATH, --module-path MODULE_PATH                    | 要执行的模块的路径，默认路径`~/.ansible/plugins/modules:/usr/share/ansible/plu<br/>                        gins/modules)` |
| -f FORKS, --forks FORKS                                      | 指定定要使用的并行进程数，默认为5个。                        |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -l SUBSET, --limit SUBSET                                    | 进一步限制所选主机/组模式，只执行`-l`后的主机和组。          |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |

**特权升级选项**

| 参数                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| --become-method=BECOME_METHOD | 权限升级方法使用 ，默认为sudo，有效选择：[sudo \| su \| pbrun \| pfexec   \| runas \|    doas \| dzdo] |
| --become-user=BECOME_USER     | 使用哪个用户运行，默认为root                                 |
| -K, --ask-become-pass         | 提供权限提升密码                                             |
| -b, --become                  | 运行权限提升                                                 |

 **连接选项**

| 参数                                                         | 说明                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| --private-key=PRIVATE_KEY_FILE,   --key-file=PRIVATE_KEY_FILE | 私钥路径，使用这个文件来验证连接                            |
| --scp-extra-args SCP_EXTRA_ARGS                              | 指定额外的参数传递给`scp` ，例如`-l`                        |
| --sftp-extra-args SFTP_EXTRA_ARGS                            | 指定额外的参数传递给`sftp` ，例如`-f`                       |
| --ssh-common-args SSH_COMMON_ARGS                            | 指定要传递给sftp / scp / ssh的通用参数（例如 ProxyCommand） |
| --ssh-extra-args SSH_EXTRA_ARGS                              | 指定额外的参数传递给`ssh` ，例如`-R`                        |
| -T TIMEOUT,   --timeout=TIMEOUT                              | 指定默认超时时间，默认是10S                                 |
| -c CONNECTION,   --connection=CONNECTION                     | 指定连接类型，默认smart                                     |
| -k, --ask-pass                                               | 要求用户输入请求连接密码                                    |
| -u REMOTE_USER,   --user=REMOTE_USER                         | 指定连接用户                                                |

 

**示例：**

```bash
ansible-console all -i 192.168.77.133, -m ping -k

root@all (1)[f:5]$ ping

192.168.77.133 | SUCCESS => {
    "changed": false, 
    "ping": "pong"

}
```

 

### ansible-doc

该指令用于查看模块信息，常用参数有两个-l 和 -s 

```bash
# ansible-doc --help
usage: ansible-doc [-h] [--version] [-v] [-M MODULE_PATH]
                   [--playbook-dir BASEDIR]
                   [-t {become,cache,callback,cliconf,connection,httpapi,inventory,lookup,netconf,shell,module,strategy,vars}]
                   [-j] [-F | -l | -s | --metadata-dump]
                   [plugin [plugin ...]]

```

 **位置参数**

| 参数   | 说明 |
| ------ | ---- |
| plugin | 插件 |

**选项参数**

| 参数                                                         | 说明                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| --metadata-dump                                              | 获取所有插件的metadata json数据                         |
| --playbook-dir BASEDIR                                       | 指定playbook目录，为`role`,`group_vars/etc`指定相对路径 |
| --version                                                    | 显示程序版本信息                                        |
| -F, --list_files                                             | 显示插件名称及其源文件，不显示摘要                      |
| -h, --help                                                   | 显示帮助文件                                            |
| -j, --json                                                   | 使用json格式输出                                        |
| -l, --list                                                   | 列出可用的插件                                          |
| -s, --snippet                                                | 显示指定插件的`playbook`摘要                            |
| -t {become,cache,callback,<br />cliconf,connection,httpapi,<br />inventory,lookup,netconf,<br />shell,module,strategy,vars},<br /> --type {become,cache,callback,<br />cliconf,connection,httpapi,<br />inventory,lookup,netconf,<br />shell,module,strategy,vars} | 指定插件类型，默认`module`                              |

 

**示例：**

```bash
ansible-doc -l
ansible-doc yum
ansible-doc yum -s
ansible-doc -t cache -l
ansible-doc -t become -l
```

### ansible-galaxy

ansible-galaxy 指令用于方便的从https://galaxy.ansible.com/ 站点下载第三方扩展模块，我们可以形象的理解其类似于centos下的yum、python下的pip或easy_install

```bash
# ansible-galaxy --help
usage: ansible-galaxy [-h] [--version] [-v] TYPE ...
```

 **位置参数**

| 参数       | 说明                      |
| ---------- | ------------------------- |
| collection | 管理Ansible Galaxy。      |
| role       | 管理Ansible Galaxy role。 |

 **选项参数**

| 参数          | 说明                                            |
| ------------- | ----------------------------------------------- |
| --version     | 显示程序版本号                                  |
| -h, --help    | 显示此帮助信息                                  |
| -v, --verbose | 详细模式（-vvv表示更多，-vvvv表示启用连接调试） |

 

**示例：**

```bash
ansible-galaxy search tomcat  # 搜索角色
ansible-galaxy install aeriscloud.docker #下载角色

ansible-galaxy list ragingbal.tomcat  

ansible-galaxy info ragingbal.tomcat

ansible-galaxy init abc  # 创建角色模板
# 安装的role在 /root/.ansible/roles/
```

 

###  ansible-playbook

对于需反复执行的、较为复杂的任务，我们可以通过定义 Playbook 来搞定。Playbook 是 Ansible 真正强大的地方，它允许使用变量、条件、循环、以及模板，也能通过角色 及包含指令来重用既有内容。

```bash
# ansible-playbook --help
usage: ansible-playbook [-h] [--version] [-v] [-k]
                        [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER]
                        [-c CONNECTION] [-T TIMEOUT]
                        [--ssh-common-args SSH_COMMON_ARGS]
                        [--sftp-extra-args SFTP_EXTRA_ARGS]
                        [--scp-extra-args SCP_EXTRA_ARGS]
                        [--ssh-extra-args SSH_EXTRA_ARGS] [--force-handlers]
                        [--flush-cache] [-b] [--become-method BECOME_METHOD]
                        [--become-user BECOME_USER] [-K] [-t TAGS]
                        [--skip-tags SKIP_TAGS] [-C] [--syntax-check] [-D]
                        [-i INVENTORY] [--list-hosts] [-l SUBSET]
                        [-e EXTRA_VARS] [--vault-id VAULT_IDS]
                        [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
                        [-f FORKS] [-M MODULE_PATH] [--list-tasks]
                        [--list-tags] [--step] [--start-at-task START_AT_TASK]
                        playbook [playbook ...]
```

 

**位置参数**

| 参数     | 说明         |
| -------- | ------------ |
| playbook | playbook文件 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --ask-vault-pass                                             | 提示输入vault 密码。                                         |
| --flush-cache                                                | 清除fact缓存                                                 |
| --force-handlers                                             | 如果任务失败，也要运行handlers                               |
| --list-hosts                                                 | 输出匹配主机的列表。                                         |
| --list-tags                                                  | 列出所有可用的标签                                           |
| --list-tasks                                                 | 列出将要执行的所有任务                                       |
| --skip-tags=SKIP_TAGS                                        | 跳过运行标记此标签的任务                                     |
| -start-at-task=START_AT_TASK                                 | 在此任务处开始运行                                           |
| --step                                                       | 一步一步的执行：在运行之前确认每个任务                       |
| --syntax-check                                               | 对playbook进行语法检查，且不执行playbook。                   |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --version                                                    | 显示程序版本信息                                             |
| -C, --check                                                  | 只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化。 |
| -D, --diff                                                   | 当更改文件和模板时，显示这些文件得差异，比--check效果好。    |
| -M MODULE_PATH, --module-path MODULE_PATH                    | 要执行的模块的路径，默认路径`~/.ansible/plugins/modules:/usr/share/ansible/plu<br/>                        gins/modules)` |
| -e EXTRA_VARS, --extra-vars EXTRA_VARS                       | 添加附加变量，比如key=value，yaml，json格式。使用`@`指定文件 |
| -f FORKS, --forks FORKS                                      | 指定定要使用的并行进程数，默认为5个。                        |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -l SUBSET, --limit SUBSET                                    | 进一步限制所选主机/组模式，只执行`-l`后的主机和组。          |
| -t TAGS, --tags TAGS                                         | 运行指定的带有tags任务                                       |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |

**特权升级选项**

| 参数                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| --become-method=BECOME_METHOD | 权限升级方法使用 ，默认为sudo，有效选择：[sudo \| su \| pbrun \| pfexec   \| runas \|    doas \| dzdo] |
| --become-user=BECOME_USER     | 使用哪个用户运行，默认为root                                 |
| -K, --ask-become-pass         | 提供权限提升密码                                             |
| -b, --become                  | 运行权限提升                                                 |

 **连接选项**

| 参数                                                         | 说明                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| --private-key=PRIVATE_KEY_FILE,   --key-file=PRIVATE_KEY_FILE | 私钥路径，使用这个文件来验证连接                            |
| --scp-extra-args SCP_EXTRA_ARGS                              | 指定额外的参数传递给`scp` ，例如`-l`                        |
| --sftp-extra-args SFTP_EXTRA_ARGS                            | 指定额外的参数传递给`sftp` ，例如`-f`                       |
| --ssh-common-args SSH_COMMON_ARGS                            | 指定要传递给sftp / scp / ssh的通用参数（例如 ProxyCommand） |
| --ssh-extra-args SSH_EXTRA_ARGS                              | 指定额外的参数传递给`ssh` ，例如`-R`                        |
| -T TIMEOUT,   --timeout=TIMEOUT                              | 指定默认超时时间，默认是10S                                 |
| -c CONNECTION,   --connection=CONNECTION                     | 指定连接类型，默认smart                                     |
| -k, --ask-pass                                               | 要求用户输入请求连接密码                                    |
| -u REMOTE_USER,   --user=REMOTE_USER                         | 指定连接用户                                                |

**示例：**

```bash
ansible-playbook -i hosts ssh-addkey.yml   # 指定主机清单文件

ansible-playbook -i hosts ssh-addkey.yml  --list-tags   # 列出tags

ansible-playbook -i hosts ssh-addkey.yml  -t install  # 执行install标签的任务

ansible-playbook -i hosts ssh-addkey.yml  -t install -e a=1  # 指定变量
```



### ansible-pull 

pull模式在被配置的机器上运行，速度很快。在这种模式下，你需要提供一个git仓库来供Ansible下载来配置你的机器。

```bash
# ansible-pull --help
usage: ansible-pull [-h] [--version] [-v] [-k]
                    [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER]
                    [-c CONNECTION] [-T TIMEOUT]
                    [--ssh-common-args SSH_COMMON_ARGS]
                    [--sftp-extra-args SFTP_EXTRA_ARGS]
                    [--scp-extra-args SCP_EXTRA_ARGS]
                    [--ssh-extra-args SSH_EXTRA_ARGS] [--vault-id VAULT_IDS]
                    [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
                    [-e EXTRA_VARS] [-t TAGS] [--skip-tags SKIP_TAGS]
                    [-i INVENTORY] [--list-hosts] [-l SUBSET] [-M MODULE_PATH]
                    [-K] [--purge] [-o] [-s SLEEP] [-f] [-d DEST] [-U URL]
                    [--full] [-C CHECKOUT] [--accept-host-key]
                    [-m MODULE_NAME] [--verify-commit] [--clean]
                    [--track-subs] [--check] [--diff]
                    [playbook.yml [playbook.yml ...]]
```

**位置参数**

| 参数     | 说明         |
| -------- | ------------ |
| playbook | playbook文件 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --accept-host-key                                            | 指定仓库的主机秘钥                                           |
| --ask-vault-pass                                             | 提示输入vault 密码。                                         |
| --check                                                      | 只做检查，不做更改                                           |
| --clean                                                      | 工作存储库中的已修改文件将被删除                             |
| --diff                                                       | 更改（小的）文件和模板时，显示这些文件中的差异               |
| --full                                                       | 完整克隆                                                     |
| --list-hosts                                                 | 输出匹配主机列表                                             |
| --purge                                                      | 运行后清除                                                   |
| --skip-tags SKIP_TAGS                                        | 跳过运行标记此标签的任务                                     |
| --track-subs                                                 | 模块将跟踪最新的变化。   这相当于指定--remote标志来git子模块更新 |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --verify-commit                                              | 验证已检出提交的GPG签名，如果失败则中止运行剧本。            |
| --version                                                    | 显示程序版本信息                                             |
| -C CHECKOUT,   --checkout=CHECKOUT                           | 指定克隆的分支                                               |
| -M MODULE_PATH, --module-path MODULE_PATH                    | 要执行的模块的路径，默认路径`~/.ansible/plugins/modules:/usr/share/ansible/plu<br/>                        gins/modules)` |
| -U URL, --url URL                                            | playbook仓库的地址                                           |
| -d DEST, --directory DEST                                    | 指定检出目录                                                 |
| -e EXTRA_VARS, --extra-vars EXTRA_VARS                       | 添加附加变量，比如key=value，yaml，json格式。使用`@`指定文件 |
| -f FORKS, --forks FORKS                                      | 指定定要使用的并行进程数，默认为5个。                        |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -l SUBSET, --limit SUBSET                                    | 进一步限制所选主机/组模式，只执行`-l`后的主机和组。          |
| -m MODULE_NAME, --module-name MODULE_NAME                    | 仓库模块名称，可选值('git', 'subversion', 'hg', 'bzr')默认为git。 |
| -o, --only-if-changed                                        | 当存储库已更新时才运行剧本                                   |
| -s SLEEP, --sleep SLEEP                                      | 指定睡眠时间                                                 |
| -t TAGS, --tags TAGS                                         | 运行指定的带有tags任务                                       |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |

**特权升级选项**

| 参数                  | 说明             |
| --------------------- | ---------------- |
| -K, --ask-become-pass | 提供权限提升密码 |

 **连接选项**

| 参数                                                         | 说明                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| --private-key=PRIVATE_KEY_FILE,   --key-file=PRIVATE_KEY_FILE | 私钥路径，使用这个文件来验证连接                            |
| --scp-extra-args SCP_EXTRA_ARGS                              | 指定额外的参数传递给`scp` ，例如`-l`                        |
| --sftp-extra-args SFTP_EXTRA_ARGS                            | 指定额外的参数传递给`sftp` ，例如`-f`                       |
| --ssh-common-args SSH_COMMON_ARGS                            | 指定要传递给sftp / scp / ssh的通用参数（例如 ProxyCommand） |
| --ssh-extra-args SSH_EXTRA_ARGS                              | 指定额外的参数传递给`ssh` ，例如`-R`                        |
| -T TIMEOUT,   --timeout=TIMEOUT                              | 指定默认超时时间，默认是10S                                 |
| -c CONNECTION,   --connection=CONNECTION                     | 指定连接类型，默认smart                                     |
| -K, --ask-become-pass                                        | 要求用户输入请求连接密码                                    |
| -u REMOTE_USER,   --user=REMOTE_USER                         | 指定连接用户                                                |

**示例：**

```bash
ansible-pull -o -C master -d /tmp/pull -i /tmp/pull/hosts -U https://github.com/lework/Ansible-Pull-Example.git
```



### ansible-config

编辑管理ansible配置

```bash
# ansible-config --help
usage: ansible-config [-h] [--version] [-v] {list,dump,view} ...
```

**位置参数**

| 参数 | 说明               |
| ---- | ------------------ |
| list | 显示所有的参数配置 |
| dump | dump配置           |
| view | 查看配置文件       |

 **选项参数**

| 参数          | 说明                                            |
| ------------- | ----------------------------------------------- |
| --version     | 显示程序版本号                                  |
| -h, --help    | 显示此帮助信息                                  |
| -v, --verbose | 详细模式（-vvv表示更多，-vvvv表示启用连接调试） |

 

**示例：**

```bash
ansible-config view

ansible-config  list

ansible-config  dump
```





 

### ansible-inventory

查看主机清单信息

```bash
# ansible-inventory --help 
usage: ansible-inventory [-h] [--version] [-v] [-i INVENTORY]
                         [--vault-id VAULT_IDS]
                         [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES]
                         [--playbook-dir BASEDIR] [--list] [--host HOST]
                         [--graph] [-y] [--toml] [--vars] [--export]
                         [--output OUTPUT_FILE]
                         [host|group]
```

 **位置参数**

| 参数       | 说明        |
| ---------- | ----------- |
| host/group | 主机/主机组 |

**选项参数**

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| --accept-host-key                                            | 指定仓库的主机秘钥                                           |
| --export                                                     | 导出信息，与--list或--graph一起使用                          |
| --output OUTPUT_FILE                                         | 导出信息到文件，与--list或--graph一起使用                    |
| --playbook-dir BASEDIR                                       | 指定playbook目录，为`role`,`group_vars/etc`指定相对路径      |
| --toml                                                       | 使用toml格式输出,默认是json格式                              |
| --vars                                                       | 输出变量信息，与--list或--graph一起使用                      |
| --vault-id=VAULT_IDS                                         | 标识使用的vault id                                           |
| --vault-password-file=VAULT_PASSWORD_FILE                    | 指定vault密码文件                                            |
| --version                                                    | 显示程序版本信息                                             |
| -h, --help                                                   | 显示此帮助信息。                                             |
| -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY | 指定主机清单文件或逗号分隔的主机，默认为/etc/ansible/hosts。 |
| -v, --verbose                                                | 输出执行的详细信息，使用-vvv获得更多，-vvvv 启用连接调试     |
| -y, --yaml                                                   | 使用yaml格式输出,默认是json格式                              |

**动作选项**

| 参数        | 说明                             |
| ----------- | -------------------------------- |
| --graph     | 创建主机清单图                   |
| --host HOST | 输出主机清单信息                 |
| --list      | 以json的格式输出所有主机清单信息 |



**示例：**

```bash
ansible-inventory --export --graph

ansible-inventory -i /etc/ansible/hosts --export --list

ansible-inventory --host=192.168.1.100

ansible-inventory --vars --list
 ```



### ansible-vault

ansible-vault主要应用于配置文件中含有敏感信息，又不希望他能被人看到，vault可以帮你加密/解密这个配置文件。这种playbook文件在执行时，需要加上 `--ask-vault-pass`参数，同样需要输入密码后才能正常执行。

```bash
# ansible-vault --help
usage: ansible-vault [-h] [--version] [-v]
                     {create,decrypt,edit,view,encrypt,encrypt_string,rekey}
                     ...
```

**位置参数**

| 参数           | 说明           |
| -------------- | -------------- |
| create         | 创建加密文件   |
| decrypt        | 解密文件       |
| edit           | 编辑加密文件   |
| view           | 查看加密文件   |
| encrypt        | 加密文件       |
| encrypt_string | 输出加密字符串 |
| rekey          | 重新加密文件   |

**选项参数**

| 参数          | 说明                                            |
| ------------- | ----------------------------------------------- |
| --version     | 显示程序版本号                                  |
| -h, --help    | 显示此帮助信息                                  |
| -v, --verbose | 详细模式（-vvv表示更多，-vvvv表示启用连接调试） |

**示例：**

```bash
ansible-vault create # /tmp/123 创建加密文件

ansible-vault view  # /tmp/123 查看加密文件

ansible-vault encrypt  # /tmp/abc 加密文件

ansible-vault decrypt  # /tmp/abc 解密文件

ansible-vault edit  # /tmp/abc 编辑加密文件

ansible-vault encrypt_string '123'  # 输出加密字符串
```


## 8.使用 Playbook


**Playbook**（剧本） 是 **Ansible** 指令的集合，其利用 YAML 语言编写，自上而下按顺序一次执行。

如果Ansible模块是你的车间的工具，那playbook则是你的指导手册，你的主机清单(inventory)是你的原材料。

play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲所谓task无非是调用ansible的一个module。将多个play组织在一个playbook中即可以让它们联同起来按事先编排的机制同唱一台大戏。其主要有以下四部分构成:



- Target section：   定义将要执行 playbook 的远程主机组

- Variable section： 定义 playbook 运行时需要使用的变量

- Task section：     定义将要在远程主机上执行的任务列表

- Handler section：  定义 task 执行完成以后需要调用的任务

 

### Playbook 示例

> centos7 环境

开始书写我们第一个playbook

**第一步：** 定义我们得主机清单

```ini
[web]
192.168.77.129 ansible_ssh_pass=123456
192.168.77.130 ansible_ssh_pass=123456
```

>  注：这里如果做了ssh免密码登陆，可以去掉ansible_ssh_pass

**第二步：** 明确playbook做哪些任务

web组的主机完成下列任务

1. 远程执行用户为root
2. 安装httpd
3. apache配置文件实现自定义http端口和客户端连接数
4. 在配置文件变更的时候，重启httpd
5. 启动httpd，并设置其开机自启动

**第三步：** 书写playbook

> playbook 使用 YAML 标记语言 (see [YAML Syntax](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html#yaml-syntax))  来描述任务的编排

```yaml
---
- hosts: web                 # Target section
  remote_user: root
  vars:                      # Variable section
    http_port: 80
    max_clients: 200
  tasks:                     # Task section
  - name: ensure apache is at the latest version
    yum:
      name: httpd
      state: latest
  - name: write the apache config file
    template:
      src: httpd.j2
      dest: /etc/httpd/conf/httpd.conf
    notify:
    - restart apache
  - name: ensure apache is running
    service:
      name: httpd
      state: started
  handlers:                 # Handler section
    - name: restart apache
      service:
        name: httpd
        state: restarted
```

> `remote_user` `vars` 等等这些都是ansible的playbook对象的关键字, 全部可用的关键字列表见 [Ansible 关键字](/basic/Reference/Keywords/)


当前目录下的 `httpd.j2` 文件内容

```jinja2
ServerRoot "/etc/httpd"
Listen {{ http_port }}

Include conf.modules.d/*.conf

User apache
Group apache

ServerAdmin root@localhost

<Directory />
    AllowOverride none
    Require all denied
</Directory>

DocumentRoot "/var/www/html"

<Directory "/var/www">
    AllowOverride None
    Require all granted
</Directory>

<Directory "/var/www/html">
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
</Directory>

<IfModule dir_module>
    DirectoryIndex index.html
</IfModule>

<Files ".ht*">
    Require all denied
</Files>

ErrorLog "logs/error_log"
LogLevel warn

<IfModule log_config_module>
    LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
    LogFormat "%h %l %u %t \"%r\" %>s %b" common
    <IfModule logio_module>
      LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" %I %O" combinedio
    </IfModule>
    CustomLog "logs/access_log" combined
</IfModule>

<IfModule alias_module>
    ScriptAlias /cgi-bin/ "/var/www/cgi-bin/"
</IfModule>

<Directory "/var/www/cgi-bin">
    AllowOverride None
    Options None
    Require all granted
</Directory>

<IfModule mime_module>
    TypesConfig /etc/mime.types
    AddType application/x-compress .Z
    AddType application/x-gzip .gz .tgz
    AddType text/html .shtml
    AddOutputFilter INCLUDES .shtml
</IfModule>

AddDefaultCharset UTF-8
<IfModule mime_magic_module>
    MIMEMagicFile conf/magic
</IfModule>

<IfModule mpm_prefork_module>
    ServerLimit        256
    StartServers         5
    MinSpareServers      5
    MaxSpareServers     10
    MaxClients          {{ max_clients }}
    MaxRequestsPerChild  0
</IfModule>

EnableSendfile on
IncludeOptional conf.d/*.conf
```

题外：一个playbook文件可以拥有多个play, 比如我们在加一个`databases`组的数据库安装操作

```yaml
---
- hosts: webservers
  remote_user: root

  tasks:
  - name: ensure apache is at the latest version
    yum:
      name: httpd
      state: latest
  - name: write the apache config file
    template:
      src: httpd.j2
      dest: /etc/httpd/conf/httpd.conf

- hosts: databases
  remote_user: root

  tasks:
  - name: ensure postgresql is at the latest version
    yum:
      name: postgresql
      state: latest
  - name: ensure that postgresql is started
    service:
      name: postgresql
      state: started
```



**第四步：** 运行playbok

```bash
ansible-playbook -i hosts test.yml
```

!!! note "注：还有一种运行方式"

    在yml文件头部加入
    
    ```
    #!/bin/env ansible-playbook
    ```
    
    在给yml文件执行权限
    
    ```bash
    chmod +x t.yml
    ```
    
    运行playbook
    
    ```bash
    ./t.yml
    ```



### 主机和用户

对于每个playbok的play,都会有一个主机和远程用户来确定哪些主机为目标

```yaml
---
- hosts: webservers
  remote_user: root
```

`hosts` 定义了主机清单的`patterns` 来确定哪些主机为执行目标。`remote_user`指定执行目标主机的执行用户。

`remote_user` 也可以为每个`task`设置

```yaml
---
- hosts: webservers
  remote_user: root
  tasks:
    - name: test connection
      ping:
      remote_user: yourname
```

如果你想要为执行提升权限，可以设置`become`提权参数

```yaml
---
- hosts: webservers
  remote_user: yourname
  become: yes
```

当然，你也可以为每个`task`设置

```yaml
---
- hosts: webservers
  remote_user: yourname
  tasks:
    - service:
        name: nginx
        state: started
      become: yes
      become_user: root
      become_method: sudo
```

become 相关参数

- `become`是否开启提权 

- `become_method` 指定提升方式

- `become_user` 指定提升用户
- `become_flags`  提权命令的参数



#### 主机的执行顺序

```yaml
---
- name: exec order
  hosts: all
  order: sorted
  gather_facts: False
  tasks:
    - debug:
        var: inventory_hostname
```

> `play` 也可以加上`name`来标识名称, `gather_facts` 定义不获取主机fact数据

 `order` 参数可以控制主机的 **运行顺序**， 默认是`inventory` 按主机清单的从上到下顺序依次执行，其他的可选值如下表：

| 可选值            | 说明                                     |
| ----------------- | ---------------------------------------- |
| inventory         | 默认值，按主机清单的从上到下顺序依次执行 |
| reverse_inventory | 按主机清单的从下到上顺序依次执行         |
| sorted            | 以主机名称按字母顺序排序                 |
| reverse_sorted    | 以主机名称按字母顺序反序排序             |
| shuffle           | 随机排序                                 |

 

### 任务列表

每个play包含一组任务列表， 任务之间是按照从上往下顺序执行的，执行完上一个任务再去执行下一个任务。

运行从上到下运行的剧本时，任务失败的主机将从整个剧本的轮换中删除。 如果失败，只需更正剧本文件并重新运行即可。

每个任务(task)的目标是执行带有特定参数的模块。 变量可以在模块的参数中使用。

模块应该是幂等的，也就是说，在一个序列中多次运行一个模块应该与只运行它一次具有相同的效果。实现幂等性的一种方法是让一个模块检查它所期望的最终状态是否已经实现，如果已经实现，则退出而不执行任何操作。如果playbook使用的所有模块都是幂等的，那么playbook本身可能也是幂等的，所以重新运行playbook应该是安全的。

每个任务都应该有一个名称(names)，它包含在运行剧本的输出中。这是人类可读的输出，因此提供每个任务步骤的良好描述非常有用。但是，如果没有提供名称，那么将使用提供给 ‘action’ 的字符串作为输出。



任务示例

```yaml
tasks:
  - name: make sure apache is running
    service:
      name: httpd
      state: started
```

也可以使用`key=value`的形式表示模块参数

```yaml
tasks:
  - name: make sure apache is running
    service: name=httpd state=started
```

`command`和`shell`模块只有一组参数，可以直接写在模块后面

```yaml
tasks:
  - name: enable selinux
    command: /sbin/setenforce 1
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand || /bin/true
```

如果想忽略模块的执行错误，可以为模块添加`ignore_errors`

```yaml
tasks:
  - name: run this command and ignore the result
    shell: /usr/bin/somecommand
    ignore_errors: True
```

如果行太长了，可以换行缩进表示

```yaml
tasks:
  - name: Copy ansible inventory file to client
    copy: src=/etc/ansible/hosts dest=/etc/ansible/hosts
            owner=root group=root mode=0644
```

也可以使用变量`vhost`

```yaml
tasks:
  - name: create a virtual host file for {{ vhost }}
    template:
      src: somefile.j2
      dest: /etc/httpd/conf.d/{{ vhost }}
```

task还有一种古老的标记方法，不建议使用这类形式来标记任务。

```yaml
action: template src=templates/foo.j2 dest=/etc/foo.conf
```

### 事件处理Handlers

这些`notify`动作在play中每个任务块结束时触发，并且即使由多个不同的任务通知，也只会触发一次。

```yaml
- name: template configuration file
  template:
    src: template.j2
    dest: /etc/foo.conf
  notify:
     - restart memcached
     - restart apache
```

>  `notify` 定义的时handlers里的任务名称列表

Handlers 也是任务列表，与常规任务没有什么不同，它们由全局惟一的名称引用，并由`notify`动作通知。如果没有通知处理程序，它将不会运行。不管有多少任务通知一个处理程序，它都将只运行一次，即在一个特定`play`中的所有任务完成之后。

```yaml
handlers:
  - name: restart memcached
    service:
      name: memcached
      state: restarted
  - name: restart apache
    service:
      name: apache
      state: restarted
```

Handlers  里的任务名称 **不能使用** 变量

在 ansible 2.2之后，handlers 支持`listen` 来实现监听一个通知程序来实现执行多个通知任务。

```yaml
handlers:
    - name: restart memcached
      service:
        name: memcached
        state: restarted
      listen: "restart web services"
    - name: restart apache
      service:
        name: apache
        state: restarted
      listen: "restart web services"

tasks:
    - name: restart everything
      command: echo "this task will restart the web services"
      notify: "restart web services"
```



### 执行 Playbook

使用`ansible-playbook`命令执行`playbook`

```bash
ansible-playbook playbook.yml -f 10
```

在执行playbook前，可以做些检查

1. 检查palybook语法

   ```bash
   ansible-playbook -i hosts httpd.yml --syntax-check
   ```

2. 列出要执行的主机

   ```bash
   ansible-playbook -i hosts httpd.yml --list-hosts
   ```

3. 列出要执行得任务

   ```bash
   ansible-playbook -i hosts httpd.yml --list-tasks
   ```



也可以使用`ansible-lint` 命令进行详细检查playbook文件

```bash
ansible-lint httpd.yml
```

 [ansible-lint 默认规则](https://docs.ansible.com/ansible-lint/rules/default_rules.html) 页面描述了每一个错误信息。



#### playbook执行顺序

一个playbook的内容，是按照下列表依次执行的

1. Variable loading  变量加载

2. Fact gatherin      是否获取fact数据

3. The pre_tasks execution  执行pre_tasks任务

4. Handlers notified from the pre_tasks execution  执行pre_tasks任务里的事件通知

5. Roles execution  执行roles角色

6. Tasks execution  执行tasks任务

7. Handlers notified from roles or tasks execution 执行tasks任务里的事件通知

8. The post_tasks execution 执行post_tasks任务

9. Handlers notified from post_tasks execution 执行post_tasks任务里的事件通知
