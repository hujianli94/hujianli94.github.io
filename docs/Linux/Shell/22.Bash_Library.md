# 22.Bash Library

## shell 模板

```sh
#!/bin/env bash
###################################################################
#Script Name    :
#Description    :
#Args           :
#Update Date    :
#Author           : lework
#Email             : lework@yeah.net
###################################################################

set -o errexit          # Exit on most errors (see the manual)
set -o errtrace         # Make sure any error trap is inherited
set -o nounset          # Disallow expansion of unset variables
set -o pipefail         # Use last non-zero exit code in a pipeline


TAG="CMD"
LOG_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/logs"
LOG_FILE="$LOG_PATH/example_`date +"%Y%m%d"`.log"
HIDE_LOG=true

function log() {
    [ ! -d "$LOG_PATH" ] && mkdir -p $LOG_PATH
    if [ $HIDE_LOG ]; then
        echo -e "[`date +"%Y/%m/%d:%H:%M:%S %z"`] [`whoami`] [$TAG] $@" >> $LOG_FILE
    else
        echo "[`date +"%Y/%m/%d:%H:%M:%S %z"`] [`whoami`] [$TAG] $@" | tee -a $LOG_FILE
    fi
}

function script_trap_err() {
    local exit_code=1

    # Disable the error trap handler to prevent potential recursion
    trap - ERR

    # Consider any further errors non-fatal to ensure we run to completion
    set +o errexit
    set +o pipefail

    log "[E] ERROR"

    exit "$exit_code"
}

function script_trap_exit() {
    log "[I] shell exec done."
}

function main() {
    trap script_trap_err ERR
    trap script_trap_exit EXIT

    log "[I] shell start"

}

main "${@}"
```

## Docker

### Docker 容器

```sh
# $1: container name
func_docker_destroy_container(){
    local exist=`docker ps -a |awk '{print $NF}'|grep $1`
    if [[ $exist == "" ]];then
        return 0
    fi
    docker kill $1 >/dev/null 2>&1
    if [[ $(docker version --format '{{.Server.Version}}') = 17.06.0* ]]; then
        # Workaround https://github.com/moby/moby/issues/33948.
        # TODO: remove when 17.06.0 is not relevant anymore
        DOCKER_API_VERSION=v1.29 docker wait "$1" >/dev/null 2>&1 || true
    else
        docker wait "$1" >/dev/null 2>&1 || true
    fi
    docker rm -f -v "$1" >/dev/null 2>&1 || true
}

#$1: imagename:tag
#ret: 0 exist, 1 not exist
func_docker_image_exist(){
    local ret=`docker images $1  |wc |awk '{ print $1 }'`
    if [[ $ret == "2" ]];then
        return 0
    fi
    return 1
}

#$1: imagename:tag
func_docker_destroy_image(){
    func_docker_image_exist $1
    if [[ $? == "0" ]];then
        docker rmi $1
    fi
}
```

### 通过代理下载谷歌 Docker 容器

```sh
#!/bin/env bash
#
# lework
# Download Google container image from proxy point.


######################################################################################################
# environment configuration
######################################################################################################

RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
GREEN_PS3=$'\e[0;32m'
ORANGE_PS3=$'\e[0;33m'
WHITE='\033[0;37m'

proxy=(
  "gcr.azk8s.cn/google_containers"
  "registry.aliyuncs.com/google_containers"
  "gcrxio"
)
images=(
  "k8s.gcr.io/kube-apiserver:"
  "k8s.gcr.io/kube-controller-manager:"
  "k8s.gcr.io/kube-scheduler:"
  "k8s.gcr.io/kube-proxy:"
  "k8s.gcr.io/pause-amd64:3.1"
)

######################################################################################################
# function
######################################################################################################

function check() {
  docker info >/dev/null 2>1
  if [ "$?" != "0" ]; then
    echo -e "${RED}Please check if the docker service is started or installed."
    tput sgr0
    exit 1
  fi
}

function pull() {
  local image_url=$1
  local image=${image_url##*/}

  for proxy_url in ${proxy[*]}; do
    [ "${proxy_url:0-1}" != "/" ] && proxy_url=$proxy_url/
    echo -e "${ORANGE}[Proxy:] $proxy_url"
    echo -e "[Image:] $image_url"
    tput sgr0
    docker pull $proxy_url$image
    if [ "$?" == "0" ]; then
      docker tag $proxy_url$image $image_url
      docker images ${image_url}
      echo -e "${ORANGE}[Delete:] Delete Proxy image."
      tput sgr0
      docker rmi $proxy_url$image
      echo -e "${GREEN}[Result:] Pull image success."
      tput sgr0
      echo
      break
    else
      echo -e "${RED}[Result:] Pull image failed."
      tput sgr0
      echo
    fi
  done
}

function usage {
    echo "Download the Google docker image through the proxy node"
    echo
    echo "Usage: $0 [[[-p proxy] [-i image] | [-t tag] | [-f file]] | [-h]]"
    echo "  -p,--proxy      Specify proxy node url"
    echo "  -i,--image      Specify the image name"
    echo "  -t,--tag        Specify the image tag and download the k8s family bucket."
    echo "  -f,--file       Specify a file path containing the name"
    echo "  -h,--help       View help"
    echo
    echo
    echo "Example:"
    echo "  $0 gcr.io/google_containers/pause-amd64:3.1"
    echo "  $0 \"k8s.gcr.io/kube-{apiserver,controller-manager,proxy,scheduler}:v1.14.3\""
    echo "  $0 -i k8s.gcr.io/pause-amd64:3.1"
    echo "  $0 -p registry.aliyuncs.com/google_containers -i k8s.gcr.io/pause-amd64:3.1"
    echo "  $0 -t v1.14.3"
    echo "  $0 -f ./images.txt"
    echo
    exit 1
}


######################################################################################################
# main
######################################################################################################

check

[ "$#" == "0" ] && usage

while [ "$1" != "" ]; do
    case $1 in
        -p | --proxy )          shift
                                unset proxy
                                proxy=$1
                                ;;
        -i | --image )          shift
                image_url=$1
                                ;;
        -t | --tag )            shift
                tag=$1
                                ;;
        -f | --file )           shift
                file=$1
                                ;;
        -h | --help )           usage
                                exit
                                ;;
        *\.* | *\/*)            image_url=$1
                                ;;
        * )                     usage
                                exit 1
    esac
    shift
done

if echo "$image_url" | grep -q "{"; then
  prefix_image=$(echo $image_url | cut -d '{' -f 1)
  tag_image=$(echo $image_url | cut -d ':' -f 2)
  muti_image=$(echo $image_url | cut -d '{' -f 2 | cut -d '}' -f 1)
  for i in $(echo $muti_image | tr "," "\n")
  do
    pull $prefix_image$i:$tag_image
  done
  exit 0
fi

if [ "$tag" != "" ]; then
  for image in ${images[*]}
  do
    [ "${image:0-1}" == ":" ] && pull $image$tag || pull $image
  done
  exit 0
fi

if [ "$file" != "" ]; then
  while IFS= read line
  do
    pull $line
  done <"$file"
  exit 0
fi

pull $image_url
```

## Openssl

```sh
#$1: keyfile
#$2: cafile
#$3: valid_days
func_self_signed_ca_interactive(){
    local key=$1
    local ca=$2
    local days=$3
    if [ ! -d `dirname $key` ];then
        mkdir -p `dirname $key`
    fi
    if [ ! -d `dirname $ca` ];then
        mkdir -p `dirname $ca`
    fi
    openssl req  -nodes -new -x509 -days ${days} -keyout ${key} -out ${ca}
}

#$1: result config file
#$2: prompt, yes/no
#$3: bits
#$4: keyfile
#$5: email
#$6: commonName
#$7: subjectAltName
func_cert_sign_req_config(){
    local config_file=$1
    local dir=`dirname $config_file`
    if [ ! -d $dir ];then
        mkdir -p $dir
    fi

    local prompt=$2
    local bits=$3
    local keyfile=$4
    local email=$5
    local commonName=$6
    local subjectAltName=$7

    cat > $config_file <<EOF
[ req ]
prompt                 = ${prompt}
default_bits           = ${bits}
default_keyfile        = ${keyfile}
distinguished_name     = req_distinguished_name
attributes             = req_attributes
x509_extensions        = v3_ca

dirstring_type = nobmp

[ req_distinguished_name ]

countryName                    = Country Name (2 letter code)
countryName_default            = CN
countryName_min                = 2
countryName_max                = 2

localityName                   = Locality Name (eg, city)
localityName_default           = BeiJing

organizationalUnitName         = Organizational Unit Name (eg, section)
organizationalUnitName_default = no

commonName                     = Common Name (eg, YOUR name)
commonName_default             = ${commonName}
commonName_max                 = 64

emailAddress                   = Email Address
emailAddress_default           = ${email}
emailAddress_max               = 40

[ req_attributes ]
challengePassword              = A challenge password
challengePassword_min          = 4
challengePassword_max          = 20

[ v3_ca ]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer:always
basicConstraints = CA:true
subjectAltName=${subjectAltName}
EOF
}
```

## k8s

```sh
#Generate config file from k8s style params
#$1: Saved Config file
#$2: command
#$3..:  command params
func_gen_config_k8s(){
    local file=$1
    local cmd=$2
    shift 2
    echo "declare -A CONFIGS" >$file
    $cmd 2>&1 $* |sed '1d' |sed  -E  's/.*(--[^:]*):(.*)/\#\2\n\1/' | sed -E 's/\[(.*)\]/\1/' | sed -E "s/--(.*)=(.*)/CONFIGS\[\1\]=\'--\1=\2\'/" >>$file
}
```

## Time

```sh
func_since_1970(){
    echo `date +"%s"`
}
func_cur_date(){
    echo `date +"%Y%m%d"`
}
func_yesterday_date(){
    echo `date -d yesterday +"%Y%m%d"`
}
func_before_yesterday_date(){
    echo `date -d "-2 day" +"%Y%m%d"`
}
func_cur_time(){
    echo `date +"%Y-%m-%d %H:%M:%S"`
}
func_yesterday_time(){
    echo `date -d yesterday +"%Y-%m-%d %H:%M:%S"`
}
```

## 编码转换

```sh
#convert 16base into 10base
#
func_16to10(){
    echo "ibase=16;obase=A; $1"|bc
}
```

## 日志

### 日志处理

```sh
#!/bin/env bash

LOGFILE=log.log
RETAIN_NUM_LINES=10

function logsetup {
    TMP=$(tail -n $RETAIN_NUM_LINES $LOGFILE 2>/dev/null) && echo "${TMP}" > $LOGFILE
    exec > >(tee -a $LOGFILE)
    exec 2>&1
}

function log {
    echo "[$(date --rfc-3339=seconds)]: $*"
}

logsetup
log hello this is a log
```

```sh
LOG_WARN () {
  local time=$(date +'%F %T')
  printf "\033[1;31m$time WARN %-25s %-25s %-5s %s\n\033[0m" $0 ${FUNCNAME[1]} ${BASH_LINENO[0]} "$*"
  printf "$time WARN %-25s %-25s %-5s %s\n" $0 ${FUNCNAME[1]} ${BASH_LINENO[O]}"$*" > $LOGFILE
}


LOG_ERROR() {
  local time=$(date +'%F %T')
  printf "\033[1;31m$time ERROR %-25s %-25s %-5s %s\n\033[0m" $0 ${FUNCNAME[1} ${BASH_LINENO[0]} "$*"
  printf "$time ERROR %-25s %-25s %-5s %s\n" $0 ${FUNCNAME[1]} ${BASH_LINENO[O]} "$*" > $LOGFILE
}


LOG_INFO(){
  local time=$(date +'%F %T')
  printf "\033[1;32m$time INF0 %-25s %-25s %-5s %ss\n\033[0m" $0 ${FUNCNAME[1} ${BASH_LINENO[0]} "$*"
  printf "$time INFO %-25s %-25s %-5s %s\n" $0 ${FUNCNAME[1]} ${BASH_LINENO[0]} "$*" > $LOGFILE
}

LOG_DEBUG(){
  local time=$(date +'%F %T')
  [ "x"debug == 'xFalse' ] || printf "\033[1m$time INF0 %-25s %-25s %-5s %ss\n\033[0m" $0 ${FUNCNAME[1} ${BASH_LINENO[0]} "$*"
  printf "$time INFO %-25s %-25s %-5s %s\n" $0 ${FUNCNAME[1]} ${BASH_LINENO[0]} "$*" > $LOGFILE
}
```

### 错误日志

```sh
#$1: message
func_fatal(){
    echo  -n -e "\033[31m"
    echo "Fatal Error: $1"
    echo -n -e "\033[0m"
    exit
}
```

```sh
ERROR_INFO="\n\033[31mERROR Summary: \033[0m\n  "
ACCESS_INFO="\n\033[32mACCESS Summary: \033[0m\n  "

TMP_DIR="$(rm -rf /tmp/kainstall* && mktemp -d -t kainstall.XXXXXXXXXX)"
LOG_FILE="${TMP_DIR}/kainstall.log"

function log::error() {
  # 错误日志

  local item
  item="[$(date +'%Y-%m-%dT%H:%M:%S.%N%z')]: \033[31mERROR:   \033[0m$*"
  ERROR_INFO="${ERROR_INFO}${item}\n  "
  echo -e "${item}" | tee -a "$LOG_FILE"
}

function log::info() {
  # 基础日志

  printf "[%s]: \033[32mINFO:    \033[0m%s\n" "$(date +'%Y-%m-%dT%H:%M:%S.%N%z')" "$*" | tee -a "$LOG_FILE"
}

function log::warning() {
  # 警告日志

  printf "[%s]: \033[33mWARNING: \033[0m%s\n" "$(date +'%Y-%m-%dT%H:%M:%S.%N%z')" "$*" | tee -a "$LOG_FILE"
}

function log::access() {
  # 访问信息

  ACCESS_INFO="${ACCESS_INFO}$*\n  "
  printf "[%s]: \033[32mINFO:    \033[0m%s\n" "$(date +'%Y-%m-%dT%H:%M:%S.%N%z')" "$*" | tee -a "$LOG_FILE"
}

function log::exec() {
  # 执行日志

  printf "[%s]: \033[34mEXEC:    \033[0m%s\n" "$(date +'%Y-%m-%dT%H:%M:%S.%N%z')" "$*" >>"$LOG_FILE"
}
```

## 字体颜色

```sh
#Input is the command.
#The command's execute output will use red color
func_red_cmd(){
    echo  -n -e "\033[31m"
    $*
    echo  -n -e "\033[0m"
}

#Input is the command.
#The command's execute output will use yellow color
func_yellow_cmd(){
    echo  -n -e "\033[33m"
    $*
    echo  -n -e "\033[0m"
}

#Input is the command
#If command is error, display the error
func_error_cmd(){
    $*
    local ret=$?
    if [ ! $ret -eq 0 ];then
        echo  -n -e "\033[41;37m"
        echo "Error: [$ret] $*"
        echo  -n -e "\033[0m"
    fi
    return 0
}

#Input is the command
#If command is error, display the error and eixt
func_fatal_cmd(){
    $*
    local ret=$?
    if [ ! $ret -eq 0 ];then
        echo  -n -e "\033[41;37m"
        echo "Error: [$ret] $*"
        echo  -n -e "\033[0m"
        exit 1
    fi
    return 0
}

#Input is a string.
#The string  will be displayed with green color
func_green_str(){
    echo  -n -e "\033[32m"
    echo  -e "$*"
    echo  -n -e "\033[0m"
}

func_yellow_str(){
    echo  -n -e "\033[33m"
    echo  -e "$*"
    echo  -n -e "\033[0m"
}

#Input is a string.
#The string  will be displayed with red color
func_red_str(){
    echo  -n -e "\033[31m"
    echo  -e "$*"
    echo  -n -e "\033[0m"
}
```

## 系统资源

### 获取系统资源

以 json 数据格式返回

```sh
#!/bin/bash
#
# author: lework
# date: 2019-10-11


######################################################################################################
# Environmental configuration
######################################################################################################

export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin


######################################################################################################
# Define globle variable
######################################################################################################

system_facts=''
cpu_facts=''
mem_facts=''
disk_facts=''
network_facts=''

bad=''
critical=''

bad_threshold=80
critical_threshold=90


######################################################################################################
# Define function
######################################################################################################

function check_used() {
  # 依据阀值设置,进行标记严重程度

  item=$1
  value=${2:-0}

  if [[ ${value%.*} -ge ${critical_threshold%.*} ]]; then
    critical=${critical}'"'${item}'",'
  elif [[ ${value%.*} -ge ${bad_threshold%.*} ]]; then
    bad=${bad}'"'${item}'",'
  fi

}


function get_system() {
  # 获取系统信息

  hostname=$(hostname 2>/dev/null)
  default_ipv4=$(ip -4 route get 8.8.8.8 2>/dev/null | head -1 | awk '{print $7}')
  distribution=$(awk '/^ID=/' /etc/*-release 2>/dev/null | awk -F'=' '{gsub("\"","");print $2}')
  distribution_version=$(python -c 'import platform; print platform.linux_distribution()[1]' 2>/dev/null)
  [ -z $distribution_version ] && distribution_version=$(awk '/^VERSION_ID=/' /etc/*-release 2>/dev/null | awk -F'=' '{gsub("\"","");print $2}')
  os_pretty_name=$(awk '/^PRETTY_NAME=/' /etc/*-release 2>/dev/null | awk -F'=' '{gsub("\"","");print $2 }')
  kernel=$(uname -r 2>/dev/null)
  os_time=$(date +"%F %T" 2>/dev/null)
  uptime=$(uptime 2>/dev/null |awk '{print $3}'|awk -F, '{print $1}')

  system_facts=$(cat << EOF
  {
    "hostname": "${hostname:-}",
    "default_ipv4": "${default_ipv4:-}",
    "distribution": "${distribution:-}",
    "distribution_version": "${distribution_version:-}",
    "os_pretty_name": "${os_pretty_name:-}",
    "kernel": "${kernel:-}",
    "os_time": "${os_time:-}",
    "uptime": "${uptime:-}"
  }
EOF
  )

}


function get_cpu() {
  # 获取cpu使用信息

  cpu_usedutilization=$(cat <(grep 'cpu ' /proc/stat) <(sleep 1 && grep 'cpu ' /proc/stat) | awk -v RS="" '{printf ("%.2f\n", ($13-$2+$15-$4)*100/($13-$2+$15-$4+$16-$5))}')
  cpu_loadavg1=$(awk '{print $1}' /proc/loadavg)
  cpu_loadavg5=$(awk '{print $2}' /proc/loadavg)
  cpu_loadavg15=$(awk '{print $3}' /proc/loadavg)

  cpu_facts=$(cat << EOF
  {
    "cpu_usedutilization": "${cpu_usedutilization:-0}",
    "cpu_loadavg1": "${cpu_loadavg1:-0}",
    "cpu_loadavg5": "${cpu_loadavg5:-0}",
    "cpu_loadavg15": "${cpu_loadavg15:-0}"
  }
EOF
  )

  check_used 'cpu_usedutilization' ${cpu_usedutilization}
  check_used 'cpu_loadavg1' ${cpu_loadavg1}
  check_used 'cpu_loadavg5' ${cpu_loadavg5}
  check_used 'cpu_loadavg15' ${cpu_loadavg15}

}


function get_mem() {
  # 获取内存使用信息

  memfree=$(awk -F":|kB" '$1~/^MemFree/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  memavailable=$(awk -F":|kB" '$1~/^MemAvailable/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  memtotal=$(awk -F":|kB" '$1~/^MemTotal/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  memcache=$(awk -F":|kB" '$1~/^Cached/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  membuffer=$(awk -F":|kB" '$1~/^Buffers/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  swaptotal=$(awk -F":|kB" '$1~/^SwapTotal/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  swapfree=$(awk -F":|kB" '$1~/^SwapFree/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)

  [ "${memtotal:-0}" != "0" ] && mem_usedutilization=$(echo "${memtotal:-0} ${memfree:-0} ${memcache:-0} ${membuffer:-0}" | awk '{printf ("%.2f\n", ($1-$2-$3-$4)*100/$1)}')
  [ "${swaptotal:-0}" != "0" ] && swap_usedutilization=$(echo "${swaptotal:-0} ${swapfree:-0}"| awk '{printf ("%.2f\n", ($1-$2)*100/$1)}')

  mem_facts=$(cat << EOF
  {
    "memtotal": "${memtotal:-}",
    "memfree": "${memfree:-}",
    "memavailable": "${memavailable:-}",
    "memcache": "${memcache:-}",
    "membuffer": "${membuffer:-}",
    "mem_usedutilization": "${mem_usedutilization:-0}",
    "swaptotal": "${swaptotal:-}",
    "swapfree": "${swapfree:-}",
    "swap_usedutilization": "${swap_usedutilization:-0}"
  }
EOF
  )

  check_used 'mem' ${mem_usedutilization}
  check_used 'swap' ${swap_usedutilization}

}


function get_disk() {
  # 获取磁盘使用信息

  mount=$(grep '^/dev/' /proc/mounts | grep -v -E 'docker|containers|iso9660|kubelet' | awk '{print $2}')

  for m in ${mount:-}; do
    size_total=$(df -hP $m 2>/dev/null | awk 'END{print $2}')
    size_use=$(df -hP $m 2>/dev/null | awk 'END{print $3}')
    size_available=$(df -hP $m 2>/dev/null | awk 'END{print $4}')
    size_usedutilization=$(df -hP $m 2>/dev/null | awk 'END{sub(/'%'/,"");print $5}')
    block_total=$(df -hPBM $m 2>/dev/null | awk 'END{print $2}')
    block_use=$(df -hPBM $m 2>/dev/null | awk 'END{print $3}')
    block_available=$(df -hPBM $m 2>/dev/null | awk 'END{print $4}')
    block_usedutilization=$(df -hPBM $m 2>/dev/null | awk 'END{sub(/'%'/,"");print $5}')
    inode_total=$(df -hPi $m 2>/dev/null | awk 'END{print $2}')
    inode_use=$(df -hPi $m 2>/dev/null | awk 'END{print $3}')
    inode_available=$(df -hPi $m 2>/dev/null | awk 'END{print $4}')
    inode_usedutilization=$(df -hPi $m 2>/dev/null | awk 'END{sub(/'%'/,"");print $5}')

    mount_facts=${mount_facts:-''}$(cat <<EOF
    {
      "mount": "${m:-}",
      "size_total": "${size_total:-}",
      "size_use": "${size_use:-}",
      "size_available": "${size_available:-}",
      "size_usedutilization": "${size_usedutilization:-0}",
      "block_total": "${block_total:-}",
      "block_use": "${block_use:-}",
      "block_available": "${block_available:-}",
      "block_usedutilization": "${block_usedutilization:-0}",
      "inode_total": "${inode_total:-}",
      "inode_use": "${inode_use:-}",
      "inode_available": "${inode_available:-}",
      "inode_usedutilization": "${inode_usedutilization:-0}"
    },
EOF
    )

    check_used 'mount_size_'${m} ${size_usedutilization}
    check_used 'mount_block_'${m} ${block_usedutilization}
    check_used 'mount_inode_'${m} ${inode_usedutilization}
  done

  disk_facts="["${mount_facts%?}"]"

}


function get_network() {
  # 获取网络信息

  stat=$(netstat -nat 2>/dev/null | awk '/^tcp/{++S[$NF]}END{for(m in S) print "\"" m "\":",S[m] ","}')

  conn="None"
  curl -V >/dev/null 2>&1
  if [ $? -eq 0 ]; then
    curl -sI http://www.baidu.com 2>/dev/null | grep '200 OK' >/dev/null 2>&1
    [ $? -eq 0 ] && conn="True"
  fi
  network_facts=$(cat << EOF
  {
    "tcpconnection": {${stat%?}},
    "conn": "${conn}"
  }
EOF
  )

}


function main() {
  # 脚本主要流程

  get_system
  get_cpu
  get_mem
  get_disk
  get_network


  [ ! -z $bad ] && bad='['${bad%?}']'
  [ ! -z $critical ] && critical='['${critical%?}']'

  check_facts=$(cat << EOF
  {
    "system": ${system_facts:-[]},
    "cpu": ${cpu_facts:-[]},
    "mem": ${mem_facts:-[]},
    "disk": ${disk_facts:-[]},
    "network": ${network_facts:-[]},
    "bad": ${bad:-[]},
    "critical": ${critical:-[]}
  }
EOF
  )

  echo ${check_facts:-[]}

}


######################################################################################################
# main
######################################################################################################

main
```

### 网卡

```sh
#Get the net interfaces's name
func_nic_names(){
    local names=`ip addr |grep \<.*\>|awk '{print $2}'|sed -e "s/://"`
    echo $names
}
```

### 系统信息

```sh
#Get ipv4 address
func_ipv4_addr(){
    local ips=`ip addr |grep inet|grep -v inet6| awk '{print $2}'|sed "s/\/.*//"`
    echo $ips
}
```

### IP 地址处理

```sh
# converts IPv4 as "A.B.C.D" to integer
ip4_to_int() {
  IFS=. read -r i j k l <<EOF
$1
EOF
  echo $(( (i << 24) + (j << 16) + (k << 8) + l ))
}

# converts interger to IPv4 as "A.B.C.D"
int_to_ip4() {
  echo "$(( ($1 >> 24) % 256 )).$(( ($1 >> 16) % 256 )).$(( ($1 >> 8) % 256 )).$(( $1 % 256 ))"
}

# returns the ip part of an CIDR
cidr_ip() {
  IFS=/ read -r ip _ <<EOF
$1
EOF
  echo $ip
}

# returns the prefix part of an CIDR
cidr_prefix() {
  IFS=/ read -r _ prefix <<EOF
$1
EOF
  echo $prefix
}

# returns net mask in numberic from prefix size
netmask_of_prefix() {
  echo $((4294967295 ^ (1 << (32 - $1)) - 1))
}

# returns default gateway address (network address + 1) from CIDR
cidr_default_gw() {
  ip=$(ip4_to_int $(cidr_ip $1))
  prefix=$(cidr_prefix $1)
  netmask=$(netmask_of_prefix $prefix)
  gw=$((ip & netmask + 1))
  int_to_ip4 $gw
}

# returns default gateway address (broadcast address - 1) from CIDR
cidr_default_gw_2() {
  ip=$(ip4_to_int $(cidr_ip $1))
  prefix=$(cidr_prefix $1)
  netmask=$(netmask_of_prefix $prefix)
  broadcast=$(((4294967295 - netmask) | ip))
  int_to_ip4 $((broadcast - 1))
}


ip4_to_int 192.168.0.1
# => 3232235521

int_to_ip4 3232235521
# => 192.168.0.1


# network address
ip=$(ip4_to_int 172.16.10.20)
netmask=$(ip4_to_int 255.255.252.0)
int_to_ip4 $((ip & netmask))
# => 172.16.8.0


# broadcast address
ip=$(ip4_to_int 172.16.10.20)
netmask=$(ip4_to_int 255.255.252.0)
int_to_ip4 $(((ip & netmask) + 1))
# => 172.16.8.1


cidr_ip "172.16.0.10/22"
# => 172.16.0.10

cidr_prefix "172.16.0.10/22"
# => 22

netmask_of_prefix 8
# => 4278190080


cidr_default_gw 192.168.10.1/24
# => 192.168.10.1
cidr_default_gw 192.168.10.1/16
# => 192.168.0.1
cidr_default_gw 172.17.18.19/20
# => 172.17.16.1


cidr_default_gw_2 192.168.10.1/24
# => 192.168.10.254
cidr_default_gw_2 192.168.10.1/16
# => 192.168.255.254
cidr_default_gw_2 172.17.18.19/20
# => 172.17.31.254


# 获取外网ip
get_ip(){
    local IP=$( ip addr | egrep -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | egrep -v "^192\.168|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-2]\.|^10\.|^127\.|^255\.|^0\." | head -n 1 )
    [ -z ${IP} ] && IP=$( wget -qO- -t1 -T2 ipv4.icanhazip.com )
    [ -z ${IP} ] && IP=$( wget -qO- -t1 -T2 ipinfo.io/ip )
    [ -z ${IP} ] && IP=$( wget -qO- -t1 -T2 api.ip.sb/ip )
    [ -z ${IP} ] && IP=$( wget -qO- -t1 -T2 members.3322.org/dyndns/getip )
    [ -z ${IP} ] && IP=$( ip -4 route get 8.8.8.8 2>/dev/null | head -1 | awk '{print $7}' )
    echo ${IP}
}

get_ipv6(){
    local ipv6=$(wget -qO- -t1 -T2 ipv6.icanhazip.com)
    [ -z ${ipv6} ] && return 1 || return 0
}
```

### 系统类型检查

```sh
check_sys(){
    if [[ -f /etc/redhat-release ]]; then
        release="centos"
    elif cat /etc/issue | grep -q -E -i "debian"; then
        release="debian"
    elif cat /etc/issue | grep -q -E -i "ubuntu"; then
        release="ubuntu"
    elif cat /etc/issue | grep -q -E -i "centos|red hat|redhat"; then
        release="centos"
    elif cat /proc/version | grep -q -E -i "debian"; then
        release="debian"
    elif cat /proc/version | grep -q -E -i "ubuntu"; then
        release="ubuntu"
    elif cat /proc/version | grep -q -E -i "centos|red hat|redhat"; then
        release="centos"
    fi
    bit=`uname -m`
}
```

## 系统服务

```sh
#Start a systemd style Service
func_start_sd_service(){
    systemctl start $1
    sleep 1
    local sta=`systemctl status ${1} |grep "Active: failed"`
    if [ -n "$sta" ];then
        func_red_str   "Start[Fail] $1"
        func_red_str   "            $sta"
        ret=1
    else
        local x=`systemctl status ${1} | grep "Active:"`
        func_green_str "Start[OK]   $1"
        func_green_str "            $x"
    fi
    return $ret
}

#Start a systemd style Service
func_stop_sd_service(){
    systemctl stop $1
    ret=$?
    local sta=`systemctl status ${1} |grep "Active:"`
    func_yellow_str "Stopping $1"
    func_yellow_str "         $sta"
}
```

## 目录操作

```sh
#Create Dirs: $1 $2 $3 ...
func_create_dirs(){
    for i in $*
    do
        if [ ! -d $i ];then
            mkdir -p $i
        fi
    done
}

#Force Copy:
#$1: Destiation Directory
#$2,$3,$4,...: Source File or Directories
func_force_copy(){
    local dest=$1
    shift 1

    if [ ! -d $dest ];then
        func_red_str "Dest Dir doesn't exist: $dest"
        return 1
    fi

    for i in $*
    do
        if [ ! -e $i ];then
            func_red_str "Not Found: $i"
            return 1
        fi
    done

    for i in $*
    do
        cp -rf $i $dest/
    done
}
```

## Git

```sh
#$1: respositry url
#$2：branch
#$3: tag
#$4: local directory
func_git_check_tag(){
    local url=$1
    local branch=$2
    local tag=$3
    local dir=$4

    if [ ! -e $dir ];then
        func_error_cmd git clone $url $dir
        if [ ! $?  -eq 0 ];then
            func_red_str "Something is wrong in cloning"
            return 1
        fi
    fi

    if [ ! -d $dir ];then
        func_red_str "The local respositry is not a directory"
        return 1
    fi

    local cur=`pwd`
    cd $dir
        func_error_cmd git checkout master
        func_error_cmd git pull
        func_error_cmd git checkout $branch
        func_error_cmd git checkout $tag
        if [ ! $? -eq 0 ];then
            return 1
        fi
    cd $cur
}
```

## 守护进程

```sh
#$1: pidfile
#$2: log file
#$4: commands
func_daemon_cmd(){
    local pidfile=$1
    local stdout="$2.stdout"
    local stderr="$2.stderr"
    shift 2

    $* 1>>$stdout 2>>$stderr &
    local pid=$!
    echo $pid >$pidfile
}

#$1: pid
func_check_pid(){
    ps -p $1 1>/dev/null 2>&1
    if [ $? -eq 0 ];then
        return 0
    fi
    return 1
}

#$1: pid
#$2: pid desc
func_exit_no_pid(){
    func_check_pid  $1
    if [ ! $? -eq 0 ];then
        func_red_str "Pid($1:$2) doesn't exist"
        exit 1
    fi
    return 0
}

#$1: pid file
#$2: log file
#$3: executuable binary file name
#$4: command
func_start_cmd(){
    local pidf=$1
    local logf=$2
    local name=$3
    shift 3
    local cmd=$*

    if [ -e $pidf ];then
        func_red_str "The PID file has already existed, please check: $pidf"
        func_yellow_str "It may be running or hasn't delete the PID file when it was stopped last time"
        exit 1
    fi
    func_daemon_cmd $pidf $logf $cmd
    sleep 1
    func_exit_no_pid `cat $pidf` "[Fail]${name} is not running!"
    if [ $? -eq 0 ];then
        return 0
    fi
}

#$1: pid file
func_stop_cmd(){
    local pidf=$1

    if [ ! -e $pidf ];then
        func_red_str "The PID file doesn't exist': $pidf"
        func_yellow_str "It may be not running"
        exit 1
    fi

    local pid=`cat $pidf`
    if [ "$pid" == "1" ];then
        func_red_str "You are not allowed to stop PID 1 !"
        exit 1
    else
        kill -9 $pid
        rm -rf $pidf
    fi
    return 0
}

#$1: Target executable  file
#$2: Log path
#$3: An config Array's name, the Array must be global. Becareful, Just give Name, not value(no $)
#$4: Other parametes from the command line, [start|stop]
func_service_template_1(){
    local TARGET=$1
    local Logs=$2
    eval config_2334200776=\${$3[@]}
    local cmdline=$4
    CMD="${TARGET} ${config_2334200776[@]}"
    NAME=`basename ${TARGET}`
    PID_FILE="${Logs}/${NAME}.pid"
    LOG_FILE="${Logs}/${NAME}"
    OPERATE="${Logs}/${NAME}.operate"

    start(){
        echo -e "`func_cur_time`: [start] $CMD" >>$OPERATE
        func_start_cmd $PID_FILE $LOG_FILE $NAME $CMD
        if [ $? == 0 ];then
            func_green_str "$TARGET is running"
        fi
    }

    stop(){
        echo -e "`func_cur_time`: [stop]" >>$OPERATE
        func_stop_cmd $PID_FILE
        if [ $? == 0 ];then
            func_red_str "$TARGET is terminated"
        fi
    }

    case $cmdline in
        (start)
            start;;
        (stop)
            stop;;
        (restart)
            stop;start;;
        (*)
            echo "usage: $0 [stop|start|restart]"
    esac
}
```

## 数组

```sh
#$1: sep string
#$2: prefix
#$3: Array's name, the Array must be global. Becareful, Just give Name, not value(no $)
#$4: postfix
func_join_array(){
    local sep=$1
    local prefix=$2
    local postfix=$4
    eval array_doimgaeg3234553=(\${$3[@]})
    local len=${#array_doimgaeg3234553[@]}

    if [ $len -eq 1 ];then
        echo ${prefix}${array_doimgaeg3234553[@]}${postfix}
        return 0
    fi

    local i=0
    local str=${prefix}${array_doimgaeg3234553[$i]}${postfix}
    i=$(($i+1))

    while [ $i -lt $len ]
    do
        str=${str}${sep}${prefix}${array_doimgaeg3234553[$i]}${postfix}
        i=$(($i+1))
    done
    echo $str
    return 0
}

#if value is in array, return 0, else return 1
#$1: value
#$2: Array's name, the Array must be global. Becareful, Just give Name, not value(no $)
func_in_array(){
    eval array_adfadfadfgli3323455=(\${$2[@]})
    for i in ${array_adfadfadfgli3323455[@]}
    do
        if [ $i == $1 ];then
            return 0
        fi
    done
    return 1
}
```

## 更新

```sh
#return 0: the file is updated  1: nothing is changed 2:remote is wrong.
#must checksum by sha1sum
#$1: local version file
#$2: remote version url
#$3: local file path
#$4: remote file url
func_update_file(){
    if [ ! -e $1 ];then
        func_red_str "Can't found Local Version"
        exit 1
    fi

    local lver=`cat $1`
    if [ "$lver" == "" ];then
        func_red_str "Local Version is NULL!"
        exit 1
    fi

    local rver=`curl $2 2>/dev/null |grep -v \<`
    if [ "$rver" == "" ];then
        func_red_str "Can't get Remote Version"
        exit 1
    fi

    if [ "$lver" == "$rver" ];then
        func_green_str "Local Version matches the Remote Version."
        return 1
    fi

    local lfile=$3
    curl -o $lfile  $4 2>/dev/null

    local lsha1=`sha1sum $lfile|awk '{print $1}'`
    local rsha1=`echo $rver|awk '{print $1}'`

    if [ "$lsha1" == "$rsha1" ];then
        func_green_str "The Remote Version file lays: $lfile"
        return 0
    else
        func_red_str "The Remote File dosen't match the Remote Version: $lfile"
        return 2
    fi
}

#$1: local file path
#$2: remote file url
func_replace_lfile(){
    curl -o $1 $2 2>/dev/null
}

#get a file and check the sha1 code
#$1 local file
#$2 file url
#$3 sha1 code url
func_curl_file_sha1(){
    local rsha1=`curl $3 2>/dev/null|grep -v \<|awk '{print $1}'`
    if [ "$rsha1" == "" ];then
        func_red_str "Can't the file sha1 code!"
        return 1
    fi
    curl -o $1 $2
    local lsha1=`sha1sum $1|awk '{print $1}'`

    if [ "$lsha1" == "$rsha1" ];then
        func_green_str "The File lays: $lfile"
        return 0
    else
        func_red_str "The File dosen't match the sha1 code: $1"
        return 2
    fi
}
```

## 交互操作

```sh
#$1: password
#$2...: cmds
func_cmd_need_password(){
    local password=$1
    shift 1
    expect -c "
        spawn $*
        expect {
            \"*password:\" {set timeout 300; send \"${password}\r\";}
            \"*yes/no\" {send \"yes\r\"; exp_continue;}
        }
    expect eof"
}

#$1: VARNAME
#$2: prompt
func_secret_input(){
    echo -n "$2"
    stty -echo
    read $1
    stty echo
    echo ""
}
```

## 随机数

```sh
function TimestampRand()
{
    range=$1
    timestamp=`date +%s%N`
    let res=$timestamp%$range
    echo $res
}

function RandomRand()
{
    range=$1
    let res=$RANDOM%$range
    echo $res
}

function UrandomRand()
{
    range=$1
    rand=`head -200 /dev/urandom | cksum | cut -f1 -d" "`
    let res=$rand%$range
    echo $res
}

function UuidRand()
{
    range=$1
    rand=`cat /proc/sys/kernel/random/uuid| cksum | cut -f1 -d" "`
    let res=$rand%$range
    echo $res
}


function exp()
{
    echo "基于时间戳: `TimestampRand 10`"
    echo "基于\$RANDOM: `RandomRand 10`"
    echo "基于urandom: `UrandomRand 10`"
    echo "基于uuid: `UuidRand 10`"

    str=""
    for i in `seq 1 6`;do
        str="$str`RandomRand 9`"
    done

    echo $str
    echo "字符翻转:"
    echo $str | rev

    echo $str | awk '{for(i=1;i<=length;i++){line=substr($0,i,1)line}}END{print line}'
}

function random_str()
{
  num=8
  [ ! -z $1 ] && num=$1
  base64 /dev/urandom | tr -d '/+' | dd bs=$num count=1 2>/dev/null
}
```

## 防火墙

```sh
# 设置 防火墙规则
add_iptables(){
    iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport $1 -j ACCEPT
    iptables -I INPUT -m state --state NEW -m udp -p udp --dport $1 -j ACCEPT
    ip6tables -I INPUT -m state --state NEW -m tcp -p tcp --dport $1 -j ACCEPT
    ip6tables -I INPUT -m state --state NEW -m udp -p udp --dport $1 -j ACCEPT
}
del_iptables(){
    iptables -D INPUT -m state --state NEW -m tcp -p tcp --dport $1 -j ACCEPT
    iptables -D INPUT -m state --state NEW -m udp -p udp --dport $1 -j ACCEPT
    ip6tables -D INPUT -m state --state NEW -m tcp -p tcp --dport $1 -j ACCEPT
    ip6tables -D INPUT -m state --state NEW -m udp -p udp --dport $1 -j ACCEPT
}
save_iptables(){
    if [[ ${release} == "centos" ]]; then
        service iptables save
        service ip6tables save
    else
        iptables-save > /etc/iptables.up.rules
        ip6tables-save > /etc/ip6tables.up.rules
    fi
}
```

## 下载文件

```sh
# 下载文件
download(){
    local filename=$(basename $1)
    if [ -f ${1} ]; then
        echo "${filename} [found]"
    else
        echo "${filename} not found, download now..."
        wget --no-check-certificate -c -t3 -T60 -O ${1} ${2}
        if [ $? -ne 0 ]; then
            echo -e "[${red}Error${plain}] Download ${filename} failed."
            exit 1
        fi
    fi
}
```

## 其他

### 自动压缩和解压

```sh
# 自动解压：判断文件后缀名并调用相应解压命令
function q-extract() {
    if [ -f $1 ] ; then
        case $1 in
        *.tar.bz2)   tar -xvjf $1    ;;
        *.tar.gz)    tar -xvzf $1    ;;
        *.tar.xz)    tar -xvJf $1    ;;
        *.bz2)       bunzip2 $1     ;;
        *.rar)       rar x $1       ;;
        *.gz)        gunzip $1      ;;
        *.tar)       tar -xvf $1     ;;
        *.tbz2)      tar -xvjf $1    ;;
        *.tgz)       tar -xvzf $1    ;;
        *.zip)       unzip $1       ;;
        *.Z)         uncompress $1  ;;
        *.7z)        7z x $1        ;;
        *)           echo "don't know how to extract '$1'..." ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}

# 自动压缩：判断后缀名并调用相应压缩程序
function q-compress() {
    if [ -n "$1" ] ; then
        FILE=$1
        case $FILE in
        *.tar) shift && tar -cf $FILE $* ;;
        *.tar.bz2) shift && tar -cjf $FILE $* ;;
        *.tar.xz) shift && tar -cJf $FILE $* ;;
        *.tar.gz) shift && tar -czf $FILE $* ;;
        *.tgz) shift && tar -czf $FILE $* ;;
        *.zip) shift && zip $FILE $* ;;
        *.rar) shift && rar $FILE $* ;;
        esac
    else
        echo "usage: q-compress <foo.tar.gz> ./foo ./bar"
    fi
}
```

### 获取命令行选项

```sh
while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do case $1 in
  -V | --version )
    echo "$version"
    exit
    ;;
  -s | --string )
    shift; string=$1
    ;;
  -f | --flag )
    flag=1
    ;;
esac; shift; done
if [[ "$1" == '--' ]]; then shift; fi
```

处理命令行参数的一个样例

```sh
while [ "$1" != "" ]; do
    case $1 in
        -s  )   shift
		SERVER=$1 ;;
        -d  )   shift
		DATE=$1 ;;
        --paramter|p ) shift
		PARAMETER=$1;;
        -h|help  )   usage # function call
                exit ;;
        * )     usage # All other parameters
                exit 1
    esac
    shift
done
```

### 使用 while 循环处理文本文件

#### 整行处理

对 while 语句使用输入重定向读取文本文件

```sh
while read -r line; do
  echo "$line"
done < filename
```

将文本文件内容通过管道传给 while 语句

```sh
cat filename |while read line;do
  echo $line
done
```

读取文件使用 for 循环的方式

```sh
#!/bin/bash
for i in `cat users.txt`
do
  #echo "$i"
  id $i &>/dev/null
  if [ "$?" -eq 0 ];then
    echo "$i already exists...."
  else
    echo "add $i .... && create $i...."
  fi
done
```

#### 区分字段处理

对 while 语句使用输入重定向读取文本文件

```sh
while read -r file1 file2 file3; do
  echo $file , $file2 , $file3
done < filename
```

将文本文件内容通过管道传给 while 语句

```sh
cat filename |while read file1 file2 file3 ;do
  echo $file , $file2 , $file3
done
```

代码示例

```sh
##-----------------------整行处理-----------------------------------

# 读取文件方法 1
count=1
cat test | while read line ; do
echo "Line $count: $line"
    count=$[ $count + 1 ]
done
echo "Finished processing the file"

# 读取文件方法 2
#!/bin/bash
while read LINE;do
  NAME=`echo $LINE | awk '{print $1}'`
  AGE=`echo $LINE | awk '{print $2}'`
  Sex=`echo $LINE | awk '{print $3}'`
  echo "My name is $NAME, I'm $AGE years old, I'm a $Sex"
done < student_info.txt



##-----------------------区分字段处理-----------------------------------
#!/bin/sh
file=$1
if [ $# -lt ]; then
    echo "Usage: $0 FILEPATH"
    exit
fi
while read -r f1 f2 f3
do
    echo "Field 1: $f1 ===> Field2:$f2===>Field3:$f3"
done <"$file"
```

### case 语句

```sh
OS=$(uname -s)

case "$OS" in
  FreeBSD) echo "This is FreeBSD" ;;
  Darwin) echo "This is Mac OSX" ;;
  AIX) echo "This is AIX" ;;
  Minix) echo "This is Minix" ;;
  Linux) echo "This is Linux" ;;
  *) echo "Failed to identify this OS" ;;
esac
```

```sh
case "$1" in
  start | up)
    vagrant up
    ;;

  *)
    echo "Usage: $0 {start|stop|ssh}"
    ;;
esac
```

### 常见颜色

```sh
NOCOLOR='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
LIGHTGRAY='\033[0;37m'
DARKGRAY='\033[1;30m'
LIGHTRED='\033[1;31m'
LIGHTGREEN='\033[1;32m'
YELLOW='\033[1;33m'
LIGHTBLUE='\033[1;34m'
LIGHTPURPLE='\033[1;35m'
LIGHTCYAN='\033[1;36m'
WHITE='\033[1;37m'

echo -e "The first five colors of the rainbow are ${RED}red ${ORANGE}orange ${YELLOW}yellow ${GREEN}green ${NOCOLOR}and ${BLUE}blue${NOCOLOR}"
```

```sh
#定义一个颜色的函数
echo_color (){
    local color=$1
    local info=$2
    case "$color" in
    red)
        echo -e "\e[1;31m ${info} \e[0m"
       ;;
    green)
        echo -e "\e[1;32m ${info} \e[0m"
       ;;
    yellow)
        echo -e "\e[1;33m ${info} \e[0m"
       ;;
    blue)
        echo -e "\e[1;34m ${info} \e[0m"
       ;;
    Magenta)
        echo -e "\e[1;35m ${info} \e[0m"
    ;;
    cyan-blue)
        echo -e "\e[1;36m ${info} \e[0m"
    ;;
    esac

}


echo_color red "哈哈哈哈哈哈哈"
echo_color green "哈哈哈哈哈哈哈"
echo_color yellow "哈哈哈哈哈哈哈"
echo_color blue "哈哈哈哈哈哈"
echo_color Magenta "哈哈哈哈哈哈"
```

```sh
function echo_r (){
    # Color red: Error, Failed
    [ $# -ne 1 ] && return 1
    echo -e "\033[31m$1\033[0m"
}

function echo_g (){
    # Color green: Success
    [ $# -ne 1 ] && return 1
    echo -e "\033[32m$1\033[0m"
}
```

### 脚本目录

```sh
DIR="${0%/*}"
```

取当前运行脚本绝对路径的示例：（注：Linux 下可以用）

```sh
dirname $(readlink -f $0)
```

### echo 和 printf 打印

```sh
#!/bin/bash
#Version:2.0
function clear1() {
  clear
  echo -e "\033[42m---------------------------------\033[0m"
  echo -e "\e[2;10H这里是菜单\t\t#"
  echo -e "#\e[32m 1.查看网卡信息\e[0m                #"
  echo -e "#\e[33m 2.查看内存信息\e[0m                #"
  echo -e "#\e[34m 3.查看磁盘信息\e[0m                #"
  echo -e "#\e[35m 4.查看CPU信息\e[0m                 #"
  echo -e "#\e[36m 5.查看账户信息\e[0m                #"
  echo -e "\033[42m---------------------------------\033[0m"
  echo
}

function clear2() {
  clear
  printf  "\e[42m%s\n\e[0m" "---------------------------------"
  printf  "\e[2;10H%s\t\t\n" "这里是菜单"
  printf  "\e[32m%s\e[0m\n"  "1.查看网卡信息"
  printf  "\e[35m%s\e[0m\n"  "2.查看内存信息"
  printf  "\e[36m%s\e[0m\n"  "3.查看磁盘信息"
  printf  "\e[34m%s\e[0m\n"  "4.查看CPU信息"
  printf  "\e[33m%s\e[0m\n"  "5.查看账户信息"
  printf  "\e[42m%s\n\e[0m" "---------------------------------"
}

printf "%-5s %-10s %-4s\n" NO Name Mark
printf "%-5s %-10s %-4.2f\n" 01 Tom 90.3456
printf "%-5s %-10s %-4.2f\n" 02 Jack 89.2345
printf "%-5s %-10s %-4.2f\n" 03 Jeff 98.4323
# %-5s 格式为左对齐且宽度为5的字符串代替（-表示左对齐），不使用则是又对齐。
# %-4.2f 格式为左对齐宽度为4，保留两位小数。
```

## 脚本编写注意事项

```sh
1）开头加解释器：#!/bin/bash
2）语法缩进，使用四个空格；多加注释说明。
3）命名建议规则：变量名大写、局部变量小写，函数名小写，名字体现出实际作用。
4）默认变量是全局的，在函数中变量 local 指定为局部变量，避免污染其他作用域。
5）有两个命令能帮助我调试脚本：set -e 遇到执行非 0 时退出脚本，set -x 和 set +x 打印执行过程。



set -x 和 set +x 常用于调试函数。

set -x
function(){
}
set +x

6）写脚本一定先测试再到生产上。


set 的一些用法：
    shopt -s -o nounset     # 强调变量必须先声明才能使用

    set x y z               # 将x,y,z的值赋予位置参数1,2,3

    # 把 set -u 或 set -o nounset 插入到脚本中, 并运行它, 就会在每个试图使用未声明变量的地方给出一个unbound variable错误信息.
    # set -e     # 遇到执行非 0 时退出脚本，set -x 打印执行过程

    set -o pipefail #在这个设置执行后，其后面的代码，包括管道命令的返回值，为最后一个非零的命令的返回值，或者当管道内的所有命令都执行成功后返回零。

    set -o nounset      #未声明变量就报错，强制退出
    set +o nounset      # set -/+u,简写

    set -o errexit      # 脚本只要发生错误，执行出现非0的结果,当脚本发生第一个错误时退出脚本
    set +o errexit      # set -/+e,简写

    set -o xtrace       # 表示跟踪脚本的执行过程，有利于调试,运行结果之前，先输出执行的那一行命令,比set -v更加完整详细
    set +o xtrace       # set -/+x,简写

    set -o noclobber    # 防止文件覆盖，文件存在就报错，不存在就正常创建
    set +o noclobber    # set -/+C,简写

    set -o allexport    # export 所有已定于的变量
    set +o allexport    # set -/+a,简写

    set -o noexec       # 读取脚本命令，不执行，进行语法检查
    set +o noexec       # set -/+n,简写

    set -o verbose      # 执行一个命令前打印出这个命令
    set +o verbose      # set -/+v,简写



    set -x
    uname -a
    ......
    set +x              #调试某一个区域  打印执行过程,用于调试函数居多
```

脚本开头执行时，执行如下命令， 在执行过程中若遇到使用了未定义的变量或命令返回值为非零，将直接报错退出：

```sh
set -eu
set -euo pipefail
```

## Shell 脚本的调试技术

### 使用 echo 命令调试脚本

```sh
#! /bin/bash
# 定义变量 a
a=1
# 当 a 的值等于 1 时
if [ "$a" -eq 1 ]
then
   b=2
else
   b=1
fi
c=3

echo "a=$a"
echo "b=$b"
echo "c=$c"
```

### 使用 trap 命令调试 Shell 脚本

trap 命令可以捕获指定的信号，并且执行预定的命令，其基本语法如下：

`trap 'command' signal`

演示使用 trap 命令输出发生错误的行号以及退出状态码，代码如下：

```sh
#! /bin/bash
# 定义信号处理函数
ERRTRAP()
{
   echo "[LINE:$1] Error:Command or function exited with status code $?"
}
# 定义函数
func()
{
   # 返回值为 1
   return 1
}

# 使用 trap 命令捕获 ERR 信号
trap 'ERRTRAP $LINENO' ERR
# 调用错误的命令
abc
# 调用函数
func
```

```sh
[root@192 chapter5]# sh sample01.sh
sample01.sh:行17: abc: 未找到命令
[LINE:17] Error:Command or function exited with status code 127
[LINE:11] Error:Command or function exited with status code 1
```

演示通过捕获 DEBUG 信号来进行程序调试的方法，代码如下：

```sh
#! /bin/bash
# 捕获 DEBUG 信号
trap 'echo "before execute line:$LINENO,a=$a,b=$b,c=$c"' DEBUG

# 定义变量 a
a=1
# 根据变量 a 的值初始化变量 b
if [ "$a" -eq 1 ]
then
   b=2
else
   b=1
fi
# 定义变量 c
c=3

echo "end"
```

```sh
bash a.sh
before execute line:6,a=,b=,c=
before execute line:8,a=1,b=,c=
before execute line:10,a=1,b=,c=
before execute line:15,a=1,b=2,c=
before execute line:17,a=1,b=2,c=3
end
```

### 使用 tee 命令调试 shell 脚本

在普通的语句中，用户使用 echo 和 trap 命令就可以非常轻松地完成调试，但是对于管道或者重定向来说，使用上面两种方法就显得心有余而力不足，因为在管道的作用下，一些命令的输出结果将会直接成为下一个命令的输入，中间结果并不会显示在屏幕上，因此给程序调试带来了困难。

由于在实际开发过程中，管道和重定向在 Shell 脚本中使用得非常多。所以必须找到能够输出中间结果的方法。在这种情况下，tee 命令就可以轻松地完成任务。tee 命令会从标准输入读取数据，将其内容输出到标准输出设备，同时又可将内容保存成文件。

```sh
#! /bin/bash
# 将文件名转换为大写
list='ls -l | tee list.txt | awk '{print toupper($7)}'''
echo "$list"
```

### 使用钩子函数

在许多程序设计语言中，用户在调试程序的时候都可以设定一个开关变量，当该变量的值为真时，才输出调试信息；否则，不输出调试信息。例如用户可以设计以下代码：

```sh
if [ "$DEBUG" = "true" ]; then
  输出调试信息
fi
```

只有当变量 DEBUG 的值为 true 时，才输出调试信息。
这样的代码块称为调试钩子。在调试钩子中，用户可以输出任何调试信息。
使用调试钩子，用户可以通过开关变量控制是否输出调试信息。这样的话，在开发过程中，可以将开关变量的值设置为真，便于程序的调试。
当调试完成，需要发布脚本的时候，将开关变量的值设置为 flase 即可，无需再一条条地删除程序中的调试代码。

演示使用调试钩子调试程序的方法，代码如下：

```sh
#! /bin/bash

# 定义调试开关
export DEBUG=true

# 调试函数
DEBUG() {
  [ "$_DEBUG" == "true" ] && $@ || :
}

a=1
# 调用调试函数
DEBUG echo "a=$a"

if [ "$a" -eq 1 ]
then
     b=2
else
     b=1
fi
# 调用调试函数
DEBUG echo "b=$b"
c=3
# 调用调试函数
DEBUG echo "c=$c"
```

从上面的执行结果可以得知，因为开关变量 DEBUG 的值为 true，所以输出了相应的调试信息。如果将 DEBUG 变量的值设置为 false，则上面的程序没有任何输出，用户可以自行验证。

`gouzi.sh`

```sh
#!/bin/bash
DEBUG() {
[ "$_DEBUG" == "on" ] && $@ || :

}
for i in {1..10};do
    set -x
    DEBUG echo -e "I is $i"
    set +x
done
```

```sh
[root@centos7-base tmp]# _DEBUG=on ./gouzi.sh
I is 1
I is 2
I is 3
I is 4
I is 5
I is 6
I is 7
I is 8
I is 9
I is 10
[root@centos7-base tmp]# ./gouzi.sh
```



```sh
#!/bin/bash
# 开启调试模式
[[ -n $DEBUG ]] && set -x
set -o errtrace         # Make sure any error trap is inherited
set -o nounset          # Disallow expansion of unset variables
set -o pipefail         # Use last non-zero exit code in a pipeline
# ....
# 脚本内容
```


### shell 自带的调试选项

Shell 提供了一些用于调试脚本的选项，如下所示：

| 参数 | 说明                                                   |
| ---- | ------------------------------------------------------ |
| -n   | 读一遍脚本中的命令但不执行，用于检查脚本中的语法错误   |
| -v   | 一边执行脚本，一边将执行过的脚本命令打印到标准错误输出 |
| -x   | 提供跟踪执行信息，将执行的每一条命令和结果依次打印出来 |

使用这些选项有三种方法，

一是在命令行提供参数

```sh
$ sh -x ./script.sh
```

二是在脚本开头提供参数

```sh
#!/bin/sh -x
```

第三种方法是在脚本中用 set 命令启用或禁用参数

```sh
#! /bin/sh
if [ -z "$1" ]; then
  set -x
  echo "ERROR: Insufficient Args."
  exit 1
  set +x
fi
```

```sh
set -e    #若指令传回值不等于0，则立即退出shell。
set -n    #只读取指令，而不实际执行。

set -u 　     #当执行时使用到未定义过的变量，则显示错误信息。
set -v 　     #显示shell所读取的输入值。


set -x
# ......
set +x
#分别表示启用和禁用-x参数，这样可以只对脚本中的某一段进行跟踪调试。
```

## 进度条

```sh
#!/bin/bash

# 进度条函数
progress_bar() {
    local total_steps=$1
    local step_name=$2
    local current_step=0

    # 控制台最上方显示大纲名称，并添加闪烁效果
    echo -ne "\033[5mProgress: $step_name\033[0m"

    # 初始化进度
    local progress=0
    echo

    # 模拟执行
    while [ $current_step -lt $total_steps ]; do
        # 更新进度条
        progress=$((current_step * 100 / total_steps))
        printf "\r[%-${total_steps}s] %d%%" "$(printf "#%.0s" $(seq 1 $current_step))" "$progress"

        # 模拟执行内容
        echo -ne " Step $((current_step + 1))/$total_steps: Executing...\033[K"

        ((current_step++))

        # 模拟执行时间
        sleep 0.1
    done

    # 完成后显示完成信息，并以绿色显示
    echo -e "\nStep $total_steps/$total_steps: $step_name \t[ \033[32m完成\033[0m ]"
}

# 测试进度条函数
progress_bar 20 "Process A"
```



```sh
#!/bin/bash
[[ -n $DEBUG ]] && set -x
set -o errtrace # Make sure any error trap is inherited
set -o nounset  # Disallow expansion of unset variables
set -o pipefail # Use last non-zero exit code in a pipeline

# 初始化变量
STEP_COUNT=5 # 总步骤数
CURRENT_STEP=1

# 显示标题的函数
function display_title() {
  echo -e "\e[1mInstalling Software Package...\e[0m" # 加粗标题
}

# 进度条函数
function update_progress_bar() {
  local PROGRESS=$((CURRENT_STEP * 100 / STEP_COUNT))
  local TITLE="["
  local BAR=""
  local END="] $PROGRESS%"

  # 构建进度条
  for ((i = 0; i < 20; i++)); do
    if [[ $((i * STEP_COUNT / 20)) -lt CURRENT_STEP ]]; then
      BAR+="="
    else
      BAR+=" "
    fi
  done

  # 添加颜色和样式
  echo -ne "\r\033[K$TITLE\e[32m$BAR\e[0m$END"
  # if [[ $CURRENT_STEP == $STEP_COUNT ]]; then
  #   echo -e "\n" # 在最后一次更新后换行输出
  # fi
}

# 步骤函数示例
function step() {
  local DESCRIPTION=$1
  local DELAY=$2
  echo -e "$DESCRIPTION"
  update_progress_bar
  ((CURRENT_STEP++))
  sleep $DELAY
  echo -e " \e\t[32m[✔]\e[0m" # 显示绿色的勾表示完成
}

# 主安装函数
function install_with_steps() {
  display_title
  step "Step 1: Setting up environment..." 1

  step "Step 2: Downloading package..." 1

  step "Step 3: Verifying package integrity..." 1

  step "Step 4: Installing dependencies..." 1

  step "Step 5: Finalizing installation..." 1
  echo
  # 闪烁显示
  echo -ne "\033[5mProgress:Installation finished successfully.\033[0m"
  echo
}

# 调用主安装函数
install_with_steps
```

高级玩法

https://github.com/Cocean001/progress_bar_shell
