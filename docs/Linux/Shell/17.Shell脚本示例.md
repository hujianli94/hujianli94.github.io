# 17.Shell脚本示例

脚本编写注意事项

1. 开头加解释器：#!/bin/bash 
2. 语法缩进，使用四个空格；多加注释说明。 
3. 命名建议规则：变量名大写、局部变量小写，函数名小写，名字体现出实际作用。
4. 默认变量是全局的，在函数中变量 local 指定为局部变量，避免污染其他作用域。 
5. 有两个命令能帮助我调试脚本：set -e 遇到执行非 0 时退出脚本，set -x 和 set +x 打印执行过程。set-x 和set+x常用于调试函数。 
6. 写脚本一定先测试再到生产上。



[常用Shell脚本-生产可用](https://gitbook.curiouser.top/origin/bash-scirpts.html?h=shell)



```shell
set -x
function(){
}
set +x

```



```shell

# set 的一些用法：
    shopt -s -o nounset         #强调变量必须先声明才能使用

    set x y z               # 将x,y,z的值赋予位置参数1,2,3

    #把 set -u 或 set -o nounset 插入到脚本中, 并运行它, 就会在每个试图使用未声明变量的地方给出一个unbound variable错误信息.
    #set -e     # 遇到执行非 0 时退出脚本，set -x 打印执行过程

    set -o pipefail #在这个设置执行后，其后面的代码，包括管道命令的返回值，为最后一个非零的命令的返回值，或者当管道内的所有命令都执行成功后返回零。

    set -o nounset      #未声明变量就报错，强制退出
    set +o nounset      # set -/+u,简写

    set -o errexit      # 脚本只要发生错误，执行出现非0的结果,当脚本发生第一个错误时退出脚本
    set +o errexit      # set -/+e,简写

    set -o xtrace       # 表示跟踪脚本的执行过程，有利于调试,运行结果之前，先输出执行的那一行命令,比set -v更加完整详细
    set +o xtrace       # set -/+x,简写

    set -o noclobber    # 防止文件覆盖，文件存在就报错，不存在就正常创建
    set +o noclobber    # set -/+C,简写

    set -o allexport    # export 所有已定于的变量
    set +o allexport    # set -/+a,简写

    set -o noexec       # 读取脚本命令，不执行，进行语法检查
    set +o noexec       # set -/+n,简写

    set -o verbose      # 执行一个命令前打印出这个命令
    set +o verbose      # set -/+v,简写



    set -x
    uname -a
    ......
    set +x              #调试某一个区域  打印执行过程,用于调试函数居多
```

脚本开头执行时，执行如下命令， 在执行过程中若遇到使用了未定义的变量或命令返回值为非零，将直接报错退出：

```shell
set -eu
set -euo pipefail
```




## 1.判断curl返回状态码
```shell
#!/bin/bash
response=$(curl -sL -o /dev/null -w %{http_code} https://baidu.com)
if [[ $response -ge 200 && $response -le 299 ]] ;then 
    echo 'check point success'
else 
    echo 'check point fail'
fi
```

## 2.读取文件中的配置到变量中
```shell
#!/bin/bash
# 配置文件中的配置项格式为key1=value1，一行一个配置项
while read line;do
    eval "$line"
done < /etc/openvpn/server/smtp.conf
echo $key1
```


## 3.根据console输入条件执行
```shell
#!/bin/bash
echo "选择以下功能:"
echo "   0) 功能0"
echo "   1) 功能1"
echo "   2) 功能2"
echo "   3) 功能3"
echo "   4) 功能4"
read -p "功能选项[4]: " option
until [[ -z "$option" || "$option" =~ ^[0-4]$ ]]; do
    read -p "$option为无效的选项，请重新输入功能选项: " option
done
case "$option" in
    0) 
        echo "功能0已执行!" 
    ;;
        1)
            echo "功能1已执行!" 
      exit
    ;;
        2)
            echo "功能2已执行!" 
            exit
        ;;
        3)
            echo "功能3已执行!"  
            exit
        ;;
        # 默认选项
        4|"")
            echo "功能4已执行!" 
            exit
        ;;
esac
```



## 4.将指定输出内容写入文件
```shell
{
echo "hahh"
echo "lalal"
} > /tmp/test
```


## 5.判断变量是否存在或为空

```shell
if [ -z ${var+x} ]; then 
    echo "var is unset"; 
else 
    echo "var is set to '$var'"; 
fi
```

参考：https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash

```shell
#!/bin/bash

# -z 选项用于检查变量是否为空字符串，如果是，则返回true
if [ -z "${VAR}" ]; then
    echo "VAR is empty"
fi

# -n 选项用于检查变量是否为非空字符串，如果是，则返回true。
if [ -n "${VAR}" ]; then
    echo "VAR is not empty"
fi
```

在测试变量是否为空时，最好使用双引号将变量括起来，以避免在变量为空时出现语法错误。

### 5.1 字符串判断中x的作用

```shell
# 范例

if [ "x${var}" == "x" ]
if [ x"$DPVS_TYPE" == x"SNAT" ]

# 目的:防止出现语法错误。

[ x$1 = x ] is true if $1 is unset/null/empty or not.

Try yourself with:
TEST= ;[ x$TEST = x] && echo "TEST is unset"
and
TEST=lolz ;[ x$TEST = x ] && echo "TEST is unset"

# 类似于[ -z "${1:+x}" ] 操作，当$1为空时，赋值给x，避免判断直接报错。
```

## 6.文件扫描校验
```shell
#!/bin/bash
#func:scan file
#md5sum -c $SCAN_FILE


SCAN_DIR=`echo $PATH |sed 's/:/ /g'`
SCAN_CMD=`which md5sum`
SCAN_FILE_FALL="/tmp/scan_$(date +%F%H%m)_fall.txt"
SCAN_FILE_BIN="/tmp/scan_$(date +%F%H%m)_bin.txt"

scan_fall_disk() {
        echo "正在全盘扫描，请稍等！文件路径:$SCAN_FILE_FALL"
        find / -type f -exec $SCAN_CMD \{\} \;>> $SCAN_FILE_FALL 2>/dev/null
}

scan_bin() {
    echo "正在扫描PATH可执行文件，请稍等，文件路径：$SCAN_FILE_BIN"
    for file in $SCAN_DIR
    do
        find $filae -type f -exec $SCAN_CMD \{\} \;>> $SCAN_FILE_BIN 2>/dev/null
    done
}

main() {
    [ $# -lt 1 ] && echo "请使用参数，1表示全盘扫描，2表示二进制可执行文件扫描"
    read number
    case $number in
    1)
        scan_fall_disk;;
    2)
        scan_bin;;
    *)
        echo "参数错误，1，表示全盘扫描，2表示二进制文件扫描"
    esac
}


main
```

## 7.Linux系统检测
```shell
#!/bin/bash
# auth:kaliarch
# func:sys info check
# version:v1.0
# sys:centos6.x/7.x

[ $(id -u) -gt 0 ] && echo "请用root用户执行此脚本！" && exit 1
sysversion=$(rpm -q centos-release|cut -d- -f3)
line="-------------------------------------------------"


[ -d logs ] || mkdir logs

sys_check_file="logs/$(ip a show dev eth0|grep -w inet|awk '{print $2}'|awk -F '/' '{print $1}')-`date +%Y%m%d`.txt"

# 获取系统cpu信息
function get_cpu_info() {
    Physical_CPUs=$(grep "physical id" /proc/cpuinfo| sort | uniq | wc -l)
    Virt_CPUs=$(grep "processor" /proc/cpuinfo | wc -l)
    CPU_Kernels=$(grep "cores" /proc/cpuinfo|uniq| awk -F ': ' '{print $2}')
    CPU_Type=$(grep "model name" /proc/cpuinfo | awk -F ': ' '{print $2}' | sort | uniq)
    CPU_Arch=$(uname -m)
cat <<EOF | column -t
CPU信息:

物理CPU个数: $Physical_CPUs
逻辑CPU个数: $Virt_CPUs
每CPU核心数: $CPU_Kernels
CPU型号: $CPU_Type
CPU架构: $CPU_Arch
EOF
}

# 获取系统内存信息
function get_mem_info() {
    check_mem=$(free -m)
    MemTotal=$(grep MemTotal /proc/meminfo| awk '{print $2}')  #KB
    MemFree=$(grep MemFree /proc/meminfo| awk '{print $2}')    #KB
    let MemUsed=MemTotal-MemFree
    MemPercent=$(awk "BEGIN {if($MemTotal==0){printf 100}else{printf \"%.2f\",$MemUsed*100/$MemTotal}}")
    report_MemTotal="$((MemTotal/1024))""MB"        #内存总容量(MB)
    report_MemFree="$((MemFree/1024))""MB"          #内存剩余(MB)
    report_MemUsedPercent="$(awk "BEGIN {if($MemTotal==0){printf 100}else{printf \"%.2f\",$MemUsed*100/$MemTotal}}")""%"   #内存使用率%

cat <<EOF
内存信息：

${check_mem}
EOF
}

# 获取系统网络信息
function get_net_info() {
    pri_ipadd=$(ip a show dev eth0|grep -w inet|awk '{print $2}'|awk -F '/' '{print $1}')
    pub_ipadd=$(curl ifconfig.me -s)
    gateway=$(ip route | grep default | awk '{print $3}')
    mac_info=$(ip link| egrep -v "lo"|grep link|awk '{print $2}')
    dns_config=$(egrep -v "^$|^#" /etc/resolv.conf)
    route_info=$(route -n)
cat <<EOF | column -t
IP信息:

系统公网地址: ${pub_ipadd}
系统私网地址: ${pri_ipadd}
网关地址: ${gateway}
MAC地址: ${mac_info}

路由信息:
${route_info}

DNS 信息:
${dns_config}
EOF
}

# 获取系统磁盘信息
function get_disk_info() {
    disk_info=$(fdisk -l|grep "Disk /dev"|cut -d, -f1)
    disk_use=$(df -hTP|awk '$2!="tmpfs"{print}')
    disk_inode=$(df -hiP|awk '$1!="tmpfs"{print}')

cat <<EOF
磁盘信息:

${disk_info}
磁盘使用:

${disk_use}
inode信息:

${disk_inode}
EOF


}

# 获取系统信息
function get_systatus_info() {
    sys_os=$(uname -o)
    sys_release=$(cat /etc/redhat-release)
    sys_kernel=$(uname -r)
    sys_hostname=$(hostname)
    sys_selinux=$(getenforce)
    sys_lang=$(echo $LANG)
    sys_lastreboot=$(who -b | awk '{print $3,$4}')
    sys_runtime=$(uptime |awk '{print  $3,$4}'|cut -d, -f1)
    sys_time=$(date)
    sys_load=$(uptime |cut -d: -f5)

cat <<EOF | column -t
系统信息:

系统: ${sys_os}
发行版本:   ${sys_release}
系统内核:   ${sys_kernel}
主机名:    ${sys_hostname}
selinux状态:  ${sys_selinux}
系统语言:   ${sys_lang}
系统当前时间: ${sys_time}
系统最后重启时间:   ${sys_lastreboot}
系统运行时间: ${sys_runtime}
系统负载:   ${sys_load}
EOF
}

# 获取服务信息
function get_service_info() {
    port_listen=$(netstat -lntup|grep -v "Active Internet")
    kernel_config=$(sysctl -p 2>/dev/null)
    if [ ${sysversion} -gt 6 ];then
        service_config=$(systemctl list-unit-files --type=service --state=enabled|grep "enabled")
        run_service=$(systemctl list-units --type=service --state=running |grep ".service")
    else
        service_config=$(/sbin/chkconfig | grep -E ":on|:启用" |column -t)
        run_service=$(/sbin/service --status-all|grep -E "running")
    fi
cat <<EOF
服务启动配置:

${service_config}
${line}
运行的服务:

${run_service}
${line}
监听端口:

${port_listen}
${line}
内核参考配置:

${kernel_config}
EOF
}


function get_sys_user() {
    login_user=$(awk -F: '{if ($NF=="/bin/bash") print $0}' /etc/passwd)
    ssh_config=$(egrep -v "^#|^$" /etc/ssh/sshd_config)
    sudo_config=$(egrep -v "^#|^$" /etc/sudoers |grep -v "^Defaults")
    host_config=$(egrep -v "^#|^$" /etc/hosts)
    crond_config=$(for cronuser in /var/spool/cron/* ;do ls ${cronuser} 2>/dev/null|cut -d/ -f5;egrep -v "^$|^#" ${cronuser} 2>/dev/null;echo "";done)
cat <<EOF
系统登录用户:

${login_user}
${line}
ssh 配置信息:

${ssh_config}
${line}
sudo 配置用户:

${sudo_config}
${line}
定时任务配置:

${crond_config}
${line}
hosts 信息:

${host_config}
EOF
}


function process_top_info() {

    top_title=$(top -b n1|head -7|tail -1)
    cpu_top10=$(top b -n1 | head -17 | tail -10)
    mem_top10=$(top -b n1|head -17|tail -10|sort -k10 -r)

cat <<EOF
CPU占用top10:

${top_title}
${cpu_top10}

内存占用top10:

${top_title}
${mem_top10}
EOF
}


function sys_check() {
    get_cpu_info
    echo ${line}
    get_mem_info
    echo ${line}
    get_net_info
    echo ${line}
    get_disk_info
    echo ${line}
    get_systatus_info
    echo ${line}
    get_service_info
    echo ${line}
    get_sys_user
    echo ${line}
    process_top_info
}

sys_check > ${sys_check_file}
```

### 7.1 监控100台服务器磁盘利用率脚本

```shell
#!/bin/bash
HOST_INFO=host.info
for IP in $(awk '/^[^#]/{print $1}' $HOST_INFO); do
    USER=$(awk -v ip=$IP 'ip==$1{print $2}' $HOST_INFO)
    PORT=$(awk -v ip=$IP 'ip==$1{print $3}' $HOST_INFO)
    TMP_FILE=/tmp/disk.tmp
    ssh -p $PORT $USER@$IP 'df -h' > $TMP_FILE
    USE_RATE_LIST=$(awk 'BEGIN{OFS="="}/^\/dev/{print $NF,int($5)}' $TMP_FILE)
    for USE_RATE in $USE_RATE_LIST; do
        PART_NAME=${USE_RATE%=*}
        USE_RATE=${USE_RATE#*=}
        if [ $USE_RATE -ge 80 ]; then
            echo "Warning: $PART_NAME Partition usage $USE_RATE%!"
        fi
    done
done
```


## 8.启动脚本示例
```shell
#!/usr/bin/env bash
#?$Id:?gmond.init?180?2003-03-07?20:38:36Z?sacerdoti $
# chkconfig:?2345?70?40
# description:?gmond?startup?script

#定义变量GMOND，指定gmond守护进程路径
GMOND=/usr/sbin/gmond

#读取并执行文件 /etc/rc.d/init.d/functions的内容
. /etc/rc.d/init.d/functions

#定义变量RETVAL
RETVAL=0

#使用case语句来根据指定的不同参数，执行不同的行为
case $1 in
    start)
    echo -n "Starting GANGLIA gmond: "
    #如果gmond守护进程不存在，则退出脚本的执行，退出状态码为1
    [ -f $GMOND ] || exit 1
    #将gmond守护进程放在后台运行，daemon是function中的函数
    daemon $GMOND
    #将上一命令的退出状态码赋值给变量RETVAL
    RETVAL=$?
    echo
    ##若gmond守护进程成功运行，则创建一个lock文件/var/lock/subsys/gmond
    [ $RETVAL -eq 0 ] && touch /var/lock/subsys/gmond
   ;;
    stop)
        #显示停止ganglia gmond的信息
        echo -n "Shutting down GANGLIA gmond: "
        #停止gmond守护进程，killproc是functions中定义的函数
        killproc gmond
        #将上一命令的退出状态码赋值给变量RETVAL
        RETVAL=$?
        echo
        #若gmond守护进程成功停止，则删除lock文件 /var/lock/subsys/gmond
        [ $RETVAL -eq 0 ] && rm -rf /var/lock/subsys/gmond
   ;;
    restart|reload)
        #重新调用此脚本，命令行参数为stop
        $0 stop
        #重新调用此脚本，命令行参数为start
        $0 start
        RETVAL=$?
   ;;
    status)
        #显示gmond守护进程的运行状态，其中status是functions 定义的函数
        status gmond
        RETVAL=$?
   ;;
    *)
        #显示脚本的使用方法信息到标准输出
        echo "Usage: $0 {start|stop|restart|status}"
        #退出脚本的运行，退出状态码为1
        exit 1
   ;;
esac

#退出脚本的运行，退出状态码为变量RETVAL的值
exit $RETVAL
```

## 9.备份24小时被修改的文件

```shell
#!/usr/bin/env bash

#备份当前目录下所有前24小时被修改的文件为一个归档压缩包
BACKUPFILE=back-$(date +%m-%d-%Y)   #备份文件中嵌入日期
archive=${1:-$BACKUPFILE}   #如果没有在命令行上指定备份的归档文件名，默认以"back-xxxx作为默认的文件名"

tar cvf - $(find . -mtime -1 -type f -print) >${archive}.tar
gzip ${archive}.tar
echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."

#建议使用xagrs或者-exec
find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
find . -mitime -1 -type f -exec tar rvf "$archive.tar" '{}' \ ;
```

## 10.卸载相关的rpm包

```shell
#!/usr/bin/env bash
File_1=unstall.txt
rpm -qa | grep ssh > $File_1

while read -r line
do
    rpm -e $line
    [ $? -eq 0 ] && echo "unstall is successful!!" || exit 1
done < $File_1
```

## 11.检查rpm包的方法

```shell
#!/usr/bin/env bash
if rpm -qa sysstat &> /dev/null; then
    echo "sysstat is already  install"
else
    echo "sysstat is not  install"
fi
```


## 12.检查软件状态
```shell
#!/usr/bin/env bash
PORT_C=$(ss -anu| grep -c 123)
PS_C=$(ps -aux| grep ntp| grep -vc grep)
if [ $PORT_C -eq 0 -o $PS_C -eq 0 ]; then
    echo "Server is fail,restart !!"
    :
fi
```

## 13.color输出

```shell
!/usr/bin/env bash
#方法1
color_printf1(){
    if [[ $1 == "red" ]]; then
        echo -e "\033[32;40m$2\033[0m"
    elif [[ $1 == "green" ]];then
        echo -e "\033[31;40m$2\033[0m"
    fi
}

#方法2
color_printf2(){
    case "$1" in
    "red")
       echo -e "\033[32;40m$2\033[0m"
       ;;
    "green")
       echo -e "\033[31;40m$2\033[0m"
       ;;
    *)
       echo -e "Example: color_printf2 red xxxxxx"
       ;;
    esac

}

function echo_r (){
    # Color red: Error, Failed
    [ $# -ne 1 ] && return 1
    echo -e "\033[31m$1\033[0m"
}

function echo_g (){
    # Color green: Success
    [ $# -ne 1 ] && return 1
    echo -e "\033[32m$1\033[0m"
}
```


## 14.Nginx日志切割
```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh
# author：xiaojian

S_LOG=/usr/local/nginx/logs/access.log
D_LOG=/data/backup/`date +%Y-%m-%d`
echo -e "\033[32mPlease wait start cut shell scripts ....\033[0m"
sleep 2

if [ ! -d $D_LOG ]; then
    mkdir -p $D_LOG
fi

mv $S_LOG $D_LOG
kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`
echo "---------------------------------------------"
echo "The Nginx log Cutting Successfully! "
echo "You can access backup nginx log ${D_LOG}/access.log files."
```

```shell
#!/bin/sh
#nginx日志切割

#设置
Log_path=/www/server/nginx/logs
Yesterday=$(date -d "yesterday" +%Y-%m-%d_%S)
Nginxbin=/www/server/nginx/sbin/nginx

#日志改名
/bin/mv $Log_path/access.log $Log_path/access.$Yesterday.log
/bin/mv $Log_path/error.log  $Log_path/error.$Yesterday.log

#重新生成日志
$Nginxbin -s reopen

# #定时任务
# #nginx日志切割
# 00 00 * * *  /root/sh/cut_log.sh
# #
```

## 15.一键安装docker
```shell
#!/bin/bash
#Author:
#Date: 2019-06-06
#install docker in ubuntu and centos


function install_docker_in_ubuntu
{
    sudo  apt-get update -y
    # install some tools
    sudo apt-get install \
        apt-transport-https \
        ca-certificates \
        curl \
        gnupg-agent \
        software-properties-common \
        net-tools \
        wget -y

    # install docker
    curl -fsSL get.docker.com -o get-docker.sh
    sh get-docker.sh

    # start docker service
    sudo groupadd docker &> /dev/null
    sudo gpasswd -a "${USER}" docker
    sudo systemctl start docker

    rm -rf get-docker.sh
}


function install_docker_in_centos
{
    # install some tools
    sudo yum install -y git vim gcc glibc-static telnet bridge-utils

    # install docker
    curl -fsSL get.docker.com -o get-docker.sh
    sh get-docker.sh

    # start docker service
    sudo groupadd docker &> /dev/null
    sudo gpasswd -a "${USER}" docker
    sudo systemctl start docker

    rm -rf get-docker.sh

}


SYSTEM_NAME="$(awk -F= '/^NAME/{print $2}' /etc/os-release)"
if [[ "${SYSTEM_NAME,,}" =~ "ubuntu"  ]] ; then
    echo "Your system is ubuntu."
    echo "Installing Docker in ubuntu..."
    install_docker_in_ubuntu
elif [[ "${SYSTEM_NAME,,}" =~ "centos" ]] ; then
    echo "Your system is centos."
    echo "Installing Docker in centos..."
    install_docker_in_centos
else
    echo "This script can only run in ubuntu and centos system."
    exit 1
fi
```

## 16. 备份MongoDB
```shell
#!/bin/bash
#backup mongodb

. /etc/profile
CMD=`which mongodump`
DATE=`date +%F`
DB="test"
DB_HOST="localhost"
DB_PORT="27017"
DB_USER="testuser"
DB_PWD="testpass"
BACKUP_DIR="/data/mongodb/"
TAR_DIR="/data/tardir/"
TAR_DIR_DATE="${TAR_DIR}${DATE}"
TAR_BAK="mongodb_bak_$DATE.tar.gz"

check_dir(){
    for DIR in ${BACKUP_DIR} ${TAR_DIR_DATE}
    do
        if [ ! -d $DIR ];then
            mkdir -p $DIR
        fi
    done
}
backup_mongodb(){
    $CMD -h ${DB_HOST}:${DB_PORT} -u $DB_USER -p $DB_PWD -d ${DB} -o ${BACKUP_DIR}${DATE} >/dev/null
    if [ $? -eq 0 ];then
        tar -zcf ${TAR_DIR_DATE}/${TAR_BAK} ${BACKUP_DIR}${DATE} && return 0
    fi
}
clean_tar() {
    find ${TAR_DIR} -mtime +7 -exec rm -rf {} \; && return 0
}

main() {
    check_dir
    [ $? -eq 0 ] && backup_mongodb
    [ $? -eq 0 ] && clean_tar
}

main
```


## 17.Linux下以秒为单位执行脚本


### example1
```shell
写一个触发的脚本，在触发脚本中使用死循环来解决此问题
[root@test ~]# cat kevin.sh
#!/bin/bash
while : ;do

echo "beijing is so good!" >> /root/test.log
sleep 2

done

[root@test ~]# chmod 755 kevin.sh

可以把它放到计划任务使其运行
[root@test ~]# crontab -e
* * * * * /bin/bash -x /root/kevin.sh >/dev/null 2>&1

等待这个计划任务执行后，就将计划任务中的此条目删除或注释！防止该计划条目无限制地执行下去（只需执行一次就可以，因为kevin.sh脚本里本身就有死循环）
[root@test ~]# ps -ef|grep kevin.sh
root     29839 29835  0 16:05 ?        00:00:00 /bin/sh -c /bin/bash -x /root/kevin.sh >/dev/null 2>&1
root     29842 29839  0 16:05 ?        00:00:00 /bin/bash -x /root/kevin.sh
root     29852 16356  0 16:05 pts/0    00:00:00 grep kevin.sh

[root@test ~]# crontab -e
#* * * * * /bin/bash -x /root/kevin.sh >/dev/null 2>&1

最后把这个脚本放到 /etc/rc.local 让它每次开机都可以被运行
[root@test ~]# vim /etc/rc.local
/bin/bash -x /root/kevin.sh >/dev/null 2>&1

验证（查看是不是每隔2秒在/root/test.log文件中写入了）
[root@test ~]# tail -f /root/test.log
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
```
### example2
```shell
[root@test ~]# vim kevin.sh
#!/bin/bash

for((i=1;i<=20;i++));do

echo "beijing is so good!" >> /root/test.log
sleep 2

done

然后添加脚本执行权限， 写入的crontab里每分钟执行一次
[root@test ~]# chmod 755 kevin.sh
[root@test ~]# crontab -e
* * * * * /bin/bash -x /root/kevin.sh >/dev/null 2>&1

[root@test ~]# ps -ef|grep kevin.sh
root     30515 30514  0 16:27 ?        00:00:00 /bin/sh -c /bin/bash -x /root/kevin.sh >/dev/null 2>&1
root     30516 30515  0 16:27 ?        00:00:00 /bin/bash -x /root/kevin.sh
root     30527 16356  0 16:27 pts/0    00:00:00 grep kevin.sh

[root@test ~]# tail -f /root/test.log
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
.......
```
### example3
- 使用crontab计划任务来直接实现！经验证，这种方式是最靠谱，最稳妥的！

```shell
[root@test ~]# cat /root/kevin.sh
#!/bin/bash
echo "beijing is so good!" >> /root/test.log

添加脚本执行权限，并配置到crontab计划任务里（使用&& 或者 ；都是一样的效果）。思路：先过一分钟执行第一次，接着就是每隔2秒钟执行一次。
[root@test ~]# chmod 755 /root/kevin.sh
[root@test ~]# crontab -e
* * * * * /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 2 &&  /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 4; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 6; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 8; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 10; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 12; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 14; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 16; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 18; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 20; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 22; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 24; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 26; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 28; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 30; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 32; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 34; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 36; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 38; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 40; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 42; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 44; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 46; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 48; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 50; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 52; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 54; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 56; /bin/bash -x /root/kevin.sh >/dev/null 2>&1
* * * * * sleep 58; /bin/bash -x /root/kevin.sh >/dev/null 2>&1

[root@test ~]# tail -f /root/test.log
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
beijing is so good!
```

一个取巧的方法如下。

行秒级的定时任务

```shell
* * * * * cmd
* * * * * sleep 20; cmd
* * * * * sleep 40; cmd
```


## 18.备份文件

- Auto_Backup_Linux_System_Files.sh

```shell
#!/usr/bin/env bash

SOURCE_DIR=(
    $*
)
TARGET_DIR=/data/backup/
YEAR=`date +%Y`
MONTH=`date +%m`
DAY=`date +%d`
WEEK=`date +%u`
FILES=system_backup.tgz
CODE=$?


if [ -z "$*" ]; then
    echo -e "\033[32mUsage:\nPlease Ebter Your Backup Files or Directories\n--------------------------------------------\n
    \nUsage:{ $0 /boot/etc}\033[0m"
    exit
fi

# Deternube Wgether the Target Directory Exists

if [ ! -d $TARGET_DIR ]; then
    mkdir -p $TARGET_DIR/$YEAR/$MONTH/$DAY
    echo -e "\033[32mThe $TARGET_DIR Create Successfully ! \033[0m"
fi

#EXEC Full_Backup Function Command
#EXEC Full_Backup Function Command
Full_Backup()
{
if
    [ "$WEEK" -eq "7" ];then
    rm -rf $TARGET_DIR/snapshot
    cd $TARGET_DIR/$YEAR/$MONTH/$DAY ;tar -g $TARGET_DIR/snapshot -czvf $FILES `echo ${SOURCE_DIR[@]}`
    [ "$CODE" == "0" ]&&echo -e  "--------------------------------------------\nFull_Backup System Files Backup Successfully !"
fi
}
#Perform incremental BACKUP Function Command
Add_Backup()
{
   cd $TARGET_DIR/$YEAR/$MONTH/$DAY ;
if
    [ -f $TARGET_DIR/$YEAR/$MONTH/$DAY/$FILES ];then
    read -p "$FILES Already Exists, overwrite confirmation yes or no ? : " SURE
    if [ $SURE == "no" -o $SURE == "n" ];then
    sleep 1;exit 0
    fi
#Add_Backup Files System
    if
        [ $WEEK -ne "7" ];then
        cd $TARGET_DIR/$YEAR/$MONTH/$DAY;tar -g $TARGET_DIR/snapshot -czvf $$_$FILES `echo ${SOURCE_DIR[@]}`
        [ "$CODE" == "0" ]&&echo -e  "-----------------------------------------\n\033[32mAdd_Backup System Files Backup Successfully !\033[0m"
   fi
else
   if
      [ $WEEK -ne "7" ];then
      cd $TARGET_DIR/$YEAR/$MONTH/$DAY ;tar -g $TARGET_DIR/snapshot -czvf $FILES `echo ${SOURCE_DIR[@]}`
      [ "$CODE" == "0" ]&&echo -e  "-------------------------------------------\n\033[32mAdd_Backup System Files Backup Successfully !\033[0m"
   fi
fi
}
Full_Backup
Add_Backup


# crontab计划任务中加入如下语句，每天凌晨1点整执行备份脚本。
# 0 1 *  *  * /bin/sh /data/sh/Auto_Backup_Linux_System_Files.sh /boot /etc/ >> /tmp/back.log 2>&1
```


## 19.修改IP_主机名_网卡信息

```shell
#!/usr/bin/env bash

#静态IP修改
#动态IP修改
#根据IP生产主机名并配置
#修改DNS域名解析
ETHCONF=/etc/sysconfig/network-scripts/ifcfg-ens32
HOSTS=/etc/hosts
NETWORK=/etc/sysconfig/network
DIR=/data/backup/`date +%Y%m%d`
NETMASK=255.255.255.0
echo "------------------------------------------------------------------"
judeg_ip(){
    read -p "Please enter ip Address,example 192.168.0.11 ip":IPADDR
    echo $IPADDR|grep -v "[Az-Zz]"|grep --color -E "([0-9]{1,3}\.){3}[0-9]{1,3}"
}

count_ip(){
    count=(`echo ${IPADDR}|awk -F. '{print $1,$2,$3,$4}'`)
    IP1=${count[0]}
    IP2=${count[1]}
    IP3=${count[2]}
    IP4=${count[3]}
}


ip_check(){
judeg_ip

while [ "$?" -ne 0 ]; do
    judeg_ip
done

count_ip
while [ "$IP1" -lt 0 -o "$IP1" -ge 255 -o "$IP2" -ge 255 -o "$IP3" -ge 255 -o "$IP4" -ge 255 ]; do
    judeg_ip
    while [ "$?" -ne 0 ]; do
        judeg_ip
    done
    count_ip
done
}


change_ip(){

if [ ! -d $DIR ]; then
    mkdir -p $DIR
fi
echo "The Change ip address to Backup Interface eth0"
cp $ETHCONF $DIR
grep "dhcp" $ETHCONF
if [ "$?" -eq 0 ]; then
    read -p "Please enter ip Address:" IPADDR
    sed -i 's/dhcp/static/g' $ETHCONF
    echo -e "IPADDR=$IPADDR\nNERMASK=$NETMASK\nGATEWAY=`echo $IPADDR|awk -F. '{print $1"."$2"."$3}'`.2" >> $ETHCONF
    echo "The IP configuration success. !"
else
    echo -n "Static IP has been configured,please confirm whether to modify,yes or No";
    read i
fi
if [ "$i" == "y" -o "$i" == "yes" ]; then
    ip_check
    sed -i -e '/IPADDR/d' -e '/NETMASK/d' -e '/GATEWAY/d' $ETHCONF
    echo -e "IPADDR=$IPADDR\nNETMASK=$NETMASK\nGATEWAY=`echo  $IPADDR|awk -F. '{print $1"."$2"."$3}'`.2" >> $ETHCONF
    echo "The IP configuration success. !"
    echo
else
    echo "Static IP already exists,please exit."
    echo $?
fi
}

change_hosts(){
    if [ ! -d $DIR ]; then
        mkdir -p $DIR
    fi
    cp $HOSTS $DIR
    ip_check
    host=`echo $IPADDR|sed 's/\./-/g'|awk '{print "BJ-IDC-" $0 "-Hujianli.net"}'`
    cat $HOSTS|grep "$host"
    if [ "$?" -ne 0 ]; then
        echo "$IPADDR    $host" >> $HOSTS
        echo "The hosts modify success"
    fi
    grep "$host" $NETWORK
    if [ "$?" -ne 0 ]; then
        sed -i 's/^HOSTNAME/#HOSTNAME/g' $NETWORK
        echo "NETWORK=$host" >> $NETWORK
        hostname $host;su
    fi
}


PS3="Please Select configuration ip or configuration host:"
select i in "modify_ip" "modify_hosts" "exit"
do
    case "$i" in
    modify_ip)
        change_ip
       ;;
    modify_hosts)
        change_hosts
       ;;
    exit)
        exit
       ;;
    *)
       echo -e "1)modify_ip\n2)modify_host\n3)exit"
    esac
done
```


## 20.检查恶意IP登录，拒绝SSH
```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh
SEC_FILE=/var/log/secure
IP_ADDR=`awk '{print $0}' /var/log/secure |grep -i "fail"|egrep -o "([0-9]{1,3}\.){3}[0-9]{1,3}"|sort -nr|uniq -c|awk '$1>=15 {prin
t $2}'`
IPTABLE_CONF=/etc/sysconfig/iptables
echo

cat <<EOF
+++++++++++++++++++++++++++++++++++++= Welcome to yse ssh login drop failed ip ++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++-----------------------------------------------=++++++++++++++++++++++++++
EOF
echo
for (( VAR = 0; VAR <=6 ; ++VAR )); do echo -n "-";sleep 1;done
echo
for i in `cat $IP_ADDR` ; do
    cat $IPTABLE_CONF|grep $i > /dev/null
    if [ "$?" -ne 0 ]; then
        sed -i "/lo/a -A INPUT -s $i -m state --state NEW -m tcp -p tcp --dport 22 -j DROP" $IPTABLE_CONF
    fi
done
NUM=`find /etc/sysconfig/ - name -a -mmin -1|wc -l `

if test "$NUM" -eq 1; then
     /etc/init.d/iptables restart
fi
```


## 21.数据库备份

### 备份数据库
```shell
#!/bin/bash
#
# Filename:
# backupdatabase.sh
# Description:
# backup cms database and remove backup data before 7 days
# crontab
# 55 23 * * * /bin/sh /yundisk/cms/crontab/backupdatabase.sh >> /yundisk/cms/crontab/backupdatabase.log 2>&1

DATE=`date +%Y-%m-%d`
OLDDATE=`date +%Y-%m-%d -d '-7 days'`

#MYSQL=/usr/local/mysql/bin/mysql
#MYSQLDUMP=/usr/local/mysql/bin/mysqldump
#MYSQLADMIN=/usr/local/mysql/bin/mysqladmin

BACKDIR=/yundisk/cms/database
[ -d ${BACKDIR} ] || mkdir -p ${BACKDIR}
[ -d ${BACKDIR}/${DATE} ] || mkdir ${BACKDIR}/${DATE}
[ ! -d ${BACKDIR}/${OLDDATE} ] || rm -rf ${BACKDIR}/${OLDDATE}

mysqldump --default-character-set=utf8 --no-autocommit --quick --hex-blob --single-transaction -uroot  cms_production  | gzip > ${BACKDIR}/${DATE}/cms-backup-${DATE}.sql.gz
echo "Database cms_production and bbs has been backup successful"
/bin/sleep 5

aws s3 cp ${BACKDIR}/${DATE}/* s3://example-share/cms/databackup/
```


!!! example "参考文献"

    [使用mysqldump进行mysql数据库备份的完整shell]( http://www.04007.cn/article/1050.html)
    [Linux定时备份数据库到COS](https://www.naraku.cn/posts/92.html)
   

### MySQL定时备份脚本
```shell
#!/bin/bash
# 初始化时，创建相应目录
# mkdir /home/node/bakmysql/sql/

# 定时任务
# 每天凌晨1:00执行备份脚本
#0 1 * * * /bin/bash -x /home/node/bakmysql/backup.sh >/dev/null 2>&1
#2分钟运行一次-测试用
#*/2 * * * * /bin/bash -x /home/node/bakmysql/backup.sh >/dev/null 2>&1

BakDir=/home/node/bakmysql/sql
LogFile=/home/node/bakmysql/sql/bak.log
Date=`date +%Y%m%d`
Begin=`date +"%Y年%m月%d日 %H:%M:%S"`
cd $BakDir
DumpFile=$Date.sql


# 导出到本地
mysqldump -uroot -p123456 test --quick --single-transaction | gzip > $DumpFile.gz
Last=`date +"%Y年%m月%d日 %H:%M:%S"`
echo [FullBack] 开始:$Begin 结束:$Last $DumpFile.gz successful >> $LogFile


# 删除7天前的备份文件
find $BakDir -mtime +7 -type f -name "*.sql.gz" | xargs rm -f
```
你需要做的就是修改数据库配置，然后就是配置一下定时任务即可


### MySQL数据库分库备份

数据库密码保存在/etc/my.cnf文件中，所以在执行与mysql相关的命令不需要输入密码

分库备份思路：
```shell
mysqldump  db1 >db1.sql.gz
mysqldump  db2 >db2.sql.gz
```


拿到库名
```shell
mysql  -e 'show databases' |sed '1d' |grep -v "_schema"
```

注意看注释信息

```shell
#!/bin/bash
# author: xiongminghao
# mail: jasonminghao@163.com
# describe：Mysql database backup
# 定义变量
IP=$(ifconfig eth1 |awk 'NR==2{print $2}')
Path=/backup/database  # 备份目录路径
Time=$(date +%F)
Ba_Path=$Path/$Time
Ba_Logs=/var/log/db_database_$Time # 定义一个存放日志的文件
Md5_Path=$Path/$Time/md5 # 定义一个存放md5校验的目录


# 创建两个目录以当天时间为命名
[ ! -d $Ba_Path ] && mkdir $Ba_Path
[ ! -d $Md5_Path ] && mkdir $Md5_Path

# 循环获取数据库名进行备份和生成MD5校验文件
for dbname in `mysql  -e 'show databases' |sed '1d' |grep -v "_schema"`
do
# 判断是否有数据库已经备份了,如果备份了则continue 调出当次循环，否则进行备份

if [ ! -f $Ba_Path/${dbname}.sql.gz ];then

   # 备份参数
   # -B 增加use[name]语句, -R 备份存储过程和函数数据
   # --master=data2 记录备份时刻的binlog位置点，2表示将其位置点注释
   # --single-ransaction 对innodb引擎进行热备（对数据进行快照）
   # gzip 对备份的数据进行gzip压缩
   mysqldump  -B -R --master-data=2 --single-transaction  |gzip >$Ba_Path/${dbname}.sql.gz
   RETVAL=$?

   # 通过返回值判断备份是否执行成功,把执行的成功与否纪录到日志中
   [ $? -eq 0 ] && echo "${dbname} successful" >>$Ba_Logs || echo "${dbname} failed" >>$Ba_Logs

   # 对数据库的数据完整性做MD5校验
   md5sum $Ba_Path/${dbname}.sql.gz  >$Md5_Path/${dbname}_md5.log

 else
    # 如果备份已存在则跳出当次循环,进行下次循环
    continue

  fi
done

# 将备份日志结果邮件方式发送给管理员
 mail -s "$HOSTNAME $IP" jasonminghao@163.com < $Ba_Logs
```

### MySQL数据库分库分表备份

数据库密码保存在/etc/my.cnf文件中，所以在执行与mysql相关的命令不需要输入密码

分库分表备份思路：

库名db1，两张表
```shell
mysqldump  db1 table01 >db1_table01.sql.gz
mysqldump  db1 table02 >db1_table01.sql.gz

```

库名db2，两张表
```shell
mysqldump  db2 table01 >db2_table01.sql.gz
mysqldump  db2 table02 >db2_table02.sql.gz
```


拿到表名列表
```shell
mysql  -e "show tables from db1;" |sed 1d
```

注意看注释信息

```shell
#!/bin/bash
# author: xiongminghao
# mail: jasonminghao@163.com
# describe：Mysql database table backup
# 定义变量
IP=$(ifconfig eth1 |awk 'NR==2{print $2}')
Path=/backup/table # 备份目录
Time=$(date +%F)
Ba_Path=$Path/$Time
Ba_Logs=/var/log/db_table_$Time  # 定义一个存放日志的文件
Md5_Path=$Path/$Time/md5 # 定义一个存放md5校验的目录

# 创建两个目录以当天时间为命名
[ ! -d $Ba_Path ] && mkdir $Ba_Path
[ ! -d $Md5_Path ] && mkdir $Md5_Path

# 循环获取数据库名
for dbname in `mysql  -e 'show databases' |sed '1d' |grep -v "_schema"`
do

  # 循环获取到数据库名后再次循环获取到该库名下的表，进行备份和MD5校验
  for tablename in `mysql -e "show tables from $dbname" |sed '1d'`
  do

  # 判断是否有表已经备份了,如果备份了则continue 调出当次循环，否则进行备份
  if [ ! -f $Ba_Path/${dbname}_${tablename}.sql.gz ];then

   mysqldump -R --master-data=2 --single-transaction  ${dbname} ${tablename} |gzip >$Ba_Path/${dbname}_${tablename}.sql.gz
   RETVAL=$?

   # 通过返回值判断备份是否执行成功,把执行的成功与否纪录到日志中
   [ $? -eq 0 ] && echo "${dbname}_${tablename} successful" >>$Ba_Logs || echo "${dbname}_${tablename} failed" >>$Ba_Logs
   # 对表的数据完整性做MD5校验
   md5sum $Ba_Path/${dbname}_${tablename}.sql.gz  >$Md5_Path/${dbname}_${tablename}_md5.log

 else
    continue

  fi
 done
done
# 将备份日志结果邮件方式发送给管理员
mail -s "$HOSTNAME $IP" jasonminghao@163.com < $Ba_Logs
```


## 22.开机性能优化
```shell
#!/bin/bash
#添加epel外部yum扩展源
cd /usr/local/src
wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
rpm -ivh epel-release-6-8.noarch.rpm
#安装gcc基础库文件以及sysstat工具
yum -y install gcc gcc-c++ vim-enhanced unzip unrar sysstat
#配置ntpdate自动对时
yum -y install ntp
echo "01 01 * * * /usr/sbin/ntpdate ntp.api.bz    >> /dev/null 2>&1" >> /etc/crontab
ntpdate ntp.api.bz
service crond restart
#配置文件的ulimit值
ulimit -SHn 65535
echo "ulimit -SHn 65535" >> /etc/rc.local
cat>> /etc/security/limits.conf << EOF
*                     soft     nofile             65535
*                     hard     nofile             65535
EOF

#基础系统内核优化
cat>> /etc/sysctl.conf << EOF
fs.file-max=419430
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 1
net.ipv4.tcp_keepalive_time = 1200
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.tcp_max_tw_buckets = 36000
net.ipv4.route.gc_timeout = 100
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_synack_retries = 1
net.core.somaxconn = 16384
net.core.netdev_max_backlog = 16384
net.ipv4.tcp_max_orphans = 16384
EOF
/sbin/sysctl -p

#禁用control-alt-delete组合键以防止误操作
sed -i 's@ca::ctrlaltdel:/sbin/shutdown -t3 -r now@#ca::ctrlaltdel:/sbin/shutdown -t3 -r now@' /etc/inittab
#关闭SElinux
sed -i 's@SELINUX=enforcing@SELINUX=disabled@' /etc/selinux/config
#关闭iptables
service iptables stop
chkconfig iptables off
#ssh服务配置优化,请至少保持机器中至少有一个具有sudo权限的用户，下面的配置会禁止root远程登录
sed -i 's@#PermitRootLogin yes@PermitRootLogin no@' /etc/ssh/sshd_config #禁止root远程登录
sed -i 's@#PermitEmptyPasswords no@PermitEmptyPasswords no@' /etc/ssh/sshd_config #禁止空密码登录
sed -i 's@#UseDNS yes@UseDNS no@' /etc/ssh/sshd_config /etc/ssh/sshd_config
service sshd restart
#禁用ipv6地址
echo "alias net-pf-10 off" >> /etc/modprobe.d/dist.conf
echo "alias ipv6 off" >> /etc/modprobe.d/dist.conf
chkconfig ip6tables off
#vim基础语法优化
echo "syntax on" >> /root/.vimrc
echo "set nohlsearch" >> /root/.vimrc
#精简开机自启动服务，安装最小化服务的机器初始可以只保留crond，network，rsyslog，sshd这四个服务。
for i in `chkconfig --list|grep 3:on|awk '{print $1}'`;do chkconfig --level 3 $i off;done
for CURSRV  in crond rsyslog sshd network;do chkconfig --level 3 $CURSRV on;done
#重启服务器
reboot
```



服务器系统配置初始化脚本
```shell
#/bin/bash
# 设置时区并同步时间
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
if ! crontab -l |grep ntpdate &>/dev/null ; then
    (echo "* 1 * * * ntpdate time.windows.com >/dev/null 2>&1";crontab -l) |crontab
fi

# 禁用selinux
sed -i '/SELINUX/{s/permissive/disabled/}' /etc/selinux/config

# 关闭防火墙
if egrep "7.[0-9]" /etc/redhat-release &>/dev/null; then
    systemctl stop firewalld
    systemctl disable firewalld
elif egrep "6.[0-9]" /etc/redhat-release &>/dev/null; then
    service iptables stop
    chkconfig iptables off
fi

# 历史命令显示操作时间
if ! grep HISTTIMEFORMAT /etc/bashrc; then
    echo 'export HISTTIMEFORMAT="%F %T `whoami` "' >> /etc/bashrc
fi

# SSH超时时间
if ! grep "TMOUT=600" /etc/profile &>/dev/null; then
    echo "export TMOUT=600" >> /etc/profile
fi

# 禁止root远程登录
sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config

# 禁止定时任务向发送邮件
sed -i 's/^MAILTO=root/MAILTO=""/' /etc/crontab

# 设置最大打开文件数
if ! grep "* soft nofile 65535" /etc/security/limits.conf &>/dev/null; then
    cat >> /etc/security/limits.conf << EOF
    * soft nofile 65535
    * hard nofile 65535
EOF
fi

# 系统内核优化
cat >> /etc/sysctl.conf << EOF
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_tw_buckets = 20480
net.ipv4.tcp_max_syn_backlog = 20480
net.core.netdev_max_backlog = 262144
net.ipv4.tcp_fin_timeout = 20
EOF

# 减少SWAP使用
echo "0" > /proc/sys/vm/swappiness

# 安装系统性能分析工具及其他
yum install gcc make autoconf vim sysstat net-tools iostat if
```



## 23.函数输出帮助信息
```shell
#!/bin/bash
#功能描述(Description):使用函数输出帮助信息.

function print_usage() {
    cat << EOF
Usage: --help | -h
  Print help information for script.
Usage: --memory | -m
  Monitor memory information.
Usage: --network | -n
  Monitor network interface information.
EOF
}

case $1 in
--memory|-m)
    free;;
--network|-n)
    ip -s link;;
--help|-h)
    print_usage;;
*)
    print_usage;;
esac
```


## 24.设置锁文件防止脚本重复执行
```shell
#!/bin/bash
#功能描述(Description):通过设置锁文件防止脚本重复执行.

#使用Ctrl+C中断脚本时,删除锁文件.
trap 'rm -rf /tmp/lockfile;exit' HUP INT

#检查是否存在锁文件,没有锁文件就执行backup备份函数,如果有锁文件脚本则脚本直接退出.
lock_check(){
    if (set -C; :> /tmp/lockfile) 2>/dev/null ;then
        backup
    else
        echo -e "\033[91mWarning:其他用户在执行该脚本.\033[0m"
        exit 66
    fi
}

#执行备份前创建所文件,然后执行备份数据库的操作,备份完成后删除锁文件.
#sleep 10实验测试时使用,为了防止小数据库备份太快,无法验证重复执行脚本的效果.
backup(){
    touch /tmp/lockfile
    mysqldump --all-database > /var/log/mysql-$(date +%Y%m%d).bak
    sleep 10
    rm -rf /tmp/lockfile
}

lock_check
backup
```

## 25.对一组url测试能否访问成功

```shell
#!/bin/bash

url_list=(  #定义一个包含三个网址的数组 url_list
http://www.baidu.com
https://www.shiyanlou.com
http://www.google.com
)

wait(){   #定义倒计时函数 wait
    echo -n 'wait 3 second...'
    for ((i=0;i<3;i++))
    do
        echo -n ".";sleep 1  #每隔1秒打印一个点
    done
    echo
}

check_url(){
    wait   # 调用已经定义的 wait 函数

    #循环遍历 url_list 中的地址
    for ((i=0;i<`echo ${#url_list[*]}`;i++))
    do

        #检测是否可以访问数组元素中的地址
        wget -o /dev/null -T 3 --tries=1 --spider ${url_list[$i]} >/dev/null 2>&1  #--tries是设置尝试次数，--spider检查网址，后面的>/dev/null 2>&1是不保留任何输出

        if [ $? -eq 0 ];then   #如果返回值为0则表示访问成功
            echo "${url_list[$i]} success"
        else
            echo "${url_list[$i]} false"
        fi
    done
}

main(){  #定义主函数，即入口函数，应用程序运行时首先执行的代码
        check_url   #调用定义的 check_url 函数
}


main    #调用主函数
```


## 26.MySQL单表数据同步脚本
```shell
#!/usr/bin/env bash
# Auth: liuli
# Version: v1.0, 2020/6/17
# Sys: CentOS 7.6
# Features: 用于同步研发数据库中的某些表至生产数据库

# set -xeuo pipefail

time=`date '+%Y-%m-%d-%H:%M'`
mkdir -p ./sql/${time}

db_Name="temp-tenant"
table_Name=(
interface_authority
interface_permissions
t_user_function_authority
t_user_function_permission
t_menu
)
# 研发环境
dev_IP="192.168.1.15"
dev_Port="3306"
dev_Pass="123456Aa."
# 生产环境
prod_IP="192.168.1.16"
prod_Port="23306"
prod_Pass="123456Aa."

# 导出研发环境的表
for i in ${table_Name[*]}
do
        mysqldump -h${dev_IP} -uroot -P${dev_Port} -p${dev_Pass} ${db_Name} ${i} > ./sql/${time}/dev.sql
done

# 导出生产环境的整个库
mysqldump -h${prod_IP} -uroot -P${prod_Port} -p${prod_Pass} ${db_Name} > ./sql/${time}/${db_Name}.sql

# 删除生产环境的表
for i in ${table_Name[*]}
do
        mysql -h${prod_IP} -uroot -P${prod_Port} -p${prod_Pass} -e "USE ${db_Name};DROP TABLE ${i}"
done

# 导入研发环境的表
mysql -h${prod_IP} -uroot -P${prod_Port} -p${prod_Pass} ${db_Name} < ./sql/${time}/dev.sql
```


## 27.shell实现多并发控制

### 不并发
```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh
shutdown_instance_array=($(nova list | grep SHUTOFF | awk -F "|" '{print $2}'))
shutdown_instance_Name=($(nova list | grep SHUTOFF | awk -F "|" '{print $3}'))
declare -A array_instance

# 设置关联数组
for i in ${!shutdown_instance_array[@]}; do array_instance[${shutdown_instance_Name[$i]}]=${shutdown_instance_array[$i]}; done

name_arry=(${!array_instance[@]}) #key -name
id_arry=(${array_instance[@]})    #value -id

for ((i = 0; i < ${#shutdown_instance_array[@]}; i++)); do
{
#     echo ${name_arry[$i]}
    map_dev=$(rbd map ${id_arry[$i]}_disk -p vms)
    echo -e "xfs_repair -L $map_dev > ${name_arry[$i]}.log 2>&1 &"
  } &
    sleep 1
done
wait

stop_time=$(date +%s) #定义脚本运行的结束时间
echo "TIME:`expr $stop_time - $start_time`"
```

### 控制并发



#### 示例1
```shell
#!/usr/bin/env bash
#usage: To repair the virtual machine hard disk, the virtual machine must be off
source /etc/kolla/admin-openrc.sh
start_time=$(date +%s)

Nproc=5

shutdown_instance_array=($(nova list | grep SHUTOFF | awk -F "|" '{print $2}'))
shutdown_instance_Name=($(nova list | grep SHUTOFF | awk -F "|" '{print $3}'))
declare -A array_instance

# 设置关联数组
for i in ${!shutdown_instance_array[@]}; do array_instance[${shutdown_instance_Name[$i]}]=${shutdown_instance_array[$i]}; done
name_arry=(${!array_instance[@]}) #key -name
id_arry=(${array_instance[@]})    #value -id


[ -e /tmp/fifo.$$ ] || mkfifo /tmp/fifo.$$
exec 3<>/tmp/fifo.$$
rm -f /tmp/fifo.$$

for ((i = 0; i < $Nproc; i++)); do
  echo >&3
done

for ((i = 0; i < ${#shutdown_instance_array[@]}; i++)); do
  {
    read -u3
    sleep 1
    echo "xfs_repair instamceName: ${name_arry[$i]} instamceID: ${id_arry[$i]} "
    device_name=$(rbd map ${id_arry[$i]}_disk -p vms)
    xfs_repair -L ${device_name} > ${name_arry[$i]}_$$.log 2>&1
    echo "instamceName: ${name_arry[$i]} instamceID: ${id_arry[$i]}" >> repairInformationSummary.log
    echo >&3 #执行到最后，把令牌放回管道

  }&
done
wait

stop_time=$(date +%s)
echo "TIME:$(expr $stop_time - $start_time)"

exec 3<&-
```


#### 示例2


```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh

thread=5
tmp_fifofile=/tmp/$$.fifo

mkfifo $tmp_fifofile
exec 8<> $tmp_fifofile
rm $tmp_fifofile

for i in `seq $thread`
do
    echo $i &> 8
done

for i in {1..245}
do
    read -u8
    {
        ip=192.168.122.$i
        ping -c1 -W1 $ip &>/dev/null
        if [ $? -eq 0 ];then
            echo "$ip is down!"
        else
            echo "$ip is up"
        fi
        echo $i >& 8
    }&
done
wait
exec 8 <&-
echo "all finished......"
```
#### 示例3
```shell
#!/bin/bash
date

DIR=/test/log/

FILE_NAME=65535_`date +"%Y%m%d"`;
FILE_NAME_LAST_DAY=`date -d "yesterday" +"%Y%m%d"`;

time_of_system=`date +"%Y-%m-%d"`

function multi_processor(){
    [ -e /tmp/fd1 ] || mkfifo /tmp/fd1
    exec 3<>/tmp/fd1
    rm -rf /tmp/fd1
    for ((i=1;i<=30;i++))
    do
        echo >&3
    done

    for file in $1
    do
    read -u3
    {
        grep $3 $file | awk -F"|" '{print $7}' | sort | uniq >> $2;
        echo >&3
    }&
    done
    wait

    exec 3<&-
    exec 3>&-
}

#register 1 day ago
register_file=register_file_1_day_ago_$HOSTNAME.txt
file_modify_time=`stat $register_file | grep Modify | awk '{print $2}'`
files_last_day=`find $DIR -type f -name "$FILE_NAME_LAST_DAY*"`
if [[ $file_modify_time != $time_of_system ]]; then
    echo "$register_file file_modify_time(${file_modify_time}) time_of_system(${time_of_system})"
    rm $register_file
    multi_processor "$files_last_day" "$register_file" "REGISTER"
fi
```

#### 示例4
```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh
# author：xiaojian

Njob=15 #任务总数

Nproc=5 #最大并发进程数

mkfifo ./fifo.$$ && exec 777<> ./fifo.$$ && rm -f ./fifo.$$ #通过文件描述符777访问fifo文件

for ((i=0; i<$Nproc; i++)); do #向fifo文件先填充等于Nproc值的行数

    echo "init time add $i" >&777

done

for ((i=0; i<$Njob; i++)); do

        {

        read -u 777 #从fifo文件读一行

        echo "progress $i is sleeping for 3 seconds zzz…"

        sleep 3

        echo "real time add $(($i+$Nproc))" >&777 #sleep完成后，向fifo文件重新写入一行

        } &

done

wait

exec 777 >&-
exec 777 <&-
echo -e "time-consuming: $SECONDS seconds"
```

#### 示例5
```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:${NAME}.sh
# author：xiaojian

CE_HOME="/data/ContentEnginne"
LOG_PATH="/data/logs"

# 控制爬虫数量为8
MAX_SPIDER_COUNT=8

count=`ps -ef|grep -v grep|grep run.py|wc -l`
try_time=0
cd $CE_HOME
while [ $count -lt $MAX_SPIDER_COUNT -a $try_time -lt $MAX_SPIDER_COUNT ]; do
    let try_time +=1
    python run.py >> ${LOG_PATH}/spider.log 2>&1 &
    count=`ps -ef|grep -v grep|grep run.py|wc -l`
done
```


#### 示例6

```shell
#!/bin/bash
#Version:3.0
#功能描述(Description):控制进程数量的ping测试脚本.
#使用wait命令等待所有子进程结束后再退出脚本.

num=10             #控制进程数量.
net="192.168.4"
pipefile="/tmp/multiping_$$.tmp"

multi_ping() {
    ping -c2 -i0.2 -W1 $1 &>/dev/null && echo "$1 is up." || echo "$1 is down."
}

#创建命名管道文件,创建其文件描述符,通过重定向导入数据到管道文件中.
mkfifo $pipefile
exec 12<>$pipefile
for i in $(seq $num)
do
    echo "" >&12 &
done

#通过循环反复调用函数并将其放入后台并行执行.
#成功读取命名管道中的数据后开启新的进程.
#所有内容读取完后read被阻塞,无法再启动新进程.
#等待前面启动的进程结束后,继续往管道文件中写入数据,释放阻塞,再次开启新的进程.
for j in {1..254}
do
    read -u12
    {
        multi_ping $net.$j
        echo "" >&12
    } &
done
wait
rm -rf $pipfile
```


## 28.一些常用的函数
```shell
#判断是否是false
is_false() {
    case "$1" in
    [fF] | [nN] | [nN][oO] | [fF][aA][lL][sS][eE] | 0)
        return 0
        ;;
    esac
    return 1
}

#判断进程是否运行
is_running()
{
    if [ -f $1 ]; then
        read pid < $1
        if [ -d "/proc/$pid" ]; then
            return 0
        fi
    fi
    return -1
}

#安装epel源
function _install_epel {
    # NOTE: We always remove and install latest -- some environments
    # use snapshot images, and if EPEL version updates they break
    # unless we update them to latest version.
    if sudo yum repolist enabled epel | grep -q 'epel'; then
        uninstall_package epel-release || true
    fi

    # This trick installs the latest epel-release from a bootstrap
    # repo, then removes itself (as epel-release installed the
    # "real" repo).
    #
    # You would think that rather than this, you could use
    # $releasever directly in .repo file we create below.  However
    # RHEL gives a $releasever of "6Server" which breaks the path;
    # see https://bugzilla.redhat.com/show_bug.cgi?id=1150759
    cat <<EOF | sudo tee /etc/yum.repos.d/epel-bootstrap.repo
[epel-bootstrap]
name=Bootstrap EPEL
mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=epel-7&arch=\$basearch
failovermethod=priority
enabled=0
gpgcheck=0
EOF
    # Enable a bootstrap repo.  It is removed after finishing
    # the epel-release installation.
    is_package_installed yum-utils || install_package yum-utils
    sudo yum-config-manager --enable epel-bootstrap
    yum_install epel-release || \
        die $LINENO "Error installing EPEL repo, cannot continue"
    sudo rm -f /etc/yum.repos.d/epel-bootstrap.repo
}

#记录日志的function
function fnLogInfo()
{
        local infomsg=$1
        echo ${infomsg}
        echo `date "${data_format}"` "Info:${infomsg}" >> ${log_file}
}


#备份文件的function
fnBackupBeforeModify()
{
        local file=$1
        local backupFile="${file}.bak"

        fnLogInfo "Start to backup file $file"

        cp ${file} -p ${backupFile}

        fnLogInfo "End to backup file $file"
}

# 1. change the network config as DHCP
# 2. delete the 70-persistent-net.rules file
fnModifyNetworkConfig()
{
        fnLogInfo "----------------------------------------"
        fnLogInfo "Start to modify the network configuration"

        local files=''

        #1. change the network config as DHCP
        case $os_type in

        #/etc/sysconfig/network-scripts
        "redhat")
        files="`ls /etc/sysconfig/network-scripts/ifcfg-eth* |grep -v .bak`"
        files="${files} `ls /etc/sysconfig/network-scripts/ifcfg-ens* |grep -v .bak`"
        for file in $files
        do
            fnLogInfo "Start to modify the network configuration: $file"
            #backup  the file
            fnBackupBeforeModify $file
            #modify the file
            sed -i '/PERSISTENT_DHCLIENT/d' $file
            sed -i '$a\PERSISTENT_DHCLIENT=yes' $file
            fnLogInfo "End to modify the network configuration: $file"
        done
        ;;

        #/etc/sysconfig/network/dhcp
        "suse")
        file='/etc/sysconfig/network/dhcp'

        #first backup file
        fnBackupBeforeModify $file

        sed -i "s/DHCLIENT_USE_LAST_LEASE=yes\|DHCLIENT_USE_LAST_LEASE='yes'\|DHCLIENT_USE_LAST_LEASE=\"yes\"/DHCLIENT_USE_LAST_LEASE=\"no\"/g" $file
        ;;

        #/etc/network/interfaces
        "debian" | "ubuntu")
        file='/etc/network/interfaces'

        #backup the file
        fnBackupBeforeModify $file

        sed -i "s/static\| manual/ dhcp/g" $file
        sed -i "s/address /#address /g" $file
        sed -i "s/netmask /#netmask /g" $file
        sed -i "s/gateway /#gateway /g" $file

        ;;

        *)
        fnLogInfo "Other Linux, network configuration cannot be modified."
        ;;
        esac

        #2. delete the 70-persistent-net.rules file
        rm -rf /etc/udev/rules.d/70-persistent-net.rules

        fnLogInfo "Delete 70-persistent-net.rules file, resut: $?"

        fnLogInfo "End to modify the network configuration"
}
#check OS的function
fnGetOSType()
{
        fnLogInfo "---------------------------"
        fnLogInfo "Start to get the os type"

        local version="/proc/version"
        if ! [ -e "${version}" ];then
            return 1
        elif [ -n "$(grep -i 'suse' ${version})" ];then
            os_type='suse'
        elif [ -n "$(grep -i 'ubuntu' ${version})" ];then
            os_type='ubuntu'
        elif [ -n "$(grep -i 'Red Hat' ${version})" ];then
            os_type='redhat'
                elif [ -n "$(grep -i 'debian' ${version})" ];then
            os_type='debian'
        fi


        fnLogInfo "End to get the os type: $os_type"
}

#输入选择Yes和No函数
YES_NO_choice(){
read -t 10 -p "Please input you commit ,wait 5.....to exit: " input

case $input in
    [yY]|[yY][eE][sS] )
        echo "YES!!!!!"
        ;;
    [nN]|[nN][oO] )
        echo "NO  Error!!!!!"
        ;;
        *)
        echo "============================"
        ;;

esac

#错误提示函数
die () {
    echo "ERROR: $1. Aborting!"
    exit 1
}

#判断用户输入如果没有输入，选择默认值 redis为例
_REDIS_PORT=6379
_MANUAL_EXECUTION=false     #标志信息
check_input_redis_port(){
if ! echo $REDIS_PORT | egrep -q '^[0-9]+$' ; then
    _MANUAL_EXECUTION=true      #重置标志信息
    #Read the redis port
    read  -p "Please select the redis port for this instance: [$_REDIS_PORT] " REDIS_PORT
    if ! echo $REDIS_PORT | egrep -q '^[0-9]+$' ; then
        echo "Selecting default: $_REDIS_PORT"
        REDIS_PORT=$_REDIS_PORT
    fi
fi
}


Get_OS_Bit()
{
    if [[ `getconf WORD_BIT` = '32' && `getconf LONG_BIT` = '64' ]] ; then
        Is_64bit='y'
    else
        Is_64bit='n'
    fi
}


Download_Files()
{
    local URL=$1
    local FileName=$2
    if [ -s "${FileName}" ]; then
        echo "${FileName} [found]"
    else
        echo "Notice: ${FileName} not found!!!download now..."
        wget -c --progress=bar:force --prefer-family=IPv4 --no-check-certificate ${URL}
    fi
}

#批量安装基础包
CentOS_Dependent()
{
    \cp /etc/yum.conf /etc/yum.conf.lnmp
    sed -i 's:exclude=.*:exclude=:g' /etc/yum.conf

    Echo_Blue "[+] Yum installing dependent packages..."
    for packages in make cmake gcc gcc-c++ gcc-g77 flex bison file libtool libtool-libs autoconf kernel-devel patch wget crontabs libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel libxml2 libxml2-devel zlib zlib-devel glib2 glib2-devel unzip tar bzip2 bzip2-devel libevent libevent-devel ncurses ncurses-devel curl curl-devel libcurl libcurl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel vim-minimal gettext gettext-devel ncurses-devel gmp-devel pspell-devel unzip libcap diffutils ca-certificates net-tools libc-client-devel psmisc libXpm-devel git-core c-ares-devel libicu-devel libxslt libxslt-devel xz;
    do yum -y install $packages; done

    mv -f /etc/yum.conf.lnmp /etc/yum.conf
}


#设置cron计划任务
Crontab_func(){
#!/bin/bash
cat  <<EOF > /var/spool/cron/root
*/30 * * * * sh /home/cheungssh/mysite/mysite/cheungssh/cheungssh_demo.sh 2>>/home/cheungssh/logs/demo.log  >> /home/cheungssh/logs/demo.log
EOF
}



#判断进程信息，杀掉进程
kill_Process(){
ps -fel|grep websocket_server_cheung.py|grep  -v "$$"|awk  '{print  $4}'|xargs -i kill  -9 {}
}

#获取MD5值
MD5_value(){
md5sum /etc/hosts |awk '{print $1}'

}

data_format="+%Y-%m-%d %H:%M:%S"

#记录日志的function
function fnLogInfo()
{
        local infomsg=$1
        echo ${infomsg}
        echo `date "${data_format}"` "Info:${infomsg}" >> ${log_file}
}


#scritps path
dir_path(){
pwd=`dirname $0`
}
```

## 30.猜随机数
```shell
#!/usr/bin/env bash
#usage:xxx
#scripts_name:xxx.sh
#取余的算法将随机数变为1-100之间
num=$[RANDOM%100+1]

#使用read捕获输入
#使用if判断
while True; do
    read -p "计算生成的一个1-100的随机数：" cai
    if [ $cai -eq $num ]; then
        echo "恭喜，猜对了"
    elif [ $cai -gt $num ]; then
        echo "oops，猜大了"
    else
        echo "oops，猜小了"
    fi
done
```


## 31.test多种写法

```shell
#!/usr/bin/env bash
FreeMem=`free -m|awk 'NR==3 {print $NF}'`
if (( $FreeMem < 1000 )); then
    echo "xxxxxxxxxx"
fi

if [[ $FreeMem -lt 1000 ]]; then
    echo "xxxxxxxx"
fi

if test $FreeMem -lt 1000; then
    echo "xxxxxxxxxxxx"
fi

if grep  /etc/passwd >/dev/null 2>&1; then
    echo "xxxxxxxxxx"
fi
```


## 32.换算秒为分钟、小时
```shell
#!/bin/bash

a=60100
swap_seconds ()
{
    SEC=$1
    (( SEC < 60 )) && echo -e "持续时间: $SEC秒\c"
    (( SEC >= 60 && SEC < 3600 )) && echo -e "持续时间: $(( SEC / 60 ))分钟$(( SEC % 60 ))秒\c"
    (( SEC > 3600 )) && echo -e "持续时间: $(( SEC / 3600 ))小时$(( (SEC % 3600) / 60 ))分钟$(( (SEC % 3600) % 60 ))秒\c"
}

b=`swap_seconds $a`
echo $b
```

输出

```
持续时间: 16小时41分钟40秒
```


## 33.脚本命令行参数的传递与判断

```shell
#!/bin/bash

main() {
    if [[ $# == 1 ]]; then
        case $1 in
        "-h")
            echo "脚本使用方法: "
            echo "  ./gitlab-pipeline.sh git仓库名1 git仓库名2 ... tag名(tag命名规则为: *-v加数字)"
            exit
            ;;
        "--help")
            echo "脚本使用方法: "
            echo "  ./gitlab-pipeline.sh git仓库名1 git仓库名2 ... tag名(tag命名规则为: *-v加数字)"
            exit
            ;;
        *)
            echo "参数错误！"
            exit
            ;;
        esac
    fi
}

main $*
```



## 34.检测docker容器的启动状态
```shell
# 第一步：判断镜像是否存在
if [ `docker images --format {{.Repository}}:{{.Tag}} |grep -Fx 192.168.1.7:32772/applications/$CI_PROJECT_NAME:${CI_COMMIT_SHORT_SHA};echo $?` -eq 0 ];then
   docker pull 192.168.1.7:32772/applications/$CI_PROJECT_NAME:$CI_COMMIT_SHORT_SHA ;
fi;
# 第二步：判断是否已经有重名的容器在运行或者处在其他状态。重名的，先删掉，在启动；不重名的直接启动
if [ `docker ps -a --format {{.Names}} |grep -Fx $CI_PROJECT_NAME > /dev/null ;echo $?` -eq 0 ] ;then
   docker rm -f $CI_PROJECT_NAME ;
   docker run -d --name $CI_PROJECT_NAME -p 30088:8080 192.168.1.7:32772/applications/$CI_PROJECT_NAME:$CI_COMMIT_SHORT_SHA ;
else
   docker run -d --name $CI_PROJECT_NAME -p 30088:8080 192.168.1.7:32772/applications/$CI_PROJECT_NAME:$CI_COMMIT_SHORT_SHA ;
fi;
# 第三步：循环五次判断容器的监控检测是否处于什么状态。健康状态就直接退出循环，不健康显示健康检查日志，正在启动的直接显示。处于其他状态的直接显示状态
n=0;
while true ;do
  container_state=`docker inspect --format='{{json .State.Health.Status}}' $CI_PROJECT_NAME`;
  case $container_state in
    '"starting"' )
      echo "应用容器正在启动！";
    ;;
    '"healthy"' )
      echo "应用容器已启动，状态健康！";
    break;
    ;;
    '"unhealthy"' )
      echo "应用容器健康检测失败！";
      docker inspect --format='{{json .State.Health.Log}}' $CI_PROJECT_NAME;
    ;;
    * )
      echo "未知的状态:$container_state";
    ;;
  esac;
  sleep 1s;
  n=$(($n+1));
  if [ $n -eq 5 ];
     then break ;
  fi ;
done
```


## 35.检查常见系统命令是否安装
```shell
check_command() {
    if ! command -v ifconfig >/dev/null 2>&1; then
        echo -e "\033[31mifconfig命令不存在，正在下载安装！\033[0m"
        if os="ubuntu"; then
            apt install -y net-tools >/dev/null 2>&1
        elif os="centos"; then
            yum install -y net-tools >/dev/null 2>&1
        elif os="fedora"; then
            dnf install -y net-tools >/dev/null 2>&1
        fi
    elif ! command -v ip >/dev/null 2>&1; then
        echo -e "\033[31mip命令不存在，正在下载安装！\033[0m"
        if os="ubuntu"; then
            apt install -y iproute2 >/dev/null 2>&1
        elif os="centos"; then
            yum install -y iproute2 >/dev/null 2>&1
        elif os="fedora"; then
            dnf install -y iproute2 >/dev/null 2>&1
        fi
    elif ! command -v curl >/dev/null 2>&1; then
        echo -e "\033[31mcurl命令不存在，正在下载安装！\033[0m"
        if os="ubuntu"; then
            apt install -y curl >/dev/null 2>&1
        elif os="centos"; then
            yum install -y curl >/dev/null 2>&1
        elif os="fedora"; then
            dnf install -y curl >/dev/null 2>&1
        fi
    elif ! command -v wget >/dev/null 2>&1; then
        echo -e "\033[31mawk命令不存在，正在下载安装！\033[0m"
        if os="ubuntu"; then
            apt install -y wget >/dev/null 2>&1
        elif os="centos"; then
            yum install -y wget >/dev/null 2>&1
        elif os="fedora"; then
            dnf install -y wget >/dev/null 2>&1
        fi
    elif ! command -v tail >/dev/null 2>&1; then
        echo -e "\033[31mcoreutils命令不存在，正在下载安装！\033[0m"
        if os="ubuntu"; then
            apt install -y coreutils >/dev/null 2>&1
        elif os="centos"; then
            yum install -y coreutils >/dev/null 2>&1
        elif os="fedora"; then
            dnf install -y coreutils >/dev/null 2>&1
        fi
    elif ! command -v sed >/dev/null 2>&1; then
        echo -e "\033[31msed命令不存在，正在下载安装！\033[0m"
        if os="ubuntu"; then
            apt install -y sed >/dev/null 2>&1
        elif os="centos"; then
            yum install -y sed >/dev/null 2>&1
        elif os="fedora"; then
            dnf install -y sed >/dev/null 2>&1
        fi
    elif ! command -v grep >/dev/null 2>&1; then
        echo -e "\033[31mgrep命令不存在，正在下载安装！\033[0m"
        if os="ubuntu"; then
            apt install -y grep >/dev/null 2>&1
        elif os="centos"; then
            yum install -y grep >/dev/null 2>&1
        elif os="fedora"; then
            dnf install -y grep >/dev/null 2>&1
        fi
    fi
}
```

## 36.发送钉钉通知

```shell
function sendDingDing(){
  Ding_Webhook_Token='钉钉机器人的WebHook Token'
  Ding_Webhook_keyword="可用作消息标题"
  send_result=$(curl -sS \
    -XPOST https://oapi.dingtalk.com/robot/send?access_token="$Ding_Webhook_Token" \
    -H 'Content-Type: application/json' \
    -d '{"msgtype": "markdown","markdown": {"title": "'$Ding_Webhook_Keyword'","text": "'"$*"'"},"at": {"isAtAll": true}}')
  if [ $(echo $send_result | jq -r '.errcode') -eq 0 ]; then
    echo "发送成功:  \n" $*" "
  else
    echo "发送失败:  \n" $*"\n"
    echo $send_result
  fi
}

sendDingDing  "$(date +"%F %H:%M:%S") 需要告警的消息"
```


## 37.function函数库

```shell
#!/usr/bin/env bash
# -*-Shell-script-*-
#
# functions This file contains functions to be used by most or all
#       shell scripts in the /etc/init.d directory.
#

:<<EOF

checkpid():检查是否已存在pid，如果有一个存在，返回0（通过查看/proc目录）

daemon():启动某个服务。/etc/init.d目录部分脚本的start使用到这个

killproc():杀死某个进程。/etc/init.d目录部分脚本的stop使用到这个

pidfileofproc():寻找某个进程的pid

pidofproc():类似上面的，只是还查找了pidof命令

status():返回一个服务的状态

echo_success():打印OK

echo_failure():打印FAILED

echo_passed():打印PASSED

echo_warning():打印WARNING

success():打印OK并记录日志

failure():打印FAILED并记录日志

passed():打印PASSED并记录日志

action():打印某个信息并执行给定的命令，它会根据命令执行的结果来调用 success,failure方法

strstr():判断$1是否含有$2

confirm():提示是否启动某个服务

is_ignored_file():检查$1文件是否是*.bak、*.orig、*.rpmnew....等文件

is_true()/is_false():交互式yes|no的选项

apply_sysctl()应用sysctl设置，包括/etc/sysctl.d中的文件

EOF


TEXTDOMAIN=initscripts

# Make sure umask is sane
umask 022

# Set up a default search path.
PATH="/sbin:/usr/sbin:/bin:/usr/bin"

#导出环境变量
export PATH


#判断PPID和字符串否为空
if [ $PPID -ne 1 -a -z "$SYSTEMCTL_SKIP_REDIRECT" ] && \
        [ -d /run/systemd/system ] ; then
    case "$0" in
    /etc/init.d/*|/etc/rc.d/init.d/*)
        _use_systemctl=1
        ;;
    esac
fi

systemctl_redirect () {
    local s
    local prog=${1##*/}
    local command=$2
    local options=""

    case "$command" in
    start)
        s=$"Starting $prog (via systemctl): "
        ;;
    stop)
        s=$"Stopping $prog (via systemctl): "
        ;;
    reload|try-reload)
        s=$"Reloading $prog configuration (via systemctl): "
        ;;
    restart|try-restart|condrestart)
        s=$"Restarting $prog (via systemctl): "
        ;;
    esac

    if [ -n "$SYSTEMCTL_IGNORE_DEPENDENCIES" ] ; then
        options="--ignore-dependencies"
    fi

    if ! systemctl show "$prog.service" > /dev/null 2>&1 || \
            systemctl show -p LoadState "$prog.service" | grep -q 'not-found' ; then
        action $"Reloading systemd: " /bin/systemctl daemon-reload
    fi

    action "$s" /bin/systemctl $options $command "$prog.service"
}

# Get a sane screen width
[ -z "${COLUMNS:-}" ] && COLUMNS=80

if [ -z "${CONSOLETYPE:-}" ]; then
    if [ -c "/dev/stderr" -a -r "/dev/stderr" ]; then
        CONSOLETYPE="$(/sbin/consoletype < /dev/stderr 2>/dev/null)"
    else
        CONSOLETYPE="serial"
    fi
fi

if [ -z "${NOLOCALE:-}" ] && [ -z "${LANGSH_SOURCED:-}" ] && \
        [ -f /etc/sysconfig/i18n -o -f /etc/locale.conf ] ; then
    . /etc/profile.d/lang.sh 2>/dev/null
    # avoid propagating LANGSH_SOURCED any further
    unset LANGSH_SOURCED
fi

# Read in our configuration
if [ -z "${BOOTUP:-}" ]; then
    if [ -f /etc/sysconfig/init ]; then
        . /etc/sysconfig/init
    else
        # This all seem confusing? Look in /etc/sysconfig/init,
        # or in /usr/share/doc/initscripts-*/sysconfig.txt
        BOOTUP=color
        RES_COL=60
        MOVE_TO_COL="echo -en \\033[${RES_COL}G"
        SETCOLOR_SUCCESS="echo -en \\033[1;32m"
        SETCOLOR_FAILURE="echo -en \\033[1;31m"
        SETCOLOR_WARNING="echo -en \\033[1;33m"
        SETCOLOR_NORMAL="echo -en \\033[0;39m"
        LOGLEVEL=1
    fi
    if [ "$CONSOLETYPE" = "serial" ]; then
        BOOTUP=serial
        MOVE_TO_COL=
        SETCOLOR_SUCCESS=
        SETCOLOR_FAILURE=
        SETCOLOR_WARNING=
        SETCOLOR_NORMAL=
    fi
fi

# Check if any of $pid (could be plural) are running
checkpid() {
    local i

    for i in $* ; do
        [ -d "/proc/$i" ] && return 0
    done
    return 1
}

__kill_pids_term_kill_checkpids() {
    local base_stime=$1
    shift 1
    local pid=
    local pids=$*
    local remaining=
    local stat=
    local stime=

    for pid in $pids ; do
        [ ! -e  "/proc/$pid" ] && continue
        read -r line < "/proc/$pid/stat" 2> /dev/null

        stat=($line)
        stime=${stat[21]}

        [ -n "$stime" ] && [ "$base_stime" -lt "$stime" ] && continue
        remaining+="$pid "
    done

    echo "$remaining"
    [ -n "$remaining" ] && return 1

    return 0
}

__kill_pids_term_kill() {
    local try=0
    local delay=3;
    local pid=
    local stat=($(< /proc/self/stat))
    local base_stime=${stat[21]}

    if [ "$1" = "-d" ]; then
        delay=$2
        shift 2
    fi

    local kill_list=$*

    kill_list=$(__kill_pids_term_kill_checkpids $base_stime $kill_list)

    [ -z "$kill_list" ] && return 0

    kill -TERM $kill_list >/dev/null 2>&1
    usleep 100000

    kill_list=$(__kill_pids_term_kill_checkpids $base_stime $kill_list)
    if [ -n "$kill_list" ] ; then
        while [ $try -lt $delay ] ; do
            sleep 1
            kill_list=$(__kill_pids_term_kill_checkpids $base_stime $kill_list)
            [ -z "$kill_list" ] && break
            let try+=1
        done
        if [ -n "$kill_list" ] ; then
            kill -KILL $kill_list >/dev/null 2>&1
            usleep 100000
            kill_list=$(__kill_pids_term_kill_checkpids $base_stime $kill_list)
        fi
    fi

    [ -n "$kill_list" ] && return 1
    return 0
}

# __proc_pids {program} [pidfile]
# Set $pid to pids from /var/run* for {program}.  $pid should be declared
# local in the caller.
# Returns LSB exit code for the 'status' action.
__pids_var_run() {
    local base=${1##*/}
    local pid_file=${2:-/var/run/$base.pid}
    local pid_dir=$(/usr/bin/dirname $pid_file > /dev/null)
    local binary=$3

    [ -d "$pid_dir" -a ! -r "$pid_dir" ] && return 4

    pid=
    if [ -f "$pid_file" ] ; then
            local line p

        [ ! -r "$pid_file" ] && return 4 # "user had insufficient privilege"
        while : ; do
            read line
            [ -z "$line" ] && break
            for p in $line ; do
                if [ -z "${p//[0-9]/}" ] && [ -d "/proc/$p" ] ; then
                    if [ -n "$binary" ] ; then
                        local b=$(readlink /proc/$p/exe | sed -e 's/\s*(deleted)$//')
                        [ "$b" != "$binary" ] && continue
                    fi
                    pid="$pid $p"
                fi
            done
        done < "$pid_file"

            if [ -n "$pid" ]; then
                    return 0
            fi
        return 1 # "Program is dead and /var/run pid file exists"
    fi
    return 3 # "Program is not running"
}

# Output PIDs of matching processes, found using pidof
__pids_pidof() {
    pidof -c -m -o $$ -o $PPID -o %PPID -x "$1" || \
        pidof -c -m -o $$ -o $PPID -o %PPID -x "${1##*/}"
}


# A function to start a program.
daemon() {
    # Test syntax.
    local gotbase= force= nicelevel corelimit
    local pid base= user= nice= bg= pid_file=
    local cgroup=
    nicelevel=0
    while [ "$1" != "${1##[-+]}" ]; do
        case $1 in
        '')
            echo $"$0: Usage: daemon [+/-nicelevel] {program}" "[arg1]..."
            return 1
            ;;
        --check)
            base=$2
            gotbase="yes"
            shift 2
            ;;
        --check=?*)
            base=${1#--check=}
            gotbase="yes"
            shift
            ;;
        --user)
            user=$2
            shift 2
            ;;
        --user=?*)
            user=${1#--user=}
            shift
            ;;
        --pidfile)
            pid_file=$2
            shift 2
            ;;
        --pidfile=?*)
            pid_file=${1#--pidfile=}
            shift
            ;;
        --force)
            force="force"
            shift
            ;;
        [-+][0-9]*)
            nice="nice -n $1"
            shift
            ;;
        *)
            echo $"$0: Usage: daemon [+/-nicelevel] {program}" "[arg1]..."
            return 1
            ;;
      esac
    done

    # Save basename.
    [ -z "$gotbase" ] && base=${1##*/}

    # See if it's already running. Look *only* at the pid file.
    __pids_var_run "$base" "$pid_file"

    [ -n "$pid" -a -z "$force" ] && return

    # make sure it doesn't core dump anywhere unless requested
    corelimit="ulimit -S -c ${DAEMON_COREFILE_LIMIT:-0}"

    # if they set NICELEVEL in /etc/sysconfig/foo, honor it
    [ -n "${NICELEVEL:-}" ] && nice="nice -n $NICELEVEL"

    # if they set CGROUP_DAEMON in /etc/sysconfig/foo, honor it
    if [ -n "${CGROUP_DAEMON}" ]; then
        if [ ! -x /bin/cgexec ]; then
            echo -n "Cgroups not installed"; warning
            echo
        else
            cgroup="/bin/cgexec";
            for i in $CGROUP_DAEMON; do
                cgroup="$cgroup -g $i";
            done
        fi
    fi

    # Echo daemon
    [ "${BOOTUP:-}" = "verbose" -a -z "${LSB:-}" ] && echo -n " $base"

    # And start it up.
    if [ -z "$user" ]; then
       $cgroup $nice /bin/bash -c "$corelimit >/dev/null 2>&1 ; $*"
    else
       $cgroup $nice runuser -s /bin/bash $user -c "$corelimit >/dev/null 2>&1 ; $*"
    fi

    [ "$?" -eq 0 ] && success $"$base startup" || failure $"$base startup"
}

# A function to stop a program.
killproc() {
    local RC killlevel= base pid pid_file= delay try binary=

    RC=0; delay=3; try=0
    # Test syntax.
    if [ "$#" -eq 0 ]; then
        echo $"Usage: killproc [-p pidfile] [ -d delay] {program} [-signal]"
        return 1
    fi
    if [ "$1" = "-p" ]; then
        pid_file=$2
        shift 2
    fi
    if [ "$1" = "-b" ]; then
        if [ -z $pid_file ]; then
            echo $"-b option can be used only with -p"
            echo $"Usage: killproc -p pidfile -b binary program"
            return 1
        fi
        binary=$2
        shift 2
    fi
    if [ "$1" = "-d" ]; then
        delay=$(echo $2 | awk -v RS=' ' -v IGNORECASE=1 '{if($1!~/^[0-9.]+[smhd]?$/) exit 1;d=$1~/s$|^[0-9.]*$/?1:$1~/m$/?60:$1~/h$/?60*60:$1~/d$/?24*60*60:-1;if(d==-1) exit 1;delay+=d*$1} END {printf("%d",delay+0.5)}')
        if [ "$?" -eq 1 ]; then
            echo $"Usage: killproc [-p pidfile] [ -d delay] {program} [-signal]"
            return 1
        fi
        shift 2
    fi


    # check for second arg to be kill level
    [ -n "${2:-}" ] && killlevel=$2

    # Save basename.
    base=${1##*/}

    # Find pid.
    __pids_var_run "$1" "$pid_file" "$binary"
    RC=$?
    if [ -z "$pid" ]; then
        if [ -z "$pid_file" ]; then
            pid="$(__pids_pidof "$1")"
        else
            [ "$RC" = "4" ] && { failure $"$base shutdown" ; return $RC ;}
        fi
    fi

    # Kill it.
    if [ -n "$pid" ] ; then
        [ "$BOOTUP" = "verbose" -a -z "${LSB:-}" ] && echo -n "$base "
        if [ -z "$killlevel" ] ; then
            __kill_pids_term_kill -d $delay $pid
            RC=$?
            [ "$RC" -eq 0 ] && success $"$base shutdown" || failure $"$base shutdown"
        # use specified level only
        else
            if checkpid $pid; then
                kill $killlevel $pid >/dev/null 2>&1
                RC=$?
                [ "$RC" -eq 0 ] && success $"$base $killlevel" || failure $"$base $killlevel"
            elif [ -n "${LSB:-}" ]; then
                RC=7 # Program is not running
            fi
        fi
    else
        if [ -n "${LSB:-}" -a -n "$killlevel" ]; then
            RC=7 # Program is not running
        else
            failure $"$base shutdown"
            RC=0
        fi
    fi

    # Remove pid file if any.
    if [ -z "$killlevel" ]; then
        rm -f "${pid_file:-/var/run/$base.pid}"
    fi
    return $RC
}

# A function to find the pid of a program. Looks *only* at the pidfile
pidfileofproc() {
    local pid

    # Test syntax.
    if [ "$#" = 0 ] ; then
        echo $"Usage: pidfileofproc {program}"
        return 1
    fi

    __pids_var_run "$1"
    [ -n "$pid" ] && echo $pid
    return 0
}

# A function to find the pid of a program.
pidofproc() {
    local RC pid pid_file=

    # Test syntax.
    if [ "$#" = 0 ]; then
        echo $"Usage: pidofproc [-p pidfile] {program}"
        return 1
    fi
    if [ "$1" = "-p" ]; then
        pid_file=$2
        shift 2
    fi
    fail_code=3 # "Program is not running"

    # First try "/var/run/*.pid" files
    __pids_var_run "$1" "$pid_file"
    RC=$?
    if [ -n "$pid" ]; then
        echo $pid
        return 0
    fi

    [ -n "$pid_file" ] && return $RC
    __pids_pidof "$1" || return $RC
}

status() {
    local base pid lock_file= pid_file= binary=

    # Test syntax.
    if [ "$#" = 0 ] ; then
        echo $"Usage: status [-p pidfile] {program}"
        return 1
    fi
    if [ "$1" = "-p" ]; then
        pid_file=$2
        shift 2
    fi
    if [ "$1" = "-l" ]; then
        lock_file=$2
        shift 2
    fi
    if [ "$1" = "-b" ]; then
        if [ -z $pid_file ]; then
            echo $"-b option can be used only with -p"
            echo $"Usage: status -p pidfile -b binary program"
            return 1
        fi
        binary=$2
        shift 2
    fi
    base=${1##*/}

    if [ "$_use_systemctl" = "1" ]; then
        systemctl status ${0##*/}.service
        ret=$?
        # LSB daemons that dies abnormally in systemd looks alive in systemd's eyes due to RemainAfterExit=yes
        # lets adjust the reality a little bit
        if systemctl show -p ActiveState ${0##*/}.service | grep -q '=active$' && \
        systemctl show -p SubState ${0##*/}.service | grep -q '=exited$' ; then
            ret=3
        fi
        return $ret
    fi

    # First try "pidof"
    __pids_var_run "$1" "$pid_file" "$binary"
    RC=$?
    if [ -z "$pid_file" -a -z "$pid" ]; then
        pid="$(__pids_pidof "$1")"
    fi
    if [ -n "$pid" ]; then
        echo $"${base} (pid $pid) is running..."
        return 0
    fi

    case "$RC" in
    0)
        echo $"${base} (pid $pid) is running..."
        return 0
        ;;
    1)
        echo $"${base} dead but pid file exists"
        return 1
        ;;
    4)
        echo $"${base} status unknown due to insufficient privileges."
        return 4
        ;;
    esac
    if [ -z "${lock_file}" ]; then
        lock_file=${base}
    fi
    # See if /var/lock/subsys/${lock_file} exists
    if [ -f /var/lock/subsys/${lock_file} ]; then
        echo $"${base} dead but subsys locked"
        return 2
    fi
    echo $"${base} is stopped"
    return 3
}

echo_success() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    echo -n "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
    echo -n $"  OK  "
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo -n "]"
    echo -ne "\r"
    return 0
}

echo_failure() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    echo -n "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
    echo -n $"FAILED"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo -n "]"
    echo -ne "\r"
    return 1
}

echo_passed() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    echo -n "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
    echo -n $"PASSED"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo -n "]"
    echo -ne "\r"
    return 1
}

echo_warning() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    echo -n "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
    echo -n $"WARNING"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo -n "]"
    echo -ne "\r"
    return 1
}

# Inform the graphical boot of our current state
update_boot_stage() {
    if [ -x /bin/plymouth ]; then
        /bin/plymouth --update="$1"
    fi
    return 0
}

# Log that something succeeded
success() {
    [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_success
    return 0
}

# Log that something failed
failure() {
    local rc=$?
    [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_failure
    [ -x /bin/plymouth ] && /bin/plymouth --details
    return $rc
}

# Log that something passed, but may have had errors. Useful for fsck
passed() {
    local rc=$?
    [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_passed
    return $rc
}

# Log a warning
warning() {
    local rc=$?
    [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_warning
    return $rc
}

# Run some action. Log its output.
action() {
    local STRING rc

    STRING=$1
    echo -n "$STRING "
    shift
    "$@" && success $"$STRING" || failure $"$STRING"
    rc=$?
    echo
    return $rc
}

# returns OK if $1 contains $2
strstr() {
    [ "${1#*$2*}" = "$1" ] && return 1
    return 0
}

# Check whether file $1 is a backup or rpm-generated file and should be ignored
is_ignored_file() {
    case "$1" in
    *~ | *.bak | *.orig | *.rpmnew | *.rpmorig | *.rpmsave)
        return 0
        ;;
    esac
    return 1
}

# Evaluate shvar-style booleans
is_true() {
    case "$1" in
    [tT] | [yY] | [yY][eE][sS] | [tT][rR][uU][eE] | 1)
        return 0
        ;;
    esac
    return 1
}

# Evaluate shvar-style booleans
is_false() {
    case "$1" in
    [fF] | [nN] | [nN][oO] | [fF][aA][lL][sS][eE] | 0)
        return 0
        ;;
    esac
    return 1
}

# Apply sysctl settings, including files in /etc/sysctl.d
apply_sysctl() {
    if [ -x /lib/systemd/systemd-sysctl ]; then
    /lib/systemd/systemd-sysctl
    else
        for file in /usr/lib/sysctl.d/*.conf ; do
            is_ignored_file "$file" && continue
            [ -f /run/sysctl.d/${file##*/} ] && continue
            [ -f /etc/sysctl.d/${file##*/} ] && continue
            test -f "$file" && sysctl -e -p "$file" >/dev/null 2>&1
        done
        for file in /run/sysctl.d/*.conf ; do
            is_ignored_file "$file" && continue
            [ -f /etc/sysctl.d/${file##*/} ] && continue
            test -f "$file" && sysctl -e -p "$file" >/dev/null 2>&1
        done
        for file in /etc/sysctl.d/*.conf ; do
            is_ignored_file "$file" && continue
            test -f "$file" && sysctl -e -p "$file" >/dev/null 2>&1
        done
        sysctl -e -p /etc/sysctl.conf >/dev/null 2>&1
    fi
}

# A sed expression to filter out the files that is_ignored_file recognizes
__sed_discard_ignored_files='/\(~\|\.bak\|\.orig\|\.rpmnew\|\.rpmorig\|\.rpmsave\)$/d'

if [ "$_use_systemctl" = "1" ]; then
        if  [ "x$1" = xstart -o \
              "x$1" = xstop -o \
              "x$1" = xrestart -o \
              "x$1" = xreload -o \
              "x$1" = xtry-restart -o \
              "x$1" = xforce-reload -o \
              "x$1" = xcondrestart ] ; then

        systemctl_redirect $0 $1
        exit $?
    fi
fi

strstr "$(cat /proc/cmdline)" "rc.debug" && set -x
return 0
```



## 38.Bash 公共库

### 1.Bash Shell Function Library

项目地址：https://github.com/SkypLabs/bsfl



Bash Shell Function Library 是一个短小精炼的 Bash 公共库，他提供了诸如

- 数组操作
- 命令执行
- 文件管理
- 日志记录
- 信息提醒
- 网络检测
- 字符操作
- 时间操作
- 变量操作

等等功能，帮助运维工程师快速完成自己的脚本编写工作。


此外，Bash Shell Function Library 还提供了一个完整的[在线文档](https://skyplabs.github.io/bsfl/modules.html)，帮助你了解函数库中提供的重要函数。



**使用方法**

从 https://github.com/SkypLabs/bsfl 上下载仓库，并获取其中的 bsfl.sh 即可在自己的代码中引用。


示例代码

```sh
#!/usr/bin/env bash
# -*- tab-width: 4; encoding: utf-8 -*-

# 定义只读变量
declare -r DIR=$(cd "$(dirname "$0")" && pwd)
source $DIR/../lib/bsfl.sh

# --------------------
msg "This is a classic displayed message using the 'msg' function."
echo
```



### 2.Bash Lib

项目地址：http://aks.github.io/bash-lib


Bash Lib 是一个原子化的公共库，你可以根据自己的实际需要，引入所需的公共库分组，
使用相应的内容，降低整个项目的大小。




Bash Lib 提供了诸多原子库，你选择需要使用的引入即可：

- 参数处理：arg-utils
- 日历处理： calendar-utils
- 日期处理：date-utils
- Hash 处理：hash-utils
- 帮助处理：help-util
- 列表处理：list-utils
- 交互处理：prompt-colors
- 文字处理：text-utils
- 测试处理：test-utils
- 时间处理：time-utils
- ...



**使用方法**

从 https://github.com/aks/bash-lib 下载仓库，并选择你需要引入的脚本，复制到项目目录下，并进行引用即可。


示例代码

```sh
#!/usr/bin/env bash
source text-utils.sh
lowercase "HELLOWORLD"
```

### 3.Shell(Bash)库函数

some useful lib function for bash(一些有用的shell函数库)

https://github.com/malongshuai/shell_libs





### 4.bash-libs


bash脚本封装的一些函数库, 日志(彩色, 分级打印), 字符串处理, 时间日期格式化, 以及多线程等, 以实现类似高级语言的功能

https://github.com/generals-space/bash-libs