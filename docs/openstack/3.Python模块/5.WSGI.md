# 5.WSGI

## 1.RESTful API介绍


RESTful是目前流行的一种互联网软件架构。REST（Representational State Transfer）表述状态转移，最早是由Roy Thomas Fielding在他2000年的博士论文中提出的，定义了他对互联网软件的架
构原则，如果一个架构符合REST原则，就称它为RESTful架构。


RESTful架构的一个核心概念是“资源”（resource）。从RESTful的角度看，网络里的任何东西都是资源，它可以是一段文本、一张图片、一首歌曲、一种服务等，每个资源都对应一个特定的
URL（统一资源定位符）并用它进行标示，访问这个URL就可以获得这个资源。


资源可以有多种具体表现形式，也就是资源的“表述”（representation），例如，一张图片可以使用JPEG格式，也可以使用PNG格式。URL只是代表了资源的实体，并不能代表它的表现形式。


在互联网中，客户端和服务端之间进行互动传递的就只是资源的表述，我们上网的过程就是调用资源的URL，获取它不同表现形式的过程。这个互动只能使用无状态协议HTTP，也就是说，服务端必须
保存所有的状态，客户端可以使用HTTP的几个基本操作，包括GET（获取）、POST（创建）、PUT（更新）、DELETE（删除），使服务端上的资源发生状态转化（State Transfer），也就是所谓的“表
述性状态转移”。


OpenStack各个项目都提供了RESTful架构的API作为对外提供的接口，而RESTful架构的核心是资源与资源上的操作，也就是说，OpenStack定义了很多的资源，并实现了针对这些资源的各种操作函
数。

OpenStack的API服务进程接收到客户端的HTTP请求时，一个所谓的“路由”模块会将请求的URL转换成相应的资源，并路由到合适的操作函数上。


OpenStack中所使用的路由模块Routes源自于对Rails（Ruby on Rails）路由系统的重新实现。Rails是Ruby语言的Web开发框架，采用MVC（Model-View-Controller）模式，收到浏览器发出的
HTTP请求后，Rails路由系统会将这个请求指派到对应的Controller，可以参考如下的网址：http://routes.readthedocs.org。



## 2.简单的WSGI

Python内置了一个WSGI服务器，这个模块称为wsgiref，它是用纯Python编写的WSGI服务器的参考实现。

所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。


```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-


def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [('<h1>Hello World</h1>').encode('utf-8')]


if __name__ == '__main__':
    from wsgiref.simple_server import make_server

    httpd = make_server('localhost', 8080, application)
    print('Server HTTP on port 8080...')
    print('http://localhost:8080/')
    httpd.serve_forever()
```

如果觉得这个Web应用太简单了，可以稍微改造一下，从environ里读取PATH_INFO，这样可以显示更加动态的内容：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-


def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    body = '<h1>Hello, %s!</h1>' % (environ['PATH_INFO'][1:] or 'web')
    return [body.encode('utf-8')]


if __name__ == '__main__':
    from wsgiref.simple_server import make_server

    httpd = make_server('localhost', 8888, application)
    print('Server HTTP on port 8888...')
    print('http://localhost:8888/')
    httpd.serve_forever()
```


参考文献

https://www.liaoxuefeng.com/wiki/1016959663602400/1017805733037760



## 3.Middleware中间件

带过滤器的WSGI服务代码如下：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-


def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'<h1>Hello World!</h1>']


class FilterMiddleware:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        # Do some filtering before calling the actual application
        if 'admin' in environ.get('PATH_INFO', ''):
            start_response('403 Forbidden', [('Content-Type', 'text/html')])
            return [b'<h1>Access Forbidden</h1>']
        return self.app(environ, start_response)


if __name__ == '__main__':
    from wsgiref.simple_server import make_server

    filtered_app = FilterMiddleware(application)

    httpd = make_server('localhost', 8080, filtered_app)
    print('Server HTTP on port 8080...')
    print('http://localhost:8080/')
    httpd.serve_forever()
```

可以添加多个Middleware中间件，举例如下：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [b'<h1>Hello World!</h1>']


class FilterMiddleware:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        # Do some filtering before calling the actual application
        if 'admin' in environ.get('PATH_INFO', ''):
            start_response('403 Forbidden', [('Content-Type', 'text/html')])
            return [b'<h1>Access Forbidden</h1>']
        return self.app(environ, start_response)


class DaemonMiddleware:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        # Do something as a daemon middleware
        print('Daemon middleware processing...')
        return self.app(environ, start_response)


if __name__ == '__main__':
    from wsgiref.simple_server import make_server

    filtered_app = FilterMiddleware(application)
    filtered_daemon_app = DaemonMiddleware(filtered_app)

    httpd = make_server('localhost', 8080, filtered_daemon_app)
    print('Server HTTP on port 8080...')
    print('http://localhost:8080/')
    httpd.serve_forever()
```





## 4.PasteDeploy和Routes的API框架

Paste Deploy是一个WSGI工具包，对WSGI进行了一些包装，使之更易使用。

OpenStack使用Paste的Deploy组件(htp:pythonpaste.org/deploy/)来完成WSGI服务
器和应用的构建，每个项目源码的 etc 目录下都有一个Paste配置文件，比如Nova中的 `etc/nova/api-paste.ini`,部署时，这些配置文件会被复制到系统/etc/project>/目录下。

PasteDeploy的工作便是基于这些配置文件。

其主要用于通过一个配置文件完成WSGI应用和服务器的构建。

配置文件示例

```ini
# config.ini 
 
[composite:main]
# use表明具体的分发方式
# egg:Paste#urlmap表示使用paste包中的urlmap模块
use = egg:Paste#urlmap     
# key=value表示使用urlmap进行分发的参数
/ = home
/wiki = wiki
/blog = blog
/cms = config:cms.ini
 
[app:home]
# use指定app
# python egg
use = egg:Paste#static
 
[app:app2]
# config.ini
use = config:myconfig.ini#app_name
 
[app:app3]
# 直接调用另外一个模块中的app
use = call:myproject:application
 
[app:app4]
# 另外一个section
use = myotherapp
 
[app:app5]
# myapp.modulename
paste.app_factory = myapp.modulename:app_factory
 
[filter-app:blog]
# use指定过滤条件
use = egg:Authentication#auth
# next表示过滤后的app
next = blogapp
roles = admin
htpasswd = /home/me/users.htpasswd
 
[pipeline:main]
pipeline = filter1 egg:FilterEgg#filter2 filter3 app
 
[filter:filter1]
...
```

灵活但不易用：基于PasteDeploy + Routes的 API框架

参考文献：

https://blog.csdn.net/hbeth/article/details/106423928



## 5.WebOb

WebOb是一个Python的包，它主要的作用是对WSGI的request进行修饰，以及帮助生成WSGI的response。

webob对WSGI请求与响应进行封装

`webob.Request`

  - 对WSGI请求的environ参数进行封装

`webob.Response`

  - 包含所有标准WSGI响应要素

`webob.exc`

  - 封装HTTP错误代码

`webob.dec.wsgify`

  - 封装WSGI参数和返回格式


- 标准WSGI格式

```python
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return '<h1>Hello</h1>'
```

- webob.dec.wsgify封装格式

```python
@webob.dec.wsgify
def application(req):
    return webob.Response('OK')
```



### 5.1 简单示例

下面的例子实现一个8080端口的wed功能，并返回简单的信息。

`api-paste.ini`

```ini
[app:main]
paste.app_factory = wsgi_webob:app_factory
```

`wsgi_webob.py`

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from webob import Response
from webob.dec import wsgify
from paste import httpserver
from paste.deploy import loadapp
import os

INI_PATH = os.path.dirname(os.path.abspath(__file__)) + '/api-paste.ini'


@wsgify
def application(req):
    print(req.body)
    print(req.params)
    return Response('Hello, World of WebOb !')


def app_factory(global_config, **local_config):
    return application


if __name__ == '__main__':
    wsgi_app = loadapp('config:' + INI_PATH)
    httpserver.serve(wsgi_app, host='0.0.0.0', port=8080)
```

### 5.2 添加自己的中间件

添加了认证中间件，并使用基本认证（Basic Authentication）进行用户认证.

上面的示例非常简单，现在增加一个认证的中间件“filter”，将代码逻辑设置为只有通过认证的用户才能返回结果，代码实现如下:

`api-paste.ini`

```ini
[pipeline:main]
pipeline = auth hello
[app:hello]
paste.app_factory = wsgi_webob_mid:app_factory
[filter:auth]
paste.filter_factory = wsgi_webob_mid:filter_factory
```


`wsgi_webob_mid.py`

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from webob import Response
from webob.dec import wsgify
from webob import exc
from paste import httpserver
from paste.deploy import loadapp
import os

INI_PATH = os.path.dirname(os.path.abspath(__file__)) + '/api-paste.ini'


@wsgify
def application(req):
    print(req.body)
    print(req.params)
    return Response('Hello, World of WebOb !')


def app_factory(global_config, **local_config):
    return application


@wsgify.middleware
def auth_filter(req, app):
    if req.headers.get('X-Auth') != '1234':
        return exc.HTTPForbidden()
    return app(req)


def filter_factory(global_config, **local_config):
    return auth_filter


if __name__ == '__main__':
    wsgi_app = loadapp('config:' + INI_PATH)
    httpserver.serve(wsgi_app, host='0.0.0.0', port=8080)
```


### 5.3 其他特性

WebOb本身也是WSGI标准的一种实现，但具有自己的一些特性：
- 完全可以只使用WebOb构建WSGI应用。
- 提供了更好的处理。
- 对JSON提供了良好支持。


## 6.routes模块
### 6.1 routes模块概述

OpenStack中所使用的路由模块routes源自于对Rails路由系统的重新实现。Rails是Ruby语言的Web开发框架，采用MVC模式，收到浏览器发出的HTTP请求后，Rails路由系统会将这个请求指派到对应的Controller。


### 6.2 使用示例

下面用示例简单了解routes模块的使用方法。

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from wsgiref.simple_server import make_server
import routes.middleware
import webob.dec
import webob.exc


class Controller:
    @webob.dec.wsgify
    def __call__(self, req):
        print("Received request:", req)
        return webob.Response("Hello World!")


class Routes(object):
    def __init__(self):
        self._mapper = routes.Mapper()
        self._mapper.connect('/spch',
                             controller=Controller(),
                             action='index',
                             conditions={'method': ['GET']})
        self._router = routes.middleware.RoutesMiddleware(self._dispatch, self._mapper)

    @webob.dec.wsgify
    def __call__(self, req):
        return self._router

    @staticmethod
    @webob.dec.wsgify
    def _dispatch(req):
        match = req.environ['wsgiorg.routing_args'][1]
        if not match:
            return webob.exc.HTTPNotFound()
        app = match['controller']
        return app


if __name__ == '__main__':
    app = Routes()
    httpd = make_server('localhost', 8282, app)
    print("Serving on port 8282...")
    print("·http://localhost:8282/spch")
    httpd.serve_forever()
```

访问如下：

`http://localhost:8282/spch`



### 6.3 WSGI+pastedeploy+webob

`tsroutes.ini`
```ini
# tsroutes.ini

[composite:main]
use = egg:Paste#urlmap
/ = show

[pipeline:show]
pipeline = root

[app:root]
paste.app_factory = tsroutes:Router.app_factory
```


`tsroutes.py`
```python
# tsroutes.py

import logging
import os

import webob.dec
import webob.exc

from paste.deploy import loadapp
from wsgiref.simple_server import make_server

import routes.middleware

LOG = logging.getLogger(__name__)


class Controller(object):
    @webob.dec.wsgify
    def __call__(self, req):
        arg_dict = req.environ['wsgiorg.routing_args'][1]
        action = arg_dict.pop('action')

        return webob.Response('OK, %s' % action)

    def getMessage(self, context, user_id):
        return {'Message': 'TestMessage'}


class Router(object):
    def __init__(self):
        self._mapper = routes.Mapper()
        self._mapper.connect('/test/{user_id}',
                             controller=Controller(),
                             action='getMessage',
                             conditions={'method': ['GET']})
        self._router = routes.middleware.RoutesMiddleware(self._dispatch, self._mapper)

    @webob.dec.wsgify
    def __call__(self, req):
        return self._router

    @staticmethod
    @webob.dec.wsgify
    def _dispatch(req):
        match = req.environ['wsgiorg.routing_args'][1]

        if not match:
            return webob.exc.HTTPNotFound()

        app = match['controller']
        return app

    @classmethod
    def app_factory(cls, global_config, **local_config):
        return cls()


if __name__ == '__main__':
    configfile = 'tsroutes.ini'
    appname = "main"
    wsgi_app = loadapp("config:%s" % os.path.abspath(configfile), appname)
    httpd = make_server('localhost', 8282, wsgi_app)
    print('Serving on port 8282...')
    print("http://localhost:8282/test/123")
    httpd.serve_forever()
```


测试访问：`http://localhost:8282/test/123`


参考文献：

https://blog.csdn.net/hbeth/article/details/106423928


## 7.综合实例

有这样一个虚拟机管理的WSGI服务。用户可以通过发送HTTP请求来实现对虚拟机的管理（包括创建、查询、更新以及删除虚拟机等操作）。

当然，为了简单起见，这个WSGI服务不会真在物理机上创建虚拟机，只是在服务中保存相应的虚拟机记录而已。

RESTful API提供了一套URL的规则，在本节的示例中也须满足这样的规则。

在RESTful API中，每条URL都是与资源相对应的。一个资源，可能是一个集合，也可能是一个个体。

集合通常用集合的标志。例如，在本节的示例中，使用instances表示虚拟机的集合，而个体通常用统一的ID标示。例如，在示例中使用UUID来标示虚拟机。

对集合的操作通常有虚拟机的添加和查询；对个体的操作通常有虚拟机的查询、删除和更新。它们对应的URL如表


|类型|URL|方法|描述|
|----|----|----|----|
|获取集合所有|/instances|GET|列出集合中的所有虚拟机记录|
|添加集合一条记录|/instances|POST|添加一条虚拟机记录|
|获取集合一条记录|/instances/{instance_id}|GET|获取一条虚拟机记录的信息|
|更新集合一条记录|/instances/{instance_id}|PUT|更新一条虚拟机记录的信息|
|删除集合一条记录|/instances/{instance_id}|DELETE|删除一条虚拟机记录|

`{instance_id}`是虚拟机的UUID。

将资源的ID放在URL中，是RESTful API的一大特点。


在WSGI中，要实现URL映射，主要依赖于Mapper和Controller两个类。Mapper类，顾名思义，是用于实现URL的映射。

当用户发送请求时，Mapper类会根据用户请求的URL及其方法来确定处理的方法。

而Controller类，则是实现了处理HTTP请求的各种方法。

Mapper类是routes包中定义好的类，而Controller类需要自己实现。




## 8.Pecan的API框架

随着OpenStack项目的发展，Paste组合框架的Restful API代码的弊端也渐渐显现，代码过于臃肿，导致项目的可维护性变差。

为了解决这个问题，一些新项目选了Pecan框架来实现Restful API。

Pecan是一个轻量级的WSGI网络框架，其设计并不想解决Web世界的所有问题，而是主要集中在对象路由和Restful支持上，并不提供对话(session)和数据库支持，用户可以自由选择其他模块与之组合。
