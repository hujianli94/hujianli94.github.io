# 18.Python 标准库

什么是标准库？
在 Python 发行版中包含一系列非常有用的模块，这些模块也称为标准库；Python 模块是一个 Python 文件，以.py 结尾，包含了 Python 对象定义和语句。

模块让你能够有逻辑地组织代码，让你的代码更易懂、可复用。

标准库如何使用？

这些模块可以立刻使用，无需额外安装。
Python 的标准库应用非常广泛，提供了一系列功能帮助解决日常编程，非常有必要学习下，为后面应用开发打好基础。

- 官方文档：https://docs.python.org/zh-cn/3.8/library/index.html

- python 标准库概括：https://www.yuque.com/zukxu/python/fqdg34#MDbS1

Python 数组列举了常用标准库。

```python
python_modules = [
  "os --- 多种操作系统接口",
  "os.path --- 常用路径操作",
  "re --- 正则表达式操作",
  "datetime --- 基本日期和时间类型",
  "heapq --- 堆队列算法",
  "enum --- 对枚举的支持",
  "math --- 数学函数",
  "random --- 生成伪随机数",
  "itertools --- 为高效循环而创建迭代器的函数",
  "functools --- 高阶函数和可调用对象上的操作",
  "shutil --- 高阶文件操作",
  "sqlite3 --- SQLite 数据库 DB-API 2.0 接口模块",
  "csv --- CSV 文件读写",
  "hashlib --- 安全哈希与消息摘要",
  "hmac --- 基于密钥的消息验证",
  "time --- 时间的访问和转换",
  "argparse --- 命令行选项、参数和子命令解析器",
  "logging --- Python 的日志记录工具",
  "threading --- 基于线程的并行",
  "multiprocessing --- 基于进程的并行",
  "socket --- 底层网络接口",
  "email --- 电子邮件与 MIME 处理包",
  "json --- JSON 编码和解码器",
  "urllib --- URL 处理模块",
  "http --- HTTP 模块"
]
```

## 1.os

os 模块主要对目录或文件操作。
os 模块以下常用方法：

| 方法                            | 描述                                        | 示例                                                                     |
| ------------------------------- | ------------------------------------------- | ------------------------------------------------------------------------ |
| os.name                         | 返回操作系统类型                            | 返回值"posix"代表 linux，"nt"代表 windows。sys.platform 有更详细的描述。 |
| os.environ                      | 以字典形式返回系统变量                      | 返回家目录：<br> >>> os.environ['HOME']                                  |
| os.getcwd()                     | 返回当前工作目录的路径                      | >>> os.getcwd()                                                          |
| os.chdir(path)                  | 改变当前工作目录到指定路径                  | >>> os.chdir('/path/to/directory')                                       |
| os.listdir(path='.')            | 返回指定目录下的所有文件和目录名            | >>> os.listdir('/path/to/directory')                                     |
| os.mkdir(path)                  | 创建一个目录                                | >>> os.mkdir('/path/to/new/directory')                                   |
| os.remove(path)                 | 删除一个文件                                | >>> os.remove('/path/to/file')                                           |
| os.rmdir(path)                  | 删除一个目录                                | >>> os.rmdir('/path/to/directory')                                       |
| os.path.exists(path)            | 判断指定路径（文件或目录）是否存在          | >>> os.path.exists('/path/to/file_or_directory')                         |
| os.path.abspath(path)           | 返回绝对路径                                | >>> os.path.abspath('relative_path')                                     |
| os.path.basename(path)          | 返回路径的最后一个组成部分（文件名/目录名） | >>> os.path.basename('/path/to/file.txt')                                |
| os.path.dirname(path)           | 返回路径的目录部分                          | >>> os.path.dirname('/path/to/file.txt')                                 |
| os.path.join(path1, path2, ...) | 将多个路径组合成一个路径                    | >>> os.path.join('/path/to', 'file.txt')                                 |
| os.path.split(path)             | 分割路径为目录部分和文件部分                | >>> os.path.split('/path/to/file.txt')                                   |
| os.path.isfile(path)            | 判断路径是否为文件                          | >>> os.path.isfile('/path/to/file.txt')                                  |
| os.path.isdir(path)             | 判断路径是否为目录                          | >>> os.path.isdir('/path/to/directory')                                  |
| os.path.splitext(path)          | 分割路径为文件名和扩展名                    | >>> os.path.splitext('/path/to/file.txt')                                |
| os.path.getsize(path)           | 返回文件的大小（字节数）                    | >>> os.path.getsize('/path/to/file.txt')                                 |
| os.path.isabs(path)             | 判断路径是否为绝对路径                      | >>> os.path.isabs('/path/to/file.txt')                                   |

```sh
os.getcwd()                 获取当前工作目录，即当前python脚本工作的目录路径
os.chdir("dirname")         改变当前脚本工作目录；相当于shell下cd
os.curdir                   返回当前目录: ('.')
os.pardir                   获取当前目录的父目录字符串名：('..')
os.makedirs('dir1/dir2')    可生成多层递归目录
os.removedirs('dirname1')   若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推
os.mkdir('dirname')         生成单级目录；相当于shell中mkdir dirname
os.rmdir('dirname')         删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname
os.listdir('dirname')       列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.remove()                 删除一个文件
os.rename("oldname","new")  重命名文件/目录
os.stat('path/filename')    获取文件/目录信息
os.sep                      操作系统特定的路径分隔符，win下为"\\",Linux下为"/"
os.linesep                  当前平台使用的行终止符，win下为"\t\n",Linux下为"\n"
os.pathsep                  用于分割文件路径的字符串
os.name                     字符串指示当前使用平台。win->'nt'; Linux->'posix'
os.system("bash command")   运行shell命令，直接显示
os.environ                  获取系统环境变量
os.path.abspath(path)       返回path规范化的绝对路径
os.path.split(path)         将path分割成目录和文件名二元组返回
os.path.dirname(path)       返回path的目录。其实就是os.path.split(path)的第一个元素
os.path.basename(path)      返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素
os.path.exists(path)        如果path存在，返回True；如果path不存在，返回False
os.path.isabs(path)         如果path是绝对路径，返回True
os.path.isfile(path)        如果path是一个存在的文件，返回True。否则返回False
os.path.isdir(path)         如果path是一个存在的目录，则返回True。否则返回False
os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略
os.path.getatime(path)      返回path所指向的文件或者目录的最后存取时间
os.path.getmtime(path)      返回path所指向的文件或者目录的最后修改时间
```

## 2.sys

sys 模块用于与 Python 解释器交互。

| 方法                         | 描述                       | 示例                                                                   |
| ---------------------------- | -------------------------- | ---------------------------------------------------------------------- |
| sys.argv                     | 命令行参数列表             | >>> import sys<br> >>> print(sys.argv)                                 |
| sys.exit([arg])              | 退出当前程序               | >>> import sys<br> >>> sys.exit()                                      |
| sys.platform                 | 返回操作系统平台           | >>> import sys<br> >>> print(sys.platform)                             |
| sys.version                  | 返回 Python 解释器的版本   | >>> import sys<br> >>> print(sys.version)                              |
| sys.maxsize                  | 返回最大的整数值           | >>> import sys<br> >>> print(sys.maxsize)                              |
| sys.path                     | 返回模块搜索路径           | >>> import sys<br> >>> print(sys.path)                                 |
| sys.modules                  | 返回当前加载的模块列表     | >>> import sys<br> >>> print(sys.modules)                              |
| sys.stdin                    | 标准输入流                 | >>> import sys<br> >>> line = sys.stdin.readline()                     |
| sys.stdout                   | 标准输出流                 | >>> import sys<br> >>> sys.stdout.write('Hello, World!')               |
| sys.stderr                   | 标准错误流                 | >>> import sys<br> >>> sys.stderr.write('Error occurred.')             |
| sys.getsizeof(obj)           | 返回对象的大小（字节数）   | >>> import sys<br> >>> print(sys.getsizeof([]))                        |
| sys.getrecursionlimit()      | 返回递归调用的最大深度     | >>> import sys<br> >>> print(sys.getrecursionlimit())                  |
| sys.setrecursionlimit(limit) | 设置递归调用的最大深度     | >>> import sys<br> >>> sys.setrecursionlimit(1000)                     |
| sys.exc_info()               | 返回当前异常信息           | >>> import sys<br> >>> exc_type, exc_value, traceback = sys.exc_info() |
| sys.hexversion               | 返回 Python 解释器的版本号 | >>> import sys<br> >>> print(sys.hexversion)                           |
| sys.getdefaultencoding()     | 返回 Unicode 默认编码      | >>> import sys<br> >>> print(sys.getdefaultencoding())                 |
| sys.getfilesystemencoding()  | 返回文件系统编码           | >>> import sys<br> >>> print(sys.getfilesystemencoding())              |
| sys.getrefcount(object)      | 返回对象的引用计数         | >>> import sys<br> >>> print(sys.getrefcount([]))                      |

```sh
sys.argv           命令行参数List，第一个元素是程序本身路径
sys.exit(n)        退出程序，正常退出时exit(0)
sys.version        获取Python解释程序的版本信息
sys.maxint         最大的Int值
sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
sys.platform       返回操作系统平台名称
sys.stdin          输入相关
sys.stdout         输出相关
sys.stderror       错误相关
sys.getdefaultencoding          获取解释器默认字符编码。
sys.getfilesystemencoding       获取解释器文件系统编码。
```

手写进度条

```python
import sys,time
for ii in range(101):
    sys.stdout.write('\r')  #每一次清空原行。
    sys.stdout.write("%s%%  |%s|"%(int(int(ii)/100*100),int(int(ii)/100*100) * '#'))     #一共次数除当前次数算进度
    sys.stdout.flush()      #强制刷新到屏幕
    time.sleep(0.05)
```

查看 python 版本

```python
def check_python_version():
    current_python = sys.version_info[0]
    if current_python == 3:
        return
    else:
        raise Exception('Invalid python version requested: %d' % current_python)
```

简单命令行参数，命令行参数 argv

```sh
import sys

if len(sys.argv) < 2:
    print ("没有输入任何参数")
    sys.exit()

if sys.argv[1].startswith("-"):
    option = sys.argv[1][1:]

    if option == "version":
        print ("版本信息")
    elif option == "help":
        print ("帮助菜单")
    elif option == "option":
        print("配置菜单")
    else:
        print ("异常")
        sys.exit()
```

```python
import sys


def sys_arguments():
    if len(sys.argv) == 3:
        print("You are greatly!")
        print("the script pathname is: {}".format(sys.argv[0]))
        print("the first argument is: {}".format(sys.argv[1]))
        print("the second argument is: {}".format(sys.argv[2]))
        sys.exit()
    else:
        print("Use method: python {} arg1 arg2".format(sys.argv[0]))
        sys.exit(-1)

sys_arguments()
```

## 3.platform

platform 模块用于获取操作系统详细信息。

| 方法                             | 描述                     | 示例                                                                |
| -------------------------------- | ------------------------ | ------------------------------------------------------------------- |
| platform.platform()              | 返回平台标识符           | >>> import platform<br> >>> print(platform.platform())              |
| platform.system()                | 返回操作系统名称         | >>> import platform<br> >>> print(platform.system())                |
| platform.machine()               | 返回机器类型             | >>> import platform<br> >>> print(platform.machine())               |
| platform.version()               | 返回操作系统版本         | >>> import platform<br> >>> print(platform.version())               |
| platform.processor()             | 返回处理器信息           | >>> import platform<br> >>> print(platform.processor())             |
| platform.architecture()          | 返回操作系统位数信息     | >>> import platform<br> >>> print(platform.architecture())          |
| platform.python_version()        | 返回 Python 版本信息     | >>> import platform<br> >>> print(platform.python_version())        |
| platform.python_implementation() | 返回 Python 解释器的实现 | >>> import platform<br> >>> print(platform.python_implementation()) |
| platform.dist()                  | 返回发行版信息           | >>> import platform<br> >>> print(platform.dist())                  |
| platform.libc_ver()              | 返回 C 库版本信息        | >>> import platform<br> >>> print(platform.libc_ver())              |
| platform.win32_ver()             | 返回 Windows 版本信息    | >>> import platform<br> >>> print(platform.win32_ver())             |
| platform.mac_ver()               | 返回 macOS 版本信息      | >>> import platform<br> >>> print(platform.mac_ver())               |
| platform.linux_distribution()    | 返回 Linux 发行版信息    | >>> import platform<br> >>> print(platform.linux_distribution())    |

```python
import platform

# 获取操作系统名称版本号
plat = platform.platform
print("获取操作系统名称版本号:", plat)

# 获取操作系统位数
architecture = platform.architecture()
print("获取操作系统位数:", architecture)

# 获取计算机类型
machine = platform.machine()
print("计算机类型:", machine)

# 获取计算机网络名称
node = platform.node()
print("获取计算机网络名称:", node)

# 获取计算机处理器信息
processor = platform.processor()
print("获取计算机处理器信息:", processor)

# 获取所有信息
uname = platform.uname()
for i in uname:
    print("1: ",i)
print("获取所有信息:", uname)
print(uname.system)
```

## 4.glob

glob 模块用于文件查找，支持通配符（\*、？、[]）。
glob 模块以下常用方法和属性：

| 方法                     | 描述                                   | 示例                                                                  |
| ------------------------ | -------------------------------------- | --------------------------------------------------------------------- |
| glob.glob(pathname)      | 返回所有匹配的文件路径列表             | >>> import glob<br> >>> files = glob.glob('\*.txt')                   |
| glob.iglob(pathname)     | 返回一个迭代器，逐个返回匹配的文件路径 | >>> import glob<br> >>> files = glob.iglob('\*.txt')                  |
| glob.escape(pathname)    | 对 pathname 进行转义处理               | >>> import glob<br> >>> escaped_path = glob.escape('dir[1-3]/\*.txt') |
| glob.has_magic(pathname) | 检查 pathname 是否包含通配符           | >>> import glob<br> >>> is_magic = glob.has_magic('dir/\*.txt')       |

glob 模块用于文件查找，支持通配符（\*、？、[]）。

- 获取所有名称为 3 个字符的文件和目录

```sh
>>> glob.glob('???')
['sys', 'lib', 'etc', 'srv', 'usr', 'tmp', 'mnt', 'run', 'dev', 'var', 'opt', 'bin']
```

- 查找目录中所有以.sh 为后缀的文件:

```sh
>>> glob.glob('/home/user/\*.sh')
>>> ['/home/user/1.sh', '/home/user/b.sh', '/home/user/a.sh', '/home/user/sum.sh']
```

- 查找目录中出现单个字符并以.sh 为后缀的文件:

```sh
>>> glob.glob('/home/user/?.sh')
>>> ['/home/user/1.sh', '/home/user/b.sh', '/home/user/a.sh']
```

- 查找目录中出现 a.sh 或 b.sh 的文件:

```sh
>>> glob.glob('/home/user/[a|b].sh')
>>> ['/home/user/b.sh', '/home/user/a.sh']
```

- 匹配以点号开头的隐藏的文件和目录

```sh
>>> glob.glob('.*')
['.dockerenv']
>>> glob.glob('*')
['home', 'sbin', 'sys', 'lib', 'media', 'etc', 'srv', 'usr', 'tmp', 'mnt', 'lib64', 'run', 'proc', 'dev', 'var', 'opt', 'anaconda-post.log', 'bin', 'root', 'boot']
```

- 获取所有名称以指定字符开头的文件和目录

```sh
# 以a开头的文件或目录
>>> glob.glob('[a]*')
['anaconda-post.log']

# 以a或者b开头的文件或目录
>>> glob.glob('[ab]*')
['anaconda-post.log', 'bin', 'boot']

# 以a或者b或者c或者d开头的文件或目录
>>> glob.glob('[abcd]*')
['dev', 'anaconda-post.log', 'bin', 'boot']
```

- 获取所有名称不是以指定字符开头的文件和目录

```sh
# 不是以a或者b或者d开头的文件或目录
>>> glob.glob('[!abd]*')
['home', 'sbin', 'sys', 'lib', 'media', 'etc', 'srv', 'usr', 'tmp', 'mnt', 'lib64', 'run', 'proc', 'var', 'opt', 'root']
# 不是以a或者b或者d或者e开头的文件或目录
>>> glob.glob('[!abde]*')
['home', 'sbin', 'sys', 'lib', 'media', 'srv', 'usr', 'tmp', 'mnt', 'lib64', 'run', 'proc', 'var', 'opt', 'root']
# 不是以a或者b或者d或者e或者h开头的文件或目录
>>> glob.glob('[!abdeh]*')
['sbin', 'sys', 'lib', 'media', 'srv', 'usr', 'tmp', 'mnt', 'lib64', 'run', 'proc', 'var', 'opt', 'root']
# 不是以a或者b或者d或者e或者h或者l开头的文件或目录
>>> glob.glob('[!abdehl]*')
['sbin', 'sys', 'media', 'srv', 'usr', 'tmp', 'mnt', 'run', 'proc', 'var', 'opt', 'root']
# 不是以a或者b或者d或者e或者h或者l或者r开头的文件或目录
>>> glob.glob('[!abdehlr]*')
['sbin', 'sys', 'media', 'srv', 'usr', 'tmp', 'mnt', 'proc', 'var', 'opt']
# 不是以a或者b或者d或者e或者h或者l或者r或者s开头的文件或目录
>>> glob.glob('[!abdehlrs]*')
['media', 'usr', 'tmp', 'mnt', 'proc', 'var', 'opt']
```

- 查找 python 脚本文件

```sh
>>> glob.glob('./*/*.py')
[]
```

- 查找配置文件

```sh
>>> glob.glob('./*/*.conf')
['./etc/dracut.conf', './etc/yum.conf', './etc/ld.so.conf', './etc/libuser.conf', './etc/libaudit.conf', './etc/krb5.conf', './etc/vconsole.conf', './etc/host.conf', './etc/nsswitch.conf', './etc/locale.conf', './etc/resolv.conf', './etc/rsyncd.conf', './etc/safe-rm.conf', './etc/sysctl.conf']
```

- 递归查找文件

通过指定 `recursive=True` 可以进行递归查找，模式\*\*将匹配任何文件以及零个或多个目录，子目录和目录的符号链接。

```sh
>>> for conf in glob.iglob('./tmp/**', recursive=True):
...     print(conf)
...
./tmp/
./tmp/yum.log
./tmp/ks-script-eC059Y
>>> for conf in glob.iglob('./home/**', recursive=True):
...     print(conf)
...
./home/
>>> for conf in glob.iglob('./etc/**', recursive=True):
...     print(conf)
...
./etc/
./etc/profile
./etc/DIR_COLORS.lightbgcolor
./etc/yum.repos.d
# ...省略
```

## 5.fileinput

fileinput 模块用于遍历文件，适合处理多文件。
fileinput 模块以下常用方法和属性：

| 方法                        | 描述                             | 示例                                                                                  |
| --------------------------- | -------------------------------- | ------------------------------------------------------------------------------------- |
| fileinput.input(files=None) | 返回一个可迭代的文件对象         | >>> import fileinput<br> >>> for line in fileinput.input(['file1.txt', 'file2.txt']): |
| fileinput.filename()        | 返回当前文件的名称               | >>> import fileinput<br> >>> filename = fileinput.filename()                          |
| fileinput.lineno()          | 返回当前行号                     | >>> import fileinput<br> >>> lineno = fileinput.lineno()                              |
| fileinput.filelineno()      | 返回当前文件的行号               | >>> import fileinput<br> >>> file_lineno = fileinput.filelineno()                     |
| fileinput.isfirstline()     | 检查当前行是否是当前文件的第一行 | >>> import fileinput<br> >>> is_firstline = fileinput.isfirstline()                   |
| fileinput.isstdin()         | 检查当前文件是否来自标准输入     | >>> import fileinput<br> >>> is_stdin = fileinput.isstdin()                           |
| fileinput.close()           | 关闭当前文件                     | >>> import fileinput<br> >>> fileinput.close()                                        |
| fileinput.nextfile()        | 切换到下一个文件                 | >>> import fileinput<br> >>> fileinput.nextfile()                                     |
| fileinput.filelineno()      | 返回当前文件的行号               | >>> import fileinput<br> >>> file_lineno = fileinput.filelineno()                     |
| fileinput.isfirstline()     | 检查当前行是否是当前文件的第一行 | >>> import fileinput<br> >>> is_firstline = fileinput.isfirstline()                   |
| fileinput.isstdin()         | 检查当前文件是否来自标准输入     | >>> import fileinput<br> >>> is_stdin = fileinput.isstdin()                           |
| fileinput.close()           | 关闭当前文件                     | >>> import fileinput<br> >>> fileinput.close()                                        |
| fileinput.nextfile()        | 切换到下一个文件                 | >>> import fileinput<br> >>> fileinput.nextfile()                                     |
| fileinput.filename()        | 返回当前文件的名称               | >>> import fileinput<br> >>> filename = fileinput.filename()                          |
| fileinput.lineno()          | 返回当前行号                     | >>> import fileinput<br> >>> lineno = fileinput.lineno()                              |
| fileinput.filelineno()      | 返回当前文件的行号               | >>> import fileinput<br> >>> file_lineno = fileinput.filelineno()                     |
| fileinput.isfirstline()     | 检查当前行是否是当前文件的第一行 | >>> import fileinput<br> >>> is_firstline = fileinput.isfirstline()                   |
| fileinput.isstdin()         | 检查当前文件是否来自标准输入     | >>> import fileinput<br> >>> is_stdin = fileinput.isstdin()                           |
| fileinput.close()           | 关闭当前文件                     | >>> import fileinput<br> >>> fileinput.close()                                        |
| fileinput.nextfile()        | 切换到下一个文件                 | >>> import fileinput<br> >>> fileinput.nextfile()                                     |

## 6.shutil

shutil 模块用于文件或目录拷贝，归档。

常用方法：

| 方法                                             | 描述                         | 示例                                                                            |
| ------------------------------------------------ | ---------------------------- | ------------------------------------------------------------------------------- |
| shutil.copy(src, dst)                            | 复制文件或目录到目标路径     | >>> import shutil<br> >>> shutil.copy('source.txt', 'destination.txt')          |
| shutil.move(src, dst)                            | 移动文件或目录到目标路径     | >>> import shutil<br> >>> shutil.move('source.txt', 'destination.txt')          |
| shutil.copyfile(src, dst)                        | 仅复制文件内容到目标文件     | >>> import shutil<br> >>> shutil.copyfile('source.txt', 'destination.txt')      |
| shutil.copytree(src, dst)                        | 递归复制整个目录树到目标路径 | >>> import shutil<br> >>> shutil.copytree('source_dir', 'destination_dir')      |
| shutil.rmtree(path)                              | 递归删除目录及其内容         | >>> import shutil<br> >>> shutil.rmtree('directory_to_delete')                  |
| shutil.make_archive(base_name, format, root_dir) | 创建压缩文件                 | >>> import shutil<br> >>> shutil.make_archive('archive', 'zip', 'source_dir')   |
| shutil.unpack_archive(filename, extract_dir)     | 解压缩文件到目标目录         | >>> import shutil<br> >>> shutil.unpack_archive('archive.zip', 'extracted_dir') |
| shutil.disk_usage(path)                          | 返回指定路径的磁盘使用情况   | >>> import shutil<br> >>> usage = shutil.disk_usage('/')                        |

小结：

- 如果你想操作文件路径，请参考 os.path 模块
- 如果你想读写一个文件请使用 `open()`函数
- 如果你想读取通过命令行传入的所有文件中的所有行，请参考 fileinput 模块
- 对于高级文件和目录处理，请参考 shutil 模块

```python
import os
import shutil

os.chdir('/tmp')

# 实现touch操作
def touch(path):
    with open(path, 'a'):
        os.utime(path, None)

# 创建目录
os.makedirs('src/sub1')
os.makedirs('src/sub2')
os.makedirs('dest')

# 创建文件
touch('src/sub1/file11')
touch('src/sub1/file12')
touch('src/sub1/file13')
touch('dest/file22')

# 复制文件
shutil.copy('src/sub1/file11','dest')          # 复制单个文件到目录
# 删除单个文件
os.remove('dest/file11')
shutil.copy('src/sub1/file11','dest/file22')   # 复制到文件，覆盖既有文件

# 复制目录
shutil.copytree('src/sub1','dest/sub2')        # 第二个参数必须是不存在的路径，用来作为目标目录
# 删除整个目录，包括指定的目标本身
shutil.rmtree('dest/sub1')

# 移动目录
shutil.move('src/sub1','dest/sub1')
# 移动文件
shutil.move('dest/sub1/file11','src')
```

```python
#shutil.copyfileobj(fsrc, fdst[, length])
#将文件内容拷贝到另一个文件中
import  shutil
shutil.copyfileobj(open('old.xml','r'), open('new.xml', 'w'))


#shutil.copyfile(src, dst)
#拷贝文件
shutil.copyfile('f1.log', 'f2.log') #目标文件无需存在

#shutil.copymode(src, dst)
#仅拷贝权限。内容、组、用户均不变
shutil.copymode('f1.log', 'f2.log') #目标文件必须存在

#shutil.copystat(src, dst)
#仅拷贝状态的信息，包括：mode bits, atime, mtime, flags
shutil.copystat('f1.log', 'f2.log') #目标文件必须存在


#shutil.copy(src, dst)
#拷贝文件和权限
shutil.copy('f1.log', 'f2.log')

#shutil.copy2(src, dst)
#拷贝文件和状态信息
shutil.copy2('f1.log', 'f2.log')
shutil.ignore_patterns(*patterns)


#shutil.copytree(src, dst, symlinks=False, ignore=None)
#递归的去拷贝文件夹
shutil.copytree('folder1', 'folder2', ignore=shutil.ignore_patterns('*.pyc', 'tmp*')) #目标目录不能存在，注意对folder2目录父级目录要有可写权限，ignore的意思是排除

#shutil.rmtree(path[, ignore_errors[, onerror]])
#递归的去删除文件
shutil.rmtree('folder1')


#shutil.move(src, dst)
# 递归的去移动文件，它类似mv命令，其实就是重命名。
shutil.move('folder1', 'folder3')
```

## 7.math

math 模块用于数字处理。

常用的方法：

| 方法              | 描述                        | 示例                                            |
| ----------------- | --------------------------- | ----------------------------------------------- |
| math.ceil(x)      | 返回大于或等于 x 的最小整数 | >>> import math<br> >>> math.ceil(3.4)          |
| math.floor(x)     | 返回小于或等于 x 的最大整数 | >>> import math<br> >>> math.floor(3.9)         |
| math.trunc(x)     | 返回 x 的整数部分           | >>> import math<br> >>> math.trunc(3.9)         |
| math.sqrt(x)      | 返回 x 的平方根             | >>> import math<br> >>> math.sqrt(16)           |
| math.pow(x, y)    | 返回 x 的 y 次幂            | >>> import math<br> >>> math.pow(2, 3)          |
| math.exp(x)       | 返回 e 的 x 次幂            | >>> import math<br> >>> math.exp(1)             |
| math.log(x, base) | 返回 x 的对数，可指定基数   | >>> import math<br> >>> math.log(10, 2)         |
| math.sin(x)       | 返回 x 的正弦值             | >>> import math<br> >>> math.sin(math.pi/2)     |
| math.cos(x)       | 返回 x 的余弦值             | >>> import math<br> >>> math.cos(math.pi)       |
| math.tan(x)       | 返回 x 的正切值             | >>> import math<br> >>> math.tan(math.pi/4)     |
| math.degrees(x)   | 将角度从弧度转换为度        | >>> import math<br> >>> math.degrees(math.pi/2) |
| math.radians(x)   | 将角度从度转换为弧度        | >>> import math<br> >>> math.radians(180)       |
| math.pi           | 圆周率的近似值              | >>> import math<br> >>> math.pi                 |
| math.e            | 自然常数 e 的近似值         | >>> import math<br> >>> math.e                  |

## 8.random

random 模块用于生成随机数。

常用的方法：

| 方法                         | 描述                             | 示例                                                                   |
| ---------------------------- | -------------------------------- | ---------------------------------------------------------------------- |
| random.random()              | 返回一个 0 到 1 之间的随机浮点数 | >>> import random<br> >>> random.random()                              |
| random.randint(a, b)         | 返回一个在指定范围内的随机整数   | >>> import random<br> >>> random.randint(1, 10)                        |
| random.choice(seq)           | 从序列中随机选择一个元素         | >>> import random<br> >>> random.choice(['apple', 'banana', 'orange']) |
| random.shuffle(lst)          | 随机打乱列表中的元素顺序         | >>> import random<br> >>> random.shuffle([1, 2, 3, 4, 5])              |
| random.sample(population, k) | 从总体中选择 k 个样本            | >>> import random<br> >>> random.sample([1, 2, 3, 4, 5], 3)            |
| random.uniform(a, b)         | 返回一个在指定范围内的随机浮点数 | >>> import random<br> >>> random.uniform(1.0, 10.0)                    |
| random.seed(seed)            | 设置随机数生成器的种子           | >>> import random<br> >>> random.seed(42)                              |

验证码

```python
import string,random



s = string.ascii_lowercase+string.digits+string.punctuation
print(s)


r = random.sample(s,6)
print('6位数随机密码:' ,''.join(r))
```

## 9.subprocess(执行 Shell 命令)

ubprocess 模块主要用于执行 Shell 命令，工作时会 fork 一个子进程去执行任务，连接到子进程
的标准输入、输出、错误，并获得它们的返回代码。

这个模块将取代 `os.system`、`os.spawn*`、`os.popen*`、popen2._和 commands._。

subprocess 的主要方法：
`subprocess.run()`，`subprocess.Popen()`,`subprocess.call`

在 Python3.5 之后版本中，新增 subprocess.run()函数，官方建议使用此函数来使用 subprocess 模块的功能。当然，也可以依旧可以直接使用底层 Popen 接口。

https://www.runoob.com/w3cnote/python3-subprocess.html

参考文献

https://www.cnblogs.com/lsdb/p/13068187.html

### python2

方法一：os.system()

os.system() 可以说是最为基本的运行 shell 命令的方式了，这个方法的特点就是直接运行命令，并将运行之后的状态值返回码返回，所以结果是一个 int 类型，这个方式比较常见是运用在只需要执行 shell 命令而不需要得到命令的返回结果的场景。

```python
import  os

# 调用系统命令或脚本
os.system('uname -a')
f = os.popen('ls')
print(f.read())


#shell
def shell(cmd):
    os.system(cmd+'&>/dev/null')
    #不返还


def shellinfo(cmd):
    r=os.popen(cmd)
    text=r.read()
    r.close()
    return text
    #有返回
```

方法二：os.popen()

os.popen() 方法执行命令之后会把成功执行的命令的结果以文件的形式返回，所以可以通过 read() 方法获取执行的结果，而如果执行失败，则文件为空，所以这个方法的适用场景是命令返回的结果比较多，需要进行提取结果的场景。

```python

def shell(cmd):
    r = os.popen(cmd)
    text = r.read()
    r.close()
    return text
```

方法三：commands 模块

commands 模块主要常用的是下面两个方法：

- commands.getstatusoutput(cmd) 返回(状态码, 输出结果)
- commands.getoutput(cmd) 只返回输出结果

这个模块看起来就比较完善了，可以同时得到执行的状态码和输出结果，可以说是同时具备了 os.system() 和 os.popen() 的功能，实用性更强一些。

```python
import commands
def shell_status(cmd):
    (status, output) = commands.getstatusoutput(cmd)
    return status, output

def shellinfo(cmd):
    (status, output) = commands.getoutput(cmd)
    return output
```

方法四：subprocess 模块

subprocess 模块是官方比较推荐的模块，基本可以取代上面的三种方法，功能也更加强大，可以满足大部分的场景。

subprocess.call() 相当于 os.system() 命令的用法，它执行命令并将执行结果状态码返回。

直接看下面例子：

```python
import subprocess

# subprocess 模块里面的方法执行 shell 命令的时候如果传入的命令是字符串的形式，那必须将参数 shell 设置为 True，不然默认就是使用的列表作为命令的传入参数，比如看下面这种不设置 shell=True 和设置的对比：
def shell(cmd):
    res1 = subprocess.call(['ls', '-l'])
    res2 = subprocess.call('ls -l', shell=True)
    print(res1, res2)

def shellinfo(cmd):
    return subprocess.check_output(cmd, shell=True)

def shell_exec(cmd):
    return subprocess.check_call(cmd, shell=True)

# subprocess.Popen() 方法是我们项目代码中使用的，这个方法同样是可以输出执行的状态码和输出结果，但是参数比 commands 需要的多。
# 使用 communicate() 方法可以得到执行结果的成功输出和报错输出，如果没有报错则报错为空字符串。
def shell(cmd):
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    return p.returncode, stdout.decode(), stderr.decode()
```

使用 python 执行 shell 命令的几种常用方式

- https://tendcode.com/subject/article/python-shell-cmd/

### python3

| 方法                                      | 描述                                       | 示例                                                                                                                                                                                              |
| ----------------------------------------- | ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| subprocess.run(args, \*\*kwargs)          | 运行子进程并等待其完成，推荐使用的高级接口 | >>> import subprocess<br> >>> subprocess.run(["ls", "-l"])                                                                                                                                        |
| subprocess.Popen(args, \*\*kwargs)        | 以更灵活的方式启动一个子进程               | >>> import subprocess<br> >>> p = subprocess.Popen(["ls", "-l"], stdout=subprocess.PIPE)                                                                                                          |
| subprocess.check_output(args, \*\*kwargs) | 运行命令并返回输出结果                     | >>> import subprocess<br> >>> output = subprocess.check_output(["ls", "-l"])                                                                                                                      |
| subprocess.call(args, \*\*kwargs)         | 运行命令并等待其完成，返回退出状态码       | >>> import subprocess<br> >>> subprocess.call(["ls", "-l"])                                                                                                                                       |
| subprocess.communicate(input, timeout)    | 与子进程进行交互，发送数据并读取输出       | >>> import subprocess<br> >>> p = subprocess.Popen(["grep", "example"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)<br> >>> output, \_ = p.communicate(input=b"Hello\\nThis is an example\\n") |
|                                           |

python 执行 linux 系统命令的几种方法:

```shell
1. 使用os.system
仅仅在一个子终端运行系统命令，而不能获取命令执行后的返回信息

2. 使用os.popen
该方法不但执行命令还返回执行后的信息对象，好处在于：将返回的结果赋于一变量，便于程序的处理。

cmd = os.popen('df -h').read().split('\n')

3. 使用模块 subprocess
https://blog.51cto.com/u_14320361/2491366
```

```python
"""
三种执行命令的方法

subprocess.run(*popenargs, input=None, timeout=None, check=False, **kwargs) #官方推荐

subprocess.call(*popenargs, timeout=None, **kwargs) #跟上面实现的内容差不多，另一种写法

subprocess.Popen() #上面各种方法的底层封装
"""

#!/usr/bin/env python
# -*- coding: utf-8 -*-
import subprocess
import sys,os


def base(cmd):
    if subprocess.call(cmd, shell=True):
        raise Exception("{} 执行失败".format(cmd))

def run_if(args):
    base(args)


def shell(cmd):
    """ shell执行  """
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
    results = p.communicate()[0]
    return results.decode()


def run_shell(cmd):
    """
    执行系统命令
    """
    (status, output) = subprocess.getstatusoutput(cmd)
    context = {
        'status': status,
        'output': output,
    }
    return context


if __name__ == '__main__':
    # if(os.geteuid() != 0):
    #     raise("请以root权限运行")
    run_if("ifconfig |awk '/netmask/ && !/127/  {print $2}'")
```

**示例 1**

```python
def execute_cmd(cmd):
    prcs = subprocess.Popen(cmd,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    stdout, stderr = prcs.communicate()
    if prcs.returncode != 0:
        return prcs.returncode, stderr

    return (prcs.returncode, prcs.stdout)


def exec_cmd(cmd):
    """
    Execute arbitrary commands as sub-processes.
    """
    proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE,
                            stdin=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            universal_newlines=True,
                            shell=True)
    stdout, stderr = proc.communicate()
    return (proc.returncode, stdout, stderr)

def cmd(command):
    result = Result()

    p = Popen(shlex.split(command), stdin=PIPE, stdout=PIPE, stderr=PIPE)
    (stdout, stderr) = p.communicate()

    result.exit_code = p.returncode
    result.stdout = stdout
    result.stderr = stderr
    result.command = command

    if p.returncode != 0:
        print 'Error executing command [%s]' % command
        print 'stderr: [%s]' % stderr
        print 'stdout: [%s]' % stdout

    return result




import os
import sys
import shlex
import subprocess
import select

def run_cmd(cmd, live=False, readsize=10, shell=False, cwd=None):
    if shell:
        # 如果使用 shell 模式，直接使用 cmd 而不是拆分后的参数
        cmdargs = cmd
    else:
        cmdargs = shlex.split(cmd)

    p = subprocess.Popen(
        cmdargs,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=shell,
        cwd=cwd
    )

    stdout = ''
    stderr = ''
    rpipes = [p.stdout, p.stderr]
    while True:
        rfd, wfd, efd = select.select(rpipes, [], rpipes, 1)

        if p.stdout in rfd:
            dat = os.read(p.stdout.fileno(), readsize)
            if live:
                sys.stdout.write(dat)
            stdout += dat
            if dat == '':
                rpipes.remove(p.stdout)
        if p.stderr in rfd:
            dat = os.read(p.stderr.fileno(), readsize)
            stderr += dat
            if live:
                sys.stdout.write(dat)
            if dat == '':
                rpipes.remove(p.stderr)
        # only break out if we've emptied the pipes, or there is nothing to
        # read from and the process has finished.
        if (not rpipes or not rfd) and p.poll() is not None:
            break
        # Calling wait while there are still pipes to read can cause a lock
        elif not rpipes and p.poll() is None:
            p.wait()

    return p.returncode, stdout, stderr
```

**示例 2**

```python
def run_cmd(cmd, retry=1):
    """
    执行命令，默认执行一次，log提示执行结果
    :param cmd:
    :param retry:
    :return:
    """
    while retry:
        retry -= 1
        exit_code = subprocess.call(cmd, shell=True)
        if exit_code == 0:
            logging.info('\033[32mRUN %s success.\033[0m' % cmd)
            return exit_code
        else:
            if retry == 0:
                logging.error('\033[31mRUN %s failed.\033[0m' % cmd)
                return exit_code
```

**示例 3**

```python
def exec_cmd(cmd):
    """
    执行命令，不输出，返回元祖--元祖内容 （执行状态，执行输出结果，错误结果）
    """
    proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE,
                            stdin=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            universal_newlines=True,
                            shell=True)
    stdout, stderr = proc.communicate()
    return (proc.returncode, str(stdout).strip(), stderr)
```

**示例 4**

```python
# -*- coding: utf-8 -*-
'''Module for Shell.'''


import shlex
import subprocess as sbps


def run(cmd, shell=False):
    if shell:
        return sbps.call(cmd, shell=shell)
    else:
        return sbps.call(shlex.split(cmd))


def exec_command(cmd, cwd):
    '''executive command
    '''
    cmd = shlex.split(cmd)
    cwd = cwd or '/'
    # print('shell cmd', cmd)
    try:
        p = sbps.Popen(cmd,
                       stdout=sbps.PIPE,
                       stderr=sbps.PIPE,
                       close_fds=True,
                       shell=True,
                       cwd=cwd)
        if p.wait() == 0:
            result = p.stdout.read()  # result = p.stdout.readlines()
            # print(p.cc.read())
        else:
            result = p.stderr.read()  # result = p.stderr.readlines()
        return {
            'code': p.wait(),
            'cwd': cwd,
            'data': result,
            'msg': 'success'
        }
    except:
        return {
            'code': -1,
            'data': '',
            'msg': 'error'
        }


if __name__ == '__main__':
    print(exec_command('cd /var/db', '/var'))
    # print(exec_command('who -a'))
    # print(exec_command('ls')['code'] == 0)
    # print(shlex.split('uname -a - b'))

def run_command(command, wait=False):
    try:
        if (wait):
            p = subprocess.Popen(
                [command],
                stdout = subprocess.PIPE,
                shell = True)
            p.wait()
        else:
            p = subprocess.Popen(
                [command],
                shell = True,
                stdin = None, stdout = None, stderr = None, close_fds = True)

        (result, error) = p.communicate()

    except subprocess.CalledProcessError as e:
        sys.stderr.write(
            "common::run_command() : [ERROR]: output = %s, error code = %s\n"
            % (e.output, e.returncode))

    return result
```

**示例 5**

封装一个 run_cmd() 函数，用于执行命令，并返回执行结果、标准输出和标准错误。

```python
# Prints to stderr
def printerr(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

# Prints to stdout
def printout(*args, **kwargs):
    print(*args, **kwargs)

# Exits process with a message and non-0 exit code
def fail(msg):
    sys.exit(msg)

# Runs a given command with optional timeout.
# Returns (returncode, stdout, stderr) tuple. If timeout
# occurred, returncode will be negative (-9 on macOS).
def run(cmd, timeout=None, stdin=None, show_stderr=True):
    stdout, stderr, returncode, timer = None, None, None, None
    try:
        proc = subprocess.Popen(shlex.split(cmd),
                                stdout=subprocess.PIPE,
                                stdin=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        if timeout is not None:
            timer = threading.Timer(timeout, proc.kill)
            timer.start()
        stdout, stderr = proc.communicate(input=stdin)
        if len(stderr) > 0 and show_stderr:
            printerr(stderr)
        returncode = proc.returncode
    except OSError as e:
        stdout = e.strerror
        returncode = e.errno
    except Exception as e:
        stdout = str(e)
        returncode = 1
    finally:
        if timer is not None:
            timer.cancel()
        return returncode, stdout, stderr
```

### 案例-build_doc.py

```python
#!/usr/bin/env python3

from subprocess import run, PIPE
import shlex
import os
import logging


logging.basicConfig(format='{levelname}:{message}',
                    style='{',
                    level=logging.DEBUG)

DOCUMENT_FOLDER = 'doc'
API_DOCUMENT_FOLDER = '{}/{}'.format(DOCUMENT_FOLDER, 'api')
SOURCE = 'everywhere'
MASTER_BRANCH = 'master'
HTML_DIR = 'html'


def run_cmd(cmd, quiet=False):
    if not quiet:
        logging.info('command: {}'.format(cmd))

    # use shlex to keep quoted substrings
    result = run(shlex.split(cmd), stdout=PIPE, stderr=PIPE)
    stdout = result.stdout.strip().decode()
    stderr = result.stderr.strip().decode()

    if stdout and not quiet:
        logging.debug(stdout)

    if stderr and not quiet:
        logging.warning(stderr)

    return result.stdout.strip()


def build_docstring_rst():
    run_cmd('sphinx-apidoc -o {} {}'.format(API_DOCUMENT_FOLDER, SOURCE))


def build_html():
    run_cmd('python setup.py build_sphinx -s {}'.format(DOCUMENT_FOLDER))


def clean_old_build():
    run_cmd('rm -rf build/sphinx/html {} {}'.format(API_DOCUMENT_FOLDER,
                                                    HTML_DIR))


def duplicate_old_html():
    url = get_repo_url().decode()
    run_cmd('git clone -b gh-pages {} {}'.format(url, HTML_DIR))
    run_cmd('rm -rf {html}/.git {html}/{br}'.format(html=HTML_DIR,
                                                    br=MASTER_BRANCH))


def get_git_tags():
    return run_cmd('git tag --contains').split()


def update_html():
    run_cmd('mv build/sphinx/html {}/{}'.format(HTML_DIR, MASTER_BRANCH))

    tags = get_git_tags()
    if tags:
        destination = tags[0].decode()
        run_cmd('rm -rf {}/{}'.format(HTML_DIR, destination))
        run_cmd('cp -r {html}/{br} {html}/{dst}'.format(html=HTML_DIR,
                                                        br=MASTER_BRANCH,
                                                        dst=destination))


def get_commit_message():
    return run_cmd('git log -1 --pretty="%s"')


def get_repo_url():
    result = run_cmd('git remote get-url origin')
    # older version of Git doesn't have 'get-ur' ...
    if not result:
        result = run_cmd('git remote -v').split()[1]
    return result


def commit_to_github():
    run_cmd('pip install -U ghp-import')
    if os.environ.get('TRAVIS', ''):
        run_cmd('git config --global user.name "Travis"')
        run_cmd('git config --global user.email wdv4758h+travis@gmail.com')
    msg = get_commit_message().decode()
    cmd = 'ghp-import -n -r origin -b gh-pages -m "{}" {}'.format(msg,
                                                                  HTML_DIR)
    run_cmd(cmd)

    url = get_repo_url().decode().lstrip('https://')
    gh_token = os.environ['GH_TOKEN']
    # Please set your GH_TOKEN as Travis CI
    cmd = 'git push -fq \
            https://{}@{} gh-pages:gh-pages'.format(gh_token,
                                                    url)
    run_cmd(cmd, quiet=True)


def main():
    clean_old_build()
    build_docstring_rst()
    build_html()
    duplicate_old_html()
    update_html()
    commit_to_github()


if __name__ == '__main__':
    main()
```

### 案例-install_venv_common.py

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Provides methods needed by installation script for OpenStack development
virtual environments.

Since this script is used to bootstrap a virtualenv from the system's Python
environment, it should be kept strictly compatible with Python 2.6.

Synced in from openstack-common
"""

from __future__ import print_function

import optparse
import os
import subprocess
import sys


class InstallVenv(object):

    def __init__(self, root, venv, requirements,
                 test_requirements, py_version,
                 project):
        self.root = root
        self.venv = venv
        self.requirements = requirements
        self.test_requirements = test_requirements
        self.py_version = py_version
        self.project = project

    def die(self, message, *args):
        print(message % args, file=sys.stderr)
        sys.exit(1)

    def check_python_version(self):
        if sys.version_info < (2, 6):
            self.die("Need Python Version >= 2.6")

    def run_command_with_code(self, cmd, redirect_output=True,
                              check_exit_code=True):
        """Runs a command in an out-of-process shell.

        Returns the output of that command. Working directory is self.root.
        """
        if redirect_output:
            stdout = subprocess.PIPE
        else:
            stdout = None

        proc = subprocess.Popen(cmd, cwd=self.root, stdout=stdout)
        output = proc.communicate()[0]
        if check_exit_code and proc.returncode != 0:
            self.die('Command "%s" failed.\n%s', ' '.join(cmd), output)
        return (output, proc.returncode)

    def run_command(self, cmd, redirect_output=True, check_exit_code=True):
        return self.run_command_with_code(cmd, redirect_output,
                                          check_exit_code)[0]

    def get_distro(self):
        if (os.path.exists('/etc/fedora-release') or
                os.path.exists('/etc/redhat-release')):
            return Fedora(
                self.root, self.venv, self.requirements,
                self.test_requirements, self.py_version, self.project)
        else:
            return Distro(
                self.root, self.venv, self.requirements,
                self.test_requirements, self.py_version, self.project)

    def check_dependencies(self):
        self.get_distro().install_virtualenv()

    def create_virtualenv(self, no_site_packages=True):
        """Creates the virtual environment and installs PIP.

        Creates the virtual environment and installs PIP only into the
        virtual environment.
        """
        if not os.path.isdir(self.venv):
            print('Creating venv...', end=' ')
            if no_site_packages:
                self.run_command(['virtualenv', '-q', '--no-site-packages',
                                 self.venv])
            else:
                self.run_command(['virtualenv', '-q', self.venv])
            print('done.')
        else:
            print("venv already exists...")
            pass

    def pip_install(self, *args):
        self.run_command(['tools/with_venv.sh',
                         'pip', 'install', '--upgrade'] + list(args),
                         redirect_output=False)

    def install_dependencies(self):
        print('Installing dependencies with pip (this can take a while)...')

        # First things first, make sure our venv has the latest pip and
        # setuptools and pbr
        self.pip_install('pip>=1.4')
        self.pip_install('setuptools')
        self.pip_install('pbr')

        self.pip_install('-r', self.requirements, '-r', self.test_requirements)

    def parse_args(self, argv):
        """Parses command-line arguments."""
        parser = optparse.OptionParser()
        parser.add_option('-n', '--no-site-packages',
                          action='store_true',
                          help="Do not inherit packages from global Python "
                               "install")
        return parser.parse_args(argv[1:])[0]


class Distro(InstallVenv):

    def check_cmd(self, cmd):
        return bool(self.run_command(['which', cmd],
                    check_exit_code=False).strip())

    def install_virtualenv(self):
        if self.check_cmd('virtualenv'):
            return

        if self.check_cmd('easy_install'):
            print('Installing virtualenv via easy_install...', end=' ')
            if self.run_command(['easy_install', 'virtualenv']):
                print('Succeeded')
                return
            else:
                print('Failed')

        self.die('ERROR: virtualenv not found.\n\n%s development'
                 ' requires virtualenv, please install it using your'
                 ' favorite package management tool' % self.project)


class Fedora(Distro):
    """This covers all Fedora-based distributions.

    Includes: Fedora, RHEL, CentOS, Scientific Linux
    """

    def check_pkg(self, pkg):
        return self.run_command_with_code(['rpm', '-q', pkg],
                                          check_exit_code=False)[1] == 0

    def install_virtualenv(self):
        if self.check_cmd('virtualenv'):
            return

        if not self.check_pkg('python-virtualenv'):
            self.die("Please install 'python-virtualenv'.")

        super(Fedora, self).install_virtualenv()
```

### 案例-完整封装

```python
def exe_cmd(cmd, print_output=False, shell=False):
    stdout_output = ''
    stderr_output = ''
    if isinstance(cmd, str):
        cmd = cmd.split()
    elif isinstance(cmd, list):
        pass
    else:
        raise Exception("unsupported type when run do_exec_cmd", type(cmd))

    # print("Run cmd:" + " ".join(cmd))
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=shell)
    while True:
        # 使用select模块，监控stdout和stderr的可读性，设置超时时间为0.1秒
        rlist, _, _ = select.select([p.stdout, p.stderr], [], [], 0.1)
        # 遍历可读的文件对象
        for f in rlist:
            # 读取一行内容，解码为utf-8
            line = f.readline().decode('utf-8').strip()
            # 如果有内容，判断是stdout还是stderr，并打印到屏幕，并刷新缓冲区
            if line:
                if f == p.stdout:
                    if print_output == True:
                        print("STDOUT", line)
                    stdout_output += line + '\n'
                    sys.stdout.flush()
                elif f == p.stderr:
                    if print_output == True:
                        print("STDERR", line)
                    stderr_output += line + '\n'
                    sys.stderr.flush()
                else:
                    print("UNKOWN:", line)
        if p.poll() is not None:
            break
    return p.returncode, stdout_output, stderr_output
```

### 案例-ansible 中完整封装

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import random
import select
import subprocess
import fcntl
import pipes

"""
# 普通用户执行命令
>>> from test_local_exec_command import exec_command
>>> print(exec_command("whoami"))
EXEC ['/bin/sh', '-c', 'whoami']
(0, '', 'hujianli\n', '')

# 输入错误的密码
>>> print(exec_command("whoami", sudoable=True, sudo_pass="123"))
EXEC /bin/sh -c 'sudo -k && sudo -H -S -p "[sudo via ansible, key=yfxfdtbcysnjsxkvobxzapaxlvaeftru] password: " /bin         /sh -c whoaim'
Sorry, try again.
(1, '', '', '[sudo via ansible, key=yfxfdtbcysnjsxkvobxzapaxlvaeftru] password: \nsudo: no password was provided\nsu         do: 1 incorrect password attempt\n')
>>>
KeyboardInterrupt

# 输入正确的密码
>>> print(exec_command("whoami", sudoable=True, sudo_pass="123456"))
EXEC /bin/sh -c 'sudo -k && sudo -H -S -p "[sudo via ansible, key=oisrsmpdcxtkaohcamtxkfksnasymiqv] password: " /bin         /sh -c whoami'
(0, '', 'root\n', '')
"""

def make_sudo_cmd(executable, cmd):
    """
    ansible 1.1 源码中的 make_sudo_cmd 方法 去掉了 sudo_user 参数
    """
    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in range(32))
    prompt = '[sudo via ansible, key=%s] password: ' % randbits
    sudocmd = '%s -k && %s %s -S -p "%s" %s -c %s' % (
        "sudo", "sudo", "-H", prompt, executable or '$SHELL', pipes.quote(cmd))
    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt)


def exec_command(cmd, sudoable=False, executable='/bin/sh', sudo_pass=None):
    """
    本地执行命令,改造 ansible 1.1 源码中 local.py 文件，中的 exec_command 方法
    """
    if not sudoable:
        if executable:
            local_cmd = [executable, '-c', cmd]
        else:
            local_cmd = cmd
    else:
        local_cmd, prompt = make_sudo_cmd(executable, cmd)

    print("EXEC %s" % (local_cmd))
    p = subprocess.Popen(local_cmd, shell=isinstance(local_cmd, str),
                         executable=executable or None,
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    if sudoable and sudo_pass:
        fcntl.fcntl(p.stdout, fcntl.F_SETFL,
                    fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)
        fcntl.fcntl(p.stderr, fcntl.F_SETFL,
                    fcntl.fcntl(p.stderr, fcntl.F_GETFL) | os.O_NONBLOCK)
        sudo_output = ''
        while not sudo_output.endswith(prompt):
            rfd, wfd, efd = select.select([p.stdout, p.stderr], [],
                                          [p.stdout, p.stderr], 10)
            if p.stdout in rfd:
                chunk = p.stdout.read()
            elif p.stderr in rfd:
                chunk = p.stderr.read()
            else:
                stdout, stderr = p.communicate()
                raise Exception('timeout waiting for sudo password prompt:\n' + sudo_output)
            if not chunk:
                stdout, stderr = p.communicate()
                raise Exception('sudo output closed while waiting for password prompt:\n' + sudo_output)
            sudo_output += chunk
        p.stdin.write(sudo_pass + '\n')
        fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)
        fcntl.fcntl(p.stderr, fcntl.F_SETFL, fcntl.fcntl(p.stderr, fcntl.F_GETFL) & ~os.O_NONBLOCK)

    stdout, stderr = p.communicate()
    return (p.returncode, '', stdout, stderr)
```

更多参考示例

- https://github.com/canonical/curtin/blob/master/curtin/util.py

### envoy 库

envoy 封装了 subprocess，

- https://www.yuque.com/fcant/python/gi6b92rkp684gele

Python envoy 模块源码剖析

- https://anyisalin.github.io/2017/05/09/python-envoy-code-reading/
- https://blog.csdn.net/junli_chen/article/details/78295454

## 10.pickle

注意： pickle 模块只能用于 python 中

在 Python 中提供了两个模块：cPickle 和 pickle 来实现序列化，前者是由 C 语言编写的，效率比后者高很多，但是两个模块的功能是一样的。一般编写程序的时候，采取的方案是先导入 cPickle 模块，如果此模块不存在，再导入 pickle 模块。

pickle 模块实现了对一个 Python 对象结构的二进制序列化和反序列化。

主要用于将对象持久化到文件存储。

pickle 模块主要有两个函数：

- dump() 把对象保存到文件中（序列化），使用 load()函数从文件中读取（反序列化）
- dumps() 把对象保存到内存中，使用 loads()函数读取

pickle 模块以下常用方法和属性：

| 方法                                  | 描述                         | 示例                                                                                     |
| ------------------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------- |
| pickle.dump(obj, file, protocol=None) | 将对象序列化并保存到文件中   | >>> import pickle<br> >>> with open("data.pkl", "wb") as f:<br> ... pickle.dump(obj, f)  |
| pickle.load(file)                     | 从文件中加载序列化的对象     | >>> import pickle<br> >>> with open("data.pkl", "rb") as f:<br> ... obj = pickle.load(f) |
| pickle.dumps(obj, protocol=None)      | 将对象序列化为字节对象       | >>> import pickle<br> >>> data = pickle.dumps(obj)                                       |
| pickle.loads(bytes_object)            | 从字节对象中加载序列化的对象 | >>> import pickle<br> >>> obj = pickle.loads(data)                                       |
| pickle.dump(obj, file, protocol=None) | 将对象序列化并保存到文件中   | >>> import pickle<br> >>> with open("data.pkl", "wb") as f:<br> ... pickle.dump(obj, f)  |
| pickle.dumps(obj, protocol=None)      | 将对象序列化为字节对象       | >>> import pickle<br> >>> data = pickle.dumps(obj)                                       |
| pickle.load(file)                     | 从文件中加载序列化的对象     | >>> import pickle<br> >>> with open("data.pkl", "rb") as f:<br> ... obj = pickle.load(f) |
| pickle.loads(bytes_object)            | 从字节对象中加载序列化的对象 | >>> import pickle<br> >>> obj = pickle.loads(data)                                       |
| pickle.HIGHEST_PROTOCOL               | pickle 使用的最高协议版本    | >>> import pickle<br> >>> pickle.HIGHEST_PROTOCOL                                        |

```python
#序列化
import pickle
dic={'name':'alvin','age':23,'sex':'male'}
print(type(dic))#<class 'dict'>
j=pickle.dumps(dic)
print(type(j))#<class 'bytes'>

f=open('序列化对象_pickle','wb')    #注意是w是写入str,wb是写入bytes,j是'bytes'
f.write(j)                          #等价于pickle.dump(dic,f)
f.close()




#反序列化
import pickle
f=open('序列化对象_pickle','rb')
data=pickle.loads(f.read())#  等价于data=pickle.load(f)

print(data['age'])
```

代码示例

```python
#!/usr/bin/env python
# -*- coding:utf8 -*-
# auther; 18793
# Date：2020/2/26 10:35
# filename: 序列化01.py

try:
    import cPickle as pickle
except:
    import pickle

d = dict(url="index.html", title="首页", content="首页")
# print(pickle.dumps(d))
with open("dump1.txt", "wb") as f:
    # f.write(pickle.dumps(d))
    pickle.dump(d, f)

with open("dump1.txt", "rb") as f:
    # print(pickle.loads(f.read()))
    print(pickle.load(f))
```

## 11.json

json 模块以下常用方法和属性：

| 方法                                   | 描述                             | 示例                                                                                                       |
| -------------------------------------- | -------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| json.dumps(obj, \*args, \*\*kwargs)    | 将 Python 对象编码为 JSON 字符串 | >>> import json<br> >>> json.dumps({"name": "Alice", "age": 25})                                           |
| json.loads(s, \*args, \*\*kwargs)      | 将 JSON 字符串解码为 Python 对象 | >>> import json<br> >>> json.loads('{"name": "Alice", "age": 25}')                                         |
| json.dump(obj, fp, \*args, \*\*kwargs) | 将 Python 对象编码并写入文件     | >>> import json<br> >>> with open('data.json', 'w') as f:<br> ... json.dump({"name": "Bob", "age": 30}, f) |
| json.load(fp, \*args, \*\*kwargs)      | 从文件中加载并解码 JSON 数据     | >>> import json<br> >>> with open('data.json', 'r') as f:<br> ... obj = json.load(f)                       |

**json 小工具(将字符串转为 JSON)**

```sh
# 简单的字符格式
[root@k8s-master ~]# echo '{"job":"developer","name":"lmx","sex":"male"}' | python -m json.tool
{
    "job": "developer",
    "name": "lmx",
    "sex": "male"
}

# 复杂的嵌套的格式
[root@k8s-master yum.repos.d]# echo '{"address":{"python":"wuhan","java":"shanghai","Go":"beijing"},"name":"hu"}'| python -m json.tool
{
    "address": {
        "Go": "beijing",
        "java": "shanghai",
        "python": "wuhan"
    },
    "name": "hu"
}
```

处理 JSON 数据

```python
import json

# 字典转 JSON 字符串
data = {'name': 'Alice', 'age': 25}
json_str = json.dumps(data)
print(json_str)

# JSON 字符串转字典
data_back = json.loads(json_str)
print(data_back)
```

**json 与基本数据类型对应关系**

python 数据类型 ------> json 数据 进行传输和存储的过程叫做“编码”

json 数据 ------> python 进行读写的过程叫做“解码”

Python 数据与 JSON 数据类型对应关系

| Python 数据类型 | JSON 数据类型 |
| --------------- | ------------- |
| dict            | object        |
| list, tuple     | array         |
| str             | string        |
| int, float      | number        |
| True            | true          |
| False           | false         |
| None            | null          |

**json 数据编码**

```python
#!/usr/bin/env python
# filename: json模块编码.py
import json

py_dict = {"name": "hujianli", "age": 18, "sex": True}
py_list = [1, 3]
py_tuple = ("A", "B", "C")

py_dict["a"] = py_list
py_dict["b"] = py_tuple
print(py_dict)
print(type(py_dict))

# 编码过程
json_obj = json.dumps(py_dict)
print(json_obj)
print(type(json_obj))

# 编码过程，使用格式化输出
json_obj = json.dumps(py_dict, indent=4)
# 输出格式化后的字符串
print(json_obj)
print(type(json_obj))

# 写入json数据到data1.json文件
with open('data1.json', 'w') as f:
    json.dump(py_dict, f)

# 写入json数据到data2.json文件
with open('data2.json', 'w') as f:
    json.dump(py_dict, f, indent=4)



# 读取data2.json文件中的内容
with open("data2.json", 'r') as f:
    data = json.load(f)
    print(data)
```

**json 数据解码**

```python
#!/usr/bin/env python
# filename: json模块数据解码.py
import json
#准备数据
json_obj = r'{"name":"hujianli","age":20,"sex":true,"a":[1,3],"b":["A","B","C"]}'
print(type(json_obj))

print("开始数据解码".center(100,"*"))
py_dict = json.loads(json_obj)
print(type(py_dict))
print(py_dict["name"])
print(py_dict["sex"])
print(py_dict["age"])

py_list1 = py_dict["a"]
py_list2 = py_dict["b"]
print(py_list1)
print(py_list2)


# 读取data2.json中的数据
with open("data2.json","r") as f:
    data = json.load(f)
    print(data)
    print(type(data))
```

一个快递 API 的例子

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# filename: 快递数据爬取.py

import requests
import json

url = "http://www.kuaidi100.com/query"

querystring = {"type": "shunfeng", "postid": "121213123"}

headers = {
    'User-Agent': "PostmanRuntime/7.19.0",
    'Accept': "_/_",
    'Cache-Control': "no-cache",
    'Host': "www.kuaidi100.com",
    'Accept-Encoding': "gzip, deflate",
    'Connection': "keep-alive",
    'cache-control': "no-cache"
}

response = requests.request("GET", url, headers=headers, params=querystring)
json_data = json.loads(response.text)

with open("kuaidi1.json", "w", encoding="utf-8") as f:
    json.dump(json_data, f, ensure_ascii=False, indent=4)

with open("kuaidi2.json", "w", encoding="utf-8") as f_json:
    f_json.write(json.dumps(json_data, ensure_ascii=False, indent=4))
```

**json 读写文件示例**

如果你要处理的是文件而不是字符串

你可以使用 json.dump() 和 json.load()来编码和解码 JSON 数据。例如：

```python
# Writing JSON data
with open('data.json', 'w') as f:
    json.dump(data, f)

# Reading data back
with open('data.json', 'r') as f:
    data = json.load(f)

json.dumps({'ret':'cmd_ret0', 'out':'cmd_ret1'}, separators=(',', ':'))    # 紧凑的json格式,去掉空格
```

写入 json 文件的时候保持中文，使用参数 `ensure_ascii=False`

```python
with open("翻译.json", "w", encoding="utf-8") as f:
    json.dump(json_data, f, ensure_ascii=False, indent=4)

with open("data.json", "w", encoding="utf-8") as file:
    file.write(json.dumps(json_data, indent=4, ensure_ascii=False))
```

### json 库常用方法

```python
#!/usr/bin/python3
# -*- coding: utf-8 -*-
# ----------------------------------------------------------
# @Description   : 处理json数据
# @Software      : PyCharm
# @Python Version: python3.6.2
# ----------------------------------------------------------

import json
JSON_STRING = '{"username":"meizhaohui","password":"passwd"}'
DICT_DATA = {"username": "meizhaohui", "ID":1, "password": "passwd"}
class jsonAPI:
    def json_to_dict(self, json_string=JSON_STRING):
        """
        将JSON字符串转换成dict字典
        :param json_string: JSON字符串
        :return: dict
        """
        return json.loads(json_string)

    def dict_to_json(self, dict_data):
        """
        将dict字典转换成JSON字符串
        :param dict_data: dict字典
        :return: str
        """
        return json.dumps(dict_data)

    def json_file_to_dict(self, filename):
        """
        读取json文件到dict字典中
        :param filename:  json文件
        :return: dict
        """
        with open(filename) as file:
            return json.load(file)

    def write_json_to_file(self, filename, dict_data):
        """
        将数据转为json字符串并写入文件
        :param filename: 文件名
        :param dict_data: 字典数据
        :return: NoneType
        """
        with open(filename, 'w') as file:
            return json.dump(dict_data, file)

    def write_pretty_json_to_file(self, filename, dict_data):
        """
        将数据转为json字符串并写入文件
        :param filename: 文件名
        :param dict_data: 字典数据
        :return: NoneType
        """
        with open(filename, 'w') as file:
            # sort_keys 是否按key排序,默认False
            # indent 缩进长度，几个空格，建议用4或"    "四个空格
            # seperators分隔符是(item_separator, key_separator)的元组，默认(', ', ': ')
            # 第一个是每行键值对后的分隔符，第二个是每行键值对之间的分隔符
            return json.dump(dict_data, file, sort_keys=True, indent=4, separators=(',', ': '))


if __name__ == "__main__":
    JAPI = jsonAPI()
    print(JAPI.json_to_dict(JSON_STRING))
    print(type(JAPI.json_to_dict(JSON_STRING)))
    print(JAPI.dict_to_json(DICT_DATA))
    print(type(JAPI.dict_to_json(DICT_DATA)))
    FILENAME='json_file.json'
    print(JAPI.json_file_to_dict(FILENAME))
    print(type(JAPI.json_file_to_dict(FILENAME)))
    NEW_JSON_FILE='new_json.json'
    print(type(JAPI.write_json_to_file(NEW_JSON_FILE, DICT_DATA)))
    PRETTY_JSON_FILE = 'pretty_json.json'
    print(type(JAPI.write_pretty_json_to_file(PRETTY_JSON_FILE, DICT_DATA)))


"""
output as follow:

{'username': 'meizhaohui', 'password': 'passwd'}
<class 'dict'>
{"username": "meizhaohui", "ID": 1, "password": "passwd"}
<class 'str'>
{'user_id': 1, 'username': 'meizhaohui', 'password': 'passwd'}
<class 'dict'>
<class 'NoneType'>
<class 'NoneType'>


json_file.json content:
{
    "user_id":1,
    "username":"meizhaohui",
    "password":"passwd"
}

new_json.json content:
{"username": "meizhaohui", "ID": 1, "password": "passwd"}

pretty_json.json
{
    "ID": 1,
    "password": "passwd",
    "username": "meizhaohui"
}

"""
```

参考文献：

- https://hellogitlab.com/backend/python/X_json_module

## 12.time

time 模块用于满足简单的时间处理，例如获取当前时间戳、日期、时间、休眠。

time 模块以下常用方法和属性：

| 方法                     | 描述                                               | 示例                                                                                    |
| ------------------------ | -------------------------------------------------- | --------------------------------------------------------------------------------------- |
| time()                   | 返回当前时间的时间戳                               | >>> import time<br> >>> current_time = time.time()                                      |
| localtime(\[secs\])      | 将一个时间戳转换为本地时间                         | >>> import time<br> >>> local_time = time.localtime(current_time)                       |
| gmtime(\[secs\])         | 将一个时间戳转换为 UTC 时间                        | >>> import time<br> >>> utc_time = time.gmtime(current_time)                            |
| strftime(format[, t])    | 格式化时间为字符串                                 | >>> import time<br> >>> formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", local_time) |
| strptime(string, format) | 将字符串解析为时间对象                             | >>> import time<br> >>> parsed_time = time.strptime("2022-01-01", "%Y-%m-%d")           |
| sleep(secs)              | 暂停指定的秒数                                     | >>> import time<br> >>> time.sleep(5)                                                   |
| perf_counter()           | 返回性能计数器的值，用于精确计时                   | >>> import time<br> >>> start_time = time.perf_counter()                                |
| process_time()           | 返回当前进程的 CPU 时间                            | >>> import time<br> >>> cpu_time = time.process_time()                                  |
| monotonic()              | 返回单调时钟的值，用于测量时间间隔                 | >>> import time<br> >>> start_time = time.monotonic()                                   |
| monotonic_ns()           | 返回单调时钟的值（以纳秒为单位），用于测量时间间隔 | >>> import time<br> >>> start_time_ns = time.monotonic_ns()                             |

更多参考
https://my-go-py-blog.readthedocs.io/en/latest/Python/12.Python%E6%A0%87%E5%87%86%E5%BA%93/04.time-datetime%E6%A8%A1%E5%9D%97.html

## 13.datetime

datetime 模块用于处理更复杂的日期和时间。
datetime 模块以下常用方法和属性：

| 方法                                                                                                | 描述                                                 | 示例                                                                                         |
| --------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | -------------------------------------------------------------------------------------------- |
| datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])                     | 创建一个表示特定日期和时间的 datetime 对象           | >>> import datetime<br> >>> dt = datetime.datetime(2022, 1, 1, 12, 0, 0)                     |
| datetime.now(\[tz\])                                                                                | 返回当前日期和时间的 datetime 对象                   | >>> import datetime<br> >>> current_dt = datetime.datetime.now()                             |
| datetime.strftime(format)                                                                           | 格式化日期和时间为字符串                             | >>> import datetime<br> >>> formatted_dt = current_dt.strftime("%Y-%m-%d %H:%M:%S")          |
| datetime.strptime(date_string, format)                                                              | 将字符串解析为 datetime 对象                         | >>> import datetime<br> >>> parsed_dt = datetime.datetime.strptime("2022-01-01", "%Y-%m-%d") |
| datetime.timestamp()                                                                                | 返回 datetime 对象的 POSIX 时间戳                    | >>> import datetime<br> >>> timestamp = dt.timestamp()                                       |
| datetime.replace(\[year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])      | 创建一个新的 datetime 对象，替换指定的日期和时间部分 | >>> import datetime<br> >>> new_dt = dt.replace(year=2023)                                   |
| datetime.timedelta(\[days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]]) | 表示两个日期或时间之间的时间差                       | >>> import datetime<br> >>> td = datetime.timedelta(days=7)                                  |
| datetime.fromtimestamp(timestamp\[, tz\])                                                           | 从 POSIX 时间戳创建一个 datetime 对象                | >>> import datetime<br> >>> dt = datetime.datetime.fromtimestamp(timestamp)                  |
| datetime.utcfromtimestamp(timestamp)                                                                | 从 POSIX 时间戳创建一个 UTC datetime 对象            | >>> import datetime<br> >>> utc_dt = datetime.datetime.utcfromtimestamp(timestamp)           |

更多参考
https://my-go-py-blog.readthedocs.io/en/latest/Python/12.Python%E6%A0%87%E5%87%86%E5%BA%93/04.time-datetime%E6%A8%A1%E5%9D%97.html

## 14.urllib

urllib 提供了一系列用于操作 URL 的功能，其中最常用的请求是 GET 和 POST。
下面简单介绍一下在 Python 中使用 GET 和 POST 请求。

```python
# get 请求
from urllib import request
def get_request():
    with request.urlopen("http://www.baidu.com") as f:
        data = f.read()
        print("Status: ", f.status, f.reason)
        for k, v in f.getheaders():
            print("{}:{}".format(k, v))
    print("Data: ", data.decode('utf-8'))


# get 获得静态数据
import urllib.request

url = 'https://www.nasdaq.com/symbol/aapl/historical#.UWdnJBDMhHk'
req = urllib.request.Request(url)

with urllib.request.urlopen(req) as response:
    data = response.read()
    htmlstr = data.decode()
    print(htmlstr)

# get 获得动态数据
import re
import urllib.request

url = 'http://q.stock.sohu.com/hisHq?code=cn_600519&stat=1&order=D&period=d&callback=historySearchHandler&rt=jsonp&0.8115656498417958'
req = urllib.request.Request(url)

with urllib.request.urlopen(req) as response:
    data = response.read()
    htmlstr = data.decode('gbk')
    print(htmlstr)
    htmlstr = htmlstr.replace('historySearchHandler(', '')
    htmlstr = htmlstr.replace(')', '')
    print('替换后的：', htmlstr)




# post请求
from urllib import parse
from urllib import request

query_args = {'q': 'query string', 'foo': 'bar'}
encoded_args = parse.urlencode(query_args).encode('utf-8')
url = 'http://localhost:8080/'
print(request.urlopen(url, encoded_args).read().decode('utf-8'))
```

简单的小爬虫

```python
import urllib.request

import os
import re

url = 'http://p.weather.com.cn/'


def findallimageurl(htmlstr):
    """从HTML代码中查找匹配的字符串"""

    # 定义正则表达式
    pattern = r'http://\S+(?:\.png|\.jpg)'
    return re.findall(pattern, htmlstr)


def getfilename(urlstr):
    """根据图片连接地址截取图片名"""

    pos = urlstr.rfind('/')
    return urlstr[pos + 1:]


# 分析获得的url列表
url_list = []
req = urllib.request.Request(url)
with urllib.request.urlopen(req) as response:
    data = response.read()
    htmlstr = data.decode()

    url_list = findallimageurl(htmlstr)

for imagesrc in url_list:
    # 根据图片地址下载
    req = urllib.request.Request(imagesrc)
    with urllib.request.urlopen(req) as response:
        data = response.read()
        # 过滤掉用小于100kb字节的图片
        if len(data) < 1024 * 100:
            continue

        # 创建download文件夹
        if not os.path.exists('download'):
            os.mkdir('download')

        # 获得图片文件名
        filename = getfilename(imagesrc)
        filename = 'download/' + filename
        # 保存图片到本地
        with open(filename, 'wb') as f:
            f.write(data)

    print('下载图片', filename)
```

https://learnku.com/docs/pymotw/urllibrequest-network-resource-access/3433

## 15.requests

从给定的 URL 下载文件，并保存到本地。

```python
import requests
import shutil

def download_file(url):
    local_filename = url.split('/')[-1]
    with requests.get(url, stream=True) as r:
        with open(local_filename, 'wb') as f:
            shutil.copyfileobj(r.raw, f)    # shutil.copyfileobj(r.raw, f)：将响应的原始内容（r.raw）复制到打开的文件中。这是一种高效的文件复制方法。

    return local_filename


download_file('https://www.python.org/ftp/python/3.6.15/Python-3.6.15.tar.xz')
```

https://my-go-py-blog.readthedocs.io/en/latest/Python/12.Python%E6%A0%87%E5%87%86%E5%BA%93/25.requests%E6%A8%A1%E5%9D%97.html

## 16.configparser

### 生成一个配置文档

配置文件 `example.ini`

```ini
[default]
serveraliveinterval = 45
compression = yes
compressionlevel = 9

[bitbucket.org]
user = hg

[topsecret.server.com]
port = 50022
forwardx11 = no
```

注:生成配置文件 `example.ini` 的代码如下：

```python
import configparser

config = configparser.ConfigParser()
config['default'] = {'ServerAliveInterval':'45',
                     'Compression':'yes',
                     'CompressionLevel':'9'}

config['bitbucket.org'] = {}
config['bitbucket.org']['User'] = 'hg'


config['topsecret.server.com'] = {'port':'50022',
                                'Forwardx11':'no'}

with open('example.ini','w') as configfile:
    config.write(configfile)
```

### 读取

```python
import configparser

config = configparser.ConfigParser()
print(config.read('example.ini'))

#查看所有的标题
print(config.sections())
#['default', 'bitbucket.org', 'topsecret.server.com']

#查看标题section1下所有key=value的key
options = config.options('default')
print(options)
#['serveraliveinterval', 'compression', 'compressionlevel']

# 注：conf.defaults：读取的是defaults以字典类型读取
print(conf.defaults())

# 注：conf.sections：读取的是节点，不包含defaults。
print(conf.sections())

# 注：conf['bitbucket.org']['user']：则是直接读取节点下内容。
print(conf['bitbucket.org']['user'])

#查看标题section1下所有key=value的(key,value)格式
items_list = config.items('topsecret.server.com')
print(items_list)
#[('port', '50022'), ('forwardx11', 'no')]
```

### 增删改查

```python
import configparser

config = configparser.ConfigParser()
config.read('example.ini',encoding = 'utf-8')

#删除整个标题
config.remove_section('bitbucket.org')

#删除标题下的option
config.remove_option('topsecret.server.com','port')

#添加一个标题
config.add_section('info')
#在标题下添加options
config.set('info','name','derek')

#判断是否存在
print(config.has_section('info'))        #True
print(config.has_option('info','name'))    #True

#将修改的内容存入文件
config.write(open('new_example.ini','w'))
```

修改后的 `new_example.ini` 配置文件

```ini
[default]
serveraliveinterval = 45
compression = yes
compressionlevel = 9

[topsecret.server.com]
forwardx11 = no

[info]
name = derek
```

### Python 操作 ini 的三种方法

#### crudini

crudini 是一个命令行工具，用于管理 ini 配置文件。

```sh
crudini --set [--existing] config_file section [param] [value]    # 修改配置文件内容
crudini --get [--format=sh|ini] config_file [section] [param]     # 获取配置文件内容
crudini --del [--existing] config_file section [param]            # 删除配置文件内容
crudini --merge [--existing] config_file [section]                # 合并
```

举例

```sh
# 添加
crudini --set test.ini test_section test_param test_value

# 更新
crudini --set [--existing] test.ini test_section test_param test_value

# 删除
# 删除param：
crudini --del test.ini test_section test_param

# 删除section：
crudini --del test.ini test_section

# 获取
crudini --del test.ini test_section test_param

# 如果该标量不在某一个section里面，则section用一个空字符表示：
crudini --del test.ini '' test_param

# 合并
## 将another.ini配置文件合并到test.ini中：
crudini --merge test.ini < another.ini
```

#### ConfigParser 模块

ConfigParser 模块为常用的操作 ini 文件的模块，但是存在一些缺陷，无法识别 section 的大小写，无法读取文件注释，这样修带有注释的配置文件时就会存在问题。

示例文件 test.ini

```ini
[test_section]
test_param = test_value
```

```python
# 读取
import ConfigParser
config = ConfigParser.ConfigParser()
config.readfp(open('test.ini'))
test_value = config.get("test_section","test_param")

# 写入
##添加section
import ConfigParser
config = ConfigParser.ConfigParser()
# set a value of parameters
config.add_section("test_section2")
config.set("test_section2", "test_param2", "test_value2")
config.set("test_section3", "test_param3", "test_value3")
# write to file
config.write(open('test.ini', "w"))


# 修改
import ConfigParser
config = ConfigParser.ConfigParser()
config.read('1.ini')
config.set("test_section", "test_param3", "test_value3")
config.write(open('test.ini', "r+"))
```

#### configobj 模块

ConfigParser 一些问题。

1. 不能区分大小写。
2. 重新写入的 ini 文件不能保留原有 INI 文件的注释。
3. 重新写入的 ini 文件不能保持原有的顺序。
4. 不支持嵌套。
5. 不支持格式校验。

所以推荐 configobj 读写配置文件

```sh
pip install configobj
```

示例 test.ini 文件

```ini
[server]
servername = 192.168.11.1
serverport = 8000

[client_srv]
# 这里是注释
server = localhost
port = 8000
```

读配置文件

```python
from configobj import ConfigObj

conf_ini = "./test.ini"
config = ConfigObj(conf_ini, encoding='UTF8')

# 读配置文件
print(config['server'])
print(config['server']['servername'])
```

写配置文件

```python
from configobj import ConfigObj

config = ConfigObj()
config.filename = './write_config.ini'

config['keyword1'] = 'value_1'
config['keyword2'] = 'value_2'

config['section1'] = {}
config['section1']['keyword3'] = 'value_3'
config['section1']['keyword4'] = 'value_4'
#
section2 = {
    'keyword5': 'value_5',
    'keyword6': 'value_6',
    'sub-section': {
        'keyword7': 'value_7'
    }
}
config['section2'] = section2

config['section3'] = {}
config['section3']['keyword 8'] = ['value_8', 'value_9', 'value_10']
config['section3']['keyword 9'] = ['value_11', 'value_12', 'value_13']
config.write()
```

修改 配置文件

```python
from configobj import ConfigObj
#
conf_ini = "./test.ini"
config = ConfigObj(conf_ini,encoding='UTF8')
config['server']['servername'] = "127.0.0.1"
config.write()
```

添加 新项

```python
from configobj import ConfigObj
#
conf_ini = "./test.ini"
config = ConfigObj(conf_ini,encoding='UTF8')
config['new_items'] = {}
config['new_items']['Items1'] = "test items"
config.write()
```

删除项

```python
from configobj import ConfigObj
#
conf_ini = "./test.ini"
config = ConfigObj(conf_ini,encoding='UTF8')
del config['client_srv']['port']
config.write()
```

将配置文件写入到不同的文件

````python
from configobj import ConfigObj
#
conf_ini = "./test.ini"
config = ConfigObj(conf_ini,encoding='UTF8')
del config['client_srv']['port']
config.filename = "./test1.ini"
config.write()
```

### 参考文献

https://python3-cookbook.readthedocs.io/zh-cn/latest/c13/p10_read_configuration_files.html

https://learnku.com/docs/pymotw/configparser-work-with-configuration-files/3455

常用模块和使用案例

- https://www.cnblogs.com/wf-linux/archive/2018/08/01/9400354.html

Python3 读写 ini 配置文件

- https://sre.ayunw.cn/posts/python3_read_and_write_ini_config_file/

## 17.getopt

此模块帮助脚本解析 sys.argv 中的命令行参数。它支持与 Unix getopt()函数相同的约定（包括“-”和“-- ’）。类似于 GNU 软件支持的长选项也可以通过可选的第三个参数使用。

在脚本中，典型的用法是这样的：

```python
import getopt, sys

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "ho:v", ["help", "output="])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(err)  # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    output = None
    verbose = False
    for o, a in opts:
        if o == "-v":
            verbose = True
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-o", "--output"):
            output = a
        else:
            assert False, "unhandled option"
    # ...

if __name__ == "__main__":
    main()
````

注意，通过使用`argparse`模块，可以生成更少代码和更多信息帮助和错误消息的等效命令行界面：

```python
import argparse

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-o', '--output')
    parser.add_argument('-v', dest='verbose', action='store_true')
    args = parser.parse_args()
    # ... do something with args.output ...
    # ... do something with args.verbose ..
```

也可以看看模块 argparse 备用命令行选项和参数解析库。

参考文献：

https://learnku.com/docs/pymotw/getopt-command-line-option-parsing/3450#38e213

https://www.cnblogs.com/lsdb/p/9799679.html

### ansible 中 configparser 的使用

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import (absolute_import, division, print_function)
import os
import sys
import configparser

__metaclass__ = type


# copied from utils, avoid circular reference fun :)
def mk_boolean(value):
    if value is None:
        return False
    val = str(value)
    if val.lower() in ["true", "t", "y", "1", "yes"]:
        return True
    else:
        return False


def get_config(p, section, key, env_var, default, boolean=False, integer=False, floating=False, islist=False):
    ''' return a configuration variable with casting '''
    value = _get_config(p, section, key, env_var, default)
    if boolean:
        return mk_boolean(value)
    if value and integer:
        return int(value)
    if value and floating:
        return float(value)
    if value and islist:
        return [x.strip() for x in value.split(',')]
    return value


def _get_config(p, section, key, env_var, default):
    ''' helper function for get_config '''
    if env_var is not None:
        value = os.environ.get(env_var, None)
        if value is not None:
            return value
    if p is not None:
        try:
            return p.get(section, key, raw=True)
        except:
            return default
    return default


def load_config_file():
    ''' Load Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''

    p = configparser.ConfigParser()

    path0 = os.getenv("ANSIBLE_CONFIG", None)
    if path0 is not None:
        path0 = os.path.expanduser(path0)
    path1 = os.getcwd() + "/ansible.cfg"
    path2 = os.path.expanduser("~/.ansible.cfg")
    path3 = "/etc/ansible/ansible.cfg"

    for path in [path0, path1, path2, path3]:
        if path is not None and os.path.exists(path):
            try:
                p.read(path)
            except configparser.Error as e:
                print("Error reading config file: \n%s" % e)
                sys.exit(1)
            return p
    return None


def shell_expand_path(path):
    ''' shell_expand_path is needed as os.path.expanduser does not work
        when path is None, which is the default for ANSIBLE_PRIVATE_KEY_FILE '''
    if path:
        path = os.path.expanduser(os.path.expandvars(path))
    return path


p = load_config_file()

active_user = os.getenv("USER", None)

# sections in config file
DEFAULTS = 'defaults'

# configurable things
DEFAULT_HOST_LIST = shell_expand_path(get_config(p, DEFAULTS, 'inventory', 'ANSIBLE_INVENTORY',
                                                 get_config(p, DEFAULTS, 'hostfile', 'ANSIBLE_HOSTS',
                                                            '/etc/ansible/hosts')))
DEFAULT_MODULE_PATH = get_config(p, DEFAULTS, 'library', 'ANSIBLE_LIBRARY', None)
# CONNECTION RELATED
ANSIBLE_SSH_ARGS = get_config(p, 'ssh_connection', 'ssh_args', 'ANSIBLE_SSH_ARGS', None)
ANSIBLE_SSH_CONTROL_PATH = get_config(p, 'ssh_connection', 'control_path', 'ANSIBLE_SSH_CONTROL_PATH',
                                      "%(directory)s/ansible-ssh-%%h-%%p-%%r")
ANSIBLE_SSH_PIPELINING = get_config(p, 'ssh_connection', 'pipelining', 'ANSIBLE_SSH_PIPELINING', False, boolean=True)
PARAMIKO_RECORD_HOST_KEYS = get_config(p, 'paramiko_connection', 'record_host_keys',
                                       'ANSIBLE_PARAMIKO_RECORD_HOST_KEYS', True, boolean=True)

if __name__ == '__main__':
    print(DEFAULT_HOST_LIST)
    print(DEFAULT_MODULE_PATH)
    print(ANSIBLE_SSH_ARGS)
    print(ANSIBLE_SSH_CONTROL_PATH)
    print(ANSIBLE_SSH_PIPELINING)
    print(PARAMIKO_RECORD_HOST_KEYS)
```

## 18.argparse(命令行参数解析)

python 3.2 之前的版本参数解析库是 optparse，用法和 argparse 类似且会被取代就不介绍了。

argparse 模块用于命令行参数解析，能自动生成帮助文档。

```python
import argparse
parser = argparse.ArgumentParser( prog='usage_name', description='开头打印', epilog="结束打印")
parser.add_argument('-f', '--foo', help='foo help', action='append')      # 可选参数,如使用此参数必须传值 action='store_true' 不加参数为True  action='append' 多个参数可叠加为列表
parser.add_argument('--aa', type=int, default=42, help='aa!')             # type规定参数类型,default设置默认值
parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')     # 位置参数 必须传递  nargs=2 需要传递2个参数
parser.add_argument('args', nargs=argparse.REMAINDER)                     # 剩余参数收集到列表
parser.print_help()                                                       # 打印使用帮助
#parser.parse_args('BAR --foo FOO'.split())                               # 设置位置参数
args = parser.parse_args()                                                # 全部的值
parser.get_default('foo')                                                 # 获取
```

```sh
python a.py --foo ww  --aa 40 xuesong 27                                  # 执行此脚本
```

其他参数设置示例

```python
def get_args():
    parser = ArgumentParser(
        description="Investigate nucleotide composition and base quality.")
    parser.add_argument("-v", "--version",
                        help="Print version and exit.",
                        action="version",
                        version='NanoQC {}'.format(__version__))
    parser.add_argument("--outdir",
                        help="Specify directory in which output has to be created.",
                        default=".")
    parser.add_argument("-f", "--format",
                        help="Specify the output format of the plots.",
                        default="png",
                        type=str,
                        choices=['eps', 'jpeg', 'jpg', 'pdf', 'pgf', 'png', 'ps',
                                 'raw', 'rgba', 'svg', 'svgz', 'tif', 'tiff'])
    parser.add_argument("fastq",
                        help="Reads data in fastq format.")
    return parser.parse_args()
```

```python
def get_args():
    """
    Return Command Line Arguments.
    :return: ArgumentParser instance
    """
    parser = ArgumentParser(description="vSphere Ansible Inventory.",
                            epilog="Example:\n"
                                   "./vsphere_inventory.py -l\n"
                                   "./vsphere_inventory.py -s <vSphere.hostname>"
                                   "-u <vSphere_username> -p <vSphere_password> -l\n")
    parser.add_argument('-s', '--hostname', help='vSphere vCenter FQDN')
    parser.add_argument('-u', '--username', help='vSphere username')
    parser.add_argument('-p', '--password', help='vSphere password')
    parser.add_argument('-P', '--port', help='vSphere Port')
    parser.add_argument('-c', '--no_cert_check', help='Dont check vSphere certificate', action='store_true')
    parser.add_argument('-g', '--guest', help='Print a single guest')
    parser.add_argument('-x', '--host', help='Print a single guest')
    parser.add_argument('-r', '--reload-cache', help='Reload cache', action='store_true')
    parser.add_argument('-l', '--list', help='List all VMs', action='store_true')

    return parser.parse_args()
```

```python
def parse_options():
    """
    parse command line options
    """
    parser = argparse.ArgumentParser()

    helptext="Root path of input run for which metadata should be created, should contain metadata.tsv and genome_to_id.tsv"
    parser.add_argument("-i", "--input-run", type=str, help=helptext)

    helptext="output file to write metadata to"
    parser.add_argument("-o", "--output", type=str, help=helptext)

    helptext="Name of the data set"
    parser.add_argument("-n", "--name", type=str, help=helptext)

    if not len(sys.argv) > 1:
        parser.print_help()
        return None
    args = parser.parse_args()

    return args
```

学习这个工具目的是为后面写工具，给用户提供一个友好的使用方式。

### 示例 1

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2024/3/22 21:45
# @Author  : hjl
# @Site    :
# @File    : argparse-ex.py
# @Software: PyCharm
# @Desc    :

import argparse

"""
# parser.add_argument()支持参数及各参数说明如下:

    # 默认会自动添加-h参数，-h的作用是打印各参数说明并使用exit退出。不想要原始的-h可设置add_help=False指示不自动添加
    # parser = argparse.ArgumentParser(add_help=False)
    # parser.add_argument()支持参数及各参数说明如下
    # 开头的非关键字参数--可以是-开头的短格式，也可以是--开头的长格式。
    #   --其中短格式也支持-ltnp等多个参数连写的形式，但这多个连写的参数必须都已注册，不然程序会直接报错退出
    # action--参数操作动作
    #   --store(赋值)/store_const(赋给定的常量值)/store_true(如果命令中有该参数赋true)/store_false(如果命令中无该参数赋false)/append(多次出现时拼成列表)/
    #   --count(赋出现的次数)/help(打印帮助)/version(打印--version参数)/extend(存成列表)。默认为store
    # nargs--消费其后多少个参数作为其值。不同参数操作动作默认消费个数不同
    # const--当action为store_const时，要赋值变量的常量值
    # default--当命令行没有该参数时，该参数的默认值。默认为None
    # type--变量类型。可以是所有python的变量类型，默认是str
    # choices--可给该参数传的值的可选列表
    # required--参数是否必须。默认为false
    # help--参数描述信息
    # metavar--参数赋值形式示例
    # dest--参数解析后赋值到的变量。默认先赋给dest，没有则赋给长格式，没有再赋给短格式
"""

def _argparse():
    # 脚本的描述
    parser = argparse.ArgumentParser(description='Search some files')
    # 脚本接收的全部参数,用`filenames`接收
    # nargs 参数收集所有剩余的命令行参数到一个列表中。在本例中它被用来构造一个文件名列表
    parser.add_argument(dest='filenames', metavar='filename', nargs='*')

    # 脚本接收
    # action='append' 参数说明允许某个参数重复出现多次，并将它们追加到一个列表中去。
    # required 标志表示该参数至少要有一个。-p 和 --pat 表示两个参数名形式都可使用。
    # metavar参数用于指定在使用帮助信息中显示的参数占位符。
    # 在这里，metavar='pattern'指定了在帮助信息中替代-p/--pat参数的占位符为pattern。这有助于用户理解该参数的预期输入格式。
    parser.add_argument('-p', '--pat', metavar='pattern', required=True,
                        dest='patterns', action='append',
                        help='text pattern to search for')
    # action='store_true' 根据参数是否存在来设置一个 Boolean 标志：
    parser.add_argument('-v', dest='verbose', action='store_true',
                        help='verbose mode')

    # action='store' 参数接受一个单独值并将其存储为一个字符串
    parser.add_argument('-o', dest='outfile', action='store',
                        help='output file')

    # choices={'slow', 'fast'}, 参数说明接受一个值，但是会将其和可能的选择值做比较，以检测其合法性：
    parser.add_argument('--speed', dest='speed', action='store',
                        choices={'slow', 'fast'}, default='slow',
                        help='search speed')
    return parser.parse_args()


if __name__ == '__main__':
    args = _argparse()
    # Output the collected arguments
    print(args.filenames)
    print(args.patterns)
    print(args.verbose)
    print(args.outfile)
    print(args.speed)
```

```sh
$ python argparse-ex.py --help

Search some files

positional arguments:
  filename

options:
  -h, --help            show this help message and exit
  -p pattern, --pat pattern
                        text pattern to search for
  -v                    verbose mode
  -o OUTFILE            output file
  --speed {slow,fast}   search speed


$ python argparse-ex.py --pat=eggs --speed fast  foo.txt bar.txt
['foo.txt', 'bar.txt']
['eggs']
False
None
fast
```

### 示例 2

```python
import argparse


def _argparse():
    parser = argparse.ArgumentParser(description="This is description")
    parser.add_argument("--host", action="store",
                        dest="server", default="localhost", help="connect to host")
    parser.add_argument("-t", action="store_true",
                        dest="boolean_switch", default=False, help="Set a switch to true")
    return parser.parse_args()


def main():
    parser = _argparse()
    print(parser)
    print("host = ", parser.server)
    print("boolean_switch=", parser.boolean_switch)


if __name__ == '__main__':
    main()
```

输出信息

```sh
python apgparse模块.py
Namespace(boolean_switch=False, server='localhost')
host =  localhost
boolean_switch= False

python apgparse模块.py --host=127.0.0.1 -t
Namespace(boolean_switch=True, server='127.0.0.1')
host =  127.0.0.1
boolean_switch= True
```

### 示例 3

模仿 Mysql 客户端的命令行参数

```python
import argparse


def _argparse():
    parser = argparse.ArgumentParser(description="A Python-MySQL client")
    parser.add_argument("--host", action="store",
                        dest="host", required=True, help="connect to host")

    parser.add_argument("-u", "--user", action="store",
                        dest="user", required=True, help="user for login")

    parser.add_argument("-p", "--password", action="store",
                        dest="password", required=True,
                        help="password to use when connecting to server")

    parser.add_argument("-P", "--port", action="store",
                        dest="port", default=3306, type=int,
                        help="port number to use for connection or 3306 for default")
    parser.add_argument("-v", "--version", action="version", version='%(prog)s 0.1')
    return parser.parse_args()

def main():
    parser = _argparse()
    conn_args = dict(host=parser.host, user=parser.user,
                     password=parser.password,port=parser.port)
    print(conn_args)

if __name__ == '__main__':
    main()
```

输出信息

```sh
python apgparse模块.py --help

usage: apgparse模块.py [-h] --host HOST -u USER -p PASSWORD [-P PORT] [-v]

A Python-MySQL client

optional arguments:
  -h, --help            show this help message and exit
  --host HOST           connect to host
  -u USER, --user USER  user for login
  -p PASSWORD, --password PASSWORD
                        password to use when connecting to server
  -P PORT, --port PORT  port number to use for connection or 3306 for default
  -v, --version         show program's version number and exit
```

### 示例 4

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import argparse


def get_argparse():
    parser = argparse.ArgumentParser(description='A email client in terminal')
    parser.add_argument('-s', action='store', dest='subject', required=True, help='specify a subject (must be in quotes if it has spaces)')
    parser.add_argument('-a', action='store', nargs='*', dest='attaches', required=False, help='attach file(s) to the message')
    parser.add_argument('-f', action='store', dest='conf', required=False, help='specify an alternate .emcli.cnf file')
    parser.add_argument('-r', action='store', nargs='*', dest='recipients', required=True, help='recipient who you are sending the email to')
    parser.add_argument('-v', action='version', version='%(prog)s 0.2')
    return parser.parse_args()



if __name__ == '__main__':
    parser = get_argparse()
    print(parser)
    print("s = ", parser.subject)
    print("r = ", parser.recipients)
    print("f = ", parser.conf)
```

```sh
> python argparse02.py -s hu -r huajianli -f "config.cfg"
Namespace(attaches=None, conf='config.cfg', recipients=['huajianli'], subject='hu')
s =  hu
r =  ['huajianli']
f =  config.cfg
```

https://learnku.com/docs/pymotw/argparse-command-line-option-and-argument-parsing/3449

### 示例 5

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import requests
import argparse

DOCKER_REGISTRY_URL = "http://localhost:4000/v2"


def list_repositories():
    """
    打印镜像和镜像对应的tag
    :return:
    """
    response = requests.get(f"{DOCKER_REGISTRY_URL}/_catalog")
    repositories = response.json().get("repositories", [])
    print("-" * 80)
    for repo in repositories:
        list_tags(repo)


def list_tags(repository_name):
    """
    打印指定仓库的标签列表
    :param repository_name: 仓库名称
    :return:
    """
    response = requests.get(f"{DOCKER_REGISTRY_URL}/{repository_name}/tags/list")
    tags = response.json().get("tags", [])
    # tags_str = ", ".join(tags)  # 将标签列表转换为逗号分隔的字符串
    # print(f"Tags for repository '{repository_name}': {tags_str}")
    # print(f"{repository_name}: {tags_str}")
    print(f"{repository_name}:\t {tags}")
    print("-" * 80)


def delete_image(repository_name, tag):
    response = requests.delete(f"{DOCKER_REGISTRY_URL}/{repository_name}/manifests/{tag}")
    if response.status_code == 202:
        print(f"Image '{repository_name}:{tag}' deleted successfully.")
    else:
        print(f"Failed to delete image '{repository_name}:{tag}'. Status code: {response.status_code}")


def main():
    parser = argparse.ArgumentParser(description="Docker CLI Tool")
    parser.add_argument("command", choices=["list", "tags", "delete"], help="Command to execute")
    parser.add_argument("--repository", help="Repository name")
    parser.add_argument("--tag", help="Tag name (required for 'delete' command)")
    args = parser.parse_args()

    if args.command == "list":
        list_repositories()
    elif args.command == "tags":
        if not args.repository:
            print("Repository name is required for 'tags' command.")
            return
        list_tags(args.repository)
    elif args.command == "delete":
        if not args.repository or not args.tag:
            print("Repository name and tag are required for 'delete' command.")
            return
        delete_image(args.repository, args.tag)
    else:
        print("Invalid command. Use 'list', 'tags', or 'delete'.")


if __name__ == "__main__":
    main()
```

### 示例 6

一个命令行参数的 udp 广播 python 服务端和客户端

UDP client and server for broadcast messages on a local LAN

```python
import argparse, socket

BUFSIZE = 65535

def server(interface, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((interface, port))
    print('Listening for datagrams at {}'.format(sock.getsockname()))
    while True:
        data, address = sock.recvfrom(BUFSIZE)
        text = data.decode('ascii')
        print('The client at {} says: {!r}'.format(address, text))

def client(network, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    text = 'Broadcast datagram!'
    sock.sendto(text.encode('ascii'), (network, port))

if __name__ == '__main__':
    choices = {'client': client, 'server': server}
    parser = argparse.ArgumentParser(description='Send, receive UDP broadcast')
    parser.add_argument('role', choices=choices, help='which role to take')
    parser.add_argument('host', help='interface the server listens at;'
                        ' network the client sends to')
    parser.add_argument('-p', metavar='port', type=int, default=1060,
                        help='UDP port (default 1060)')
    args = parser.parse_args()
    function = choices[args.role]
    function(args.host, args.p)
```

UDP client and server on localhost

```python
#!/usr/bin/env python3
# Foundations of Python Network Programming, Third Edition
# https://github.com/brandon-rhodes/fopnp/blob/m/py3/chapter02/udp_local.py
# UDP client and server on localhost

import argparse, socket
from datetime import datetime

MAX_BYTES = 65535

def server(port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('127.0.0.1', port))
    print('Listening at {}'.format(sock.getsockname()))
    while True:
        data, address = sock.recvfrom(MAX_BYTES)
        text = data.decode('ascii')
        print('The client at {} says {!r}'.format(address, text))
        text = 'Your data was {} bytes long'.format(len(data))
        data = text.encode('ascii')
        sock.sendto(data, address)

def client(port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    text = 'The time is {}'.format(datetime.now())
    data = text.encode('ascii')
    sock.sendto(data, ('127.0.0.1', port))
    print('The OS assigned me the address {}'.format(sock.getsockname()))
    data, address = sock.recvfrom(MAX_BYTES)  # Danger! See Chapter 2
    text = data.decode('ascii')
    print('The server {} replied {!r}'.format(address, text))

if __name__ == '__main__':
    choices = {'client': client, 'server': server}
    parser = argparse.ArgumentParser(description='Send and receive UDP locally')
    parser.add_argument('role', choices=choices, help='which role to play')
    parser.add_argument('-p', metavar='PORT', type=int, default=1060,
                        help='UDP port (default 1060)')
    args = parser.parse_args()
    function = choices[args.role]
    function(args.p)
```

### 示例 7

ssh 发送命令获取输出的 命令行工具- 单线程版本

```python
#!/usr/bin/env python3
# Foundations of Python Network Programming, Third Edition
# https://github.com/brandon-rhodes/fopnp/blob/m/py3/chapter16/ssh_commands.py
# Running three separate commands, and reading three separate outputs

import argparse, paramiko

class AllowAnythingPolicy(paramiko.MissingHostKeyPolicy):
    def missing_host_key(self, client, hostname, key):
        return

def main(hostname, username):
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(AllowAnythingPolicy())
    client.connect(hostname, username=username)  # password='')

    for command in 'echo "Hello, world!"', 'uname', 'uptime':
        stdin, stdout, stderr = client.exec_command(command)
        stdin.close()
        print(repr(stdout.read()))
        stdout.close()
        stderr.close()

    client.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Connect over SSH')
    parser.add_argument('hostname', help='Remote machine name')
    parser.add_argument('username', help='Username on the remote machine')
    args = parser.parse_args()
    main(args.hostname, args.username)
```

ssh 发送命令获取输出的 命令行工具- 多线程版本

```python
#!/usr/bin/env python3
# Foundations of Python Network Programming, Third Edition
# https://github.com/brandon-rhodes/fopnp/blob/m/py3/chapter16/ssh_threads.py
# Running two remote commands simultaneously in different channels

import argparse, paramiko, threading

class AllowAnythingPolicy(paramiko.MissingHostKeyPolicy):
    def missing_host_key(self, client, hostname, key):
        return

def main(hostname, username):
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(AllowAnythingPolicy())
    client.connect(hostname, username=username)  # password='')

    def read_until_EOF(fileobj):
        s = fileobj.readline()
        while s:
            print(s.strip())
            s = fileobj.readline()

    ioe1 = client.exec_command('echo One;sleep 2;echo Two;sleep 1;echo Three')
    ioe2 = client.exec_command('echo A;sleep 1;echo B;sleep 2;echo C')
    thread1 = threading.Thread(target=read_until_EOF, args=(ioe1[1],))
    thread2 = threading.Thread(target=read_until_EOF, args=(ioe2[1],))
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()

    client.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Connect over SSH')
    parser.add_argument('hostname', help='Remote machine name')
    parser.add_argument('username', help='Username on the remote machine')
    args = parser.parse_args()
    main(args.hostname, args.username)
```

### 示例 8

```python
import sys
import argparse
from os import path

"""
read the CLI version from the VERSION file
"""
DIR_PATH = path.dirname(path.realpath(__file__))
VERSION_FILE = path.join(DIR_PATH, './../VERSION')

def add(args):
    print(args.num1 + args.num2)

def subtract(args):
    print(args.num1 - args.num2)

"""
function to create the parser with subparsers
"""
def create_parser():
    # create the main parser object
    parser = argparse.ArgumentParser(description='CLI demo')
    version = open(VERSION_FILE).read().strip()
    parser.add_argument('--version', '-V', action='version', version=version)
    # addition subparser
    subparsers = parser.add_subparsers()
    add_subparser = subparsers.add_parser('add', help='add 2 numbers')
    add_subparser.add_argument('--num1', '-a', help='first number in operation', type=int, required=True)
    add_subparser.add_argument('--num2', '-b', help='second number in operation', type=int, required=True)
    add_subparser.set_defaults(func=add)
    # subtraction subparser
    subtract_subparser = subparsers.add_parser('subtract', help='subtract 2 numbers')
    subtract_subparser.add_argument('--num1', '-a', help='first number in operation', type=int, required=True)
    subtract_subparser.add_argument('--num2', '-b', help='second number in operation', type=int, required=True)
    subtract_subparser.set_defaults(func=subtract)
    return parser

"""
the main function creating the parser and executing all commands
"""
def main():
    parser = create_parser()
    args = parser.parse_args()
    if len(sys.argv) == 1:
        sys.exit(parser.print_usage())
    args.func(args)
```

参考文献：
https://github.com/sahibdhanjal/PyCLI/tree/master

### 案例 写一个简单的 linux find 命令

```python
import os
import argparse

def parse_args():
    parser = argparse.ArgumentParser(description="A simple implementation of the find command.")
    parser.add_argument('path', help="The path to start the search from.")
    parser.add_argument('-name', help="The filename pattern to search for.")

    return parser.parse_args()

def find_files(start_path, name_pattern=None):
    for root, dirs, files in os.walk(start_path):
        for file_name in files:
            if name_pattern is None or name_pattern in file_name:
                print(os.path.join(root, file_name))

if __name__ == "__main__":
    args = parse_args()
    find_files(args.path, args.name)
```

### 案例 通过 SFTP 把文件复制到远程设备中

```python
#!/usr/bin/env python
import argparse
import getpass
import paramiko

SOURCE = '7_2_copy_remote_file_over_sftp.py'
DESTINATION = '/tmp/7_2_copy_remote_file_over_sftp.py'


def copy_file(hostname, port, username, password, src, dst):
    try:
        client = paramiko.SSHClient()
        client.load_system_host_keys()
        print(f"Connecting to {hostname} with username={username}...")
        client.connect(hostname=hostname, port=port, username=username, password=password)
        sftp = client.open_sftp()
        print(f"Copying file: {src} to path: {dst}")
        sftp.put(src, dst)
        sftp.close()
    except (paramiko.ssh_exception.SSHException, IOError) as e:
        print(f"An error occurred: {e}")
    finally:
        client.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Remote file copy')
    parser.add_argument('--host', action="store", dest="host", default='localhost')
    parser.add_argument('--port', action="store", dest="port", default=22, type=int)
    parser.add_argument('--src', action="store", dest="src", default=SOURCE)
    parser.add_argument('--dst', action="store", dest="dst", default=DESTINATION)

    given_args = parser.parse_args()
    hostname, port = given_args.host, given_args.port
    src, dst = given_args.src, given_args.dst

    username = input("Enter the username: ")
    password = getpass.getpass(f"Enter password for {username}: ")

    copy_file(hostname, port, username, password, src, dst)
```

### 案例 扫描远程主机的指定端口范围

```python
#!/usr/bin/env python
import argparse
import socket
import sys


def scan_ports(host, start_port, end_port):
    """扫描远程主机的指定端口范围，如果端口开放则打印信息。

    :param host: 远程主机的IP地址或域名
    :param start_port: 开始扫描的端口号
    :param end_port: 结束扫描的端口号
    """
    # 创建socket
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(1)  # 设置连接超时时间
            remote_ip = socket.gethostbyname(host)
            for port in range(start_port, end_port):
                try:
                    sock.connect((remote_ip, port))
                    print(f'Port {port} is open')
                except socket.error as e:
                    # 忽略特定的socket错误
                    if 'timed out' not in str(e):
                        print(f'Failed to connect to port {port}: {e}')
                finally:
                    sock.close()
    except socket.error as e:
        print(f'Socket creation failed: {e}')


if __name__ == '__main__':
    # 设置命令行参数
    parser = argparse.ArgumentParser(description='Remote Port Scanner')
    parser.add_argument('--host', action="store", dest="host", default='localhost')
    parser.add_argument('--start-port', action="store", dest="start_port", default=1, type=int)
    parser.add_argument('--end-port', action="store", dest="end_port", default=100, type=int)
    # 解析命令行参数
    args = parser.parse_args()
    host, start_port, end_port = args.host, args.start_port, args.end_port
    scan_ports(host, start_port, end_port)
```

### 案例 一个简单的 TLS 客户端和服务器，使用安全的 pem 文件

```python
#!/usr/bin/env python3
# Foundations of Python Network Programming, Third Edition
# https://github.com/brandon-rhodes/fopnp/blob/m/py3/chapter06/safe_tls.py
# Simple TLS client and server using safe configuration defaults

import argparse, socket, ssl

def client(host, port, cafile=None):
    purpose = ssl.Purpose.SERVER_AUTH
    context = ssl.create_default_context(purpose, cafile=cafile)

    raw_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    raw_sock.connect((host, port))
    print('Connected to host {!r} and port {}'.format(host, port))
    ssl_sock = context.wrap_socket(raw_sock, server_hostname=host)

    while True:
        data = ssl_sock.recv(1024)
        if not data:
            break
        print(repr(data))

def server(host, port, certfile, cafile=None):
    purpose = ssl.Purpose.CLIENT_AUTH
    context = ssl.create_default_context(purpose, cafile=cafile)
    context.load_cert_chain(certfile)

    listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listener.bind((host, port))
    listener.listen(1)
    print('Listening at interface {!r} and port {}'.format(host, port))
    raw_sock, address = listener.accept()
    print('Connection from host {!r} and port {}'.format(*address))
    ssl_sock = context.wrap_socket(raw_sock, server_side=True)

    ssl_sock.sendall('Simple is better than complex.'.encode('ascii'))
    ssl_sock.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Safe TLS client and server')
    parser.add_argument('host', help='hostname or IP address')
    parser.add_argument('port', type=int, help='TCP port number')
    parser.add_argument('-a', metavar='cafile', default=None,
                        help='authority: path to CA certificate PEM file')
    parser.add_argument('-s', metavar='certfile', default=None,
                        help='run as server: path to server PEM file')
    args = parser.parse_args()
    if args.s:
        server(args.host, args.port, args.s, args.a)
    else:
        client(args.host, args.port, args.a)
```

### 案例 子命令实现 git demo

有时候，我们的程序可能需要根据不同的命令执行不同的操作。比如 git 程序，它有很多子命令，如 git clone、git pull 等，不同的子命令会执行不同的操作。argparse 支持这种子命令的创建。

```python
import argparse
import sys

def clone_repository(repo):
    print(f"Cloning repository {repo}...")

def pull_repository(repo):
    print(f"Pulling repository {repo}...")

def main():
    parser = argparse.ArgumentParser(description='Git-like command-line tool')
    subparsers = parser.add_subparsers(dest='command', help='Sub-command help')

    # 创建 'clone' 子命令的解析器
    parser_clone = subparsers.add_parser('clone', help='Clone a repository')
    parser_clone.add_argument('repository', help='Repository to clone')

    # 创建 'pull' 子命令的解析器
    parser_pull = subparsers.add_parser('pull', help='Pull a repository')
    parser_pull.add_argument('repository', help='Repository to pull')

    args = parser.parse_args()

    if args.command == 'clone':
        clone_repository(args.repository)
    elif args.command == 'pull':
        pull_repository(args.repository)
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == '__main__':
    main()
```

```sh
# 克隆仓库
python script.py clone https://github.com/example/repo.git
# 拉取仓库
python script.py pull https://github.com/example/repo.git
```

### 案例 ssh 命令行工具

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 安装模块:  pip3 install paramiko


import re
import os
import sys
import time
import socket
import subprocess
import argparse
import logging
from logging.handlers import RotatingFileHandler
import shlex

try:
    import paramiko
except:
    shlex.os.system("pip install  paramiko")
    import paramiko


results = {
    'unsuccessful': [],
    'successful': [],
}


def parse_args():

    content = """ssh远程工具 ^_^

        ./ssh_paramiko.py  -h 192.168.0.111   -p123456  --run "who -b"
        """
    parser = argparse.ArgumentParser(
        usage="paramiko ssh",
        description=content,
        add_help=False,
        formatter_class=lambda prog: argparse.RawTextHelpFormatter(
            prog, max_help_position=50)
    )
    parser.add_argument("--help",
                        action="help",
                        help="查看帮助信息")
    parser.add_argument('-u', '--user',
                        default="root",
                        help='系统用户名,默认root')

    parser.add_argument('-h', '--host',
                        help='服务器IP')

    parser.add_argument('-p', '--passwd',
                        help='服务器密码')

    parser.add_argument('-P', '--port',
                        type=int,
                        default=22,
                        help='服务器端口,默认为22')

    parser.add_argument('-r', '--run',
                        default="uptime",
                        help='执行命令,默认 uptime')

    args = parser.parse_args()
    return args


class LoggerLog(object):
    def __init__(self, name=__name__):
        """
        实例化LoggerFactory类时的构造函数
        :param name:
        """
        # 实例化logging
        self.logger = logging.getLogger(name)
        # 输出的日志格式
        self.formatter = formatter = logging.Formatter(
            '%(asctime)s %(name)s %(levelname)s %(message)s')

    def create_logger(self):
        """
        构造一个日志对象
        :return:
        """

        # 设置日志输出的文件
        os.makedirs('logs', exist_ok=True)
        # handle = logging.FileHandler('./logs/scripts.log')
        handle = logging.handlers.RotatingFileHandler(
            './logs/scripts.log', maxBytes=1024*1024, backupCount=3)

        # 输出到日志文件的日志级别
        handle.setLevel(logging.INFO)
        handle.setFormatter(self.formatter)
        self.logger.addHandler(handle)
        # 输出到控制台的显示信息
        console = logging.StreamHandler()
        console.setLevel(logging.DEBUG)
        console.setFormatter(self.formatter)
        self.logger.addHandler(console)


def ssh_remote_exec(args):
    date = time.strftime("%b %d %H:%M:%S", time.localtime())
    print(
        "INFO:\t%s\t[\033[1;32m%s\033[0m] Trying to connect　..." % (date, args.host))
    paramiko.util.log_to_file('paramiko.log')

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    count = 0
    try:
        if args.passwd:
            ssh.connect(
                hostname=args.host,
                username=args.user,
                password=args.passwd,
                port=args.port,
                timeout=3, allow_agent=False)
        else:

            private_key = paramiko.RSAKey.from_private_key_file(
                "/Users/lijingjing/.ssh/TZadmin.pem")
            ssh.connect(
                hostname=args.host,
                username=args.user,
                pkey=private_key,
                port=args.port,
                timeout=3, allow_agent=False, look_for_keys=False)

        stdin, stdout, stderr = ssh.exec_command(
            "source /etc/profile ; %s" % args.run)
        result = stdout.read().decode() + stderr.read().decode()
        results['successful'].append(args.host)
        return result

    except (paramiko.ssh_exception.AuthenticationException,) as e:
        print("INFO:\t%s\t\033[1;31mLogin failed\033[0m\t%s" % (date, e))
        results['unsuccessful'].append(args.host)
    except (paramiko.ssh_exception.NoValidConnectionsError, socket.gaierror, socket.timeout, socket.error) as e:
        print("INFO:\t%s\t\033[1;31mConnection failed\033[0m\t%s" % (date, e))
        results['unsuccessful'].append(args.host)
    except Exception as e:
        print(e, type(e))
    finally:
        ssh.close()


if __name__ == '__main__':
    if len(sys.argv) == 1:
        """ 如果没有参数则查看帮助信息 """
        sys.argv.append("--help")
        args = parse_args()
        sys.exit(1)

    args = parse_args()

    ret = ssh_remote_exec(args)
    print(ret)

    # print("执行成功主机数: count", len(results['successful']), results['successful'])
    # print("执行失败主机数: count", len(
    #     results['unsuccessful']), results['unsuccessful'])
```

### 综合 configparser 和 argparse 项目

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2024/4/10 22:09
# @Author  : hjl
# @Site    :
# @File    : crudini.py
# @Software: PyCharm
# @Desc    : 使用python实现一个工具 curdini.py，实现对ini或conf文件的put、get、update、delete，使用argparse、configparser
# 类似项目：https://github.com/pixelb/crudini

import argparse
import configparser
import re

"""
python .\crudini.py set Database MaxConnections 100 example.ini
python .\crudini.py get Database Host example.ini
python .\crudini.py update Server Port 9090 example.ini
python .\crudini.py del Server port example.ini
python .\crudini.py del Server port ip example.ini
python .\crudini.py merge example2.ini example.ini
"""


class Curdini:
    def __init__(self, config_file):
        self.config_file = config_file
        self.config = configparser.ConfigParser()
        self.config.read(self.config_file)

    def set_param(self, section, param, value):
        if not self.config.has_section(section):
            self.config.add_section(section)
        self.config.set(section, param, value)
        self._save_config()

    def get_param(self, section=None, param=None):
        if section is None:
            sections = self.config.sections()
            for sec in sections:
                print(f"[{sec}]")
                for key, val in self.config.items(sec):
                    print(f"{key} = {val}")
        elif not self.config.has_section(section) or (param and not self.config.has_option(section, param)):
            print("Section or parameter not found.")
        elif param:
            print(self.config.get(section, param))
        else:
            print(self.config[section])

    def update_param(self, section, param, value):
        if not self.config.has_section(section):
            print("Section not found.")
            return
        self.config.set(section, param, value)
        self._save_config()

    def delete_param(self, section, param_list):
        if not self.config.has_section(section):
            print("Section not found.")
            return
        for param in param_list:
            if self.config.has_option(section, param):
                self.config.remove_option(section, param)
        self._save_config()

    def merge_configs(self, merge_file):
        merge_config = configparser.ConfigParser()
        merge_config.read(merge_file)
        for section in merge_config.sections():
            if not self.config.has_section(section):
                self.config.add_section(section)
            for option in merge_config.options(section):
                self.config.set(section, option, merge_config.get(section, option))
        self._save_config()

    def _save_config(self):
        with open(self.config_file, 'w') as f:
            self.config.write(f)


def main():
    parser = argparse.ArgumentParser(description='INI/CONF file manipulation tool,supporting documents crud ')
    subparsers = parser.add_subparsers(title='actions', dest='action', help="commands")

    set_parser = subparsers.add_parser('set', help='Set a parameter')
    set_parser.add_argument('section', help='Section name')
    set_parser.add_argument('param', help='Parameter name')
    set_parser.add_argument('value', help='Value to set')

    get_parser = subparsers.add_parser('get', help='Get a parameter')
    get_parser.add_argument('section', help='Section name')
    get_parser.add_argument('param', help='Parameter name')

    update_parser = subparsers.add_parser('update', help='Update a parameter')
    update_parser.add_argument('section', help='Section name')
    update_parser.add_argument('param', help='Parameter name')
    update_parser.add_argument('value', help='Value to set')

    del_parser = subparsers.add_parser('del', help='Delete a parameter')
    del_parser.add_argument('section', help='Section name')
    del_parser.add_argument('list', nargs='+', help='List of parameter names to delete')

    merge_parser = subparsers.add_parser('merge', help='Merge with another configuration file')
    merge_parser.add_argument('merge_file', help='File to merge with base configuration', nargs='?')

    parser.add_argument('config_file', help='Configuration file')
    parser.add_argument("-v", "--version", action='version', version='%(prog)s 1.0')
    args = parser.parse_args()

    curdini_tool = Curdini(args.config_file)

    if args.action == 'set':
        curdini_tool.set_param(args.section, args.param, args.value)
    elif args.action == 'get':
        if args.section is None or args.param is None:
            print("Both section and param must be provided for the 'get' action.")
        else:
            curdini_tool.get_param(args.section, args.param)
    elif args.action == 'update':
        curdini_tool.update_param(args.section, args.param, args.value)
    elif args.action == 'del':
        curdini_tool.delete_param(args.section, args.list)
    elif args.action == 'merge':
        curdini_tool.merge_configs(args.merge_file)


if __name__ == "__main__":
    main()
```

配置文件 1 示例 `example.ini`

```ini
[Database]
host = localhost
port = 3306
username = admin
password = password123

[Server]
ip = 192.168.0.1
port = 6379
password = password123
```

配置文件 2 示例 `example2.ini`

```ini
[mysql]
host = localhost
port = 3306
username = admin
password = password123
maxconnections = 100

[redis]
ip = 192.168.0.1
port = 6379
password = password123
```

```sh
# Set操作：
python .\crudini.py set Database MaxConnections 100 example.ini

# Get操作：
python .\crudini.py get Database Host example.ini

# Update操作：
python .\crudini.py update Server Port 9090 example.ini

# Delete操作：
python .\crudini.py del Server port example.ini
python .\crudini.py del Server port ip example.ini

# Merge操作：
python .\crudini.py merge example2.ini example.ini
```

argparse: Python 命令行参数解析包

https://www.xiexianbin.cn/python/libs/argparse/index.html?to_index=1

### 综合 yaml 和 argparse 项目

使用 jinja2 渲染 example 文件 到 openstack_user_config.yml 中

`osa_toolkit/tools.py`

```python
import glob
import os

import jinja2
import yaml


def make_example_config(aio_config_file, configs_dir):
    """Build an inventory configuration based on example AIO files

    :param aio_config_file: ``str`` Master AIO configuration example file
    :param configs_dir: ``str`` Directory containing independent conf.d files
    """
    config = {}
    j2env = jinja2.Environment(loader=jinja2.BaseLoader,
                               autoescape=jinja2.select_autoescape())
    files = glob.glob(os.path.join(configs_dir, '*.aio'))
    for file_name in files:
        with open(file_name, 'r') as f:
            template = j2env.from_string(f.read())
            jinja_data = template.render()
            config.update(yaml.safe_load(jinja_data))

    with open(aio_config_file, 'r') as f:
        config.update(yaml.safe_load(f.read()))

    return config


def write_example_config(filename, config):
    """Dump generated configuration to a file.

    :param filename: ``str`` The filename which to write to.
    :param config: ``dict`` Dictionary containing the config which to write.
    """
    with open(os.path.realpath(filename), 'w') as f:
        f.write(yaml.dump(config, default_flow_style=False))
```

`gen-config.py`

```python
import argparse
import os
import sys

from osa_toolkit import tools


def args(arg_list):
    parser = argparse.ArgumentParser(
        usage='%(prog)s',
        description='OpenStack Ansible Configuration Generator',
        epilog='Licensed "Apache2.0"',
    )

    parser.add_argument(
        '--base',
        '-b',
        help="Base file to be used.",
    )

    parser.add_argument(
        '--conf_dir',
        '-c',
        help=("Directory of service-specific configuration files.\n"
              "Only files ending in *.aio will be processed"),
    )

    parser.add_argument(
        '--output',
        '-o',
        help=("Path to combined output file, defaults to "
              "./openstack_user_config.yml"),
        default=os.path.join(os.getcwd(), 'openstack_user_config.yml')
    )

    return vars(parser.parse_args(arg_list))


if __name__ == "__main__":
    script_args = args(sys.argv[1:])

    config = tools.make_example_config(
        script_args['base'],
        script_args['conf_dir']
    )
    tools.write_example_config(script_args['output'], config)
```

### dedup

递归目录删除重复文件工具

- https://github.com/yifengyou/dedup

### syncor

源站点镜像工具

- https://github.com/yifengyou/syncor

参考文献：

如何使用 argparse 来解析命令行参数

- https://iswbm.com/zh/2024/06/01/how-to-use-argparse-to-parse-command-line-arguments/

- https://www.yuque.com/fcant/python/hgdezit91imngs3a#1b616a40

合集 - Python 命令行参数(3):

- https://www.cnblogs.com/superhin/p/python3-argparse.html

## 19.smtplib

https://learnku.com/docs/pymotw/smtpd-sample-mail-servers/3445

## 20.封装的工具类

### 日志

#### logging

示例 1

`utils/log.py`

```python
import logging
import os

# 1. 创建一个logger
logger = logging.getLogger('simple_example')
logger.setLevel(logging.DEBUG)  # Log等级总开关

# 2.控制台的handler
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

# 3. 写入文件的handler
root_dir = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
fh = logging.FileHandler(filename=os.path.join(root_dir, 'log/run.log'), encoding='utf-8')

# 4. 定义handler的输出格式
format ='%(asctime)s - %(filename)s - %(lineno)d - %(name)s - %(levelname)s - %(message)s'
formatter = logging.Formatter(fmt=format)
ch.setFormatter(formatter)
fh.setFormatter(formatter)

# 将logger添加到handler里面
logger.addHandler(ch)
logger.addHandler(fh)
```

调用：

```python
import pymysql
from utils.log import logger

logger.error('数据库连接失败')
```

示例 2

```python
import os

import logging

from logging.handlers import TimedRotatingFileHandler

# 日志级别
CRITICAL = 50
FATAL = CRITICAL
ERROR = 40
WARNING = 30
WARN = WARNING
INFO = 20
DEBUG = 10
NOTSET = 0
# project_name = "movie"
CURRENT_PATH = os.path.dirname(os.path.abspath(__file__))
ROOT_PATH = os.path.abspath(os.path.join(CURRENT_PATH, "..", "..",".."))
LOG_PATH = os.path.join(ROOT_PATH, 'logs')

print(CURRENT_PATH,ROOT_PATH,LOG_PATH)

# LOG_PATH = "/app/logs/app/"

if not os.path.exists(LOG_PATH):
    os.makedirs(LOG_PATH)


class LogHandler(logging.Logger):
    """
    LogHandler
    """

    def __init__(self, name, level=INFO, stream=True, file=True):
        self.name = name
        self.level = level
        logging.Logger.__init__(self, self.name, level=level)
        if stream:
            self.__setStreamHandler__()
        if file:
            self.__setFileHandler__()

    def __setFileHandler__(self, level=None):
        """
        set file handler
        :param level:
        :return:
        """
        file_name = os.path.join(LOG_PATH, '{name}.log'.format(name=self.name))
        # 设置日志回滚, 保存在log目录, 一天保存一个文件, 保留15天
        file_handler = TimedRotatingFileHandler(filename=file_name, when='D', interval=1, backupCount=15,
                                                encoding="utf-8")
        file_handler.suffix = '%Y%m%d.log'
        if not level:
            file_handler.setLevel(self.level)
        else:
            file_handler.setLevel(level)
        formatter = logging.Formatter(
            '%(asctime)s.%(msecs)03d %(levelname)s | [%(threadName)s] %(name)s [%(lineno)d] | %(filename)s %(funcName)s | %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S')

        file_handler.setFormatter(formatter)
        self.file_handler = file_handler
        self.addHandler(file_handler)

    def __setStreamHandler__(self, level=None):
        """
        set stream handler
        :param level:
        :return:
        """
        stream_handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s.%(msecs)03d %(levelname)s | [%(threadName)s] %(name)s [%(lineno)d] | %(filename)s %(funcName)s | %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S')
        stream_handler.setFormatter(formatter)
        if not level:
            stream_handler.setLevel(self.level)
        else:
            stream_handler.setLevel(level)
        self.addHandler(stream_handler)

    def resetName(self, name):
        """
        reset name
        :param name:
        :return:
        """
        self.name = name
        self.removeHandler(self.file_handler)
        self.__setFileHandler__()


project_name = 'app'
log = LogHandler(project_name, level=DEBUG)
if __name__ == '__main__':
    # log = LogHandler('test')
    log.info('this is a test msg')
```

#### loguru

`utils/log.py`

```python
import os
from loguru import logger


root_dir = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
filename = os.path.join(root_dir, 'log/run.log')
logger.add(
    sink=filename,  # 写入文件路径
    rotation="500MB",
    encoding="utf-8",
    enqueue=True,
    retention="10 days"
)
```

调用：

```python
from utils.log import logger

logger.info('this is a info')
```

loguru 相比 logging，loguru 更加优雅，简单，日志的输出也更加美观。

安装 loguru

```sh
pip install loguru
```

demo

```python
from loguru import logger

logger.debug('this is a debug message')
logger.info('this is another debug message')
logger.warning('this is another debug message')
logger.error('this is another debug message')
logger.info('this is another debug message')
logger.success('this is success message!')
logger.critical('this is critical message!')
```

loguru 默认以时间，级别，函数名，模块名，行号，信息的顺序来输出日志。

- 重定向日志到文件

```python
from loguru import logger

# 配置重定向路径
logger.add('loguru.log')

logger.debug('this is a redirect to file message')
```

- 自定义格式

```python
from loguru import logger

# 配置重定向路径&格式
# 在 add 中配置的格式只对写入日志文件的内容生效。
logger.add('loguru.log',format='{level} {time} {message}')

logger.debug('this is a redirect to file message')
```

- 日志轮转

用了 loguru 我们还可以非常方便地使用 rotation 配置，比如我们想一天输出一个日志文件，或者文件太大了自动分隔日志文件，我们可以直接使用 add 方法的 rotation 参数进行配置。

```python
# 按大小轮转,实现每 500M 轮转一次。
logger.add('runtime_{time}.log', rotation="500 MB")

# 按时间轮转,实现每天 0 点轮转一次。
logger.add('runtime_{time}.log', rotation='00:00')

# 按周轮转,实现了每周轮转一次。
logger.add('runtime_{time}.log', rotation='1 week')
```

- 优雅的异常处理

```python
from loguru import logger

# 配置重定向路径&格式
logger.add('loguru.log',format='{time} | {level} | {message}')

logger.debug('test traceback')

@logger.catch
def err(x:int,y:int):
    return 1/(x+y)

if __name__ == '__main__':
    err(0,0)
```

github 地址：

- https://github.com/Delgan/loguru

### 邮件

`SendEmail.py`

```python
"""
邮件发送工具

Python对SMTP支持有smtplib和email两个模块：
    1. email负责构造邮件
    2. smtplib负责发送邮件。
"""

import smtplib
import ssl
from email.header import Header
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

import attach as attach
from loguru import logger
from utils.ReadConfig import ReadConfig


class SendMail:

    def __init__(self):
        """
        初始化smtp服务器连接
        smtp 服务器端口，仅能使用25、465和587
        25端口（明文传输）465端口（SSL 加密) 587端口（STARTTLS 加密）
        """

        self.cf = ReadConfig()
        # qq邮箱服务器地址
        self.mail_host = self.cf.get_email('mail_host')
        # 端口
        self.mail_port = self.cf.get_email('mail_port')
        # 用户名
        self.mail_user = self.cf.get_email('mail_user')
        # 密码(部分邮箱为授权码)
        self.mail_pass = self.cf.get_email('mail_pass')
        self.mail_sender = self.cf.get_email('mail_sender')

        # 根据不同的端口，用不同的方式连接
        if self.mail_port == "587":
            ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)
            self.smtpObj = smtplib.SMTP(self.mail_host, self.mail_port)
            self.smtpObj.ehlo()
            self.smtpObj.starttls(context=ctx)

        elif self.mail_port == "25":
            self.smtpObj = smtplib.SMTP(self.mail_host, self.mail_port)

        elif self.mail_port == "465":
            self.smtpObj = smtplib.SMTP_SSL(self.mail_host, self.mail_port)

        # 连接
        self.smtpObj.connect(self.mail_host, self.mail_port)
        # 登录
        self.smtpObj.login(self.mail_user, self.mail_pass)

    def send_text_mail(self, subject, content, receivers):
        """
        发送文本邮件
        :param subject: 邮件主题
        :param message: 邮件内容
        :param receivers: 邮件接受者
        :return:
        """
        # 邮件内容
        message = MIMEText(content, 'plain', 'utf-8')
        # 邮件主题
        message['Subject'] = Header(subject, 'UTF-8')
        # 发送方信息
        message['From'] = Header(self.mail_sender, 'utf-8')
        message['To'] = ','.join(receivers)
        try:
            # 发送
            self.smtpObj.sendmail(self.mail_sender, receivers, message.as_string())
            logger.info("mail has been send successfully. send to {} ".format(receivers))
        except smtplib.SMTPException as e:
            logger.error('error', e)

    def send_html_mail(self,subject, content, receivers):
        """
        发送HTML格式邮件
        :param subject: 邮件主题
        :param message: 邮件内容
        :param receivers: 邮件接受者
        :return:
        """
        # 邮件内容
        message = MIMEText(content, 'html', 'utf-8')
        # 邮件主题
        message['Subject'] = Header(subject, 'UTF-8')
        # 发送方信息
        message['From'] = Header(self.mail_sender, 'utf-8')
        message['To'] = ','.join(receivers)
        try:
            # 发送
            self.smtpObj.sendmail(self.mail_sender, receivers, message.as_string())
            logger.info("mail has been send successfully. send to {} ".format(receivers))
        except smtplib.SMTPException as e:
            logger.error('error', e)


    def send_appendix_mail(self,subject, content, receivers):
        """
        发送带附件的邮件
        """
        # 创建一个带附件的实例
        message = MIMEMultipart()
        message['From'] = Header(self.mail_sender, 'utf-8')
        message['To'] = ','.join(receivers)
        # 邮件主题
        message['Subject'] = Header(subject, 'UTF-8')

        # 邮件正文内容
        message.attach(MIMEText(content, 'plain', 'utf-8'))
        # 构造附件，传送当前目录下的 extract.py
        att = MIMEText(open('extract.py','rb').read(),'base64', 'utf-8')
        # 这里的filename可以任意写，写什么名字，邮件中显示什么名字
        att["Content-Disposition"] = 'attachment; filename="extract.py"'
        message.attach(att)

        try:
            # 发送
            self.smtpObj.sendmail(self.mail_sender, receivers, message.as_string())
            logger.info("mail has been send successfully. send to {} ".format(receivers))
        except smtplib.SMTPException as e:
            logger.error('error', e)

    def exit(self):
        # 关闭会话
        self.smtpObj.quit()
```

邮件配置通过读取配置文件实现的

调用：

```python
if __name__ == '__main__':
    mail = SendMail()
    subject = "邮件工具类测试"
    message = "这是一个test"
    receivers = ['zhengxianyi@touch-spring.com']
    mail.send_appendix_mail(subject, message, receivers)
```

Python 发送邮件

https://www.yuque.com/7125messi/df7dhh/eeemoy

### 连接 mysql 数据库

#### demo1

`DB.py`

```python
import pymysql
from config import host, user, password, db, charset, port

class DB():
    def __init__(self):
        self.host = host
        self.user = user
        self.password = password
        self.dbName = db
        self.charset = charset
        self.port = port

    # 连接数据库
    def connet(self):
        try:
            # 连接数据库
            self.conn = pymysql.connect(
                host=self.host,
                user=self.user,
                password=self.password,
                db=self.dbName,
                port=self.port,
                charset=self.charset,

            )
            # 获得游标
            # pymysql.cursors.DictCursor 以字典的形式返回查询出来的数据
            self.cursor = self.conn.cursor(pymysql.cursors.DictCursor)
        except Exception as e:
            print(str(e))	# 实际中可以写在日志中

    # 关闭游标、数据库
    def close(self):
        try:
            # 关闭游标
            self.cursor.close()
            # 关闭数据库
            self.conn.close()
        except Exception as e:
            print(str(e))

    # 查询多条数据
    def get_all(self, sql):
        try:
            self.connet()
            self.cursor.execute(sql)
            res = self.cursor.fetchall()
            self.close()
        except Exception as e:
            print(str(e))
        return res

    # 插入、更新、删除操作公共方法
    def edit(self, sql):
        try:
            self.connet()
            self.cursor.execute(sql)
            # 插入、更新、删除操作必须进行commit
            self.conn.commit()
            self.close()
        except Exception as e:
            print(str(e))

    # 数据库插入、更新、删除操作
    def insert(self, sql):
        return self.edit(sql)

    def update(self, sql):
        return self.edit(sql)

    def delete(self, sql):
        return self.edit(sql)
```

其中数据库连接信息写在根目录下面的 config.py 中

```python
host = 'localhost'
user = 'root'
password = ''
db = 'ehsy_data'
charset = 'utf8'
port = 3306
```

调用：

```python
from pymysqlStudy.connect_mysql_impro import DB

if __name__ == '__main__':
    db = DB()


    # sql = " insert into st_info(id,name,password) values (%s,%s,%s)"
    # data = (11,'lisi','123456')
    # db.insert(sql,data)

    # 更新操作
    sql = " update st_info set name=%s where id=%s"
    data = ('lisi',11)
    db.update(sql,data)
```

#### demo2

读取配置文件
`config.ini`

```python
[mysql]
host = localhost
user = root
password =
db = sizechart_spider
port = 3306
charset = utf8
```

`readconfig.py`

```python
import configparser
import os

class ReadConfig:
    """读取配置文件类"""

    def __init__(self,filepath=None):
        if filepath:
            configpath =filepath
        else:
            root_dir = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
            configpath = os.path.join(root_dir, 'config.ini')
            print(configpath)
        self.cf = configparser.ConfigParser()
        self.cf.read(configpath, encoding="utf-8")

    def get_db(self, param):
        return self.cf.get('mysql', param)
```

`DB.py`

```python
import pymysql
from readconfig import ReadConfig
rc = ReadConfig()

class DB():
    def __init__(self):
        self.host = rc.get_db('host')
        self.user = rc.get_db('user')
        self.password = rc.get_db('password')
        self.dbName = rc.get_db('db')
        self.charset = rc.get_db('charset')
        self.port = rc.get_db('port')

    # 连接数据库
    def connet(self):
        try:
            # 连接数据库
            self.conn = pymysql.connect(
                host=self.host,
                user=self.user,
                password=self.password,
                db=self.dbName,
                port=self.port,
                charset=self.charset,

            )
            # 获得游标
            # pymysql.cursors.DictCursor 以字典的形式返回查询出来的数据
            self.cursor = self.conn.cursor(pymysql.cursors.DictCursor)
        except Exception as e:
            print(str(e))	# 实际中可以写在日志中

    # 关闭游标、数据库
    def close(self):
        try:
            # 关闭游标
            self.cursor.close()
            # 关闭数据库
            self.conn.close()
        except Exception as e:
            print(str(e))

    # 查询多条数据
    def get_all(self, sql):
        try:
            self.connet()
            self.cursor.execute(sql)
            res = self.cursor.fetchall()
            self.close()
        except Exception as e:
            print(str(e))
        return res

    # 插入、更新、删除操作公共方法
    def edit(self, sql):
        try:
            self.connet()
            self.cursor.execute(sql)
            # 插入、更新、删除操作必须进行commit
            self.conn.commit()
            self.close()
        except Exception as e:
            print(str(e))

    # 数据库插入、更新、删除操作
    def insert(self, sql):
        return self.edit(sql)

    def update(self, sql):
        return self.edit(sql)

    def delete(self, sql):
        return self.edit(sql)

if __name__ == '__main__':
    db = DB()
    sql = " insert into st_info(id,name,password) values (%s,%s,%s)"
    data = (11,'lisi','123456')
    db.insert(sql,data)
    print(db.get_all("select * from st_info"))
    db.update("update st_info set name=%s where id=%s",data)
    print(db.get_all("select * from st_info"))
    db.delete("delete from st_info where id=%s",(11,))
    print(db.get_all("select * from st_info"))
    db.close()
```

### 连接 redis

在 Python 中封装 Redis 操作工具类，可以方便地在应用程序中复用 Redis 操作，简化 Redis 操作的复杂度，并提供统一的接口。

这里给出一个基本的 Redis 操作工具类封装，使用 redis-py 库，这个库是 Python 与 Redis 交互的标准库。

```sh
pip install redis
```

```python
import redis
from typing import Optional, Union, Any

class RedisHelper:
    def __init__(self, host: str = 'localhost', port: int = 6379, db: int = 0):
        """
        初始化 RedisHelper 类，设置 Redis 连接信息
        :param host: Redis 服务器主机，默认是 localhost
        :param port: Redis 服务器端口，默认是 6379
        :param db: Redis 数据库，默认是 0
        """
        self.redis_client = redis.StrictRedis(host=host, port=port, db=db, decode_responses=True)

    def set(self, key: str, value: Union[str, int, float], ex: Optional[int] = None) -> bool:
        """
        设置键值对，如果设置了 ex 参数，则键值会在过期时间后自动删除
        :param key: 键
        :param value: 值，可以是字符串、整数或浮点数
        :param ex: 过期时间（秒），默认不设置过期时间
        :return: 是否成功
        """
        try:
            if ex:
                self.redis_client.setex(key, ex, value)
            else:
                self.redis_client.set(key, value)
            return True
        except Exception as e:
            print(f"Error setting key {key}: {e}")
            return False

    def get(self, key: str) -> Optional[str]:
        """
        获取指定键的值
        :param key: 键
        :return: 键对应的值，如果键不存在，则返回 None
        """
        try:
            return self.redis_client.get(key)
        except Exception as e:
            print(f"Error getting key {key}: {e}")
            return None

    def delete(self, key: str) -> bool:
        """
        删除指定键
        :param key: 键
        :return: 是否成功
        """
        try:
            self.redis_client.delete(key)
            return True
        except Exception as e:
            print(f"Error deleting key {key}: {e}")
            return False

    def exists(self, key: str) -> bool:
        """
        检查指定的键是否存在
        :param key: 键
        :return: 键是否存在
        """
        try:
            return self.redis_client.exists(key)
        except Exception as e:
            print(f"Error checking existence of key {key}: {e}")
            return False

    def set_multiple(self, mapping: dict, ex: Optional[int] = None) -> bool:
        """
        批量设置多个键值对
        :param mapping: 键值对字典
        :param ex: 过期时间（秒），可选
        :return: 是否成功
        """
        try:
            if ex:
                for key, value in mapping.items():
                    self.redis_client.setex(key, ex, value)
            else:
                self.redis_client.mset(mapping)
            return True
        except Exception as e:
            print(f"Error setting multiple keys: {e}")
            return False

    def get_multiple(self, keys: list) -> dict:
        """
        批量获取多个键的值
        :param keys: 键列表
        :return: 键值对字典
        """
        try:
            values = self.redis_client.mget(keys)
            return dict(zip(keys, values))
        except Exception as e:
            print(f"Error getting multiple keys: {e}")
            return {}

    def increment(self, key: str, amount: int = 1) -> Union[int, None]:
        """
        对指定键的值进行自增
        :param key: 键
        :param amount: 增量，默认为 1
        :return: 增加后的值，如果操作失败，则返回 None
        """
        try:
            return self.redis_client.incrby(key, amount)
        except Exception as e:
            print(f"Error incrementing key {key}: {e}")
            return None

    def decrement(self, key: str, amount: int = 1) -> Union[int, None]:
        """
        对指定键的值进行自减
        :param key: 键
        :param amount: 减量，默认为 1
        :return: 减少后的值，如果操作失败，则返回 None
        """
        try:
            return self.redis_client.decrby(key, amount)
        except Exception as e:
            print(f"Error decrementing key {key}: {e}")
            return None

    def hset(self, hash_name: str, key: str, value: Any) -> bool:
        """
        向哈希表中设置字段值
        :param hash_name: 哈希表名称
        :param key: 字段名
        :param value: 字段值
        :return: 是否成功
        """
        try:
            self.redis_client.hset(hash_name, key, value)
            return True
        except Exception as e:
            print(f"Error setting hash {hash_name}:{key}: {e}")
            return False

    def hget(self, hash_name: str, key: str) -> Optional[Any]:
        """
        获取哈希表中的字段值
        :param hash_name: 哈希表名称
        :param key: 字段名
        :return: 字段值，如果字段不存在，则返回 None
        """
        try:
            return self.redis_client.hget(hash_name, key)
        except Exception as e:
            print(f"Error getting hash {hash_name}:{key}: {e}")
            return None

    def hgetall(self, hash_name: str) -> dict:
        """
        获取哈希表中的所有字段和值
        :param hash_name: 哈希表名称
        :return: 键值对字典
        """
        try:
            return self.redis_client.hgetall(hash_name)
        except Exception as e:
            print(f"Error getting all hash fields for {hash_name}: {e}")
            return {}

# 示例使用
if __name__ == '__main__':
    redis_helper = RedisHelper()

    # 设置单个键值对
    redis_helper.set('name', 'Alice')

    # 获取单个键值
    print(redis_helper.get('name'))

    # 设置多个键值对
    redis_helper.set_multiple({'age': 30, 'location': 'New York'})

    # 获取多个键值
    print(redis_helper.get_multiple(['name', 'age', 'location']))

    # 增加某个键的值
    redis_helper.increment('age')
    print(redis_helper.get('age'))

    # 设置哈希表
    redis_helper.hset('user:1000', 'name', 'Alice')
    print(redis_helper.hget('user:1000', 'name'))
```

### 连接 sqlite3 数据库

#### demo1

```python
# coding=utf-8
import sqlite3
import os

class simpleToolSql():
    """
    simpleToolSql for sqlite3
    简单数据库工具类
    编写这个类主要是为了封装sqlite，继承此类复用方法
    """

    def __init__(self,filename="stsql"):
        """
        初始化数据库，默认文件名 stsql.db
        filename：文件名
        """
        self.filename = filename + ".db"
        self.db = sqlite3.connect(self.filename)
        self.c = self.db.cursor()

    def close(self):
        """
        关闭数据库
        """
        self.c.close()
        self.db.close()

    def execute(self,sql,param=None):
        """
        执行数据库的增、删、改
        sql：sql语句
        param：数据，可以是list或tuple，亦可是None
        retutn：成功返回True
        """
        try:
            if param is None:
                self.c.execute(sql)
            else:
                if type(param) is list:
                    self.c.executemany(sql,param)
                else :
                    self.c.execute(sql,param)
            count = self.db.total_changes
            self.db.commit()
        except Exception as e:
            print(e)
            return False,e
        if count > 0 :
            return True
        else :
            return False

    def query(self,sql,param=None):
        """
        查询语句
        sql：sql语句
        param：参数,可为None
        retutn：成功返回True
        """
        if param is None:
            self.c.execute(sql)
        else:
            self.c.execute(sql,param)
        return self.c.fetchall()

    # def set(self,table,field=" * ",where="",isWhere=False):
    #     self.table = table
    #     self.filed = field
    #     if where != "" :
    #         self.where = where
    #         self.isWhere = True
    #     return True

if __name__ == "__main__":
    """
    测试代码
    """
    sql = simpleToolSql("test")
    f = sql.execute("create table test (id int not null,name text not null,age int);")
    print("ok")
    sql.execute("insert into test (id,name,age) values (?,?,?);",[(1,'abc',15),(2,'bca',16)])
    res = sql.query("select * from test;")
    print(res)
    sql.execute("insert into test (id,name) values (?,?);",(3,'bac'))
    res = sql.query("select * from test where id=?;",(3,))
    print(res)
    sql.close()
```

#### demo2

Python3 简单封装 sqlite3

```python
#coding: utf-8
#Author：boxker
#Mail：icjb@foxmail.com

import sqlite3
import os

class simpleToolSql():
    """
    simpleToolSql for sqlite3
    简单数据库工具类
    编写这个类主要是为了封装sqlite，继承此类复用方法
    """

    def __init__(self,filename="stsql"):
        """
        初始化数据库，默认文件名 stsql.db
        filename：文件名
        """
        self.filename = filename + ".db"
        self.db = sqlite3.connect(self.filename)
        self.c = self.db.cursor()

    def close(self):
        """
        关闭数据库
        """
        self.c.close()
        self.db.close()

    def execute(self,sql,param=None):
        """
        执行数据库的增、删、改
        sql：sql语句
        param：数据，可以是list或tuple，亦可是None
        retutn：成功返回True
        """
        try:
            if param is None:
                self.c.execute(sql)
            else:
                if type(param) is list:
                    self.c.executemany(sql,param)
                else :
                    self.c.execute(sql,param)
            count = self.db.total_changes
            self.db.commit()
        except Exception as e:
            print(e)
            return False,e
        if count > 0 :
            return True
        else :
            return False

    def query(self,sql,param=None):
        """
        查询语句
        sql：sql语句
        param：参数,可为None
        retutn：成功返回True
        """
        if param is None:
            self.c.execute(sql)
        else:
            self.c.execute(sql,param)
        return self.c.fetchall()

    # def set(self,table,field=" * ",where="",isWhere=False):
    #     self.table = table
    #     self.filed = field
    #     if where != "" :
    #         self.where = where
    #         self.isWhere = True
    #     return True

if __name__ == "__main__":
    """
    测试代码
    """
    sql = simpleToolSql("test")
    f = sql.execute("create table test (id int not null,name text not null,age int);")
    print("ok")
    sql.execute("insert into test (id,name,age) values (?,?,?);",[(1,'abc',15),(2,'bca',16)])
    res = sql.query("select * from test;")
    print(res)
    sql.execute("insert into test (id,name) values (?,?);",(3,'bac'))
    res = sql.query("select * from test where id=?;",(3,))
    print(res)
    sql.close()
```

### 日期时间

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# !/usr/bin/env python
# -*- coding: utf-8 -*-
"""
时间和日期工具类
"""
import time
import datetime
import calendar


class TimeUtil(object):
    """
    时间和日期工具类
    """

    @staticmethod
    def get_current_time():
        """
        获取当前时间
        :return: 当前时间字符串
        """
        return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))

    @staticmethod
    def get_current_date():
        """
        获取当前日期
        :return: 当前日期字符串
        """
        return time.strftime('%Y-%m-%d', time.localtime(time.time()))

    @staticmethod
    def timestamp_to_time(timestamp):
        """
        时间戳转换为时间
        :param timestamp: 时间戳
        :return: 时间字符串
        """
        return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))

    @staticmethod
    def time_to_timestamp(time_str):
        """
        时间转换为时间戳
        :param time_str: 时间字符串
        :return: 时间戳
        """
        return int(time.mktime(time.strptime(time_str, '%Y-%m-%d %H:%M:%S')))

    @staticmethod
    def date_to_timestamp(date_str):
        """
        日期转换为时间戳
        :param date_str: 日期字符串
        :return: 时间戳
        """
        return int(time.mktime(time.strptime(date_str, '%Y-%m-%d')))

    @staticmethod
    def timestamp_to_date(timestamp):
        """
        时间戳转换为日期
        :param timestamp: 时间戳
        :return: 日期字符串
        """
        return time.strftime('%Y-%m-%d', time.localtime(timestamp))

    @staticmethod
    def get_weekday(date_str):
        """
        获取日期是星期几
        :param date_str: 日期字符串
        :return: 星期几
        """
        return calendar.day_name[datetime.datetime.strptime(date_str, '%Y-%m-%d').weekday()]

    @staticmethod
    def get_month_days(year, month):
        """
        获取指定月份的天数
        :param year: 年份
        :param month: 月份
        :return: 天数
        """
        return calendar.monthrange(year, month)[1]

    @staticmethod
    def get_month_first_date(year, month):
        """
        获取指定月份的第一天日期
        :param year: 年份
        :param month: 月份
        :return: 第一天日期
        """
        return datetime.date(year, month, 1)

    @staticmethod
    def get_month_last_date(year, month):
        """
        获取指定月份的最后一天日期
        :param year: 年份
        :param month: 月份
        :return: 最后一天日期
        """
        return datetime.date(year, month, calendar.monthrange(year, month)[1])

    @staticmethod
    def get_last_month_first_date(year, month):
        """
        获取上个月份的第一天日期
        :param year: 年份
        :param month: 月份
        :return: 上个月份的第一天日期
        """
        last_month = month - 1 if month != 1 else 12
        last_year = year - 1 if month == 1 else year
        return datetime.date(last_year, last_month, 1)

    @staticmethod
    def get_last_month_last_date(year, month):
        """
        获取上个月份的最后一天日期
        :param year: 年份
        :param month: 月份
        :return: 上个月份的最后一天日期
        """
        last_month = month - 1 if month != 1 else 12
        last_year = year - 1 if month == 1 else year
        return datetime.date(last_year, last_month, calendar.monthrange(last_year, last_month)[1])

    @staticmethod
    def get_next_month_first_date(year, month):
        """
        获取下个月份的第一天日期
        :param year: 年份
        :param month: 月份
        :return: 下个月份的第一天日期
        """
        next_month = month + 1 if month != 12 else 1
        next_year = year + 1 if month == 12 else year
        return datetime.date(next_year, next_month, 1)

    @staticmethod
    def get_next_month_last_date(year, month):
        """
        获取下个月份的最后一天日期
        :param year: 年份
        :param month: 月份
        :return: 下个月份的最后一天日期
        """
        next_month = month + 1 if month != 12 else 1
        next_year = year + 1 if month == 12 else year
        return datetime.date(next_year, next_month, calendar.monthrange(next_year, next_month)[1])

    @staticmethod
    def get_last_week_date(date_str):
        """
        获取上周同一天的日期
        :param date_str: 日期字符串
        :return: 上周同一天的日期
        """
        date = datetime.datetime.strptime(date_str, '%Y-%m-%d').date()
        last_week_date = date - datetime.timedelta(days=7)
        return last_week_date.strftime('%Y-%m-%d')

    @staticmethod
    def get_next_week_date(date_str):
        """
        获取下周同一天的日期
        :param date_str: 日期字符串
        :return: 下周同一天的日期
        """
        date = datetime.datetime.strptime(date_str, '%Y-%m-%d').date()
        next_week_date = date + datetime.timedelta(days=7)
        return next_week_date.strftime('%Y-%m-%d')

    @staticmethod
    def get_last_month_date(date_str):
        """
        获取上个月同一天的日期
        :param date_str: 日期字符串
        :return: 上个月同一天的日期
        """
        date = datetime.datetime.strptime(date_str, '%Y-%m-%d').date()
        last_month_date = date - datetime.timedelta(days=date.day)
        return last_month_date.strftime('%Y-%m-%d')

    @staticmethod
    def get_next_month_date(date_str):
        """
        获取下个月同一天的日期
        :param date_str: 日期字符串
        :return: 下个月同一天的日期
        """
        date = datetime.datetime.strptime(date_str, '%Y-%m-%d').date()
        year = date.year if date.month != 12 else date.year + 1
        month = date.month + 1 if date.month != 12 else 1
        next_month_date = datetime.date(year, month, 1)
        return next_month_date.strftime('%Y-%m-%d')

    @staticmethod
    def get_day_diff(start_date_str, end_date_str):
        """
        获取两个日期之间相差的天数
        :param start_date_str: 起始日期字符串
        :param end_date_str: 结束日期字符串
        :return: 相差的天数
        """
        start_date = datetime.datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.datetime.strptime(end_date_str, '%Y-%m-%d').date()
        return (end_date - start_date).days

    @staticmethod
    def get_month_diff(start_date_str, end_date_str):
        """
        获取两个日期之间相差的月数
        :param start_date_str: 起始日期字符串
        :param end_date_str: 结束日期字符串
        :return: 相差的月数
        """
        start_date = datetime.datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.datetime.strptime(end_date_str, '%Y-%m-%d').date()
        return (end_date.year - start_date.year) * 12 + end_date.month - start_date.month

    @staticmethod
    def get_year_diff(start_date_str, end_date_str):
        """
        获取两个日期之间相差的年数
        :param start_date_str: 起始日期字符串
        :param end_date_str: 结束日期字符串
        :return: 相差的年数
        """
        start_date = datetime.datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.datetime.strptime(end_date_str, '%Y-%m-%d').date()
        return end_date.year - start_date.year

    @staticmethod
    def get_current_timestamp() -> int:
        """
        获取当前时间戳
        :return: 当前时间戳（单位：秒）
        """
        return int(time.time())

    @staticmethod
    def get_current_millisecond() -> int:
        """
        获取当前时间戳
        :return: 当前时间戳（单位：毫秒）
        """
        return int(time.time() * 1000)

    @staticmethod
    def timestamp_to_datetime(timestamp: int) -> datetime.datetime:
        """
        将时间戳转换为datetime对象
        :param timestamp: 时间戳（单位：秒）
        :return: datetime对象
        """
        return datetime.datetime.fromtimestamp(timestamp)

    @staticmethod
    def millisecond_to_datetime(millisecond: int) -> datetime.datetime:
        """
        将时间戳转换为datetime对象
        :param millisecond: 时间戳（单位：毫秒）
        :return: datetime对象
        """
        return datetime.datetime.fromtimestamp(millisecond / 1000)

    @staticmethod
    def datetime_to_timestamp(dt: datetime.datetime) -> int:
        """
        将datetime对象转换为时间戳
        :param dt: datetime对象
        :return: 时间戳（单位：秒）
        """
        return int(dt.timestamp())

    @staticmethod
    def datetime_to_millisecond(dt: datetime.datetime) -> int:
        """
        将datetime对象转换为时间戳
        :param dt: datetime对象
        :return: 时间戳（单位：毫秒）
        """
        return int(dt.timestamp() * 1000)

    @staticmethod
    def timestamp_to_string(timestamp: int, format_str: str = '%Y-%m-%d %H:%M:%S') -> str:
        """
        将时间戳转换为字符串
        :param timestamp: 时间戳（单位：秒）
        :param format_str: 时间格式化字符串
        :return: 格式化后的时间字符串
        """
        return datetime.datetime.fromtimestamp(timestamp).strftime(format_str)

    @staticmethod
    def millisecond_to_string(millisecond: int, format_str: str = '%Y-%m-%d %H:%M:%S') -> str:
        """
        将时间戳转换为字符串
        :param millisecond: 时间戳（单位：毫秒）
        :param format_str: 时间格式化字符串
        :return: 格式化后的时间字符串
        """
        return datetime.datetime.fromtimestamp(millisecond / 1000).strftime(format_str)

    @staticmethod
    def string_to_datetime(s: str, format_str: str = '%Y-%m-%d %H:%M:%S') -> datetime.datetime:
        """
        将字符串转换为datetime对象
        :param s: 时间字符串
        :param format_str: 时间格式化字符串
        :return: datetime对象
        """
        return datetime.datetime.strptime(s, format_str)

    @staticmethod
    def string_to_timestamp(s: str, format_str: str = '%Y-%m-%d %H:%M:%S') -> int:
        """
        将字符串转换为时间戳
        :param s: 时间字符串
        :param format_str: 时间格式化字符串
        :return: 时间戳（单位：秒）
        """
        return int(time.mktime(time.strptime(s, format_str)))

    @staticmethod
    def string_to_millisecond(s: str, format_str: str = '%Y-%m-%d %H:%M:%S') -> int:
        """
        将字符串转换为时间戳
        :param s: 时间字符串
        :param format_str: 时间格式化字符串
        :return: 时间戳（单位：毫秒）
        """
        return int(time.mktime(time.strptime(s, format_str)) * 1000)

    @staticmethod
    def datetime_to_string(dt: datetime.datetime, format_str: str = '%Y-%m-%d %H:%M:%S') -> str:
        """
        将datetime对象转换为字符串
        :param dt: datetime对象
        :param format_str: 时间格式化字符串
        :return: 格式化后的时间字符串
        """
        return dt.strftime(format_str)

    @staticmethod
    def get_current_datetime() -> datetime.datetime:
        """
        获取当前时间（datetime对象）
        :return: 当前时间（datetime对象）
        """
        return datetime.datetime.now()

    @staticmethod
    def get_current_datetime_string(format_str: str = '%Y-%m-%d %H:%M:%S') -> str:
        """
        获取当前时间字符串
        :param format_str: 时间格式化字符串
        :return: 格式化后的时间字符串
        """
        return datetime.datetime.now().strftime(format_str)

    @staticmethod
    def get_date_from_string(s: str, format_str: str = '%Y-%m-%d') -> datetime.date:
        """
        将字符串转换为date对象
        :param s: 日期字符串
        :param format_str: 日期格式化字符串
        :return: date对象
        """
        return datetime.datetime.strptime(s, format_str).date()

    @staticmethod
    def get_string_from_date(d: datetime.date, format_str: str = '%Y-%m-%d') -> str:
        """
        将date对象转换为字符串
        :param d: date对象
        :param format_str: 日期格式化字符串
        :return: 格式化后的日期字符串
        """
        return d.strftime(format_str)

    @staticmethod
    def get_datetime_from_string(s: str, format_str: str = '%Y-%m-%d %H:%M:%S') -> datetime.datetime:
        """
        将字符串转换为datetime对象
        :param s: 时间字符串
        :param format_str: 时间格式化字符串
        :return: datetime对象
        """
        return datetime.datetime.strptime(s, format_str)

    @staticmethod
    def get_string_from_datetime(dt: datetime.datetime, format_str: str = '%Y-%m-%d %H:%M:%S') -> str:
        """
        将datetime对象转换为字符串
        :param dt: datetime对象
        :param format_str: 时间格式化字符串
        :return: 格式化后的时间字符串
        """
        return dt.strftime(format_str)

    @staticmethod
    def get_days_between(start_date: datetime.date, end_date: datetime.date) -> int:
        """
        计算两个日期之间的天数
        :param start_date: 起始日期（date对象）
        :param end_date: 结束日期（date对象）
        :return: 两个日期之间的天数
        """
        return (end_date - start_date).days

    @staticmethod
    def get_weekday_from_date(d: datetime.date) -> int:
        """
        获取日期的星期几
        :param d: date对象
        :return: 星期几（0代表星期一，1代表星期二，以此类推）
        """
        return d.weekday()

    @staticmethod
    def get_weekday_from_datetime(dt: datetime.datetime) -> int:
        """
        获取datetime对象所在日期的星期几
        :param dt: datetime对象
        :return: 星期几（0代表星期一，1代表星期二，以此类推）
        """
        return dt.weekday()

    @staticmethod
    def get_weekday_name_from_date(d: datetime.date) -> str:
        """
        获取日期的星期几的名称
        :param d: date对象
        :return: 星期几的名称（例如：'星期一'）
        """
        weekday_names = ['星期一', '星期二', '星期三', '星期四', '星期五', '星期六', '星期日']
        return weekday_names[d.weekday()]

    @staticmethod
    def get_weekday_name_from_datetime(dt: datetime.datetime) -> str:
        """
        获取datetime对象所在日期的星期几的名称
        :param dt: datetime对象
        :return: 星期几的名称（例如：'星期一'）
        """
        weekday_names = ['星期一', '星期二', '星期三', '星期四', '星期五', '星期六', '星期日']
        return weekday_names[dt.weekday()]

    @staticmethod
    def get_month_name_from_date(d: datetime.date) -> str:
        """
        获取日期所在月份的名称
        :param d: date对象
        :return: 月份的名称（例如：'一月'）
        """
        month_names = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月',
                       '十二月']
        return month_names[d.month - 1]


if __name__ == '__main__':
    # 测试获取当前时间和日期
    print("当前时间：", TimeUtil.get_current_time())
    print("当前日期：", TimeUtil.get_current_date())

    # 测试时间戳转换
    timestamp = time.time()
    print("时间戳：", timestamp)
    print("时间戳转换为时间：", TimeUtil.timestamp_to_time(timestamp))

    # 测试日期转换
    date_str = '2024-03-15'
    print("日期转换为时间戳：", TimeUtil.date_to_timestamp(date_str))
    print("日期转换为星期几：", TimeUtil.get_weekday(date_str))

    # 测试获取月份信息
    year, month = 2024, 3
    print("指定月份的天数：", TimeUtil.get_month_days(year, month))
    print("指定月份的第一天日期：", TimeUtil.get_month_first_date(year, month))
    print("指定月份的最后一天日期：", TimeUtil.get_month_last_date(year, month))
```

### 读取配置文件

#### demo1

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import configparser

"""
  基础读取配置文件
    -read(filename)     直接读取文件内容
    -sections()       得到所有的section，并以列表的形式返回
    -options(section)    得到该section的所有option
    -items(section)     得到该section的所有键值对
    -get(section,option)  得到section中option的值，返回为string类型
    -getint(section,option) 得到section中option的值，返回为int类型，还有相应的getboolean()和getfloat() 函数。
"""


class get_ini:

    # 初始化配置文件对象
    def __init__(self, path):
        # 实例化
        self.cf = configparser.ConfigParser()
        # 读取配置文件
        self.cf.read(path)

    # 获取所有的sections
    def get_sections(self):
        sections = self.cf.sections()
        return sections

    # 获取section下的所有key
    def get_options(self, section):
        opts = self.cf.options(section=section)
        return opts

    # 获取section下的所有键值对
    def get_kvs(self, section):
        kvs = self.cf.items(section=section)
        return kvs

    # 根据section和option获取指定的value
    def get_key_value(self, section, option):
        opt_val = self.cf.get(section=section, option=option)
        return opt_val

    # 更新指定section的option下的value
    def update_section_option_val(self, section, option, value, path, module):
        self.cf.set(section=section, option=option, value=value)
        with open(path, module) as f:
            self.cf.write(f)


"""
  基础写入配置文件
    -write(fp)             将config对象写入至某个 .init 格式的文件 Write an .ini-format representation of the configuration state.
    -add_section(section)       添加一个新的section
    -set(section, option, value)    对section中的option进行设置，需要调用write将内容写入配置文件 ConfigParser2
    -remove_section(section)      删除某个 section
    -remove_option(section, option)  删除某个 section 下的 option
"""


class write_ini:

    def __init__(self, path, module):
        # 实例化配置对象
        self.cf = configparser.ConfigParser()
        # 获取写入文件路径，若采用w+方式则该文件可以不存在
        self.path = path
        # 配置写入方式，写入方式"w+"清空写
        self.module = module

    # 写入配置文件
    def write_ini_file(self):
        with open(self.path, self.module) as f:
            self.cf.write(f)

    # 设置section下的option
    def set(self, section, option, value):
        self.cf.set(section=section, option=option, value=value)
        self.write_ini_file()

    # 新增section
    def add_section(self, section):
        self.cf.add_section(section=section)
        self.write_ini_file()

    # 删除某个 section
    def remove_section(self, section):
        self.cf.remove_section(section=section)
        self.write_ini_file()

    # 删除某个 section 下的 option
    def remove_option(self, section, option):
        self.cf.remove_option(section=section, option=option)
        self.write_ini_file()


if __name__ == "__main__":
    pass
    # write_ini = write_ini("demo1.ini", "w+")
    # write_ini.add_section("section1")
    # write_ini.add_section("section2")
    # write_ini.add_section("section3")
    # write_ini.set("section1", "k1", "v1")
    # write_ini.set("section1", "k2", "v2")
    # write_ini.set("section2", "k3", "v3")
    # write_ini.set("section2", "k4", "v4")
    # write_ini.set("section3", "k5", "v5")
    # write_ini.set("section3", "k6", "v6")
    # get_ini = get_ini("demo1.ini")
    # print(get_ini.get_sections())
    # print(get_ini.get_options("section1"))
    # print(get_ini.get_kvs("section1"))
    # print(get_ini.get_key_value("section1", "k1"))
    # get_ini.update_section_option_val("section1", "k1", "v11", "demo1.ini", "w+")
```

参考文献：

- https://www.xnip.cn/biji/81751.html

#### demo2

```python
# -*- coding: utf-8 -*-
"""
# config.conf
[section]
logpath = D:\\log\
imageminsize = 200
"""
import configparser
import os


class ConfigFile:
    """配置文件操作类"""

    def __init__(self, file_name):
        """
        初始化配置文件对象
        :param file_name: 配置文件路径
        """
        self.file_name = file_name
        self.flag = False
        if os.path.isfile(file_name):
            self.cf = configparser.ConfigParser()
            self.cf.read(file_name)
            self.flag = True

    def get_value(self, section, key):
        """
        获取指定节和键的值
        :param section: 节名称
        :param key: 键名称
        :return: 键对应的值，如果不存在则返回空字符串
        """
        if self.flag:
            try:
                if self.cf.has_section(section) and self.cf.has_option(section, key):
                    return self.cf.get(section, key)
                else:
                    print(f"Section '{section}' or key '{key}' not found.")
                    return ""
            except Exception as e:
                print(f"Error getting value: {e}")
                return ""
        else:
            print("Config file not found.")
            return ""

    def set_value(self, section, key, value):
        """
        设置指定节和键的值
        :param section: 节名称
        :param key: 键名称
        :param value: 要设置的值
        """
        if self.flag:
            try:
                if not self.cf.has_section(section):
                    self.cf.add_section(section)
                self.cf.set(section, key, value)
                with open(self.file_name, "w") as config_file:
                    self.cf.write(config_file)
            except Exception as e:
                print(f"Error setting value: {e}")
        else:
            print("Config file not found.")

    def has_section(self, section):
        """
        检查指定节是否存在
        :param section: 节名称
        :return: 如果存在则返回 True，否则返回 False
        """
        if self.flag:
            return self.cf.has_section(section)
        else:
            print("Config file not found.")
            return False

    def has_option(self, section, key):
        """
        检查指定节和键是否存在
        :param section: 节名称
        :param key: 键名称
        :return: 如果存在则返回 True，否则返回 False
        """
        if self.flag:
            return self.cf.has_option(section, key)
        else:
            print("Config file not found.")
            return False


if __name__ == "__main__":
    # 测试代码
    configfile = os.path.join(os.getcwd(), "config.conf")
    cf = ConfigFile(configfile)
    print(cf.get_value("section", "logpath"))
    cf.set_value("section", "imageminsize", "200")
```

#### demo3

```python
# coding:utf-8
import configparser
import os

class IniCfg():
    def __init__(self):
        self.conf = configparser.ConfigParser()
        self.cfgpath = ''

    def checkSection(self, section):
        try:
            self.conf.items(section)
        except Exception:
            print(">> 无此section，请核对[%s]" % section)
            return None
        return True

    # 读取ini，并获取所有的section名
    def readSectionItems(self, cfgpath):
        if not os.path.isfile(cfgpath):
            print(">> 无此文件，请核对路径[%s]" % cfgpath)
            return None
        self.cfgpath = cfgpath
        self.conf.read(cfgpath, encoding="utf-8")
        return self.conf.sections()

    # 读取一个section，list里面对象是元祖
    def readOneSection(self, section):
        try:
            item = self.conf.items(section)
        except Exception:
            print(">> 无此section，请核对[%s]" % section)
            return None
        return item

    # 读取一个section到字典中
    def prettySecToDic(self, section):
        if not self.checkSection(section):
            return None
        res = {}
        for key, val in self.conf.items(section):
            res[key] = val
        return res

    # 读取所有section到字典中
    def prettySecsToDic(self):
        res_1 = {}
        res_2 = {}
        sections = self.conf.sections()
        for sec in sections:
            for key, val in self.conf.items(sec):
                res_2[key] = val
            res_1[sec] = res_2.copy()
            res_2.clear()
        return res_1

    # 删除一个 section中的一个item（以键值KEY为标识）
    def removeItem(self, section, key):
        if not self.checkSection(section):
            return
        self.conf.remove_option(section, key)

    # 删除整个section这一项
    def removeSection(self, section):
        if not self.checkSection(section):
            return
        self.conf.remove_section(section)

    # 添加一个section
    def addSection(self, section):
        self.conf.add_section(section)

    # 往section添加key和value
    def addItem(self, section, key, value):
        if not self.checkSection(section):
            return
        self.conf.set(section, key, value)

    # 执行write写入, remove和set方法并没有真正的修改ini文件内容，只有当执行conf.write()方法的时候，才会修改ini文件内容
    def actionOperate(self, mode):
        if mode == 'r+':
            conf.write(open(self.cfgpath, "r+", encoding="utf-8"))   # 修改模式
        elif mode == 'w':
            conf.write(open(self.cfgpath, "w"))                      # 删除原文件重新写入
        elif mode == 'a':
            conf.write(open(self.cfgpath, "a"))                      # 追加模式写入


cfgpath = r'C:\Users\SXF\Desktop\config.ini'

inicfg = IniCfg()
sections = inicfg.readSectionItems(cfgpath)
print(sections)
content = inicfg.readOneSection('chaoji')
print(content)
dic = inicfg.prettySecToDic('chaoji')
print(dic)
dic = inicfg.prettySecsToDic()
print(dic)
inicfg.addSection('chaoji22')

content = inicfg.readOneSection('chaoji')
print(content)
```

### 读取 json

```python
import json

class JSONDataCRUD:
    """内存JSON数据操作类[1,8](@ref)"""

    def __init__(self, initial_data=None):
        self.data = initial_data if initial_data else {}

    def create(self, key, value):
        """创建数据条目[8](@ref)"""
        if key in self.data:
            raise KeyError(f"Key '{key}' already exists")
        self.data[key] = value
        return self.data

    def read(self, key=None):
        """读取数据[7,8](@ref)"""
        if key:
            return self.data.get(key)
        return self.data

    def update(self, key, value):
        """更新数据条目[8](@ref)"""
        if key not in self.data:
            raise KeyError(f"Key '{key}' not found")
        self.data[key] = value
        return self.data

    def delete(self, key):
        """删除数据条目[8](@ref)"""
        if key not in self.data:
            raise KeyError(f"Key '{key}' not found")
        del self.data[key]
        return self.data

    def to_json(self, indent=4):
        """序列化为JSON字符串[1,7](@ref)"""
        return json.dumps(self.data, indent=indent)


import json
import os

class JSONFileCRUD:
    """JSON文件操作类[6,8](@ref)"""

    def __init__(self, file_path):
        self.file_path = file_path
        self.data = self._load_data()

    def _load_data(self):
        """加载文件数据[6,8](@ref)"""
        if not os.path.exists(self.file_path):
            return {}
        try:
            with open(self.file_path, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError:
            return {}

    def _save_data(self):
        """保存数据到文件[6,8](@ref)"""
        with open(self.file_path, 'w') as f:
            json.dump(self.data, f, indent=4)

    def create(self, key, value):
        """创建并持久化数据[8](@ref)"""
        if key in self.data:
            raise KeyError(f"Key '{key}' already exists")
        self.data[key] = value
        self._save_data()
        return self.data

    def read(self, key=None):
        """读取文件数据[7,8](@ref)"""
        self.data = self._load_data()  # 实时读取最新数据
        if key:
            return self.data.get(key)
        return self.data

    def update(self, key, value):
        """更新文件数据[8](@ref)"""
        if key not in self.data:
            raise KeyError(f"Key '{key}' not found")
        self.data[key] = value
        self._save_data()
        return self.data

    def delete(self, key):
        """删除文件数据[8](@ref)"""
        if key not in self.data:
            raise KeyError(f"Key '{key}' not found")
        del self.data[key]
        self._save_data()
        return self.data
```

使用示例

```python
# 内存操作
memory_crud = JSONDataCRUD()
memory_crud.create("key1", "value1")
print(memory_crud.read())
memory_crud.update("key1", "new_value1")
print(memory_crud.read())
memory_crud.delete("key1")
print(memory_crud.read())
# 文件操作
file_crud = JSONFileCRUD("data.json")
file_crud.create("key2", "value2")
print(file_crud.read())
file_crud.update("key2", "new_value2")
print(file_crud.read())
file_crud.delete("key2")
print(file_crud.read())
```

### 读取json cli工具

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import json
import argparse

"""
python crud_json.py -f xxx_map.json --key storage10
python crud_json.py -f xxx_map.json --key storage10 --enabled_expand_list
python crud_json.py -f test.json --key "hujianli3" --value "23" --write_json
python crud_json.py -f test.json --drop_json
"""


def parse_args():
    """
    解析命令行参数
    """
    parser = argparse.ArgumentParser(description="Json操作类")
    parser.add_argument(
        "-f", "--file_path", type=str, required=True, help="json文件的路径"
    )
    parser.add_argument("--key", type=str, help="要获取的key值")
    parser.add_argument("--value", type=str, help="要设置的值")
    parser.add_argument("--delete_key", type=str, help="要删除的key值")
    parser.add_argument(
        "--enabled_expand_list", action="store_true", help="是否展开 list 数据"
    )
    parser.add_argument("--drop_json", action="store_true", help="是否清空json文件")
    parser.add_argument("--write_json", action="store_true", help="是否写入json文件")
    return parser.parse_args()


class JsonHandler:
    """
    JsonHandler类用于处理json文件的读取和写入
    """

    def __init__(self, file_path):
        self.file_path = file_path
        if not os.path.exists(self.file_path):
            with open(file_path, "w") as f:
                json.dump({}, f, indent=4)

    def read_json(self):
        with open(self.file_path, "r") as f:
            data = json.load(f)
        return data

    def write_json(self, data):
        with open(self.file_path, "w") as f:
            json.dump(data, f, indent=4)

    def get_value(self, key):
        data = self.read_json()
        return data.get(key, None)

    def set_value(self, key, value):
        data = self.read_json()
        data[key] = value
        self.write_json(data)

    def delete_key(self, key):
        data = self.read_json()
        if key in data:
            del data[key]
            self.write_json(data)

    def get_all_keys(self):
        data = self.read_json()
        return list(data.keys())

    def get_all_values(self):
        data = self.read_json()
        return list(data.values())

    def get_all_items(self):
        data = self.read_json()
        return list(data.items())

    def clear_json(self):
        with open(self.file_path, "w") as f:
            json.dump({}, f, indent=4)


if __name__ == "__main__":
    parser = parse_args()
    json_handler = JsonHandler(parser.file_path)
    if parser.key:
        data = json_handler.get_value(parser.key)
        if isinstance(data, list) and parser.enabled_expand_list:
            data = " ".join(data)
        if data:
            print(data)
    if parser.key and parser.value and parser.write_json:
        json_handler.set_value(parser.key, parser.value)
    if parser.delete_key:
        json_handler.delete_key(parser.delete_key)
        print("Deleted key: {}".format(parser.delete_key))
    if parser.drop_json:
        json_handler.clear_json()
```

### 读取 yml

```python
import yaml
import os
class YAMLFileCRUD:
    """YAML文件操作类[6,8](@ref)"""
    def __init__(self, file_path):
        self.file_path = file_path
        self.data = self._load_data()
    def _load_data(self):
        """加载文件数据[6,8](@ref)"""
        if not os.path.exists(self.file_path):
            return {}
        try:
            with open(self.file_path, 'r') as f:
                return yaml.safe_load(f)
        except yaml.YAMLError:
            return {}
    def _save_data(self):
        """保存数据到文件[6,8](@ref)"""
        with open(self.file_path, 'w') as f:
            yaml.dump(self.data, f, default_flow_style=False)
    def create(self, key, value):
        """创建并持久化数据[8](@ref)"""
        if key in self.data:
            raise KeyError(f"Key '{key}' already exists")
        self.data[key] = value
        self._save_data()
        return self.data
    def read(self, key=None):
        """读取文件数据[7,8](@ref)"""
        self.data = self._load_data()  # 实时读取最新数据
        if key:
            return self.data.get(key)
        return self.data
    def update(self, key, value):
        """更新文件数据[8](@ref)"""
        if key not in self.data:
            raise KeyError(f"Key '{key}' not found")
        self.data[key] = value
        self._save_data()
        return self.data
    def delete(self, key):
        """删除文件数据[8](@ref)"""
        if key not in self.data:
            raise KeyError(f"Key '{key}' not found")
        del self.data[key]
        self._save_data()
        return self.data
```

使用示例

```python
# 文件操作
file_crud = YAMLFileCRUD("data.yaml")
file_crud.create("key2", "value2")
print(file_crud.read())
file_crud.update("key2", "new_value2")
print(file_crud.read())
file_crud.delete("key2")
print(file_crud.read())
```

## 21.操作 Redis

https://www.yuque.com/7125messi/df7dhh/lwqeq6

https://www.yuque.com/fcant/python/essbnd

## 22.操作 MySQL

https://www.yuque.com/7125messi/df7dhh/rruc0p

## 23.操作 MongoDB

https://www.yuque.com/7125messi/df7dhh/wmcd2z

https://www.yuque.com/fcant/python/tym0gu

## 24.压缩和解压缩

### zipfile

压缩和解压缩是日常常用的操作，不管是 windows 上图形界面的操作，还是 linux 上用命令来进行压缩解压缩，总的而言都还是比较方便的。

但用代码来实现就没做过，近期也得实现代码压缩与解压缩操作，所以就抽时间来研究一下。

zip 文件压缩和解压缩实现

#### 案例 1

```python
import os
import zipfile


# 函数功能是zip_file_list所有文件，和zip_dir_list所有目录下的所有文件，被压缩到一个zip_file_name的压缩文件中
def my_zip_function(zip_file_name, zip_file_list=[], zip_dir_list=[]):
    # 压缩文件最后需要close，为了方便我们直接用with
    with zipfile.ZipFile(zip_file_name, "w") as zip_obj:
        # 压缩文件
        for tmp_file in zip_file_list:
            zip_obj.write(tmp_file)
        # 压缩目录
        for tmp_dir in zip_dir_list:
            # zipfile没有直接压缩目录的功能，要压缩目录只能遍历目录一个一个文件压。
            for root, dirs, files in os.walk(tmp_dir):
                # 如果想要目录为空时仍将该目录压缩进去，该目录也要压缩一遍；反之请将以下行注释掉
                zip_obj.write(root)
                for tmp_file in files:
                    # 拼接文件完整目录，不然只用文件名代码找不到文件
                    tmp_file_path = os.path.join(root, tmp_file)
                    zip_obj.write(tmp_file_path)


# 函数功能是遍历压缩文件中的所有文件
def my_traversal_zip_function(zip_file_name):
    with zipfile.ZipFile(zip_file_name, "r") as zip_obj:
        # 返回结果是一个ZipInfo列表
        # 如果在压缩时显示压缩目录，则目录也作为一个单独的ZipInfo呈现在列表中；反之则没有目录的ZipInfo
        all_file_list = zip_obj.infolist()
        for tmp_file in all_file_list:
            print(tmp_file.filename)
            # 还可以在不解压的情况下直接读取文件的内容
            # 可以通过ZipInfo.is_dir()来区分是文件还是目录
            # if not tmp_file.is_dir():
            #     with zip_obj.open(tmp_file) as zip_fd:
            #         print(zip_fd.read())


# 函数的功能是将压缩文件直接解压
def my_unzip_function(zip_file_name, path="."):
    with zipfile.ZipFile(zip_file_name, "r") as zip_obj:
        zip_obj.extractall(path=path)


if __name__ == "__main__":
    zip_file_name = "test_zip.zip"
    # 自己在测试时要先自行创建好要压缩的文件和目录
    zip_file_list = ["test_tar_file1.txt", "test_tar_file2.txt"]
    zip_dir_list = ["test_tar_dir"]
    my_zip_function(zip_file_name, zip_file_list, zip_dir_list)
    my_traversal_zip_function(zip_file_name)
    # my_unzip_function(zip_file_name, path=".")
```

#### 案例 2

```python
import os
import zipfile

# 压缩
def make_zip(source_dir, output_filename):
    zipf = zipfile.ZipFile(output_filename, 'w')
    pre_len = len(os.path.dirname(source_dir))
    for parent, dirnames, filenames in os.walk(source_dir):
        for filename in filenames:
            print(filename)
            pathfile = os.path.join(parent, filename)
            arcname = pathfile[pre_len:].strip(os.path.sep)  # 相对路径
            zipf.write(pathfile, arcname)
    print()
    zipf.close()


# 解压缩
def un_zip(file_name):
    """unzip zip file"""
    zip_file = zipfile.ZipFile(file_name)
    if os.path.isdir(file_name + "_files"):
        pass
    else:
        os.mkdir(file_name + "_files")
    for names in zip_file.namelist():
        zip_file.extract(names, file_name + "_files/")
    zip_file.close()


if __name__ == '__main__':
    make_zip(r"E:python_samplelibstest_tar_fileslibs", "test.zip")
    un_zip("test.zip")
```

```python
import zipfile
import os

# 压缩目录的函数
def zipdir(archive_name, directory):
    with zipfile.ZipFile(
        archive_name, 'w', compression=zipfile.ZIP_DEFLATED
    ) as archive:
        for root, dirs, files in os.walk(directory):
            for filename in files:
                abspath = os.path.join(root, filename)
                relpath = os.path.relpath(abspath, directory)
                archive.write(abspath, relpath)

zipdir('/tmp/test.zip', '_build/doctrees')

# 查看压缩的文件内容
with zipfile.ZipFile('/tmp/test.zip') as archive:
    for n in archive.namelist():
        print(n)
```

### tarfile

除了直接的.tar 文件，还包括.tar.gz/.tar.bz2/.tar.xz 等格式文件的压缩与解压缩实现。

#### 案例 1

```python
import os
import tarfile


# 函数功能是tar_file_list所有文件，和tar_dir_list所有目录下的所有文件，被压缩到一个tar_file_name的压缩文件中
def my_tar_function(tar_file_name, tar_file_list=[], tar_dir_list=[], model="w"):
    # 本来也应该是tarfile.TarFile(tar_file_name, model)来创建的，但TarFile不支持"r:gz"等扩展形式
    # 压缩文件最后需要close，为了方便我们直接用with
    with tarfile.open(tar_file_name, model) as tar_obj:
        # 压缩文件
        for tmp_file in tar_file_list:
            tar_obj.add(tmp_file)
        # 压缩目录。和zipfile相比tarfile允许直接压缩目录，而不需要去遍历目录一个个文件压
        for tmp_dir in tar_dir_list:
            tar_obj.add(tmp_dir)


# 函数功能是遍历压缩文件中的所有文件
def my_traversal_tar_function(tar_file_name, model="r"):
    with tarfile.open(tar_file_name, model) as tar_obj:
        # 返回结果是一个TarInfo列表
        all_file_list = tar_obj.getmembers()
        for tmp_file in all_file_list:
            print(tmp_file.name)
            # 还可以在不解压的情况下直接读取文件的内容
            # 可以通过TarInfo.isdir()来区分是文件还是目录
            # if not tmp_file.isdir():
            #     # 相当于zip的open，并不会把文件给解压出来
            #     tar_fd = tar_obj.extractfile(tmp_file)
            #     print(tar_fd.read())


# 函数的功能是将压缩文件直接解压
def my_untar_function(tar_file_name, path=".", model="r"):
    with tarfile.open(tar_file_name, model) as tar_obj:
        tar_obj.extractall(path=path)


if __name__ == "__main__":
    # 自己在测试时要先自行创建好要压缩的文件和目录
    tar_file_list = ["test_tar_file1.txt", "test_tar_file2.txt"]
    tar_dir_list = ["test_tar_dir"]
    tar_file_name = "test_tar.tar"
    # 在.tar基础上，tarfile还支持gz/bz2/xz的压缩，只要在原来打开模式的基础上使用:或|接上压缩方法即可，如"r:gz"
    # 特别的，如果是读取文件，可以使用"r:*"来指示尝试以任意格式读取
    open_model = "w"
    # open_model = "w:gz"
    my_tar_function(tar_file_name, tar_file_list, tar_dir_list, model=open_model)
    open_model = "r"
    # open_model = "r:*"
    my_traversal_tar_function(tar_file_name, model=open_model)
    # open_model = "r:*"
    # my_untar_function(tar_file_name, path=".", model=open_model)
```

#### 案例 2

```python
import os
import tarfile
import gzip


# 一次性打包整个根目录。空子目录会被打包。
# 如果只打包不压缩，将"w:gz"参数改为"w:"或"w"即可。
def make_targz(output_filename, source_dir):
    with tarfile.open(output_filename, "w:gz") as tar:
        tar.add(source_dir, arcname=os.path.basename(source_dir))


# 逐个添加文件打包，未打包空子目录。可过滤文件。
# 如果只打包不压缩，将"w:gz"参数改为"w:"或"w"即可。
def make_targz_one_by_one(output_filename, source_dir):
    tar = tarfile.open(output_filename, "w:gz")
    for root, dir, files in os.walk(source_dir):
        for file in files:
            pathfile = os.path.join(root, file)
            tar.add(pathfile)
    tar.close()


def un_gz(file_name):
    """ungz zip file"""
    f_name = file_name.replace(".gz", "")
    # 获取文件的名称，去掉
    g_file = gzip.GzipFile(file_name)
    # 创建gzip对象
    open(f_name, "wb+").write(g_file.read())
    # gzip对象用read()打开后，写入open()建立的文件里。
    g_file.close()  # 关闭gzip对象


def un_tar(file_name):
    # untar zip file
    tar = tarfile.open(file_name)
    names = tar.getnames()
    if os.path.isdir(file_name + "_files"):
        pass
    else:
        os.mkdir(file_name + "_files")
    # 由于解压后是许多文件，预先建立同名文件夹
    for name in names:
        tar.extract(name, file_name + "_files/")
    tar.close()


if __name__ == '__main__':
    make_targz('test.tar.gz', "E:python_samplelibs")
    make_targz_one_by_one('test01.tgz', "E:python_samplelibs")
    un_gz("test.tar.gz")
    un_tar("test.tar")
```

#### 案例 3

```python
#!/usr/bin/env python3
# coding: utf-8
import os, tarfile

def make_targz(output_filename, source_dir):
    """
    一次性打包目录为tar.gz
    :param output_filename: 压缩文件名
    :param source_dir: 需要打包的目录
    :return: bool
    """
    try:
        with tarfile.open(output_filename, "w:gz") as tar:
            tar.add(source_dir, arcname=os.path.basename(source_dir))

        return True
    except Exception as e:
        print(e)
        return False


def untar(fname, dirs):
    """
    解压tar.gz文件
    :param fname: 压缩文件名
    :param dirs: 解压后的存放路径
    :return: bool
    """
    try:
        t = tarfile.open(fname)
        t.extractall(path = dirs)
        return True
    except Exception as e:
        print(e)
        return False

# make_targz('aa.tar.gz','folder')
untar('aa.tar.gz','./')
```

### shutil

```python
import shutil

# 创建压缩文件
shutil.make_archive("archive", "zip", "source_dir")

# 解压缩文件
shutil.unpack_archive("archive.zip", "destination_dir")
```

参考文献：

- https://www.yuque.com/fcant/python/wghlha

- https://www.cnblogs.com/lsdb/p/13572577.html

## 25.optparse

```python
# Python使用列表sys.argv存放命令行参数，第一个元素是程序的名称，后续为命令行参数
import sys
if len( sys.argv ) != 3 :
    sys.stderr.write( "Invalid arguments" )  # 访问标准输出
    raise SystemExit( 1 )  # 以非零退出
inputfile = sys.argv[1]



# 对于复杂的命令行参数，可以使用optparse模块进行处理
import optparse
p = optparse.OptionParser()
p.add_option(
             "-o" ,  # 命令行选项
             action = "store",   #store表示把值存放在Options中
             dest = "outfile",   #在处理结果Options中的键
             default = "out.log" #默认值
            )
p.add_option( "--output" , action = "store", dest = "outfile" )
p.add_option( "-o" , "--output" , action = "store", dest = "outfile" )  # 同时指定长短选项
# 布尔选项，在命令行中只指定命令选项，而不指定值
p.add_option( "-d" , action = "store_true", dest = "debug" )       #store_true表示存储为True
p.add_option( "--debug" , action = "store_true", dest = "debug" )
# 设置一个或者多个选项的默认值
p.set_defaults( debug = False )
# 解析命令行
# opts为包含所有选项值的字典
# args为为解析为选项的命令行项的列表
(opts, args) = p.parse_args()
outfile = opts.outfile
debugmode = opts.debug
```

## 26.getopt

```python
import getopt
import sys

try:
    opts, args = getopt.getopt(sys.argv[1:], 's:d:', ['source=', 'destination='])
except getopt.GetoptError as e:
    sys.exit(3)

# check if the parameters are valid
for o, a in opts:
    if o in ('-s', '--source'):
        source_address = a
    elif o in ('-d', '--destination')
        destination_address = a
    else:
        print('Error: INVALID parameters.')

# 1.s:d:即表示的是短参数，即使用-s或者-d 2.['source=', 'destination=']即表示的是长参数，即使用--source=或者--destination=

# 可以实现像平时的脚本附带参数的命令，如：
# python getopt_test.py -s 192.168.1.1 -d 1.1.1.1


# 或者：
# python getopt_test.py --source=192.168.1.1 --destination=1.1.1.1

# 1.opts中存放的是[('-s', '192.168.1.1'), ('-d', '1.1.1.1')]或者是[('--source', '192.168.1.1'), ('--destination', '1.1.1.1')] 2.args存放的是[]

# 需要注意的是：getopt并不能判断输入的参数是否合法，因此需要自己手动编程实现参数的判断是否正确
```

## 27.环境变量

```python
#可以通过字典os.environ访问环境变量
import os
path = os.environ ["PATH" ]
user = os.environ["USER"]

#写入的环境变量会影响正在运行的程序、Python创建的子进程
os.environ ["PATH" ] = ""
```

## 28.shelve

shelve 模块比 pickle 模块简单，只有一个 open 函数，返回类似字典的对象，可读可写 key 必须为字符串，而值可以是 python 所支持的数据类型

```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
import shelve
#写入数据
'''
f=shelve.open(r'sheve.txt')
f['stu1_info'] = {'name':'egon','age':18,'hobby':['piao','smoking','drinking']}
f['stu2_info'] = {'name':'gangdan','age':53}
f['school_info'] = {'website':'http://www.pypy.org','city':'beijing'}
f.close()
'''

#读取数据
'''
shelveFile_read2 = shelve.open("sheve.txt")
print(type(shelveFile_read2))
print(shelveFile_read2['stu1_info'])
print(shelveFile_read2['school_info'])

print(list(shelveFile_read2.keys()))
print(list(shelveFile_read2.values()))
'''
#写入数据
'''
shelveFile = shelve.open('mydata')
shelveFile['cats'] = ['hujianli', 'xiaojian2', 'huxiaojian3']
shelveFile.close()
'''

#读取数据
'''
shelveFile_read = shelve.open('mydata')
print(type(shelveFile_read))
print(shelveFile_read['cats'])
'''
```

参考资料

序列化及其相关模块（json,pickle,shelve,xml）详解

链接：

- http://www.cnblogs.com/wj-1314/p/8206840.html

## 29.pathlib

比文件操作 os 库更优异的标准库 pathlib

- https://www.cnblogs.com/goldsunshine/p/15664821.html

## 30.hashlib

hash 算法库

```python
import hashlib
m = hashlib.md5()
m.update("Nobody inspects")    # 使用update方法对字符串md5加密
m.digest()                     # 加密后二进制结果
m.hexdigest()                  # 加密后十进制结果
hashlib.new("md5", "string").hexdigest()               # 对字符串加密
hashlib.new("md5", open("file").read()).hexdigest()    # 查看文件MD5值

hashlib.sha224("Nobody inspects the spammish repetition").hexdigest()       # 几种hash算法 sha1  sha224  sha256  sha384  ha512
```

代码示例

```python
import hashlib

# 不加盐
md5 = hashlib.md5()  # 创建一个md5算法的对象
md5.update('123456'.encode('utf-8'))
print(md5.hexdigest())  # 这个值永远不会变，容易被人暴力破解，要加盐

# 固定加盐
md5 = hashlib.md5('SOS'.encode('utf-8'))  # 固定的盐还是可以破解的，
md5.update('123456'.encode('utf-8'))
print(md5.hexdigest())

# 动态加盐
user = 'sos'
print(user[1::-1])
md5 = hashlib.md5(user[1::-1].encode('utf-8'))
md5.update('123456'.encode('utf-8'))
print(md5.hexdigest())

# sha算法，和md5的用法一样，不过常用的还是md5，sha算法会慢一点
sha1 = hashlib.sha1('SOS'.encode('utf-8'))
sha1.update('123456'.encode('utf-8'))
print(sha1.hexdigest())

# 文件一致性校验
def md5file(file):
    md5=hashlib.md5()  # 做文件一致性校验不需要加盐
    with open(file,'rb') as f:
        # text = f.read()
        # md5.update(text)
        # 对于大文件，不能一次性读取，
        while True:
            text = f.read(1024)  # 每次读取1024字节
            if text:
                md5.update(text)
            else:
                break

    return md5.hexdigest()  # 一次性读取和循环读取的结果是一样的


print('*' * 50)
print(md5file('test.txt'))
print(md5file('text2.txt'))
```

参考文献

- https://www.cnblogs.com/xiangsikai/p/7787126.html

## 31.logging

- 日志级别大小关系为: critical > error > warning > info > debug > notset 也可自定义日志级别

```python
import logging
logging.debug('debug')                 # 默认日志级别为 warning ,故debug日志不做打印
logging.warning('warning')             # 达到默认日志级别为WARNING,打印到屏幕 warning
```

- 通过 logging.basicConfig 函数对日志的输出格式及方式做相关配置

```sh
logging.basicConfig
  # basicConfig 相关参数帮助
  filename               # 指定日志文件名
  filemode               # 和file函数意义相同，指定日志文件的打开模式，'w'或'a'
  datefmt                # 指定时间格式，同time.strftime()
  level                  # 设置日志级别，默认为logging.WARNING
  stream                 # 指定将日志的输出流，可以指定输出到sys.stderr,sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略
  format                 # 指定输出的格式和内容，format可以输出很多有用信息，如上例所示:
      %(levelno)s        # 打印日志级别的数值
      %(levelname)s      # 打印日志级别名称
      %(pathname)s       # 打印当前执行程序的路径，其实就是sys.argv[0]
      %(filename)s       # 打印当前执行程序名
      %(funcName)s       # 打印日志的当前函数
      %(lineno)d         # 打印日志的当前行号
      %(asctime)s        # 打印日志的时间
      %(thread)d         # 打印线程ID
      %(threadName)s     # 打印线程名称
      %(process)d        # 打印进程ID
      %(message)s        # 打印日志信息
```

- 加载配置文件

```python
logging.config.fileConfig("logger.conf")        # 加载配置文件
logger = logging.getLogger("example02")         # 使用已定义的日志记录器
```

```sh
# logger.conf                                     # 配置文件
###############################################
[loggers]
keys=root,example01,example02    # 设置三种日志记录器
[logger_root]                    # 针对单一种设置
level=DEBUG
handlers=hand01,hand02
[logger_example01]
handlers=hand01,hand02           # 使用2中处理方式 应该是根据不同级别区分的
qualname=example01
propagate=0
[logger_example02]
handlers=hand01,hand03
qualname=example02
propagate=0
###############################################
[handlers]                      # 不同的处理方式
keys=hand01,hand02,hand03       # 三种方式的名字
[handler_hand01]                # 第一种方式配置
class=StreamHandler             # 发送错误信息到流
level=INFO                      # 日志级别
formatter=form02                # 日志的格式方式
args=(sys.stderr,)
[handler_hand02]
class=FileHandler               # FileHandler写入磁盘文件
level=DEBUG
formatter=form01
args=('myapp.log', 'a')         # 追加到日志文件
[handler_hand03]
class=handlers.RotatingFileHandler
level=INFO
formatter=form02
args=('myapp.log', 'a', 10*1024*1024, 5)    # 追加日志并切割日志
###############################################
[formatters]                                # 针对不同处理日志方式设置具体的日志格式
keys=form01,form02
[formatter_form01]
format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s    # 日志列
datefmt=%a, %d %b %Y %H:%M:%S               # 时间格式
[formatter_form02]
format=%(name)-12s: %(levelname)-8s %(message)s
datefmt=
```

- 通用日志记录

示例-控制台打印

```python
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

exception = logger.exception
error = logger.error
info = logger.info
warning = logger.warning
debug = logger.debug

logger.setLevel(logging.DEBUG)
logger.setLevel(logging.INFO)
logger.setLevel(logging.WARNING)
logger.setLevel(logging.ERROR)
logger.setLevel(logging.FATAL)

logger.debug('debug message')
logger.info('info message')
logger.warning('warning message')
logger.error('error message')
```

```python
import logging

logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(threadName)s - '
                           '%(name)s - %(funcName)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


logger.info('数据更新')
logger.info('爬虫开始工作...')
```

示例-输出到文件

```python
import logging

logging.basicConfig(level=logging.DEBUG,
                format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',
                datefmt='%Y-%m-%d %H:%M:%S',
                filename='/var/log/myapp.log',
                filemode='a')
# 日志级别DEBUG或高于DEBUG的会写入文件 myapp.log 中
logging.debug('debug message')
logging.info('info message')
logging.warning('warning message')
```

- 给简单脚本增加日志功能

```python
import logging

def main():
    # Configure the logging system
    logging.basicConfig(
        filename='app.log',
        level=logging.ERROR
    )

    # Variables (to make the calls that follow work)
    hostname = 'www.python.org'
    item = 'spam'
    filename = 'data.csv'
    mode = 'r'

    # Example logging calls (insert into your program)
    logging.critical('Host %s unknown', hostname)
    logging.error("Couldn't find %r", item)
    logging.warning('Feature is deprecated')
    logging.info('Opening file %r, mode=%r', filename, mode)
    logging.debug('Got here')

if __name__ == '__main__':
    main()
```

- 给函数库增加日志功能

```python
# somelib.py

import logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

# Example function (for testing)
def func():
    log.critical('A Critical Error!')
    log.debug('A debug message')
```

使用这个配置，默认情况下不会打印日志。例如：

```sh
>>> import somelib
>>> somelib.func()
>>>
```

不过，如果配置过日志系统，那么日志消息打印就开始生效，例如：

```sh
>>> import logging
>>> logging.basicConfig()
>>> somelib.func()
CRITICAL:somelib:A Critical Error!
>>>
```

**示例**

- demo1

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import logging
import sys

## start log
# create logger
log_level = logging.DEBUG
formatter = logging.Formatter(
    fmt="%(asctime)-15s %(levelname)s %(process)d %(filename)s %(lineno)d: %(message)s",
    datefmt="%a %d %b %Y %H:%M:%S")

logger = logging.getLogger(name="test")
logger.setLevel(log_level)

fh = logging.FileHandler(filename="test.log")
fh.setLevel(log_level)
fh.setFormatter(formatter)
logger.addHandler(fh)

oh = logging.StreamHandler(sys.stdout)
oh.setLevel(log_level)
oh.setFormatter(formatter)
logger.addHandler(oh)
## end log

logger.debug("debug")
logger.info("info")
logger.info("info")
```

demo2

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import logging
# import logging.handlers
from logging import handlers
import datetime

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

rfh = handlers.TimedRotatingFileHandler(
    'all.log', when='midnight', interval=1, backupCount=7, atTime=datetime.time(0, 0, 0, 0))
rfh.setFormatter(
    logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))

fh = logging.FileHandler('error.log')
fh.setLevel(logging.ERROR)
fh.setFormatter(
    logging.Formatter("%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s"))

logger.addHandler(rfh)
logger.addHandler(fh)

logger.debug('debug message')
logger.info('info message')
logger.warning('warning message')
logger.error('error message')
logger.critical('critical message')
```

demo3

根据日志级别写入不同的文件

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import logging
# import logging.handlers
from logging import handlers
import datetime

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

rfh = handlers.TimedRotatingFileHandler(
    'all.log', when='midnight', interval=1, backupCount=7, atTime=datetime.time(0, 0, 0, 0))
rfh.setFormatter(
    logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))

fh = logging.FileHandler('error.log')
fh.setLevel(logging.ERROR)
fh.setFormatter(
    logging.Formatter("%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s"))

logger.addHandler(rfh)
logger.addHandler(fh)

logger.debug('debug message')
logger.info('info message')
logger.warning('warning message')
logger.error('error message')
logger.critical('critical message')
```

```python
def configure_logging(path_to_log_directory):
    """
    Configure logger

    :param path_to_log_directory:  path to directory to write log file in
    :return:
    """
    log_filename = datetime.datetime.now().strftime('%Y-%m-%d') + '.log'
    importer_logger = logging.getLogger('importer_logger')
    importer_logger.setLevel(LOG_LEVEL)
    formatter = logging.Formatter('%(asctime)s : %(levelname)s : %(message)s')

    fh = logging.FileHandler(filename=os.path.join(path_to_log_directory, log_filename))
    fh.setLevel(LOG_LEVEL)
    fh.setFormatter(formatter)
    importer_logger.addHandler(fh)

    sh = logging.StreamHandler(sys.stdout)
    sh.setLevel(LOG_LEVEL)
    sh.setFormatter(formatter)
    importer_logger.addHandler(sh)
```

通过命令行参数设置不同类型的日志，见代码：

```python
import logging
import argparse
logger = logging.getLogger(__name__)

def create_args_parse():
    parser = argparse.ArgumentParser(description="参数列表")
    parser.add_argument('-d', '--debug', action='store_true', help='调试模式')
    # 加入其他命令行参数

    return parser

def set_logger(debug):
    formatter = logging.Formatter('%(asctime)s - %(levelname)8s - %(name)s - %(filename)s:%(lineno)d - %(thread)d- %(funcName)s:\t%(message)s')
    if debug:
        hd = logging.StreamHandler()
        logger.setLevel(logging.DEBUG)
        hd.setFormatter(formatter)
    else:
        hd = logging.FileHandler(f'{__name__}.log', 'a', encoding='utf-8')
        logger.setLevel(logging.INFO)
        hd.setFormatter(formatter)
    logger.addHandler(hd)

if __name__ == '__main__':
   parser = create_args_parse()
   args = parser.parse_args()
   debug = args.debug
   set_logger(debug)
  #  ...
```

这样只需要在运行程序时，加上参数 -d 就可以让日志打印到终端上，不加，日志就会自动去 `__main__.log` 日志文件中去了。

参考文献

- https://www.yuque.com/fcant/python/tkbnx5#LdxBG

- https://www.xiexianbin.cn/python/libs/python-logging/index.html

## 32.rpc

RPC 框架

- https://www.cnblogs.com/andy0816/p/17498663.html

python 中的 rpc 库

- https://www.cnblogs.com/mayanan/p/15705500.html

python 几个 rpc 框架对比

- https://blog.51cto.com/u_16213397/12633603

## 33.signal

- https://yangsijie666.github.io/2018/06/11/signal模块/

## 扩展阅读

python3 常用标准库

- https://learnku.com/docs/pymotw

- https://www.lczmx.top/Python/442c9181ac5a/
