# 基础知识



## 1. 变量常见用法

定义一个变量特别简单：

```python
author="hujianli"
print("Hello {}!".format(author))
# Hello hujianli!
```



你也可以在一行语句里同时操作多个变量，比如调换两个变量所指向的值：

```python
>>> author, reader = 'piglei', 'raymond'
>>> author, reader = reader, author ➊
>>> author
'raymond'
```



### 1.1 变量解包

```python
>>> usernames = ['piglei', 'raymond']
# 注意：左侧变量的个数必须和待展开的列表长度相等，否则会报错
>>> author, reader = usernames
>>> author
'piglei'
```

假如在赋值语句左侧添加小括号(...)，甚至可以一次展开多层嵌套数据：

```python
>>> attrs = [1, ['piglei', 100]]
>>> user_id, (username, score) = attrs
>>> user_id
1
>>> username
'piglei'
```



除了上面的普通解包外，Python还支持更灵活的动态解包语法。

只要用星号表达式（*variables）作为变量名，它便会贪婪地捕获多个值对象，并将捕获到的内容作为列表赋值给variables。

```python
>>> data = ['piglei', 'apple', 'orange', 'banana', 100]
>>> username, *fruits, score = data
>>> username
'piglei'
>>> fruits
['apple', 'orange', 'banana']
>>> score
100
```

和常规的切片赋值语句比起来，动态解包语法要直观许多：

```python
#1. 动态解包
>>> username, *fruits, score = data
# 2. 切片赋值
>>> username, fruits, score = data[0], data[1:-1], data[-1]
# 两种变量赋值方式完全等价
```



上面的变量解包操作也可以在任何循环语句里使用：

```python
>>> for username, score in [('piglei', 100), ('raymond', 60)]:
...     print(username)
...
piglei
raymond
```



### 1.2 单下划线变量名\_

在常用的诸多变量名中，单下划线_是比较特殊的一个。它常作为一个无意义的占位符出现在赋值语句中。_这个名字本身没什么特别之处，这算是大家约定俗成的一种用法。

```python
#忽略展开时的第二个变量
>>> author, _ = usernames

# 忽略第一个和最后一个变量之间的所有变量
>>> username, *_, score = data
```

而在Python交互式命令行（直接执行python命令进入的交互环境）里，_变量还有一层特殊含义——默认保存我们输入的上个表达式的返回值：

```python
>>> 'foo'.upper()
'FOO'
>>> print(_)
FOO
```



## 2.给变量注明类型

试着读读下面这段代码：

```python
def remove_invalid(items):
    """剔除 items 里面无效的元素"""
    ... ...
```

你能告诉我，函数接收的items参数是什么类型吗？是一个装满数字的列表，还是一个装满字符串的集合？

只看上面这点儿代码，我们根本无从得知。为了解决动态类型带来的可读性问题，最常见的办法就是在函数文档（docstring）里做文章。

我们可以把每个函数参数的类型与说明全都写在函数文档里。下面是增加了Python官方推荐的Sphinx格式文档后的效果：

```python
def remove_invalid(items):
    """剔除 items 里面无效的元素

    :param items: 待剔除对象
    :type items: 包含整数的列表，[int, ...]
    """
```



当然，标注类型的办法肯定不止上面这一种。在Python 3.5版本以后，你可以用类型注解功能来直接注明变量类型。

相比编写Sphinx格式文档，我其实更推荐使用类型注解，因为它是Python的内置功能，而且正在变得越来越流行。

要使用类型注解，只需在变量后添加类型，并用冒号隔开即可，比如func(value:str)表示函数的value参数为字符串类型。

下面是给remove_invalid()函数添加类型注解后的样子：

```python
from typing import List


def remove_invalid(items: List[int]):
    pass


remove_invalid(["piglei", "raymond"])
```

- List表示参数为列表类型，[int]表示里面的成员是整型



## 3.变量命名原则



### 3.1 遵循PEP 8原则

为了让不同开发者写出的代码风格尽量保持统一，Python制定了官方的编码风格指南：PEP 8。

这份风格指南里有许多详细的风格建议，比如应该用4个空格缩进，每行不超过79个字符，等等。其中，当然也包含变量的命名规范：

- 对于普通变量，使用蛇形命名法，比如max_value；



- 对于常量，采用全大写字母，使用下划线连接，比如MAX_VALUE；



- 如果变量标记为“仅内部使用”，为其增加下划线前缀，比如\_local_var;



- 当名字与Python关键字冲突时，在变量末尾追加下划线，比如class_。

除变量名以外，PEP 8中还有许多其他命名规范，==比如类名应该使用驼峰风格（FooClass）、函数应该使用蛇形风格（bar_function）==，等等。

给变量起名的第一条原则，就是一定要在格式上遵循以上规范。



### 3.2 描述性要强

写作过程中的一项重要工作，就是为句子斟酌恰当的词语。

不同词语的描述性强弱不同，比如“冬天的梅花”就比“花”的描述性更强。而变量名和普通词语一样，同样有描述性强弱之分，假如代码大量使用描述性弱的变量名，读者就很难理解代码的含义。



### 3.3 要尽量短



### 3.4 要匹配类型

布尔值（bool）是一种很简单的类型，它只有两个可能的值：“是”（True）或“不是”（False）。

因此，给布尔值变量起名有一个原则：一定要让读到变量的人觉得它只有“肯定”和“否定”两种可能。举例来说，is、has这些非黑即白的词就很适合用来修饰这类名字。



### 3.5 超短命名

在众多变量名里，有一类非常特别，那就是只有一两个字母的短名字。这些短名字一般可分为两类，一类是那些大家约定俗成的短名字，比如：

- 数组索引三剑客i、j、k
- 某个整数n
- 某个字符串s
- 某个异常e
- 文件对象fp

我并不反对使用这类短名字，我自己也经常用，因为它们写起来的确很方便。但如果条件允许，建议尽量用更精确的名字替代。比如，在表示用户输入的字符串时，用input_str替代s会更明确一些。



### 其他技巧

除了上面这些规则外，下面再分享几个给变量命名的小技巧：

- 在同一段代码内，不要出现多个相似的变量名，比如同时使用users、users1、users3这种序列；
- 可以尝试换词来简化复合变量名，比如用is_special来代替is_not_normal；
- 如果你苦思冥想都想不出一个合适的名字，请打开GitHub，到其他人的开源项目里找找灵感吧！



## 4. 注释基础知识



### 4.1 用注释屏蔽代码

有时，人们会把注释当作临时屏蔽代码的工具。当某些代码暂时不需要执行时，就把它们都注释了，未来需要时再解除注释。

```python
#源码里有大段大段暂时不需要执行的代码
# trip = get_trip(request)
# trip.refresh()
# ... ...
```

其实根本没必要这么做。这些被临时注释掉的大段内容，对于阅读代码的人来说是一种干扰，没有任何意义。对于不再需要的代码，我们应该直接把它们删掉，而不是注释掉。如果未来有人真的需要用到这些旧代码，他直接去Git仓库历史里就能找到，毕竟版本控制系统就是专门干这个的。



### 4.2 用注释复述代码

```python
#如果直接把带空格的输入传递到后端处理，可能会造成后端服务崩溃
# 因此使用strip() 去掉首尾空格
input_string = input_string.strip()
```

注释作为代码之外的说明性文字，应该尽量提供那些读者无法从代码里读出来的信息。描述代码为什么要这么做，而不是简单复述代码本身。



### 4.3 弄错接口注释的受众

接口文档主要是给函数（或类）的使用者看的，它最主要的存在价值，是让人们不用逐行阅读函数代码，也能很快通过文档知道该如何使用这个函数，以及在使用时有什么注意事项。

```python
def resize_image(image, size):
    """将图片缩放为指定尺寸，并返回新的图片。

    注意：当文件超过 5MB 时，请使用 resize_big_image()

    :param image: 图片文件对象
    :param size: 包含宽高的元组：（width, height）
    :return: 新图片对象
    """
```



## 5.奇怪的冒泡排序

```python
# -*- coding: utf-8 -*-

# 不好的写法
def magic_bubble_sort_2(numbers):
    """有魔力的冒泡排序算法，所有的偶数都被认为比奇数大"""
    j = len(numbers) - 1
    while j > 0:
        for i in range(j):
            if numbers[i] % 2 == 0 and numbers[i + 1] % 2 == 1:
                numbers[i], numbers[i + 1] = numbers[i + 1], numbers[i]
                continue
            elif (numbers[i + 1] % 2 == numbers[i] % 2) and numbers[i] > numbers[i + 1]:
                numbers[i], numbers[i + 1] = numbers[i + 1], numbers[i]
                continue
        j -= 1
    return numbers



# 推荐的写法
from typing import List


def magic_bubble_sort(numbers: List[int]):
    """有魔力的冒泡排序算法，所有的偶数都被认为比奇数大

    :param numbers: 需要排序的列表，函数将会直接修改原始列表
    """
    stop_position = len(numbers) - 1
    while stop_position > 0:
        for i in range(stop_position):
            current, next_ = numbers[i], numbers[i + 1]
            current_is_even, next_is_even = current % 2 == 0, next_ % 2 == 0
            should_swap = False

            # 交换位置的两个条件：
            # - 前面是偶数，后面是奇数
            # - 前面和后面同为奇数或者偶数，但是前面比后面大
            if current_is_even and not next_is_even:
                should_swap = True
            elif current_is_even == next_is_even and current > next_:
                should_swap = True

            if should_swap:
                numbers[i], numbers[i + 1] = numbers[i + 1], numbers[i]
        stop_position -= 1
    return numbers


if __name__ == "__main__":
    l = [23, 32, 1, 3, 4, 19, 20, 2, 4]
    print(magic_bubble_sort(l))
    print(magic_bubble_sort_2(l))
```

