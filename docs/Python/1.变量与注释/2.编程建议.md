# 编程建议





## 1.保持变量的一致性

包含名字一致性和类型一致性。

名字一致性是指在同一个项目中，对一类事务的称呼不要变来变去。

类型一致性则是指不要把同一个变量重复指向不同类型的值。

举个例子：

```python
def foo():
    # users 本身是一个 Dict
    users = {'data': ['piglei', 'raymond']}
    ...
    # users 这个名字真不错！尝试复用它，把它变成 List 类型
    users = []
    ...
```

在foo()函数的作用域内，users变量被使用了两次：第一次指向字典，第二次则变成了列表。

虽然Python的类型系统允许我们这么做，但这样做其实有很多坏处，比如变量的辨识度会因此降低，还很容易引入bug。

所以，我建议在这种情况下启用一个新变量：

```python
def foo():
    users = {'data': ['piglei', 'raymond']}
    ...
    # 使用一个新名字
    user_list = []
    ...
```



## 2.变量定义尽量靠近使用

这个原则属于老生常谈了。很多人（包括我）在刚开始学习编程时，会有一个习惯。就是把所有的变量定义写在一起，放在函数或方法的最前面。

```python
### 看似很好看，其实不然
def generate_trip_png(trip):
    path = []
    markers = []
    photo_markers = []
    text_markers = []
    marker_count = 0
    point_count = 0
    ... ...
```



通过把变量定义移动到每段“各司其职”的代码头部，大大缩短了变量从初始化到被使用的距离。

当读者阅读代码时，可以更容易理解代码的逻辑，而不是来回翻阅代码。



```python
def generate_trip_png(trip):
    """
    根据旅途数据生成 PNG 图片
    """
    # 开始初始化 waypoints 数据
    waypoints = []
    waypoints.append(...)
    ...

    # 开始处理 photo_markers、text_markers
    photo_markers, text_markers = [], []
    photo_markers.append(...)
    ...

    # 开始计算 marker_count
    marker_count = 0
    marker_count += ...

    # 拼接图片：已省略……
```

通过把变量定义移动到每段“各司其职”的代码头部，大大缩短了变量从初始化到被使用的“距离”。

当读者阅读代码时，可以更容易理解代码的逻辑，而不是来回翻阅代码，心想：“这个变量是什么时候定义的？是干什么用的？”



## 3.定义临时变量提升可读性

随着业务逻辑变得复杂，我们的代码里也会经常出现一些复杂的表达式，就像下面这样：

```python
# 为所有性别为女性，或者级别大于 3 的活跃用户发放 10000 个金币
if user.is_active and (user.sex == 'female' or user.level > 3):
    user.add_coins(10000)
    return
```

看见if后面那一长串代码了吗？有点儿难读对不对？但这也没办法，毕竟产品经理就是明明白白这么跟我说的——业务逻辑如此。

逻辑虽然如此，不代表我们就得把代码直白地写成这样。如果把后面的复杂表达式赋值为一个临时变量，代码可以变得更易读：

```python
# 为所有性别为女性，或者级别大于 3 的活跃用户发放 10000 个金币
user_is_eligible = user.is_active and (user.sex == 'female' or user.level > 3):

if user_is_eligible:
    user.add_coins(10000)
    return
```



## 4.同一作用域内不要有太多变量

- 学会通过组合等方法减少函数内的变量数量，如建立类等；
- 把复杂函数拆分为多个小函数；
- 能不定义变量就不定义——有时候有些语句可以精简组合在一起；

局部变量过多的函数

```python
def import_users_from_file(fp):
    """尝试从文件对象读取用户，然后导入数据库

    :param fp: 可读文件对象
    :return: 成功与失败的数量
    """
    # 初始化变量：重复用户、黑名单用户、正常用户
    duplicated_users, banned_users, normal_users = [], [], []
    for line in fp:
        parsed_user = parse_user(line)
        # …… 进行判断处理，修改前面定义的{X}_users 变量

    succeeded_count, failed_count = 0, 0
    # …… 读取 {X}_users 变量，写入数据库并修改成功与失败的数量
    return succeeded_count, failed_count
```

要减少函数里的变量数量，最直接的方式是给这些变量分组，建立新的模型。

比如，我们可以将代码里的succeeded_count、failed_count建模为ImportedSummary类，用ImportedSummary.succeeded_count来替代现有变量；

对{duplicated|banned|normal}_users也可以执行同样的操作。

```python
class ImportedSummary:
    """保存导入结果摘要的数据类"""

    def __init__(self):
        self.succeeded_count = 0
        self.failed_count = 0

class ImportingUserGroup:
    """用于暂存用户导入处理的数据类"""

    def __init__(self):
        self.duplicated = []
        self.banned = []
        self.normal = []

def import_users_from_file(fp):
    """尝试从文件对象读取用户，然后导入数据库　　

    :param fp: 可读文件对象
    :return: 成功与失败的数量
    """
    importing_user_group = ImportingUserGroup()
    for line in fp:
        parsed_user = parse_user(line)
        # …… 进行判断处理，修改上面定义的importing_user_group 变量

    summary = ImportedSummary()
    # …… 读取 importing_user_group，写入数据库并修改成功与失败的数量

    return summary.succeeded_count, summary.failed_count
```



## 5.能不定义变量就别定义

```python
# 坏的代码
def get_best_trip_by_user_id(user_id):
    # 心理活动：嗯，这个值未来说不定会修改/二次使用，我们先把它定义成变量吧！
    user = get_user(user_id)
    trip = get_best_trip(user_id)
    result = {
        'user': user,
        'trip': trip
    }
    return result
    

# 上面这段代码里的三个临时变量完全可以去掉，变成下面这样：
def get_best_trip_by_user_id(user_id):
    return {
        'user': get_user(user_id),
        'trip': get_best_trip(user_id)
    }
```

这样的代码就像删掉赘语的句子，变得更精练、更易读。

所以，不必为了那些未来可能出现的变动，牺牲代码此时此刻的可读性。如果以后需要定义变量，那就以后再做吧！



## 6.不要使用locals()

locals()是Python的一个内置函数，调用它会返回当前作用域中的所有局部变量：

```python
def foo():
    name = 'piglei'
    bar = 1
    print(locals())

# 调用foo() 将输出：
{'name': 'piglei', 'bar': 1}
```

在有些场景下，我们需要一次性拿到当前作用域下的所有（或绝大部分）变量，比如在渲染Django模板时：

```python
def render_trip_page(request, user_id, trip_id):
    """渲染旅程页面"""
    user = User.objects.get(id=user_id)
    trip = get_object_or_404(Trip, pk=trip_id)
    is_suggested = check_if_suggested(user, trip)
    return render(request, 'trip.html', {
        'user': user,
        'trip': trip,
        'is_suggested': is_suggested
    })
```

看上去使用locals()函数正合适，假如调用locals()，上面的代码会简化许多：

```python
def render_trip_page(request, user_id, trip_id):
    ...

    # 利用locals() 把当前所有变量作为模板渲染参数返回
    # 节约了三行代码，我简直是个天才！
    return render(request, 'trip.html', locals())
```

第一眼看上去非常“简洁”，但是，这样的代码真的更好吗？答案并非如此。locals()看似简洁，但其他人在阅读代码时，为了搞明白模板渲染到底用了哪些变量，必须记住当前作用域里的所有变量。

假如函数非常复杂，“记住所有局部变量”简直是个不可能完成的任务。使用locals()还有一个缺点，那就是它会把一些并没有真正使用的变量也一并暴露。

因此，比起使用locals()，建议老老实实把代码写成这样：

```python
    return render(request, 'trip.html', {
        'user': user,
        'trip': trip,
        'is_suggested': is_suggested
    })
```

Python之禅：显式优于隐式在Python命令行中输入import this，你可以看到Tim Peters写的一段编程原则：The Zen of Python（“Python之禅”）。

这些原则字字珠玑，里面蕴藏着许多Python编程智慧。

“Python之禅”中有一句“Explicit is better than implicit”（显式优于隐式），这条原则完全可以套用到locals()的例子上——locals()实在是太隐晦了，直接写出变量名显然更好。



## 7.空行也是一种注释

适当地在代码中插入空行，把代码**按照不同的逻辑块**分割开，这样能有效提升代码的可读性。





## 8.先写注释，后写代码

函数名称和接口注释比函数内部代码更加抽象，因为你需要在函数名和短短几行注释里，把函数内部代码所做的事情高度浓缩的表达清楚。



==假如你没法通过几行注释把函数的职责描述清楚，那么整个函数的合理性就应该打一个问号。==

