# Linux系统管理


## 1.文件读写


### 1.1 Python内置的open函数

在Python中，要对一个文件进行操作，只需要使用内置的open函数打开文件即可。open函数接受文件名和打开模式作为参数，返回一个文件对象。工程师通过文件对象来操作文件，完成以后，调用文件对象的close方法关闭文件即可。

例如，在当前目录下有一个名为data.txt的文件，它的内容如下

```text
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
```


接下来，使用open函数打开文件，调用文件对象的read方法读取文件的所有内容，完成以后，调用文件对象的close方法关闭文件，如下所示：

```shell
In [1]: f = open('data.txt')

In [2]: print(f.read())
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.


In [3]: f.close()
```


表1-1　文件的打开模式


|模式|含义|
|----|----|
|r   |以只读方式打开文件。如果文件不存在，抛出FileNotFoundError异常|
|rb  |以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。|
|r+  |打开一个文件用于读写。文件指针将会放在文件的开头。|
|rb+ |以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。|
|w   |打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。|
|wb  |以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。|
|w+  |打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。|
|wb+ |以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。|
|x   |创建一个新文件，如果文件存在，抛出FileExistsError异常|
|a   |打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。|
|ab  |以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。|
|a+  |打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。|
|ab+ |以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。|


下面的代码分别演示，打开一个不存在的文件时'w'模式与'x'模式的区别：

```shell
In [4]: f = open('data1.txt', 'w')

In [5]: f.write('hello, world')
Out[5]: 12

In [6]: f.close()

In [7]: f = open('data1.txt', 'x')
-------------------------------------------------
FileExistsError        Traceback (most recent call last)
<ipython-input-16-e24c4c04f3d8> in <module>()
----> 1 f = open('data1.txt', 'x')

FileExistsError: [Errno 17] File exists: 'data1.txt'

In [8]: f = open('data2.txt', 'x')

In [9]: f.write('hello, world')
Out[9]: 12

In [10]: f.close()
```

### 1.2 避免文件句柄泄露
为了避免打开文件后没有及时关闭，大多数编程语言中都使用finally关闭文件句柄。在Python中，也可以使用finally语句来保证，无论在什么情况下文件都会被关闭。如下所示：

```python
try:
    f = open('data.txt')
    print(f.read())
finally:
    f.close()
```

如果工程师在可以使用上下文管理器的情况下，使用了finally语句，将会被认为代码编写得不够Pythonic。

对于文件打开、处理、再关闭的逻辑，使用上下文管理器的代码如下：

```python
with open('data.txt') as f:
    print(f.read())
```
可以看到，使用上下文管理器以后代码行数变少了。在Python中，如果想把代码写得简洁优美，就应该在保证可读性的前提下代码行数越少越好。


with工作原理

1. 紧跟with后面的语句被求值后，返回对象的“__enter__()”方法被调用，这个方法的返回值将被赋值给as后面的变量； 
   
2. 当with后面的代码块全部被执行完之后，将调用前面返回对象的“__exit__()”方法。


```python
class Sample:
    def __enter__(self):
        print("in __enter__")
        return "Foo"
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("in __exit__")
def get_sample():
    return Sample()
with get_sample() as sample:
    print("Sample: ", sample)
```

with语句为上下文管理器，__enter__和 __exit__两个方法实现，使用with操作文件会自动关闭文件句柄，无需额外进行file.close()

### 1.3 常见的文件操作函数

|文件操作|功能描述|
|-----|-----|
|file.read|读取文件中的所有内容|
|file.readline|一次读取一行|
|file.readlines|将文件内容存到一个列表中，列表中的每一行对应于文件中的一行。|
|file.write|写字符串到文件中，并返回写入的字符数|
|file.writelines|写一个字符串列表到文件中|


我们使用data.txt文件，分别测试这三个读函数的效果：

```python

In [1]: f = open('data.txt')

In [2]: f.read()
Out[2]: 'Beautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\n'

In [3]: f.seek(0)
Out[3]: 0

In [4]: f.readline()
Out[4]: 'Beautiful is better than ugly.\n'

In [5]: f.seek(0)
Out[5]: 0

In [6]: f.readlines()
Out[6]:
['Beautiful is better than ugly.\n',
 'Explicit is better than implicit.\n',
 'Simple is better than complex.\n',
 'Complex is better than complicated.\n']
```
这里可以看到，read函数和readlines函数都是一次就将所有内容读入到内存中，对于文件较小的情况不会有什么问题。

但是，如果处理的是大文件，这种使用方式会占用大量的内存，甚至有可能因为内存占用太多出现Out-Of-Memory错误。


依然使用IPython对文件对象的写入函数进行测试，并在写入完成以后使用Linux的cat命令查看文件内容：

```python
In [1]: f = open('/tmp/data.txt', 'w')

In [2]: f.write('Beautiful is better than ugly.')
Out[2]: 30

In [3]: f.writelines(['Explicit is better than implicit.', 'Simple is better than complex.'])

In [4]: ! cat /tmp/data.txt
Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.
```

在Python中，除了使用文件对象的write函数和writelines函数向文件写入数据以外，也可以使用print函数将输出结果输出到文件中。print函数比write和writelines函数更加灵活，如下所示：

```python
from __future__ import print_function

with open('/tmp/data.txt', 'w') as f:
    print(1, 2, 'hello, world', sep=",", file=f)
```

### 1.4 Python的文件是一个可迭代对象

Python的for循环比大家实际看到的还要通用，它不但可以遍历如字符串、列表、元组这样的可迭代序列，还可以使用迭代器协议遍历可迭代对象。

而Python的文件对象实现了迭代器协议，因此，我们可以在for循环中遍历文件内容。

也就是说，Python的for循环使用迭代器协议访问对象，只要对象实现了迭代器协议，就可以在Python的for循环中遍历该对象。

使用for循环遍历文件内容的代码如下：

```python
with open('data.txt') as inf:
    for line in inf:
        print(line.upper())
```


### 1.5 案例：将文件中所有单词的首字母变成大写

```python
with open('data.txt') as inf, open('out.txt', 'w') as outf:
    for line in inf:
        outf.write(" ".join([word.capitalize() for word in line.split()]))
        outf.write("\n")
```

处理完成以后，out.txt文件的内容如下：

```text
Beautiful Is Better Than Ugly.
Explicit Is Better Than Implicit.
Simple Is Better Than Complex.
Complex Is Better Than Complicated.
```

这个例子中，也可以使用print函数来简化输出语句，如下所示：

```python
from __future__ import print_function

with open('data.txt') as inf, open('out.txt', 'w') as outf:
    for line in inf:
        print(*[word.capitalize() for word in line.split()], file=outf)
```

## 2.文件与文件路径管理

介绍os模块的子模块os.path，os.path模块下的函数比较常用，而且也比较简单，很适合用来作为学习os模块的切入点。


|函数|说明|
|----|----|
|os.popen('id').read()|执行系统命令得到返回结果|
|os.system()|得到返回状态 返回无法截取|
|os.name|返回系统平台 Linux/Unix用户是'posix'|
|os.getenv()|读取环境变量|
|os.putenv()|设置环境变量|
|os.getcwd()|当前工作路径|
|os.stat('path/filename')|获取文件/目录信息|
|os.chdir()|改变当前工作目录|
|os.walk('/root/')|递归路径|
|os.environ['HOME']|查看系统环境变量|
|os.statvfs("/")|获取磁盘信息|
|os.path.abspath(path)|返回绝对路径|
|os.path.basename(path)|返回文件名|
|os.path.commonprefix(list)|返回list(多个路径)中，所有path共有的最长的路径|
|os.path.dirname(path)|返回文件所在路径（目录）|
|os.path.dirname(os.path.abspath(__file__))|返回文件当前工作路径|
|os.path.exists(path)|路径存在则返回True,路径损坏返回False|
|os.path.lexists|路径存在则返回True,路径损坏也返回True|
|os.path.expanduser(path)|把path中包含的"~"和"~user"转换成用户目录|
|os.path.expandvars(path)|根据环境变量的值替换path中包含的”$name”和”${name}”|
|os.path.getatime(path)|返回最后一次进入此path的时间|
|os.path.getmtime(path)|返回在此path下最后一次修改的时间|
|os.path.getctime(path)|返回path的大小|
|os.path.getsize(path)|返回文件大小，如果文件不存在就返回错误|
|os.path.isabs(path)|判断是否为绝对路径|
|os.path.isfile(path)|判断路径是否为文件|
|os.path.isdir(path)|判断路径是否为目录|
|os.path.islink(path)|判断路径是否为链接|
|os.path.ismount(path)|判断路径是否为挂载点（）|
|os.path.ismount(path)|判断路径是否为挂载点（）|
|os.path.join(path1[, path2[, ...]])|把目录和文件名合成一个路径|
|os.path.normcase(path)|转换path的大小写和斜杠|
|os.path.normpath(path)|规范path字符串形式|
|os.path.realpath(path)|返回path的真实路径|
|os.path.relpath(path[, start])|从start开始计算相对路径|
|os.path.samefile(path1, path2)|判断目录或文件是否相同|
|os.path.sameopenfile(fp1, fp2)|判断fp1和fp2是否指向同一文件|
|os.path.samestat(stat1, stat2)|判断stat tuple stat1和stat2是否指向同一个文件|
|os.path.split(path)|把路径分割成dirname和basename，返回一个元组|
|os.path.splitdrive(path)|一般用在windows下，返回驱动器名和路径组成的元组|
|os.path.splitext(path)|分割路径，返回路径名和文件扩展名的元组|
|os.path.splitunc(path)|把路径分割为加载点与文件|
|os.path.walk(path, visit, arg)|遍历path，进入每个目录都调用visit函数，visit函数必须有|


### 2.1 使用os.path进行路径和文件管理

前者获取当前目录，后者用来列出目录下的所有文件和文件夹

```shell
In [1]: import os

In [2]: os.getcwd()
Out[2]: '/home/lmx/t'

In [3]: os.listdir('.')
Out[3]:
['dir1',
 'dir3',
 'c.txt',
 '2.jpg',
 'a.py',
 'a.txt',
 '1.jpg',
 'b.txt',
 'dir2',
 'access.log']
```

#### 1.拆分路径

os.path模块用来对文件和路径进行管理，显然，它会包含很多拆分路径的函数。os.path模块中与拆分路径相关的函数有：

- split：返回一个二元组，包含文件的路径与文件名； 
  
- dirname：返回文件的路径；

- basename：返回文件的文件名；

- splitext：返回一个除去文件扩展名的部分和扩展名的二元组。

下面的代码测试了split、dirname、basename和splitext这几个函数的功能：

```shell
In [1]: import os

In [2]: path = "/home/lmx/t/access.log"

In [3]: os.path.split(path)
Out[3]: ('/home/lmx/t', 'access.log')

In [4]: os.path.dirname(path)
Out[4]: '/home/lmx/t'

In [5]: os.path.basename(path)
Out[5]: 'access.log'

In [6]: os.path.splitext(path)
Out[6]: ('/home/lmx/t/access', '.log')
```

#### 2.构建路径

os.path模块也包含了用以构建路径的函数。其中最常用的便是expanduser、abspath和join函数：

- expanduser：展开用户的HOME目录，如~、~username；

- abspath：得到文件或路径的绝对路径；

- join：根据不同的操作系统平台，使用不同的路径分隔符拼接路径。

- pardir: 返回父级目录（..）


下面的代码演示了各个函数的用法：

```shell

In [1]: import os

In [2]: os.getcwd()
Out[2]: '/home/lmx/t'

In [3]: os.path.expanduser('~')
Out[3]: '/home/lmx'

In [4]: os.path.expanduser('~mysql')
Out[4]: '/home/mysql'

In [5]: os.path.expanduser('~lmx/t')
Out[5]: '/home/lmx/t'

In [6]: os.path.abspath('.')
Out[6]: '/home/lmx/t'

In [7]: os.path.abspath('..')
Out[7]: '/home/lmx'

In [8]: os.path.abspath('../t/a.py')
Out[8]: '/home/lmx/t/a.py'

In [9]: os.path.join('~', 't', 'a.py')
Out[9]: '~/t/a.py'

In [10]: os.path.join(os.path.expanduser('~mysql'), 't', 'a.py')
Out[10]: '/home/mysql/t/a.py'
```

前面介绍os.path模块构建路径时，介绍了abspath函数，该函数用来返回一个相对路径的绝对路径。相应的，os.path模块也存在一个函数用来检查一个路径是否为绝对路径。

```shell
In [11]: os.path.isabs('/home/lmx/t/a.py')
Out[11]: True

In [12]: os.path.isabs('.')
Out[12]: False
```

在Python代码中，可以使用__file__这个特殊的变量表示当前代码所在的源文件。
在编写代码时，有时需要导入当前源文件父目录下的软件包（如编写单元测试）。因此，需要用到这里的路径函数获取源文件的父目录，如下所示：

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
from __future__ import print_function

import os

print("current directory :", os.getcwd())
path = os.path.abspath(__file__)
print("full path of current file :", path)
print("parent directory of current file :",
        os.path.abspath(os.path.join(os.path.dirname(path), os.path.pardir)))
```

输出结果如下：

```shell
current directory : /home/lmx/t
full path of current file : /home/lmx/t/a.py
parent directory of current file : /home/lmx
```

#### 3.获取文件属性

os.path模块也包含了若干函数用来获取文件的属性，包括文件的创建时间、修改时间、文件的大小等：

- getatime：获取文件的访问时间；

- getmtime：获取文件的修改时间；

- getctime：获取文件的创建时间；

- getsize：获取文件的大小。



#### 4.判断文件类型
os.path模块也提供了若干函数用来判断路径是否存在，以及路径所指文件的类型，这些判断类函数一般以“is”开头，并且返回一个Boolean型结果。

os.path模块提供的判断类函数包括：

- exists：参数path所指向的路径是否存在；

- isfile：参数path所指向的路径存在，并且是一个文件；

- isdir：参数path所指向的路径存在，并且是一个文件夹；

- islink：参数path所指向的路径存在，并且是一个链接；

- ismount：参数path所指向的路径存在，并且是一个挂载点。


充分使用os.path模块的函数，就能够实现很多有用的系统管理功能。例如：

1）获取当前用户home目录下所有的文件列表：

```python
import  os
[item for item in os.listdir(os.path.expanduser('~')) if os.path.isfile(item)]
```


2）获取当前用户home目录下所有的目录列表：

```python
import os
[item for item in os.listdir(os.path.expanduser('～')) if os.path.isdir(item)]
```

3）获取当前用户home目录下所有目录的目录名到绝对路径之间的字典：

```python
import os
{item: os.path.realpath(item) for item in os.listdir(os.path.expanduser('～')) if os.path.isdir(item)}
```

4）获取当前用户home目录下所有文件到文件大小之间的字典：

```python
import os
{item: os.path.getsize(item) for item in os.listdir(os.path.expanduser('～')) if os.path.isfile(item)}
```


### 2.2 使用os模块管理文件和目录

前面已经介绍了getcwd函数，该函数用来获取当前目录，与之相关的是chdir函数，该函数用来修改当前目录。如下所示：

```shell
In [1]: import os

In [2]: os.getcwd()
Out[2]: '/home/lmx/t'

In [3]: os.chdir(os.path.expanduser('～lmx'))

In [4]: os.getcwd()
Out[4]: '/home/lmx'
```


os模块也包含了文件和目录的操作函数，包括创建目录、删除目录、删除文件、重命名文件等。

- unlink/remove：删除path路径所指向的文件；

- rmdir：删除path路径锁指向的文件夹，该文件夹必须为空，否则会报错；

- mkdir：创建一个文件夹；

- rename：重命名文件或文件夹。


下面的代码演示了使用os模块进行目录和文件管理的用法：

```shell

In [5]: ls
1.jpg  2.jpg  access.log  a.py  a.txt  b.txt  c.txt  dir1/  dir2/  dir3/

In [6]: os.remove('1.jpg')

In [7]: os.unlink('2.jpg')

In [8]: os.rmdir('dir1')

In [9]: os.removedirs('dir2')

In [10]: ls
access.log  a.py  a.txt  b.txt  c.txt  dir3/

In [11]: os.mkdir('mydir')

In [12]: ls
access.log  a.py  a.txt  b.txt  c.txt  dir3/  mydir/

In [13]: os.rename('mydir', 'newdir')

In [14]: ls
access.log  a.py  a.txt  b.txt  c.txt  dir3/  newdir/
```


os模块也包含了修改文件权限、判断文件权限的函数，即chmod和access。chmod用来修改文件的权限，access用来判断文件是否具有相应的权限。在Linux中，权限分为读、写和执行。


因此，os模块也提供了三个常量来表示读、写、可执行权限，即R_OK、W_OK和X_OK。

下面的程序演示了chmod和access函数的用法。首先通过命令行读取文件的名称，先判断文件是否存在，如果文件不存在，则直接退出。

然后判断文件是否具有读权限，如果没有读权限，则将文件赋予所有用户都具有读、写、执行权限。如果文件存在并且已经具有读权限，读取文件内容。

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
from __future__ import print_function
import os
import sys

def main():
    sys.argv.append("")
    filename = sys.argv[1]
    if not os.path.isfile(filename):
        raise SystemExit(filename + ' does not exists')
    elif not os.access(filename, os.R_OK):
        os.chmod(filename, 0777)
    else:
        with open(filename) as f:
            print(f.read())

if __name__ == '__main__':
    main()
```


### 2.3 案例：打印最常用的10条Linux命令

~/.bash_history文件保存了命令的历史，因此，我们可以使用该文件获取命令的列表统计命令的执行次数。

在统计时，我们只统计命令的名称即可，以不同的参数调用相同的命令也认为是同一个命令。下面的程序用来统计每条命令的出现次数，然后找出出现次数最多的10条命令。如下所示：

```shell
In [1]: import os

In [2]: from collections import Counter

In [3]: c = Counter()

In [4]: with open(os.path.expanduser('~/.bash_history')) as f:
   ...:     for line in f:
   ...:         cmd = line.strip().split()
   ...:         if cmd:
   ...:             c[cmd[0]]+=1
   ...:

In [5]: c.most_common(10)
Out[5]:
[('ls', 116),
 ('vi', 55),
 ('cd', 47),
 ('fab', 32),
 ('cat', 25),
 ('python', 13),
 ('ps', 13),
 ('ssh', 11),
 ('pwd', 11),
 ('vim', 11)]
```

## 3 查找文件
