# 打造命令行工具

## sys.argv

```python

from __future__ import print_function
import os
import sys


def main():
    sys.argv.append("")
    filename = sys.argv[1]
    if not os.path.isfile(filename):
        raise SystemExit(filename + ' does not exists')
    elif not os.access(filename, os.R_OK):
        raise SystemExit(filename + ' is not accessible')
    else:
        print(filename + ' is accessible')


if __name__ == '__main__':
    main()
```
在这个例子中，我们从命令行参数获取文件的名称，然后判断文件是否存在。如果文件不存在，则提示用户该文件不存在；如果文件存在，则使用os.access函数判断我们是否具有对文件的读权限。

在这个程序中，我们通过`sys.argv[1]`获取文件的名称。但是，这里有种异常情况需要考虑，如果用户直接运行我们的程序，没有传递任何命令行参数，那么，访问`sys.argv[1]`将会出现索引越界的错误。

为了避免这个错误，我们可以在访问sys.argv之前先向sys.argv中添加一个空的字符串。添加空字符串以后，无论用户是否提供命令行参数，访问`sys.argv[1]`都不会出错。如果用户传递了命令行参数，那么，通过`sys.argv[1]`访问，得到的是用户提供的命令行参数。




## sys.stdin和fileinput

在Python标准库的sys库中，有三个文件描述符，分别是stdin、stdout和stderr，这三个文件描述符分别代表标准输入、标准输出和错误输出。我们不需要调用open函数打开这几个文件就可以直接使用。

例如，我们有一个名为read_stdin.py的文件，该文件仅仅是从标准输入中读取内容，然后打印到命令行终端。文件内容如下：


```python
from __future__ import print_function
import sys

for line in sys.stdin:
    print(line, end="")
```

接下来，我们就可以像Shell脚本一样，通过标准输入给该程序输入内容。如下所示：

```shell
cat /etc/passwd | python read_stdin.py
python read_stdin.py < /etc/passwd
python read_stdin.py -

```

调用readlines函数将标准输入的内容读取到一个列表中。

```python

from __future__ import print_function
import sys

def get_content():
    return sys.stdin.readlines()

print(get_content())
```

fileinput是Python语言的一个标准库，它提供了比sys.stdin更加通用的功能。

使用fileinput，可以依次读取命令行参数中给出的多个文件。

也就是说，fileinput会遍历`sys.argv[1：]`列表，并按行依次读取列表中的文件。

如果该列表为空，则fileinput默认读取标准输入中的内容。


因为fileinput可以读取多个文件的内容，所以，fileinput提供了一些方法让我们知道当前所读取的内容属于哪一个文件。fileinput中常用的方法有：

- filename：当前正在读取的文件名； 
  
- fileno：文件的描述符； 
  
- filelineno：正在读取的行是当前文件的第几行；

- isfirstline：正在读取的行是否当前文件的第一行；

- isstdin fileinput：正在读取文件还是直接从标准输入读取内容。


```python

#!/usr/bin/python
from __future__ import print_function
import fileinput

for line in fileinput.input():
    meta = [fileinput.filename(), fileinput.fileno(), fileinput.filelineno(),
            fileinput.isfirstline(), fileinput.isstdin()]
    print(*meta, end=" ")
    print(line, end="")

```


## SystemExit

使用sys.stdout与sys.stderr输出

```python
import sys

sys.stdout.write('hello\n')
sys.stderr.write('world \n')

```


```shell
$ python3 sys-error.py 
hello
world 

$ python3 sys-error.py 2> /dev/null
hello

$ python3 sys-error.py > /dev/null
world 
```

在Python程序中，print函数默认输出到命令行终端，因此，一般情况下，我们不会直接调用sys.stdout来输出内容。如果我们的Python程序执行失败，需要在标准错误中输出错误信息，然后以非零的返回码退出程序，那么，这个时候就需要使用sys.stderr。如下所示：

```python
import sys

sys.stderr.write('error message')
sys.exit(1)
```
对于“Python脚本执行出错，需要向错误输出中输出错误信息，并且以非零的返回码退出程序”的需求，我们也可以直接抛出一个SystemExit异常。如下所示：
```shell

$ python test_system_exit.py
error message

$ echo $?
1
```


## getpass
getpass是一个非常简单的Python标准库，主要包含getuser函数和getpass函数。

getpass函数与input函数的区别在于，它不会将我们输入的密码显示在命令行中，从而避免我们输入的密码被他人看到。

```python
from __future__ import print_function
import getpass

user = getpass.getuser()
passwd = getpass.getpass('your password: ')
print(user, passwd)

```


## ConfigParse

配置文件示例

example.cfg

```
[default]
serveraliveinterval = 45
compression = yes
compressionlevel = 9

[bitbucket.org]
user = hg

[topsecret.server.com]
port = 50022
forwardx11 = no
skip-external-locking
```


python生成配置文件

```python
import configparser

config = configparser.ConfigParser()
config['default'] = {'ServerAliveInterval': '45',
                     'Compression': 'yes',
                     'CompressionLevel': '9'}

config['bitbucket.org'] = {}
config['bitbucket.org']['User'] = 'hg'


config['topsecret.server.com'] = {'port': '50022',
                                  'Forwardx11': 'no'}


config.add_section('mysql')
config.set('mysql', 'host', '127.0.0.1')
config.set('mysql', 'port', 3306)

with open('example.cfg', 'w') as configfile:
    config.write(configfile)
```

### 1.读取配置项示例

先生成一个配置文件
```python
import configparser

'''
[client]
port        = 3306
user        = mysql
password    = mysql
host        = 127.0.0.1

[mysqld]
basedir         = /usr
datadir         = /var/lib/mysql
tmpdir          = /tmp
skip-external-locking

'''

cf = configparser.ConfigParser(allow_no_value=True)


cf.add_section('client')
cf.set('client', 'port', '3306')
cf.set('client', 'user', 'mysql')
cf.set('client', 'password', 'mysql')
cf.set('client', 'host', '127.0.0.1')


cf.add_section('mysqld')
cf.set('mysqld', 'basedir', '/usr')
cf.set('mysqld', 'datadir', '/var/lib/mysql')
cf.set('mysqld', 'tmpdir', '/tmp')
cf.set('mysqld', 'skip-external-locking')


with open('my.cnf', 'w') as f:
    cf.write(f)
```

ConfigParser中有很多的方法，其中与读取配置文件，判断配置项相关的方法有：

- sections：返回一个包含所有章节的列表；
- has_section：判断章节是否存在；
- items：以元组的形式返回所有选项；
- options：返回一个包含章节下所有选项的列表；
- has_option：判断某个选项是否存在；
- get、getboolean、getinit、getfloat：获取选项的值。


```python
import configparser
cf = configparser.ConfigParser(allow_no_value=True)

cf.read('my.cnf')

print(cf.sections())
# ['client', 'mysqld']

print(cf.has_section('client'))
# True

print(cf.options('client'))
# ['port', 'user', 'password', 'host']


print(cf.has_option('client', 'user'))
# True

print(cf.get('client', 'host'))
# '127.0.0.1'

print(cf.getint('client', 'port'))
# 3306
```


ConfigParser也提供了许多方法便于我们修改配置文件。如下所示：

- remove_section：删除一个章节；
- add_section：添加一个章节；
- remote_option：删除一个选项；
- set：添加一个选项；
- write将ConfigParser对象中的数据保存到文件中。


```python
import configparser


cf = configparser.ConfigParser(allow_no_value=True)

cf.read('my.cnf')
cf.remove_section('client')
cf.add_section('mysql')
cf.set('mysql', 'host', '127.0.0.1')
cf.set('mysql', 'port', '3306')
cf.write(open('my_copy.cnf', 'w'))

```

修改完成以后，新的my_copy.cnf文件内容如下：

``` 

[mysqld]
basedir = /usr
datadir = /var/lib/mysql
tmpdir = /tmp
skip-external-locking

[mysql]
host = 127.0.0.1
port = 3306
```

### 2.配置项增删改查

配置文件Background.ini

```ini
[Background]
Image        = Whitecristal.png
LeftMargin   = 8
TopMargin    = 8
RightMargin  = 8
BottomMargin = 8
Outside-LeftMargin   = 8
Outside-TopMargin    = 8
Outside-RightMargin  = 8
Outside-BottomMargin = 8
[Background2]
Image        = Whitecristal2.png
LeftMargin   = 18
TopMargin    = 28
RightMargin  = 38
BottomMargin = 48
Outside-LeftMargin   = 8
Outside-TopMargin    = 8
Outside-RightMargin  = 8
Outside-BottomMargin = 8

```

#### 读取
```python
#!/usr/bin/env python
# -*- coding:utf8 -*-
import configparser

config = configparser.ConfigParser()
config.read("Background.ini")
sections = config.sections()  # 返回所有的配置块
print("\033[31m配置块\033[0m：", sections)
o = config.options("Background2")  # 返回所有的配置项
print("\033[31m配置项:\033[0m", o)

v = config.items("Background2")  # 返回配置项的内容
print("\033[31m内容：\033[0m", v)
# 根据配置块和配置项返回内容
access = config.get("Background", "Outside-RightMargin")
print(access)

Image_info = config.get("Background", "Image")
print(Image_info)
```


#### 新增

```python
#!/usr/bin/env python
import configparser

config = configparser.ConfigParser()
config.add_section("Mysqld")            #添加新的配置块
config.set("Mysqld", "port", "3306")    #添加新的配置项
f = open("Background.ini","a+")
config.write(f)
f.close()
```

#### 修改
```python
import configparser

ini_name = "Background.ini"
config = configparser.ConfigParser()
config.read(ini_name)
config.set("Mysqld", "port", "3307")  # 修改配置项
f = open(ini_name, "r+")
config.write(f)
f.close()
```


#### 删除
```python
#!/usr/bin/env python
# -*- coding:utf8 -*-
import configparser

ini_name = "Background.ini"
config = configparser.ConfigParser()
config.read(ini_name)
config.remove_option("Mysqld", "port")  # 删除配置项
config.remove_section("Mysqld")  # 删除配置块
f = open(ini_name, "w+")
config.write(f)
f.close()

```



!!! tip "参考地址"

        常用模块和使用案例 https://www.cnblogs.com/wf-linux/archive/2018/08/01/9400354.html

        Python3读写ini配置文件 https://sre.ayunw.cn/posts/python3_read_and_write_ini_config_file/


## argparse

```python

#!/usr/bin/env python
# -*- coding:utf8 -*-
# filename: apgparse模块.py

import argparse


def _argparse():
    parser = argparse.ArgumentParser(description="This is description")
    parser.add_argument("--host", action="store",
                        dest="server", default="localhost", help="connect to host")
    parser.add_argument("-t", action="store_true",
                        dest="boolean_switch", default=False, help="Set a switch to true")
    return parser.parse_args()


def main():
    parser = _argparse()
    print(parser)
    print("host = ", parser.server)
    print("boolean_switch=", parser.boolean_switch)


if __name__ == '__main__':
    main()
```

输出信息
```shell

$ python apgparse模块.py
$ Namespace(boolean_switch=False, server='localhost')
host =  localhost
boolean_switch= False

python apgparse模块.py --host=127.0.0.1 -t
Namespace(boolean_switch=True, server='127.0.0.1')
host =  127.0.0.1
boolean_switch= True
```


通过help选项获取帮助信息

```shell
$ python apgparse模块.py --help
usage: apgparse模块.py [-h] [--host SERVER] [-t]

This is description

optional arguments:
  -h, --help     show this help message and exit
  --host SERVER  connect to host
  -t             Set a switch to true

```


模仿Mysql客户端的命令行参数
```python

import argparse


def _argparse():
    parser = argparse.ArgumentParser(description="A Python-MySQL client")
    parser.add_argument("--host", action="store",
                        dest="host", required=True, help="connect to host")

    parser.add_argument("-u", "--user", action="store",
                        dest="user", required=True, help="user for login")

    parser.add_argument("-p", "--password", action="store",
                        dest="password", required=True,
                        help="password to use when connecting to server")

    parser.add_argument("-P", "--port", action="store",
                        dest="port", default=3306, type=int,
                        help="port number to use for connection or 3306 for default")
    parser.add_argument("-v", "--version", action="version", version='%(prog)s 0.1')
    return parser.parse_args()

def main():
    parser = _argparse()
    conn_args = dict(host=parser.host, user=parser.user,
                     password=parser.password,port=parser.port)
    print(conn_args)

if __name__ == '__main__':
    main()
```

输出信息

```shell
$ python apgparse模块.py --help

usage: apgparse模块.py [-h] --host HOST -u USER -p PASSWORD [-P PORT] [-v]

A Python-MySQL client

optional arguments:
  -h, --help            show this help message and exit
  --host HOST           connect to host
  -u USER, --user USER  user for login
  -p PASSWORD, --password PASSWORD
                        password to use when connecting to server
  -P PORT, --port PORT  port number to use for connection or 3306 for default
  -v, --version         show program's version number and exit


```

示例代码

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import argparse

def get_argparse():
    parser = argparse.ArgumentParser(description='A email client in terminal')
    parser.add_argument('-s', action='store', dest='subject', required=True, help='specify a subject (must be in quotes if it has spaces)')
    parser.add_argument('-a', action='store', nargs='*', dest='attaches', required=False, help='attach file(s) to the message')
    parser.add_argument('-f', action='store', dest='conf', required=False, help='specify an alternate .emcli.cnf file')
    parser.add_argument('-r', action='store', nargs='*', dest='recipients', required=True, help='recipient who you are sending the email to')
    parser.add_argument('-v', action='version', version='%(prog)s 0.2')
    return parser.parse_args()



if __name__ == '__main__':
    parser = get_argparse()
    print(parser)
    print("s = ", parser.subject)
    print("r = ", parser.recipients)
    print("f = ", parser.conf)
```

```shell
$ python argparse02.py -s hu -r huajianli -f "config.cfg"
Namespace(attaches=None, conf='config.cfg', recipients=['huajianli'], subject='hu')
s =  hu
r =  ['huajianli']
f =  config.cfg
```




!!! tip "Python命令行参数的3种传入方式"


    https://tendcode.com/article/python-shell/



!!! tip "argparse模块示例"


    [Python实用模块(二十六)argparse](https://xugaoxiang.com/2020/11/11/python-module-argparse/)


