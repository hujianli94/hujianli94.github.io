# 5.Python数据结构

## 1.列表 List


```python
list() #创建一个空列表
[]     #创建一个空列表
```

### 1.1 列表的内置方法


```python
list.append(obj)                 # 向列表中添加一个对象obj
list.count(obj)                  # 返回一个对象obj在列表中出现的次数
list.extend(seq)                 # 把序列seq的内容添加到列表中
list.index(obj,i=0,j=len(list))  # 返回list[k] == obj 的k值,并且k的范围在i<=k<j;否则异常
list.insert(index.obj)           # 在索引量为index的位置插入对象obj
list.pop(index=-1)               # 删除并返回指定位置的对象,默认是最后一个对象
list.remove(obj)                 # 从列表中删除对象obj
list.reverse()                   # 原地翻转列表
list.sort(func=None,key=None,reverse=False)  # 以指定的方式排序列表中成员,如果func和key参数指定,则按照指定的方式比较各个元素,如果reverse标志被置为True,则列表以反序排列
list.sort(reverse=True)          #降序
```

## 2.元祖 Tuple

tuple()函数创建一个空元祖


### 2.1 元祖特性

- 不可变序列（不能添加、修改和删除元素，可以整体替换）
- 支持切片的操作（只能访问元祖中的元素）
- 元祖访问速度快
- 元祖可以作为字典的键


```python
# 和列表操作很类似，但不可变
zoo = ('wolf', 'elephant', 'penguin')


# 元祖的小括号并不是必须的，只要将一组数用逗号分隔开来，python就可以认为它是元祖。
In [1]: tmp="aa","bb","cc"

In [2]: type(tmp)
Out[2]: tuple


# 元祖使用+号可以组合，类似列表
#!/usr/bin/env python
#-*- coding:utf8 -*-
# auther; 18793
# Date：2019/4/15 20:09
# filename: 元祖.py
play1=("梅西","C罗","卡卡西","胡歌")
print("原始的元祖：{}".format(play1))
play2=play1+("胡建力","小贱","胡小健")
print("组合后的元祖：{}".format(play2))

# 在元祖添加时，若只有1个元祖，需要在后面加上逗号
play3= play2+("路飞",)
print("添加元祖，当只有一个元素时，需要在后面加上逗号:{}".format(play3))

```


## 3.字典 Dict

dict()函数创建一个空字典，字典是无序的。


### 3.1 字典的内置方法

```python
dict.clear()                            # 删除字典中所有元素
dict.copy()                             # 返回字典(浅复制)的一个副本
dict.fromkeys(seq,val=None)         # 创建并返回一个新字典,以seq中的元素做该字典的键,val做该字典中所有键对的初始值
dict.get(key,default=None)              # 对字典dict中的键key,返回它对应的值value,如果字典中不存在此键,则返回default值
dict.has_key(key)                       # 如果键在字典中存在,则返回True, python3中用in和not in代替了
dict.items()                            # 返回一个包含字典中键、值对元组的列表
dict.keys()                             # 返回一个包含字典中键的列表
dict.iter()                             # 方法iteritems()、iterkeys()、itervalues()与它们对应的非迭代方法一样,不同的是它们返回一个迭代子,而不是一个列表
dict.pop(key[,default])                 # 和方法get()相似.如果字典中key键存在,删除并返回dict[key]
dict.setdefault(key,default=None)       # 和set()相似,但如果字典中不存在key键,由dict[key]=default为它赋值
dic[key] = [value]                      #替代了setdefault方法，直接键对应值进行添加字典
dict.update(dict2)                      # 将字典dict2的键值对添加到字典dict
dict.values()                           # 返回一个包含字典中所有值得列表
dict([container])     # 创建字典的工厂函数。提供容器类(container),就用其中的条目填充字典
len(mapping)          # 返回映射的长度(键-值对的个数)
hash(obj)             # 返回obj哈希值,判断某个对象是否可做一个字典的键
del dict["key"]       # 删除具有指定键的元素
```


## 4.集合 Set

`set()`函数可以将列表转换为集合

**可以用于去重复数据**



### 4.1 集合的方法

```python
s.update(t)                         # 用t中的元素修改s,s现在包含s或t的成员   s |= t
s.intersection_update(t)            # s中的成员是共用属于s和t的元素          s &= t
s.difference_update(t)              # s中的成员是属于s但不包含在t中的元素    s -= t
s.symmetric_difference_update(t)    # s中的成员更新为那些包含在s或t中,但不是s和t共有的元素  s ^= t
s.add(obj)                          # 在集合s中添加对象obj
s.remove(obj)                       # 从集合s中删除对象obj;如果obj不是集合s中的元素(obj not in s),将引发KeyError错误
s.discard(obj)                      # 如果obj是集合s中的元素,从集合s中删除对象obj
s.pop()                             # 删除集合s中的任意一个对象,并返回它
s.clear()                           # 删除集合s中的所有元素
s.issubset(t)                       # 如果s是t的子集,则返回True   s <= t
s.issuperset(t)                     # 如果t是s的超集,则返回True   s >= t
s.union(t)                          # 合并操作;返回一个新集合,该集合是s和t的并集   s | t
s.intersection(t)                   # 交集操作;返回一个新集合,该集合是s和t的交集   s & t
s.difference(t)                     # 返回一个新集合,改集合是s的成员,但不是t的成员  s - t
s.symmetric_difference(t)           # 返回一个新集合,该集合是s或t的成员,但不是s和t共有的成员   s ^ t
s.copy()                            # 返回一个新集合,它是集合s的浅复制
obj in s                            # 成员测试;obj是s中的元素 返回True
obj not in s                        # 非成员测试:obj不是s中元素 返回True
s == t                              # 等价测试 是否具有相同元素
s != t                              # 不等价测试
s < t                               # 子集测试;s!=t且s中所有元素都是t的成员
s > t                               # 超集测试;s!=t且t中所有元素都是s的成员
```





## 5.大型数据结构

### 5.1元祖里面嵌套列表

```shell
In [31]: list1=["hujianli","leijun","hushiqiang","zhangyong"]

In [32]: list2=["wuhan","caidian","xiaogan","yingcheng"]

In [33]: list3=["21","22","23","24"]

In [34]: tuple_of_list= list1,list2,list3

In [35]: tuple_of_list
(['hujianli', 'leijun', 'hushiqiang', 'zhangyong'],
 ['wuhan', 'caidian', 'xiaogan', 'yingcheng'],
 ['21', '22', '23', '24'])

 In [36]: tuple_of_list[1]
Out[36]: ['wuhan', 'caidian', 'xiaogan', 'yingcheng']

In [37]: tuple_of_list[2]
Out[37]: ['21', '22', '23', '24']
```



### 5.2 列表里面嵌套列表


```shell
In [40]: list_of_list = [list1,list2,list3]

In [41]: list_of_list
Out[41]:
[['hujianli', 'leijun', 'hushiqiang', 'zhangyong'],
 ['wuhan', 'caidian', 'xiaogan', 'yingcheng'],
 ['21', '22', '23', '24']]

In [42]: list_of_list[0]
Out[42]: ['hujianli', 'leijun', 'hushiqiang', 'zhangyong']

In [43]: list_of_list[1]
Out[43]: ['wuhan', 'caidian', 'xiaogan', 'yingcheng']
```




### 5.3 字典里面嵌套列表


```shell
In [44]: dict_of_list = { "dict1":list1,"dict2":list2,"dict3":list3 }

In [45]: dict_of_list
{'dict1': ['hujianli', 'leijun', 'hushiqiang', 'zhangyong'],
 'dict2': ['wuhan', 'caidian', 'xiaogan', 'yingcheng'],
 'dict3': ['21', '22', '23', '24']}


In [47]: dict_of_list.keys()
Out[47]: dict_keys(['dict1', 'dict2', 'dict3'])

In [48]: dict_of_list.values()
Out[48]: dict_values([['hujianli', 'leijun', 'hushiqiang', 'zhangyong'], ['wuhan', 'caidian', 'xiaogan', 'yingcheng'], ['21', '22', '23', '24']])

In [49]: dict_of_list.items()
Out[49]: dict_items([('dict1', ['hujianli', 'leijun', 'hushiqiang', 'zhangyong']), ('dict2', ['wuhan', 'caidian', 'xiaogan', 'yingcheng']), ('dict3', ['21', '22', '23', '24'])])


# 可以一层一层打开里面的内容，使用in进行判断元素。
In [59]: for i in dict_of_list.values():
    ...:     for j in i:
    ...:         if "hujianli" in j:
    ...:             print("找到'hujianli'....")
    ...:
    ...:
找到'hujianli'....
```
