# 15.标准库和三方库


## 日常类库


### sys

获取命令行参数
```python
# argv_demo.py 
import sys 
print(sys.argv)
```


### getopt

```python
import sys 
import getopt
 
def usage(): 
    print("""e.g. python test.py [optsions]
    Options: 
    -w --word: the word should be print 
    -h --help: show this help info 
    """) 
 
def parse_args(): 
    try: 
        opts, args = getopt.getopt(sys.argv[1:], "hw:", ["help", "word="]) 
    except getopt.GetoptError as err: 
        print(err) 
        usage() 
        sys.exit(2) 
        word = None 
        
    for k, v in opts: 
        if k in ("-w", "--word"): 
            word = v 
        elif k in ("-h", "--help"): 
            usage() 
            sys.exit() 
        else: 
            assert False, "unhandled option" 
    return word
     
def print_word(): 
    word = parse_args() 
    if word: 
        print(f'hello {word}') 
    else: 
        usage() 
 
if __name__ == "__main__": 
    print_word() 
```


### minidom

内容更新
```python
from xml.dom.minidom import parse
 
doc = parse('test.xml') 
students = doc.getElementsByTagName('students')[0] 
# 创建一个新的 student 元素节点，并追加到 students 父节点
student = doc.createElement('student') 
students.appendChild(student) 
# 给 student 元素节点设置属性
student.setAttribute('id', '104') 
student.setAttribute('name', '许六') 
student.setAttribute('age', '21') 
sex = doc.createAttribute('sex') # 创建属性节点
sex.value = '女' 
student.setAttributeNode(sex) 
# 创建 subject1 元素节点并追加到 student 父节点
subject1 = doc.createElement('subject') 
txt = doc.createTextNode('化学') # 创建文本节点
subject1.appendChild(txt) 
student.appendChild(subject1) 
# 创建 subject2 元素节点并插入 subject1 节点前
subject2 = doc.createElement('subject') 
txt = doc.createCDATASection ('物理') # 支持转义的文本节点
subject2.appendChild(txt) 
student.insertBefore(subject2, subject1) 
# 保存 XML 内容
with open('test.xml', 'w', encoding='utf-8') as f: 
    doc.writexml(f, addindent='', encoding='utf-8') 
```

修改和删除 XML 节点
```python
from xml.dom.minidom import parse 
doc = parse('test.xml') 
students = doc.getElementsByTagName('students')[0] 
last_student = students.getElementsByTagName('student')[-1] 
students.removeChild(last_student) # 删除最后一个 student 节点
first_student = students.getElementsByTagName('student')[0] 
first_student.setAttribute('age', '20') # 修改元素属性值
first_subject = first_student.getElementsByTagName('subject')[0] 
first_subject.firstChild.data = '体育' # 修改文本节点内容

with open('test.xml', 'w', encoding='utf-8') as f: 
    doc.writexml(f, addindent='', encoding='utf-8')
```



### json

```python
import json 
from datetime import datetime
 
def date_to_str(dt): 
    return dt.strftime('%Y-%m-%d %H:%M:%S')
     
data = {'now': datetime.now()} 
# json.dumps(data) # 抛出 JSON serializable 异常
data['now'] = date_to_str(data['now']) 
print(json.dumps(data))
```





```python
import json 
from datetime import datetime
 
class DatetimeEncoder(json.JSONEncoder): 
    def default(self, obj): 
        if isinstance(obj, datetime): 
            return obj.strftime('%Y-%m-%d %H:%M:%S')
             
        return json.JSONEncoder.default(self, obj)

data = {'now': datetime.now()} 
print(json.dumps(data, cls=DatetimeEncoder)) 
```


### openpyxl

#### 读取 Excel 文件

```python
from openpyxl import load_workbook
 
wb = load_workbook('d:\\test.xlsx') 
ws = wb.active 
# 遍历全部内容
for row in ws.rows: # 遍历全部行
    for c in row: # 遍历行内全部列
        print(c.value) 
  
# 遍历 A1 至 C4 区域的内容
for row in ws["A1:C4"]: 
    for c in row: 
        print(c.value)
```

#### 写入 Excel 文件

```bash
>>> from openpyxl import Workbook 
>>> wb = Workbook() # 创建一个新的 Workbook 对象
>>> wb.sheetnames 
['Sheet'] 
>>> wb.active 
<Worksheet "Sheet">
```
```bash
>>> wb.create_sheet("New_Sheet") # 新建一个 Worksheet 对象
<Worksheet "New_Sheet"> 
>>> wb.copy_worksheet(wb.active) # 复制一个 Worksheet 对象
<Worksheet "Sheet Copy"> 
>>> wb.sheetnames 
['Sheet', 'New_Sheet'] 
>>> ws = wb['Sheet'] 
>>> wb.remove(ws) # 删除指定的 Worksheet 
>>> wb.sheetnames 
['New_Sheet']
```
```bash
>>> ws['A1'] = 10 # 单元格 A1 设值
>>> ws.cell(row=6, column=3, value= "Hello Python") # 单元格 C6 设值
>>> ws.append([1, 2, 3]) # 在最后一行下追加一行内容
>>> for i in range(2,6): # 对指定区域进行设值
... for j in range(1,4): 
... ws.cell(row=i, column=j, value="test") 
... 
>>> wb.save("test.xlsx")
```

#### 样式设置

```bash
>>> from openpyxl.styles import Font, colors, Alignment 
>>> ws['A1'].font = ws['A1'].font = Font(name="微软雅黑", color=colors.RED, size=28, 
italic=True, bold=True)) # 设置字体样式
>>> ws['B1'].alignment = Alignment(horizontal='center', vertical='center') 
 # 设置对齐方式
>>> ws.row_dimensions[1].height = 30 # 设置第 1 行的高度
>>> ws.column_dimensions['A'].width = 30 # 设置 A 列的宽度
```
```bash
>>> # 第一种方式
>>> ws.merge_cells('A1:A3') # 合并单元格
>>> ws.unmerge_cells('A1:A3') # 拆分单元格
>>> # 第二种方式
>>> ws.merge_cells(start_row=2, start_column=1, end_row=4, end_column=5) 
>>> ws.unmerge_cells(start_row=2, start_column=1, end_row=4, end_column=5)
```
```bash
>>> from openpyxl.drawing.image import Image 
>>> img = Image('test.png') 
>>> ws.add_image(img, 'A1') 
>>> wb.save("test.xlsx")
```


### logging

```bash
>>> import logging 
>>> logger = logging.getLogger() # 获取一个 Logger 对象
>>> logger.setLevel(logging.WARNING) # 设置日志等级为 WARNING 
>>> logger.critical("critical") # 记录严重等级日志
critical 
>>> logger.error("error") # 记录错误等级日志
error 
>>> logger.warning("warning") # 记录警告等级日志
warning 
>>> logger.info("info") # 记录信息等级日志
>>> logger.debug("debug") # 记录调试等级日志
```

#### 日志选项配置

```python
import logging 
logging.basicConfig( 
    level=logging.INFO, 
    stream=open('test.log', 'a'), 
    format="%(asctime)s - %(name)s - %(lineno)d - %(levelname)s - %(message)s", 
    datefmt="%Y-%m-%d %H:%M:%S" 
)
 
logger = logging.getLogger() 
logger.critical("critical") 
logger.error("error") 
logger.warning("warning") 
logger.info("info") 
logger.debug("debug")
```
```bash
[loggers] 
keys=root,logger01 
 
[handlers] 
keys=fileHandler,consoleHandler 
 
[formatters] 
keys=Formatter01 
 
[logger_root] 
level=DEBUG 
handlers=consoleHandler 
 
[logger_logger01] 
level=DEBUG 
handlers=consoleHandler,fileHandler 
qualname=logger01 
propagate=0 
 
[handler_consoleHandler] 
class=StreamHandler 
args=(sys.stdout,) 
level=DEBUG 
formatter=Formatter01 
 
[handler_fileHandler] 
class=FileHandler 
args=('logging.log', 'a') 
level=ERROR 
formatter=Formatter01 
 
[formatter_Formatter01] 
format=%(asctime)s - %(name)s - %(lineno)d - %(levelname)s - %(message)s 
datefmt=%Y-%m-%d %H:%M:%S
```

```python
import logging 
from logging.config import fileConfig
 
fileConfig('test.conf') # 设置日志配置
root = logging.getLogger() # 获取 root Logger 
logger01 = logging.getLogger("logger01") # 获取 logger01 
root.debug("root debug") 
root.error("root error")
logger01.debug("logger01 debug") 
logger01.error("logger01 error")
```
```python
dict_conf = { 
    "version": 1, 
    "root": { 
        "level": "DEBUG", 
        "handlers": ["consoleHandler"] 
    }, 
    "loggers": { 
        "logger01": { 
            "level": "DEBUG", 
            "handlers": ["consoleHandler", "fileHandler"], 
            "qualname": "logger01", 
            "propagate": 0 
        } 
    }, 
    "handlers": { 
        "consoleHandler": { 
            "class": "logging.StreamHandler", 
            "stream": "ext://sys.stdout", 
            "level": "DEBUG", 
            "formatter": "Formatter01" 
        }, 
        "fileHandler": { 
            "class": "logging.FileHandler", 
            "filename": "logging.log", 
            "level": "ERROR", 
            "formatter": "Formatter01" 
        } 
    }, 
    "formatters": { 
        "Formatter01": { 
            "format": "%(asctime)s - %(name)s - %(lineno)d - %(levelname)s - %(message)s", 
            "datefmt": "%Y-%m-%d %H:%M:%S" 
        } 
    } 
}
```

```python
import logging
from logging.config import dictConfig
 
dictConfig(dict_conf) 
root = logging.getLogger() 
logger01 = logging.getLogger("logger01") 
root.debug("root debug") 
root.error("root error") 
logger01.debug("logger01 debug") 
logger01.error("logger01 error")
```

```python
import sys 
import logging
 
root = logging.getLogger() 
root.setLevel(logging.DEBUG)
 
logger01 = logging.getLogger("logger01") 
logger01.setLevel(logging.DEBUG) 
logger01.propagate = 0
 
Formatter01 = logging.Formatter("%(asctime)s - %(name)s - %(lineno)d - %(levelname)s - %(message)s")
Formatter01.datefmt = "%Y-%m-%d %H:%M:%S"
 
consoleHandler = logging.StreamHandler(sys.stdout) 
consoleHandler.setLevel(logging.DEBUG) 
consoleHandler.setFormatter(Formatter01)
 
fileHandler = logging.FileHandler(filename="logging.log") 
fileHandler.setLevel(logging.ERROR) 
fileHandler.setFormatter(Formatter01)
 
root.addHandler(consoleHandler) 
logger01.addHandler(consoleHandler) 
logger01.addHandler(fileHandler)
 
root.debug("root debug") 
root.error("root error")
 
logger01.debug("logger01 debug") 
logger01.error("logger01 error")
```

#### Logger 对象使用

```python
import logging 

root = logging.getLogger() 

try: 
    1 / 0 
except Exception as e: 
    root.exception(e)
```


## 数据存储库


### records--轻量级DB框架

records是由requests作者开发的一个DB访问库，与requests的宗旨一样，records也力图成为一个非常易用的DB库，它是基于SQLAlchemy库封装的一个上层库。


其安装命令如下：

```sh
pip install records
```

records一共只有500多行代码，提供的都是简洁易用的API，所以上手非常容易。

具体示例如下：

```sh
>>> import records
>>> db = records.Database('sql://connect_string') # 实例化DB对象
>>> rows = db.query('select 1')                   # 执行SQL语句
```

records除了在SQL查询方面提供了更加易用的封装接口，在SQL更新、删除操作上仅仅是SQL执行的操作入口，而在插入操作上records额外提供了一个批量操作的方法。


其使用示例代码如下：
```python
import records
 
db = records.Database('sql://connect_string') 
data = [ 
    {'name': 'python', 'age': 15}, 
    {'name': 'java', 'age': 14} 
] 
# 批量操作的方法
db.bulk_query("insert into tn(name, age) values(:name, :age)", data)
```



records还提供了支持事务的API。其使用示例代码如下：

```python
import records
 
db = records.Database('sql://connect_string') 
t = db.transaction()
 
try: 
    db.query('select * from user') 
    t.commit() 
except: 
    t.rollback()
```


###  redis--读写Redis库

Redis作为大型项目经常用到的缓存中间件服务，在测试中也会经常接触到。

有时候会希望通过开发的测试工具来自动地读取、写入一些Redis数据，进而完成一个自动化测试行为。

Python中可以访问Redis的第三方库有很多，而最常用的则是同名的redis库。

redis库的安装命令如下：

```sh
pip install redis
```

redis库的基础使用示例代码如下：

```sh
>>> import redis
>>> conn = redis.Redis(host='localhost', port=6379, db=0)
>>> conn.set('foo', 'bar')         # 单键值写入或更新
True
>>> conn.set('foo', 'bar', ex=3)   # 键值过期时间为3秒
True
>>> conn.get('foo')                # 单键值读取
b'bar'
>>> conn.delete('foo')             # 删除指定键值
1
>>> conn.mset(k1='k1', k2='k2')    # 批量键值写入或更新
True
>>> conn.mget('k1', 'k2')          # 批量键值读取
'bar'
```



```bash
# 批量设置 Hash 对象数据
>>> conn.hmset('k2', {'foo': 'bar', 'zoo': 'app'}) 
True 
# 批量获取 Hash 对象中 key 对应的值
>>> conn.hmget('k2', ['foo', 'zoo']) 
['bar', 'app'] 
# 获取 Hash 对象中所有的 key 值
>>> conn.hkeys('k2') 
['foo', 'zoo'] 
# 获取 Hash 对象中所有的 value 值
>>> conn.hvals('k2') 
['bar', 'app'] 
# 获取 Hash 对象中的全部数据，包括全部的 key 和 value 
>>> conn.hgetall('k2') 
{'foo': 'bar', 'zoo': 'app'} 
# 检查 Hash 对象中是否存在指定的 key 
>>> conn.hexists('k2', 'foo') 
True 
# 删除 Hash 对象中指定的 key 
>>> conn.hdel('k2', 'zoo') 
1
```



```bash
# 向指定 name 的列表结构中添加新值，默认往左边追加
>>> conn.lpush('k3', 'foo', 'bar', 'zoo') 
3L 
# 获取列表结构中指定区间的内容，这里获取的是全部内容
>>> conn.lrange('k3', 0, -1) 
['zoo', 'bar', 'foo'] 
# 获取列表结构的长度
>>> conn.llen('k3') 
3 
# 在列表结构中的指定元素 bar 之前插入一个新值 app 
>>> conn.linsert('k3', 'before', 'bar', 'app') 
4 
# 向列表结构中的指定元素 bar 之后插入一个新值 app2 
>>> conn.linsert('k3', 'after', 'bar', 'app2') 
5 
# 修改列表结构中第一个元素的值为 zoooo 
>>> conn.lset('k3', 0, 'zoooo') 
True 
# 删除列表结构中的 app 元素，默认会删除值为 app 的全部元素
>>> conn.lrem('k3', 'app') 
1L 
# 从列表结构中移除一个元素并返回
>>> conn.lpop('k3') 
'zoooo' 
# 获取列表结构中索引为 0 的元素值
>>> conn.lindex('k3', 0) 
'bar'
```



```bash
>>> conn.lrange('k3', 0, -1) 
['zoooo', 'bar', 'app2', 'foo'] 
# 向列表结构的右侧追加新值 app 
>>> conn.rpush('k3', 'app') 
5L 
>>> conn.lrange('k3', 0, -1) 
['zoooo', 'bar', 'app2', 'foo', 'app']
```
```bash
# 向集合结构中添加元素，如果指定 name 的集合不存在，则新建一个集合
>>> conn.sadd("k4", 'foo', 'bar', 'zoo') 
3 
# 获取集合结构中的全部元素，返回一个 Python 的集合对象
>>> conn.smembers("k4") 
set(['foo', 'bar', 'zoo']) 
# 获取集合结构的长度，即成员数量
>>> conn.scard('k4') 
3
# 以 Python 元组的形式返回集合的元素成员
>>> conn.sscan('k4') 
(0L, ['zoo', 'bar', 'foo']) 
# 以 Python 迭代器的形式返回集合的元素成员
>>> conn.sscan_iter('k4') 
<generator object sscan_iter at 0x7fa2f1e863c0> 
# 检查指定值 zoo 是否为集合成员
>>> conn.sismember('k4', 'zoo') 
True 
# 从集合结构中随机移除一个元素，并返回这个元素
>>> conn.spop('k4') 
'zoo' 
# 从集合结构中删除指定元素 foo 
>>> conn.srem('k4', 'foo') 
1
```


```bash
>>> conn.sadd('k5', 'foo', 'bar', 'zoo') 
3 
>>> conn.sadd('k6', 'foo', 'bar', 'app') 
3 
# 求 k5 集合与 k6 集合的差集，即 k5 中有而 k6 中没有的成员
>>> conn.sdiff('k5', 'k6') 
set(['zoo']) 
# 求 k6 集合与 k5 集合的差集，即 k6 中有而 k5 中没有的成员
>>> conn.sdiff('k6', 'k5') 
set(['app']) 
# 求 k5 集合与 k6 集合的交集，即 k5 与 k6 都有的成员
>>> conn.sinter('k6', 'k5') 
set(['foo', 'bar']) 
# 求 k5 集合与 k6 集合的并集，即包含 k5 和 k6 中的全部成员
>>> conn.sunion('k6', 'k5') 
set(['app', 'foo', 'bar', 'zoo'])
```


```bash
# 检查 redis 中指定 name 的 key 是否存在
>>> conn.exists('k6') 
True 
# 查询符合匹配符（以 k 开头）的所有 key 
>>> conn.keys(pattern='k*') 
['k1', 'k4', 'k5', 'k3', 'k6', 'k2'] 
# 设置 name 为 k3 的键值对的过期时间为 3 秒
>>> conn.expire('k3', 3) 
True 
# 把 name 为 k1 的 key 重命名为 k11 
>>> conn.rename('k1', 'k11') 
True
# 查看 name 为 k5 的值类型
>>> conn.type('k5') 
'set'
```



### pymongo--读写MongoDB库

MongoDB是一个支持海量数据存储的文档数据库。

它与MySQL等关系型数据库不同，不需要提前设计表结构，可以文档的形式存储数据。

因此，MongoDB常常在一些特定业务场景中被选择使用，也会与关系型数据库结合一起作为数据存储服务。

Python中读写MongoDB最常用的库为pymongo，它提供了与原生MongoDB类似的操作流程和API，使得开发者可以快速地熟悉并上手开发程序。

pymongo库的安装命令如下：

```sh
pip install pymongo
```


```bash
>>> import pymongo 
# 创建一个 MongoDB 数据库的客户端连接对象
>>> client = pymongo.MongoClient("localhost", 27017) 
# 切换到 my_db 数据库
>>> db = client.my_db 
# 切换到 my_db 数据库下的 my_coll 集合
>>> db.my_coll 
Collection(Database(MongoClient(host=['localhost:27017'], document_class=dict, 
tz_aware=False, connect=True), u'my_db'), u'my_coll') 
# 在 my_db.my_coll 集合中插入一条文档数据
>>> db.my_coll.insert_one({"foo": "bar"}) 
<pymongo.results.InsertOneResult object at 0x7fa2f144c050> 
# 在 my_db.my_coll 集合中查询一条文档数据
>>> db.my_coll.find_one() 
{u'_id': ObjectId('603a56903ea0de7393f7f5c9'), u'foo': u'bar'}
```








```bash
# 插入单条数据
>>> db.my_coll.insert_one({'foo': 'zoo'}) 
<pymongo.results.InsertOneResult object at 0x7ff5571f35a0> 
# 插入多条数据
>>> db.my_coll.insert({'foo': 'bar'}, {'zoo': 'app'}) 
ObjectId('603b3a2c3ea0de0de3fd83ec') 
# 插入多条数据
>>> db.my_coll.insert_many([{'foo': 'bar'}, {'zoo': 'app'}])
<pymongo.results.InsertManyResult object at 0x7ff5571f37d0>
```





```bash
# 查询满足条件的单条结果
>>> db.my_coll.find_one({'foo': 'bar'}) 
{u'_id': ObjectId('603a56903ea0de7393f7f5c9'), u'foo': u'bar'} 
# 查询满足条件的全部结果
>>> db.my_coll.find({'foo': 'bar'}) 
<pymongo.cursor.Cursor object at 0x7ff5571f8f10>
```






```bash
>>> rows = db.my_coll.find({'foo': 'bar'}) 
>>> for r in rows: 
... r 
... 
{u'_id': ObjectId('603a56903ea0de7393f7f5c9'), u'foo': u'bar'} 
{u'_id': ObjectId('603b3a2c3ea0de0de3fd83ec'), u'foo': u'bar'} 
{u'_id': ObjectId('603b3a4f3ea0de0de3fd83ed'), u'foo': u'bar'}
```
```bash
>>> from bson.objectid import ObjectId 
>>> oid = '603a56903ea0de7393f7f5c9' 
>>> db.my_coll.find_one({'_id': ObjectId(oid)}) 
{u'_id': ObjectId('603a56903ea0de7393f7f5c9'), u'foo': u'bar'}
```




```bash
# 统计查询结果数量
>>> db.my_coll.find({'foo': 'bar'}).count() 
3 
# 对查询结果通过字典 foo 的内容进行升序排列
>>> db.my_coll.find({'foo': 'bar'}).sort('foo', pymongo.ASCENDING) 
<pymongo.cursor.Cursor object at 0x7ff5571f8f10> 
# 对查询结果进行偏移选择，等同于 MySQL 的 limit 1,1 
>>> db.my_coll.find({'foo': 'bar'}).sort('foo', pymongo.ASCENDING).skip(1).limit(1) 
<pymongo.cursor.Cursor object at 0x7ff55699a350>
```


```bash
>>> condition = {'foo': 'bar'} 
>>> new_value = {'foo': 'bar', 'name': 'python'} 
>>> db.my_coll.update(condition, new_value) 
{'updatedExisting': True, u'nModified': 1, u'ok': 1, u'n': 1}
```


```bash
>>> db.my_coll.update_one(condition, {'$set': new_value}) 
<pymongo.results.UpdateResult object at 0x7ff5571f3910>
```


```bash
>>> db.my_coll.insert_one({'name': 'java', 'age': 15}) 
<pymongo.results.InsertOneResult object at 0x7ff5569c16e0> 
# 查询 name 字段为 java 的数据，并将其 age 字段加 1 
>>> db.my_coll.update_one({'name': 'java'}, {'$inc': {'age': 1}}) 
<pymongo.results.UpdateResult object at 0x7ff5569c1640> 
>>> db.my_coll.find_one({'name': 'java'}) 
{u'age': 16, u'_id': ObjectId('603b4b3f3ea0de0de3fd83f3'), u'name': u'java'}
```


```bash
>>> for r in db.my_coll.find({'foo': 'bar'}): 
... r 
... 
{u'_id': ObjectId('603b3a2c3ea0de0de3fd83ec'), u'foo': u'bar', u'name': u'python'} 
{u'_id': ObjectId('603b3a4f3ea0de0de3fd83ed'), u'foo': u'bar', u'name': u'python'} 
>>> r = db.my_coll.update_many({'foo': 'bar'}, {'$set': {'name': 'java'}}) 
>>> r.matched_count
2 
>>> r.modified_count
2 
>>> for r in db.my_coll.find({'foo': 'bar'}): 
... r 
... 
{u'_id': ObjectId('603b3a2c3ea0de0de3fd83ec'), u'foo': u'bar', u'name': u'java'} 
{u'_id': ObjectId('603b3a4f3ea0de0de3fd83ed'), u'foo': u'bar', u'name': u'java'}
```


```bash
>>> db.my_coll.remove({'name': 'java'}) 
{u'ok': 1, u'n': 4}
```


```bash
>>> db.my_coll.delete_one({'foo': 'bar'})
<pymongo.results.DeleteResult object at 0x7ff5569c1780> 
>>> db.my_coll.delete_many({'foo': 'bar'}) 
<pymongo.results.DeleteResult object at 0x7ff5569c1640>
```


## Web相关库


### requests--HTTP网络请求库

requests作为一个专门为“人类”编写的HTTP请求库，其易用性很强，因此在推出之后就迅速成为Python中首选的HTTP请求库。

requests库的最大特点是提供了简单易用的API，让编程人员可以轻松地提高效率。由于 requests 不是 Python 的标准库，因此在使用之前需要进行安装：

```sh
pip install requests
```

#### 1.HTTP请求

通过requests可以完成各种类型的HTTP请求，包括HTTP、HTTPS、HTTP1.0、HTTP1.1及各种请求方法。requests库支持的HTTP方法[1]如下。

- get——发送一个GET请求，用于请求页面信息。
- options——发送一个OPTIONS请求，用于检查服务器端相关信息。
- head——发送一个HEAD请求，类似于GET请求，但只请求页面的响应头信息。
- post——发送一个POST请求，通过body向指定资源提交用户数据。
- put——发送一个PUT请求，向指定资源上传最新内容。
- patch——发送一个PATCH请求，同PUT类似，可以用于部分内容更新。
- delete——发送一个DELETE请求，向指定资源发送一个删除请求。

可以看到，requests使用与HTTP请求方法同名的API来提供相应的HTTP请求服务，从而降低了编程人员的学习和记忆成本。

另外，这些API方法都调用同一个基础方法，因此在调用参数的使用上也基本保持一致。


先来看一个GET请求示例：

```bash
>>> import requests 
>>> r = requests.get('http://httpbin.org/get') 
>>> r.status_code
```



当然也可以附加URL参数来发送一个带参数的GET请求。具体示例如下：

```bash
# 直接在 URL 路径后面追加
>>> r = requests.get('http://httpbin.org/get?name=python&age=14')
# 通过 params 参数设置
>>> params = {'name': 'python', 'age': 14} 
>>> r = requests.get('http://httpbin.org/get', params= params)
```



与GET不同的是，POST一般会通过HTTP的body来发送请求数据。这样设计的好处是支持更多类型和更多内容的请求数据。具体而言，POST请求支持的请求数据类型如下。

1. 纯文本--任意格式的普通字符串。
2. 二进制--二进制字符串，例如文件二进制内容。
3. x-www-form-urlencoded--键值对参数形式，一种特定格式的纯文本内容。
4. multipart/form-data--同时支持二进制和键值对形式的数据格式。




```bash
>>> data = "hello python" 
>>> r = requests.post('http://httpbin.org/post', data=data) 
>>> r.status_code
```


```bash
# 下面数据对应的键值对内容为：name=python&age=14 
>>> data = {'name': 'python', 'age': 14} 
>>> r = requests.post('http://httpbin.org/post', data=data) 
>>> r.status_code
```


```bash
>>> data = {'name': 'python', 'age': 14} 
>>> files = {'file1': open('/path/to/test.xls', 'rb'), 'file2': 
open('/path/to/test.png', 'rb')} 
# 请求时指定了 files 参数，就会以 multipart/form-data 形式发送数据
>>> r = requests.post('http://httpbin.org/post', data=data, files=files) 
>>> r.status_code
```


```bash
# 与 GET 相同的传参方式
>>> r = requests.delete('http://httpbin.org/delete') 
>>> r = requests.head('http://httpbin.org/get') 
>>> r = requests.options('http://httpbin.org/get') 
# 与 POST 相同的传参方式
>>> r = requests.put('http://httpbin.org/put', data = {'key':'value'}) 
>>> r = requests.patch('http://httpbin.org/patch', data = {'key':'value'})
```


```bash
>>> import json 
>>> url = 'https://api.github.com/some/endpoint' 
>>> data = json.dumps({'name': 'python'})
>>> headers = {'Content-Type': 'application/json'} 
>>> r = requests.post(url, data=data, headers=headers)
```


```bash
>>> url = 'https://api.github.com/some/endpoint' 
>>> r = requests.post(url, json={'name': 'python'})
```


```bash
>>> url = 'http://httpbin.org/cookies' 
>>> cookies = {'cookie_name': 'cookie_value'} 
>>> r = requests.get(url, cookies=cookies)
```

#### 2.HTTP 响应

```bash
>>> r = requests.get('http://httpbin.org/get') 
>>> r 
<Response [200]> 
>>> r.status_code # 响应状态码
200 
>>> r.reason # 响应状态信息
'OK'
```


```bash
>>> r.headers # 响应头信息
{'Date': 'Sat, 06 Jun 2020 08:27:48 GMT', 'Content-Type': 'application/json', 
'Content-Length': '308', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 
'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true'} 
>>> r.cookies # 响应 cookie 
<RequestsCookieJar[]>
```



```bash
>>> r = requests.get('http://www.testqa.cn/static/testqa2.png') 
>>> with open('test.png', 'wb') as f: # 下载图片并保存在本地
... f.write(r.content) 
... 
179543
```



```bash
>>> r = requests.get('http://httpbin.org/get') 
>>> r.text # 获取 unicode 形式的响应体内容
'{\n "args": {}, \n "headers": {\n "Accept": "*/*", \n "Accept-Encoding": "gzip, 
deflate", \n "Host": "httpbin.org", \n "User-Agent": "python-requests/2.20.0", \n 
"X-Amzn-Trace-Id": "Root=1-5edb57b9-0fd017fb754da1d82cabcc00"\n }, \n "origin": 
"221.218.139.172", \n "url": "http://httpbin.org/get"\n}\n'
```


```bash
>>> r = requests.get('http://httpbin.org/get') 
>>> r.encoding = 'utf-8' # 设置编码格式
>>> r.text
```


如果请求返回的内容是标准的JSON格式，除了通过unicode形式获取响应体外，还可以通过json方法获取对应的反序列化对象。具体示例如下：

```bash
>>> r = requests.get('http://httpbin.org/get') 
>>> r.json()      # 获取 unicode 内容的 JSON 反序列化对象
{'args': {}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 
'httpbin.org', 'User-Agent': 'python-requests/2.20.0', 'X-Amzn-Trace-Id': 
'Root=1-5edb57b9-0fd017fb754da1d82cabcc00'}, 'origin': '221.218.139.172', 'url': 
'http://httpbin.org/get'}
```


除了获取常规的响应内容之外，Response对象还提供了一个history的属性，用于查询当前请求的重定向历史记录。这个记录对于调试问题很有帮助，具体示例如下：

```bash
>>> r = requests.get('http://github.com') 
>>> r.url 
'https://github.com/' 
>>> r.history 
[<Response [301]>]
```



### Flask Web框架


#### 请求路由

```python
@app.route('/') 
@app.route('/hello) 
def hello_world(): 
    return "Hello World！"
```
```python
@app.route('/hello/<string:name>') 
def hello_world(name): 
    return f"hello {name}"
```

#### 请求处理

```python
from flask import Flask, request
 
app = Flask(__name__)
 
@app.route('/', methods=['GET', 'POST']) 
def parse(): 
    get_args = request.args # 类字典对象
    form_data = request.form # 类字典对象 
    raw_data = request.data # 字符串或二进制
    json_data = request.json # JSON 反序列化对象
    files = request.files # 类字典对象
    
    return 'success'
```
```python
# curl http://127.0.0.1:5000/?name=python 
@app.route('/', methods=['GET']) 
def args_example(): 
    get_args = request.args # 获取 GET 请求参数对象
    name = get_args.get('name') # 获取 name 参数的值
    return name
     
# curl http://127.0.0.1:5000/json -X POST -d '{"name":"python"}' -H "ContentType:application/json" 
@app.route('/json', methods=['POST']) 
def json_example(): 
    json_data = request.json # 获取 JSON 数据
    name = json_data.get('name') 
    return name 
    
# curl http://127.0.0.1:5000/file -F "upload=@test.json" 
@app.route('/file', methods=['POST'])
def files_example(): 
    files = request.files # 获取文件参数对象
    upload_file = files.get('upload') # 获取字段为 upload 的文件对象
    upload_file.save('new_test.txt') # 保存文件到指定文件名
    return 'success'
```



```python
@app.route('/', methods=['GET']) 
def hello_world(): 
    return "hello world!"
```


```python
@app.route('/', methods=['GET']) 
def hello_world(): 
    return "Hello World!", 201, {"Content-Type": "text/plain"}
```



```python
from flask import Flask, jsonify
app = Flask(__name__) 

@app.route('/', methods=['GET']) 
def hello_world(): 
    return jsonify({"name": "python"})
```



```python
@app.route('/', methods=['GET']) 
def hello_world(): 
    return "<h1>Hello World!</h1>"
```


```python
@app.route('/', methods=['GET']) 
def hello_world(): 
    return open('test.html', 'r', encoding='utf-8').read()
```



#### Flask 开发 RESTful 服务

##### RESTful定义
RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。

##### RESTFUL特点
1. 每一个URI代表1种资源；
1. 客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；
1. 通过操作资源的表现形式来操作资源；
1. 资源的表现形式是XML或者HTML；
1. 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。

##### Flask RESTful框架
基于`Flask`开发`RESTful`的框架`Flask-RESTful`。官网地址[http://www.pythondoc.com/Flask-RESTful/index.html](http://www.pythondoc.com/Flask-RESTful/index.html)

##### 安装
```bash
pip install flask-restful
```

##### 简单样例
```python
from flask import Flask
import flask_restful as restful

app = Flask(__name__)
api = restful.Api(app)

class HelloWorld(restful.Resource):
    def get(self):
        return {'hello': 'world'}

api.add_resource(HelloWorld, '/')

if __name__ == '__main__':
    app.run(debug=True)
```



##### 完整样例
```python
from flask import Flask
from flask_restful import reqparse, abort, Api, Resource, fields, marshal_with

app = Flask(__name__)
api = Api(app)


TODOS = {
    'todo1': {'task': 'build an API', "name": "xxx"},
    'todo2': {'task': '?????'},
    'todo3': {'task': 'profit!'},
}


def abort_if_todo_doesnt_exist(todo_id):
    if todo_id not in TODOS:
        abort(404, message="Todo {} doesn't exist".format(todo_id))


parser = reqparse.RequestParser()
parser.add_argument('task', type=str, required=True, help="task field")


resource_fields = {
    'name':   fields.String
}


class Todo(Resource):
    @marshal_with(resource_fields)
    def get(self, todo_id):
        abort_if_todo_doesnt_exist(todo_id)
        return TODOS[todo_id]

    def delete(self, todo_id):
        abort_if_todo_doesnt_exist(todo_id)
        del TODOS[todo_id]
        return '', 204

    def put(self, todo_id):
        args = parser.parse_args()
        task = {'task': args['task']}
        TODOS[todo_id] = task
        return task, 201


class TodoList(Resource):
    def get(self):
        return TODOS

    def post(self):
        args = parser.parse_args()
        todo_id = int(max(TODOS.keys()).lstrip('todo')) + 1
        todo_id = 'todo%i' % todo_id
        TODOS[todo_id] = {'task': args['task']}
        return TODOS[todo_id], 201


api.add_resource(TodoList, '/todos')
api.add_resource(Todo, '/todos/<todo_id>')


if __name__ == '__main__':
    app.run(debug=True)
```
