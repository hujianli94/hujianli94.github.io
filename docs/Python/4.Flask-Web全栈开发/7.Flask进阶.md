# 7.Flask进阶


## 7.1 类视图

之前我们接触的视图都是函数，所以一般简称视图函数。

其实视图也可以基于类来实现，类视图的好处是支持继承，但是类视图不能跟函数视图一样，写完类视图还需要通过`app.add_url_rule(url_rule,view_func)`来进行注册。


以下将对两种类视图进行讲解：


### 7.1.1 标准类视图

标准视图继承自`flask.views.View`，并且在子类中必须实现`dispatch_request`方法，这个方法类似于视图函数，也要返回一个基于Response或者其子类的对象。

以下将用一个例子进行讲解：


```python
from flask import Flask, render_template,request
from flask.views import View

app = Flask(__name__)
app.config['SECRET_KEY'] = 'VhU1YZFArUAAmBwE6s8j4QE2iK9IFCPGx'


@app.route('/')
def hello_world():
    return 'Hello World!'


class BaseView(View):
    # 自定义方法，用来获取模板路径
    def get_template_name(self):
        raise NotImplementedError()

    # 必须实现的方法，用来处理请求的
    def dispatch_request(self):
        if request.method != 'GET':
            return 'method error'
        # 这里从self.get_data()中获取数据，子类应该实现这个方法
        context = {'data': self.get_data()}
        return render_template(self.get_template_name(), **context)


class UserView(BaseView):
    # 实现从父类继承的获取模板路径的方法
    def get_template_name(self):
        return 'user.html'

    # 重写获取数据的方法
    def get_data(self):
        return [{
            'username': 'hujianli',
            'avatar': 'https://hujianli94.github.io/assets/images/logo.png'
        }]


# 类视图通过add_url_rule方法和url做映射
app.add_url_rule('/users/', view_func=UserView.as_view('userview'))

if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0", port=5000)

```

`user.html`模板如下

```html
<!DOCTYPE html>
<html>
<head>
    <title>User List</title>
</head>
<body>
<h1>User List</h1>
<ul>
    {% for user in data %}
        <li>
            <strong>Username:</strong> {{ user['username'] }}<br>
            <strong>Avatar:</strong> <img src="{{ user['avatar'] }}" alt="Avatar">
        </li>
    {% endfor %}
</ul>
</body>
</html>
```

-  GET http://localhost:5000/users


```shell
# curl -X GET --location "http://localhost:5000/users" -H "Accept: application/json"
```


### 7.1.2 基于调度方法的视图

Flask还为我们提供了另外一种类视图`flask.views.MethodView`，对每个HTTP方法执行不同的函数（映射到对应方法的小写的同名方法上），

这对`RESTful API`尤其有用，以下将用一个例子来进行讲解：


```python
from flask import Flask, jsonify
from flask.views import MethodView

app = Flask(__name__)
app.config['SECRET_KEY'] = 'VhU1YZFArUAAmBwE6s8j4QE2iK9IFCPGx'


@app.route('/')
def hello_world():
    return 'Hello World!'


class UserAPI(MethodView):
    # 当客户端通过get方法进行访问的时候执行的函数
    def get(self):
        return jsonify({
            'username': 'hujianli',
            'avatar': 'https://hujianli94.github.io/assets/images/logo.png'
        })

    # 当客户端通过post方法进行访问的时候执行的函数
    def post(self):
        return 'UNSUPPORTED!'

    # 当客户端通过put方法进行访问的时候执行的函数
    def put(self):
        # 添加你希望执行的操作
        return 'PUT method called'

    # 当客户端通过delete方法进行访问的时候执行的函数
    def delete(self):
        # 添加你希望执行的操作
        return 'DELETE method called'


# 通过add_url_rule添加类视图和url的映射，并且在as_view方法中指定该url的名称，方便url_for函数调用
app.add_url_rule('/myuser/', view_func=UserAPI.as_view('userapiview'))

if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0", port=5000)

```


- GET http://localhost:5000/myuser

```json
{
  "avatar": "https://hujianli94.github.io/assets/images/logo.png",
  "username": "hujianli"
}
```


- POST http://localhost:5000/myuser

```json
UNSUPPORTED!
```




### 7.1.3 方法限制


在函数视图中，通过`@app.route`的`methods`参数即可限制请求的方法。

类视图则通过定义methods类属性实现限制请求的功能，示例代码如下。

```python
class MyView(View):
    methods = ['GET', 'POST']
    def dispatch_request(self):
        if request.method == 'POST':
      #      ...
      #  ...
app.add_url_rule('/myview', view_func=MyView.as_view('myview'))
```



### 7.1.4 添加装饰器

用类视图的一个缺陷就是比较难用装饰器来装饰，比如有时候需要做权限验证的时候，比如看以下例子：

```python
def user_required(f):
    def decorator(*args,**kwargs):
        if not g.user:
            return 'auth failure'
        return f(*args,**kwargs)
    return decorator
```

如果要在类视图上进行装饰，只能在as_view函数上进行装饰了，使用方式如下：

```python
view = user_required(UserAPI.as_view('users'))
app.add_url_rule('/users/',view_func=view)
```


从Flask 0.8开始，还可以通过在类中添加decorators属性来实现对视图的装饰：

```python
class UserAPI(MethodView):
    decorators = [user_required]
```



## 7.2 蓝图


现在所有的视图函数都是写在app.py文件中，随着项目越来越复杂，这种写法会导致app.py文件越来越臃肿，大幅地提高了后期项目维护的成本。


对于一个商业项目而言，我们应该把代码进行模块化，蓝图就是为此而生的。

我们以豆瓣网为例，豆瓣网目前有几个模块，分别为读书、电影、音乐、同城、小组、阅读等。

每个模块都可以用一个蓝图来实现，最终在app中统一注册所有的蓝图，可以让项目结构更加清晰有序。

下面对蓝图的使用进行讲解。



### 7.2.1 基本使用


当项目越来越大的时候，Python 项目使用包(package)来管理代码，把代码分为不同的模块，然后在需要的地方导入模块。

项目名称叫xuexi_flask，布局如下：


```shell
D:\demo\xuexi_flask
├── apps/
│   ├── __init__.py
│   ├── auth.py
│   ├── blog.py
│   ├── pay.py
├── templates/
│   ├── base.html
│   ├── auth/
│   │   ├── login.html
│   │   └── register.html
│   └── blog/
│       ├── create.html
└── static/
│       └── my.css
│       └── my.js
├── tests/
│   ├── test_auth.py
│   └── test_blog.py
│   └── test_pay.py
├── venv/
├── app.py
```


### 7.2.2 初始化app

在apps目录 `__init__.py` 有两个作用：一是包含应用工厂；二是 告诉 Python apps文件夹应当视作为一个包。

`apps/__init__.py`


```python
import os

from flask import Flask


def create_app(test_config=None):
    # create and configure the app
    
    # __name__是当前Python模块的名称。应用需要知道在哪里设置路径，使用__name__是一个方便的方法。
    # instance_relative_config = True; 告诉应用配置文件是相对于
    # instance folder的相对路径。实例文件夹在 apps 包的外面，用于存放本地数据（例如配置密钥和数据库），不应当提交到版本控制系统。
    app = Flask(__name__, instance_relative_config=True)

    # 设置一个应用的缺省配置
    app.config.from_mapping(
        # SECRET_KEY 是被 Flask 和扩展用于保证数据安全的。在开发过程中， 为了方便可以设置为 'dev' ，但是在发布的时候应当使用一个随机值来 重载它。
        SECRET_KEY='dev',
        # DATABASE SQLite 数据库文件存放在路径。它位于 Flask 用于存放实例的 app.instance_path 之内。
        DATABASE=os.path.join(app.instance_path, 'apps.sqlite'),
    )

    if test_config is None:
        # 使用 config.py 中的值来重载缺省配置，如果 config.py 存在的话。 例如，当正式部署的时候，用于设置一个正式的 SECRET_KEY
        app.config.from_pyfile('config.py', silent=True)
    else:
        # load the test config if passed in
        app.config.from_mapping(test_config)

    # ensure the instance folder exists
    try:
        # Flask不会自动创建实例文件夹，但是必须确保创建这个文件夹，因为 SQLite 数据库文件会被保存在里面。
        os.makedirs(app.instance_path)
    except OSError:
        pass

    return app
```

启动应用

`app.py`

```python
from apps import create_app

app = create_app()


@app.route('/hello')
def hello():
    return 'Hello, World!'


if __name__ == '__main__':
    app.run()
```


直接运行 app.py 文件就可以启动项目了

```
 * Serving Flask app 'apps'
 * Debug mode: off
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
```

访问`http://127.0.0.1:5000/hello `会出现 'hello world'



### 7.2.3 设计蓝图

如果一个项目有多个app, 或者分成多个模块的时候，比如apps下有auth.py blog.py pay.py 三个文件，这每个文件里面都可以写视图函数，那么就需要统一管理视图。


Blueprint 是一种组织一组相关视图及其他代码的方式。与把视图及其他 代码直接注册到应用的方式不同，蓝图方式是把它们注册到蓝图，然后在 工厂函数中 把蓝图注册到应用。

`apps/auth.py`


```python
from flask import (
    Blueprint, flash, g, redirect, render_template, request, session, url_for
)

# 定义蓝图对象bp
# 第一个参数：蓝图的名称
# 第二个参数：该蓝图所在的模块名称
# 第三个参数：指定页面的URL前缀
bp = Blueprint('auth', __name__, url_prefix='/auth')


@bp.route('/register', methods=('GET', 'POST'))
def register():
    return "注册视图...."
```


`apps/blog.py`

```python
from flask import (
    Blueprint, flash, g, redirect, render_template, request, session, url_for
)

bp = Blueprint('blog', __name__, url_prefix='/blog')


@bp.route('/edit', methods=('GET', 'POST'))
def edit_blog():
    return "编辑视图...."
```


###  7.2.4 注册蓝图

那么需要在 `apps/__init__.py` 中使用 `app.register_blueprint()` 导入并注册 蓝图，新的代码放在工厂函数的尾部返回应用之前。


```python
def create_app(test_config=None):
    # .....

    # 注册蓝图
    from . import auth
    from . import blog
    app.register_blueprint(auth.bp)
    app.register_blueprint(blog.bp)

    return app

```



那么访问的时候加上前缀'/auth'或'/blog',就可以访问了如下

- 访问auth的路由：  `http://127.0.0.1:5000/auth/register`

- 访问blog的路由：  `http://127.0.0.1:5000/blog/edit`




!!! abstract  "参考文献"

  [项目设计与蓝图的使用](https://www.cnblogs.com/yoyoketang/p/16624854.html)
