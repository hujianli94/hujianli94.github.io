# 4.Jinja2模板


在实际网站开发中，为了让网页更加美观，需要渲染一个有富文本标签的页面，通常包含大量的HTML代码，如果把这些HTML代码用字符串的形式写在视图函数中，后期的代码维护将变成一场噩梦。


因此，在Flask中，渲染HTML通常会交给模板引擎来实现，而Flask中默认配套的模板引擎是Jinja2，Jinja2是一个高效、可扩展的模板引擎。


Jinja2可以独立于Flask使用，如被Django使用。Jinja2目前最新版本是3.0.2，请参考[官方文档](https://jinja.palletsprojects.com/en/3.0.x/)



## 4.1 模板的基本使用


### 4.1.1 渲染模板

在使用PyCharm Professional版创建完一个Flask项目后，默认会生成一个templates文件夹，如果没有修改模板查找路径，默认会在这个文件夹下寻找模板文件。

模板文件可以是任意纯文本格式的文件，如TXT、HTML、XML等，但是为了让项目更规范，也为了与前端开发者更无缝地协作，一般都是用HTML文件来写模板代码。


首先在templates文件夹下创建index.html文件，然后输入以下代码。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>首页</title>
</head>
<body>
<h1>这是首页</h1>
</body>
</html>
```


接下来在视图函数中使用render_template函数渲染index.html模板。在app.py中，将原来的hello_world视图函数修改为以下代码。


```python
from flask import Flask, render_template

app = Flask(__name__)


@app.route('/')
def index():
    return render_template("index.html")


if __name__ == '__main__':
    app.run()
```

render_template 默认会从当前项目的templates文件夹下寻找index.html文件，读取后进行解析，再渲染成HTML代码返回给浏览器。在浏览器中访问 http://127.0.0.1:5000


如果想修改模板文件的查找地址，可以在创建app时，给Flask类传递一个关键字参数template_folder指定具体路径，示例代码如下。

```python
from flask import Flask, render_template

app = Flask(__name__, template_folder=r"/data/coder/flaskProject/templates/")


@app.route('/')
def hello_world():
    return render_template('index.html')


if __name__ == '__main__':
    app.run()
```


### 4.1.2 渲染变量



```python
from flask import Flask, render_template

app = Flask(__name__)


@app.route("/variable")
def variable():
    hobby = "游戏"
    return render_template("variable.html", hobby=hobby)


if __name__ == '__main__':
    app.run()
```
除模板名称外，还给render_template传递了一个hobby关键字参数，后续在模板中就可以使用这个变量了。


现在再在templates文件夹下创建一个variable.html模板文件（注意：要记得先删掉template_folder参数），然后输入以下代码。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>变量使用</title>
</head>
<body>
<h1>我的兴趣爱好是：{{ hobby }}</h1>
</body>
</html>
```

从以上代码中可以看到，把变量放到两对花括号中即可使用变量。项目运行起来后，在浏览器中访问 http://127.0.0.1:5000/variable



字典的键和对象的属性在模板中都可以通过点(.)的形式访问。在variable这个视图函数中添加两个新的变量，分别是字典类型的person，以及类对象类型的user。示例代码如下。

```python
from flask import Flask, render_template

app = Flask(__name__)


class User:
    def __init__(self, username, email):
        self.username = username
        self.email = email


@app.route("/variable")
def variable():
    hobby = "游戏"
    person = {
        "name": "张三",
        "age": 18
    }
    user = User("李四", "xx@qq.com")
    return render_template("variable.html", hobby=hobby, person=person, user=user)


if __name__ == '__main__':
    app.run()

```

接下来，再在variable.html模板中通过点(.)的形式访问person的键和user属性。代码如下。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>变量使用</title>
</head>
<body>
<h1>我的兴趣爱好是：{{ hobby }}</h1>
<p>person的姓名是：{{ person.name }}，person的年龄是：{{ person.age }}</p>
<p>user的用户名是：{{ user.username }}，user的邮箱是：{{ user.email }}</p>
<p>user的用户名是：{{ user['username'] }}，user的邮箱是：{{ user['email'] }}</p>
</body>
</html>
```


字典键和对象的属性也都可以通过中括号的形式获取，如以下代码实际上是等价的。


```shell
    {{ user.username }}
    {{ user["username"] }}
```


(1)在模板中有一个变量的使用方式为foo.bar，那么在Jinja2中则按以下方式进行访问。

- 通过`getattr(foo, 'bar')`访问，先访问这个对象的属性。
- 如果没有找到，就通过`foo.__getitem__("bar")`方式访问，即访问这个对象的键。
- 如果以上两种方式都没有找到，返回一个undefined对象。


(2)在模板中有一个变量的使用方式为`foo["bar"]`，那么在Jinja2中则按以下方式进行访问。

- 通过`foo.__getitem__("bar")`方式访问，即先访问这个对象的键。
- 如果没有找到，就通过`getattr(foo, "bar")`方式访问，即访问这个对象的属性。
- 如果以上都没找到，则返回一个undefined对象。



以上案例中，传递了3个变量到模板中，在变量比较多的情况，首先可以把所有的变量存放到字典中，

然后在给`render_template`传递参数时使用**语法，将字典变成关键字参数，以上的variable视图函数代码可以改写为以下形式。


```python
from flask import Flask, render_template

app = Flask(__name__)


class User:
    def __init__(self, username, email):
        self.username = username
        self.email = email


@app.route("/variable")
def variable():
    hobby = "游戏"
    person = {
        "name": "张三",
        "age": 18
    }
    user = User("李四", "xx@qq.com")
    context = {
        "hobby": hobby,
        "person": person,
        "user": user
    }
    return render_template("variable.html", **context)


if __name__ == '__main__':
    app.run()
```

以上代码的写法更加直观和简洁，在遇到需要传给模板的变量比较多的情况，都推荐使用这种方式。



## 4.2 过滤器和测试器


### 4.2.1 自定义过滤器

过滤器本质上是Python的函数，它会把被过滤的值当作第1个参数传给这个函数，函数经过一些逻辑处理后，再返回新的值。

过滤器函数写好后可以通过`@app.template_filter`装饰器或者`app.add_template_filter`函数把函数注册成Jinja2能用的过滤器。

这里以注册一个时间格式化的过滤器为例，来说明自定义过滤器的方法，示例代码如下。


```python
def datetime_format(value, format="%Y-%d-%m %H:%M"):
    return value.strftime(format)
app.add_template_filter(datetime_format,"dformat")
```


在模板文件中，就可以按如下方式使用了。

```html
    {{ article.pub_date|dformat }}
    {{ article.pub_date|dformat("%B %Y") }}
```

如果`app.add_template_filter`没有传第2个参数，那么默认将使用函数的名称作为过滤器的名称。如以上注册过滤器代码可以改成以下代码。

```python
app.add_template_filter(datetime_format)
```

在模板中则按以下方式使用。

```html
    {{ article.pub_date|datetime_format }}
    ...
```


当然，也可以通过`@app.template_filter`装饰器在函数定义时，就将它注册成过滤器。如以上的datetime_format函数，可以改写为如下形式。

```python
@app.template_filter("dformat")
def datetime_format(value, format="%Y-%d-%m %H:%M"):
    return value.strftime(format)
```

datetime_format被@app.template_filter装饰后，就会自动被注册进Jinja2的过滤器中，并且`@app.template_filter`中的参数即为自定义过滤器的名称，如果不传参数，也会自动使用函数名称作为过滤器的名称。


### 4.2.2 Jinja2内置过滤器


学习Jinja2中内置过滤器，读者无须全部记住这些过滤器，只需在使用的时候翻阅本书或者

阅读[Jinja2官方文档](https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters)即可，用的次数多了自然会记住。



常用过滤器

|过滤器|说明|
|-----|-----|
|abs(value)|获取value的绝对值。|
|default(value,default_value,boolean=False)|如果value没有定义，则返回第2个参数default_value。|
|first(value)|返回一个序列的第一个元素。|
|last(value)|返回一个序列的最后一个元素。示例：names|last。|
|length(value)|返回一个序列或者字典的长度。示例：names|length。|
|join(value,d=u'')|将一个序列用d这个参数的值拼接成字符串。|
|safe(value)|如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例：content_html|safe。|
|int(value)|将值转换为int类型。|
|float(value)|将值转换为float类型。|
|lower(value)|将字符串转换为小写。|
|capitalize|把值的首字母转换成大写，其他字母转换成小写。|
|upper(value)|将字符串转换为小写。|
|title|把值中每个单词的首字母都转换成大写。|
|replace(value,old,new)| 替换将old替换为new的字符串。|
|truncate(value,length=255,killwords=False)|截取length长度的字符串。|
|striptags(value)|删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格。|
|trim|截取字符串前面和后面的空白字符。|
|string(value)|将变量转换成字符串。|
|wordcount(s)|计算一个长字符串中单词的个数。|



!!!tip "更多参考"

    [Jinja2 模板过滤器的使用参考](https://www.imooc.com/wiki/flasklesson/jinja2filter.html)




### 4.2.3 测试器

测试器用来测试某些元素是否满足某个条件，如测试一个变量是否是字符串、测试一个变量能否被调用等。

以下代码通过演示defined测试器，来讲解测试器的使用。

```html
    {% if user is defined %}
       user定义了 : {{ user }}
    {% else %}
        user没有定义
    {% endif %}
```


Jinja2还提供了如下的测试器

|名称|	功能|
|----|-----|
|defined|	变量是否已经定义|
|boolean|	变量的类型是否是 boolean|
|integer|	变量的类型是否是 integer|
|float|	变量的类型是否是 float|
|string|	变量是否是 string|
|mapping|	变量的类型是否是字典|
|sequence|	变量的类型是否是序列|
|even|	变量是否是偶数|
|odd|	变量是否是奇数|
|lower|	变量是否是小写|
|upper|	变量是否是大写|



可先简单阅读，无须强记，在需要使用时再翻阅[Jinja2内置测试器的官方文档](https://jinja.palletsprojects.com/en/3.0.x/templates/#list-of-builtin-tests)即可。


## 4.3 控制语句



### 4.3.1 if判断语句

jinja2 模板中，使用 {% 和 %} 包围的语法块称为语句，jinja2 支持类似于 Python 的 if-else 判断语句，语法如下：

语法

```
{% if cond %}
{% else %}
{% endif %}
```


仔细阅读if.html模板代码可以发现，在if语句结束后，需要添加endif关闭if代码块，这跟Python中的用法是有点不同。



### 4.3.2 for循环语句


jinja2 模板中，使用 {% 和 %} 包围的语法块称为语句，jinja2 支持类似于 Python 的 for 循环语句，语法如下：


语法

```
{% for item in iterable %}
{% endfor %}
```


```
<h1>Members</h1>
<ul>
{% for user in users %}
  <li>{{ user }}</li>
{% endfor %}
</ul>
```



主要通过flask做前后端分离项目，jinja2这块知识使用的时候到如下地址进行查询即可，不做扩展。


[Flask 的 jinja2 模板](https://www.imooc.com/wiki/flasklesson/flaskjinja2.html)


[官方 Jinja2 模板文档](https://jinja.palletsprojects.com/templates/)
