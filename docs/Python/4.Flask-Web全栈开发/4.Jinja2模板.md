# 4.Jinja2模板


在实际网站开发中，为了让网页更加美观，需要渲染一个有富文本标签的页面，通常包含大量的HTML代码，如果把这些HTML代码用字符串的形式写在视图函数中，后期的代码维护将变成一场噩梦。


因此，在Flask中，渲染HTML通常会交给模板引擎来实现，而Flask中默认配套的模板引擎是Jinja2，Jinja2是一个高效、可扩展的模板引擎。


Jinja2可以独立于Flask使用，如被Django使用。Jinja2目前最新版本是3.0.2，请参考[官方文档](https://jinja.palletsprojects.com/en/3.0.x/)



## 4.1 模板的基本使用


### 4.1.1 渲染模板

在使用PyCharm Professional版创建完一个Flask项目后，默认会生成一个templates文件夹，如果没有修改模板查找路径，默认会在这个文件夹下寻找模板文件。

模板文件可以是任意纯文本格式的文件，如TXT、HTML、XML等，但是为了让项目更规范，也为了与前端开发者更无缝地协作，一般都是用HTML文件来写模板代码。


首先在templates文件夹下创建index.html文件，然后输入以下代码。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>首页</title>
</head>
<body>
<h1>这是首页</h1>
</body>
</html>
```


接下来在视图函数中使用render_template函数渲染index.html模板。在app.py中，将原来的hello_world视图函数修改为以下代码。


```python
from flask import Flask, render_template

app = Flask(__name__)


@app.route('/')
def index():
    return render_template("index.html")


if __name__ == '__main__':
    app.run()
```

render_template 默认会从当前项目的templates文件夹下寻找index.html文件，读取后进行解析，再渲染成HTML代码返回给浏览器。在浏览器中访问 http://127.0.0.1:5000


如果想修改模板文件的查找地址，可以在创建app时，给Flask类传递一个关键字参数template_folder指定具体路径，示例代码如下。

```python
from flask import Flask, render_template

app = Flask(__name__, template_folder=r"/data/coder/flaskProject/templates/")


@app.route('/')
def hello_world():
    return render_template('index.html')


if __name__ == '__main__':
    app.run()
```


### 4.1.2 渲染变量



```python
from flask import Flask, render_template

app = Flask(__name__)


@app.route("/variable")
def variable():
    hobby = "游戏"
    return render_template("variable.html", hobby=hobby)


if __name__ == '__main__':
    app.run()
```
除模板名称外，还给render_template传递了一个hobby关键字参数，后续在模板中就可以使用这个变量了。


现在再在templates文件夹下创建一个variable.html模板文件（注意：要记得先删掉template_folder参数），然后输入以下代码。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>变量使用</title>
</head>
<body>
<h1>我的兴趣爱好是：{{ hobby }}</h1>
</body>
</html>
```

从以上代码中可以看到，把变量放到两对花括号中即可使用变量。项目运行起来后，在浏览器中访问 http://127.0.0.1:5000/variable



字典的键和对象的属性在模板中都可以通过点(.)的形式访问。在variable这个视图函数中添加两个新的变量，分别是字典类型的person，以及类对象类型的user。示例代码如下。

```python
from flask import Flask, render_template

app = Flask(__name__)


class User:
    def __init__(self, username, email):
        self.username = username
        self.email = email


@app.route("/variable")
def variable():
    hobby = "游戏"
    person = {
        "name": "张三",
        "age": 18
    }
    user = User("李四", "xx@qq.com")
    return render_template("variable.html", hobby=hobby, person=person, user=user)


if __name__ == '__main__':
    app.run()

```

接下来，再在variable.html模板中通过点(.)的形式访问person的键和user属性。代码如下。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>变量使用</title>
</head>
<body>
<h1>我的兴趣爱好是：{{ hobby }}</h1>
<p>person的姓名是：{{ person.name }}，person的年龄是：{{ person.age }}</p>
<p>user的用户名是：{{ user.username }}，user的邮箱是：{{ user.email }}</p>
<p>user的用户名是：{{ user['username'] }}，user的邮箱是：{{ user['email'] }}</p>
</body>
</html>
```


字典键和对象的属性也都可以通过中括号的形式获取，如以下代码实际上是等价的。


```shell
    {{ user.username }}
    {{ user["username"] }}
```


(1)在模板中有一个变量的使用方式为foo.bar，那么在Jinja2中则按以下方式进行访问。

- 通过`getattr(foo, 'bar')`访问，先访问这个对象的属性。
- 如果没有找到，就通过`foo.__getitem__("bar")`方式访问，即访问这个对象的键。
- 如果以上两种方式都没有找到，返回一个undefined对象。


(2)在模板中有一个变量的使用方式为`foo["bar"]`，那么在Jinja2中则按以下方式进行访问。

- 通过`foo.__getitem__("bar")`方式访问，即先访问这个对象的键。
- 如果没有找到，就通过`getattr(foo, "bar")`方式访问，即访问这个对象的属性。
- 如果以上都没找到，则返回一个undefined对象。



以上案例中，传递了3个变量到模板中，在变量比较多的情况，首先可以把所有的变量存放到字典中，

然后在给`render_template`传递参数时使用**语法，将字典变成关键字参数，以上的variable视图函数代码可以改写为以下形式。


```python
from flask import Flask, render_template

app = Flask(__name__)


class User:
    def __init__(self, username, email):
        self.username = username
        self.email = email


@app.route("/variable")
def variable():
    hobby = "游戏"
    person = {
        "name": "张三",
        "age": 18
    }
    user = User("李四", "xx@qq.com")
    context = {
        "hobby": hobby,
        "person": person,
        "user": user
    }
    return render_template("variable.html", **context)


if __name__ == '__main__':
    app.run()
```

以上代码的写法更加直观和简洁，在遇到需要传给模板的变量比较多的情况，都推荐使用这种方式。



## 4.2 过滤器和测试器
