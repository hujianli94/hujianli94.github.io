# 5.数据库

数据库是一个动态网站必备的基础功能。


通过使用数据库，数据可以被动态地展示、修改、删除等，极大地提高了数据的管理能力，以及数据传递的效率。


数据库有很多种，如SQL Server、Oracle、PostgreSQL、MySQL等。其中MySQL数据库由于拥有免费、不受平台限制、灵活度高、稳定性强等优点，已经成为最流行的关系型数据库之一。




## 5.1 准备工作

### 5.1.1 安装MySQL


1. 官方下载链接为https://dev.mysql.com/downloads/mysql/。

2. MySQL安装图文教程链接为https://zlkt.net/book/detail/10/306。


建议直接使用的数据库最新的`MySQL 8.0`版本







### 5.1.2 Python操作MySQL驱动


 Flask要操作数据库，必须要先安装Python操作MySQL的驱动。在Python中，目前有以下MySQL驱动包。

 1. MySQL-python：也就是MySQLdb，是对C语言操作MySQL数据库的一个简单封装，遵循了Python DB API v2，但是只支持Python2。
 2. mysqlclient：是MySQL-python的另外一个分支。支持Python3并且修复了一些bug，是目前为止执行效率最高的驱动，但是安装的时候容易因为环境问题出错。
 3. pymysql：纯Python实现的一个驱动。因为是纯Python编写的，因此执行效率不如mysqlclient高。也正因为是纯Python写的，所以可以和Python代码无缝衔接
 4. mysql-connector-python: MySQL官方推出的纯Python连接MySQL的驱动，执行效率比pymysql还低。


为了减少读者出错，提高学习效率，本书选择使用pymysql作为驱动程序。如果有需要，可以自行考虑移植到mysqlclient。pymysql是一个第三方包，因此需要通过以下命令安装。

```shell
pip install pymysql
```



### 5.1.3 Flask-SQLAlchemy

在Flask中，我们很少会使用pymysql直接写原生SQL语句去操作数据库，更多的是通过SQLAlchemy提供的ORM技术，类似于操作普通Python对象一样，实现对数据库的增、删、改、查操作。


而Flask-SQLAlchemy是对SQLAlchemy的一个封装，这使得在Flask中使用SQLAlchemy更加方便。


Flask-SQLAlchemy需要单独安装，因为Flask-SQLAlchemy依赖SQLAlchemy，所以只要安装了Flask-SQLAlchemy，SQLAlchemy便会自动安装。安装命令如下。


```shell
pip install flask-sqlalchemy
```

SQLAlchemy类似于Jinja2，可以独立于Flask使用，而且完全可以在任何Python程序中使用。

SQLAlchemy的功能非常强大，本书不能全部都讲到，读者如果有兴趣，可以在学完本章内容后阅读[SQLAlchemy的官方文档](https://www.sqlalchemy.org/)进行深入研究。



## 5.2 Flask-SQLAlchemy的基本使用


### 5.2.1 连接MySQL

在使用Flask-SQLAlchemy操作数据库之前，要先创建一个由Flask-SQLAlchemy提供的SQLAlchemy类的对象。

在创建这个类时，要传入当前的app，然后还需要在app.config中设置SQLALCHEMY_DATABASE_URI，来配置数据库的连接，示例代码如下。

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import text

app = Flask(__name__)

# MySQL所在的主机名
HOSTNAME = "127.0.0.1"
# MySQL监听的端口号，默认3306
PORT = 3306
# 连接MySQL的用户名，读者用自己设置的
USERNAME = "root"
# 连接MySQL的密码，读者用自己的
PASSWORD = "123456"
# MySQL上创建的数据库名称
DATABASE = "database_learn"
app.config[
    'SQLALCHEMY_DATABASE_URI'] = f"mysql+pymysql://{USERNAME}:{PASSWORD}@{HOSTNAME}:{PORT}/{DATABASE}?charset=utf8mb4"

db = SQLAlchemy(app)

with app.app_context():
    with db.engine.connect() as conn:
        # 使用text()方法来将查询字符串转换为可执行的对象
        rs = conn.execute(text("select 1"))
        print(rs.fetchone())


@app.route('/')
def hello_world():
    return 'Hello World!'


if __name__ == '__main__':
    app.run()
```


Flask-SQLAlchemy在连接数据库时，会从app.config中读取SQLALCHEMY_DATABASE_URI参数，以上代码分别设置了MySQL主机名、端口号、用户名、密码及数据库名称，数据库应该提前在MySQL中创建好。

SQLALCHEMY_DATABASE_URI根据不同的数据库有不同的连接方式，MySQL的连接方式如下。

```shell
mysql+[driver]://[username]:[password]@[host]:[port]/[database]?charset=utf8
```

其中[]中是变量，需要配置时填充进去即可。如果单击运行后，在PyCharm的控制台中打印了(1,)，则说明已经连接成功。


!!! abstract  "参考文献"

  [Flask-SQLAlchemy 连接 mysql 数据库](https://www.cnblogs.com/yoyoketang/p/16615745.html)





### 5.2.2 ORM模型


对象关系映射（object relationship mapping，简称ORM）是一种可以用Python面向对象的方式来操作关系型数据库的技术，具有可以映射到数据库表能力的Python类我们称之为ORM模型。



一个ORM模型与数据库中的一个表相对应，ORM模型中的每个类属性分别对应表的每个字段；

ORM模型的每个实例对象对应表中的每条记录。ORM技术提供了面向对象与SQL交互的桥梁，让开发者用面向对象的方式操作数据库，使用ORM模型具有以下优势。


1. 开发效率高：几乎不需要写原生SQL语句，使用纯Python的方式操作数据库，大大地提高了开发效率。
2. 安全性高：ORM模型底层代码对一些常见的安全问题，如SQL注入做了防护，比直接使用SQL语句更加安全。
3. 灵活性强：Flask-SQLAlchemy底层支持SQLite、MySQL、Oracle、PostgreSQL等关系型数据库，但针对不同的数据库，ORM模型的代码几乎一模一样，只需修改少量代码，即可完成底层数据库的更换。



下面用Flask-SQLAlchemy来创建一个User模型，示例代码如下。

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import text

app = Flask(__name__)

# ....前面代码都一样


class User(db.Model):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(100))
    password = db.Column(db.String(100))


with app.app_context():
    db.create_all()

if __name__ == '__main__':
    app.run()

```


以上代码中，首先创建了一个User类，并使它继承自db.Model类，所有ORM模型必须是db.Model的直接或者间接子类。

然后通过`__tablename__`属性，指定User模型映射到数据库中表的名称。

接着定义了3个db.Column类型的类属性，分别是id、username、password，只有使用db.Column定义的类属性，才会被映射到数据库表中成为字段。

在这个User模型中，id是`db.Integer`类型，在数据库中将表现为整型，并且传递`primary_key=True`参数指定id作为主键，传递`autoincrement=True`参数设置id为自增长。

username和password属性分别指定其类型为`db.String`类型，在数据库中将表现为`varchar`类型，并且指定其最大长度为100。


最后通过`db.create_all()`把User模型映射成数据库中的表。我们可以通过navicat软件来查看数据库中的表。



Flask-SQLAlchemy常用字段类型

| 类型           | 描述                                     |
| -------------- | ---------------------------------------- |
| db.Integer     | 整型。范围与数据库一致                   |
| db.SmallInteger | 小整型。范围与数据库一致                 |
| db.BigInteger  | 长整型。范围与数据库一致                 |
| db.Decimal     | 定点类型。可以指定总长度和小数点后位数     |
| db.Boolean     | 布尔类型                                 |
| db.Date        | 日期类型。存储Python中的datetime.date对象 |
| db.DateTime    | 日期时间类型。存储Python中的datetime.datetime对象 |
| db.Time        | 时间类型。存储Python中的datetime.time对象 |
| db.Interval    | 时间间隔。存储Python中的datetime.timedelay对象 |
| db.String      | 字符串类型。使用时需要指定长度，不能超过255个字符 |
| db.Text        | 文本类型。常用于字符串长度不可控的情况     |
| db.Enum        | 枚举类型                                 |
| db.PickleType  | 存储经过Pickle后的对象                   |
| db.LargeBinary | 存储二进制数据                           |


字段在数据库中的表现，都是通过db.Column上的参数实现的。db.Column常用参数如表

| 参数           | 描述                                                 |
| -------------- | ---------------------------------------------------- |
| name           | 字段在数据库表中的名称。如果没有设置，则使用此属性名作为字段名称 |
| type\_         | 字段类型                                             |
| autoincrement  | 自动增长                                             |
| default        | 默认值                                               |
| index          | 如果设置为True,则将此字段设置为索引                     |
| nullable       | 是否为空                                             |
| onupdate       | 在修改对象时，会自动使用这个属性指定的值                 |
| primary\_key   | 主键                                                 |
| unique         | 如果设置为True,则此字段的值必须唯一                     |
| comment        | 在创建表时的注释                                       |




!!! abstract  "参考文献"

  [Flask-SQLAlchemy 新建模型和字段](https://www.cnblogs.com/yoyoketang/p/16616702.html)




### 5.2.3 CRUD操作

使用ORM进行CRUD(create、read、update、delete)操作，需要先把操作添加到会话中，通过`db.session`可以获取到会话对象。

会话对象存在内存中，如果要把会话中的操作提取到数据库中，需要调用`db.session.commit()`操作；如果要把会话中的操作回滚，则需要调用`db.session.rollback()`实现。下面分别对CRUD操作进行讲解。



#### 1.Create操作

```python
@app.route('/user/add')
def user_add():
    user1 = User(username="张三", password="444444")
    user2 = User(username="李四", password="555555")
    user3 = User(username="王五", password="666666")
    db.session.add(user1)
    db.session.add(user2)
    db.session.add(user3)
    db.session.commit()
    return "用户添加成功！"
```


访问`http://127.0.0.1:5000/user/add`时,User表会自动新增3条数据。

在以上代码中，首先用User类创建了3个对象，在创建对象时，必须通过关键字参数给字段赋值，否则SQLAlchemy将不知道是给哪个字段赋值，从而报错。

由于id是作为一个自增长的主键，因此可以不需要赋值。然后再把3个对象添加到session中，最后再统一进行commit操作，即可把数据添加到数据库中。




#### 2.Read操作

ORM模型都是继承自db.Model，db.Model内置的query属性上有许多方法，可以实现对ORM模型的查询操作。

query上的方法可以分为两大类，分别是提取方法和过滤方法。首先来看提取方法，示例代码如下。

```python
@app.route("/user/fetch")
def user_fetch():
    # # 1. 获取User中所有数据
    # users = User.query.all()
    # user_list = [user.to_dict() for user in users]  # 将每个User对象转换为字典

    # 2. 获取主键为1的User对象
    user = User.query.get(1)
    user_dict = user.to_dict() if user else None  # 如果user存在，则转换为字典，否则为None

    # # 3. 获取第一条数据
    # first_user = User.query.first()
    # first_user_dict = first_user.to_dict() if first_user else None  # 如果first_user存在，则转换为字典，否则为None

    print("数据提取成功")
    response = jsonify({
        "user": user_dict
    })
    return response, 200


class User(db.Model):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(100))
    password = db.Column(db.String(100))

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "password": self.password
        }

```


访问`http://127.0.0.1:5000/user/fetch`时，会以json格式返回对应查询方式的结果。


 提取数据的常用方法

 | 方法名               | 描述                                        |
| -------------------- | ------------------------------------------- |
| query.all()          | 获取查询结果集中的所有对象，是列表类型        |
| query.first()        | 获取查询结果集中的第一个对象                  |
| query.one()          | 获取查询结果集中的一个对象，如果结果集不等于1，则抛出异常 |
| query.one_or_none()  | 获取查询结果集中的一个对象，如果结果集不等于1，则返回None |
| query.get(pk)        | 根据主键获取当前ORM模型的第一条数据          |
| query.exists()       | 判断数据是否存在                            |
| query.count()        | 获取查询结果集的个数                        |


在查询数据时，经常需要做过滤操作。过滤最常用的两个方法是`filter`和`filter_by`，filter方法传递查询条件，filter_by方法传递关键字参数，示例代码如下。


```python
@app.route("/user/filter")
def user_filter():
    # 1. filter方法：
    users_filter = User.query.filter(User.username == "张三").all()

    # 2. filter_by方法：
    users_filter_by = User.query.filter_by(username="张三").all()
    return jsonify({
        "users_filter": [user.to_dict() for user in users_filter],
        "users_filter_by": [user.to_dict() for user in users_filter_by]
    })
```


除了filter和filter_by方法以外，Flask-SQLAlchemy还提供了以下过滤方法，如表


常用过滤方法

| 方法名                | 描述                                   |
| --------------------- | -------------------------------------- |
| query.filter()        | 根据查询条件过滤                       |
|query.filter().one()   |.one() 用于确保查询结果只有一条记录，如果查询结果为空或者多于一条记录，将会抛出异常。|
| query.filter_by()     | 根据关键字参数过滤                     |
| query.slice(start,stop) | 对结果进行切片操作                     |
| query.limit(limit)    | 对结果数量进行限制                     |
| query.offset(offset)  | 在查询时跳过前面offset条数据            |
| query.order_by()      | 根据给定字段进行排序                   |
| query.group_by()      | 根据给定字段进行分组                   |


##### 排序和分组

下面讲解query.order_by()和query.group_by()的用法。


(1) query.order_by()的用法如以下代码所示。

```python
@app.route("/user/filter")
def user_filter():
    # 3. order_by方法：
    # 3.1. 正序排序
    users_order_by_id = User.query.order_by("id").all()
    users_order_by_id_attr = User.query.order_by(User.id).all()

    return jsonify({
        "users_order_by_id": [user.to_dict() for user in users_order_by_id],
        "users_order_by_id_attr": [user.to_dict() for user in users_order_by_id_attr]
    })
```


```python
@app.route("/user/filter")
def user_filter():
    # 3. order_by方法：
    # 3.2. 倒序排序
    users_order_by_id_desc_text = User.query.order_by(db.text("-id")).all()
    users_order_by_id_desc_attr = User.query.order_by(User.id.desc()).all()

    return jsonify({
        "users_order_by_id_desc_text": [user.to_dict() for user in users_order_by_id_desc_text],
        "users_order_by_id_desc_attr": [user.to_dict() for user in users_order_by_id_desc_attr]
    })
```



```python
@app.route("/user/filter")
def user_filter():
    # 3. order_by方法：
    # 3.3. 倒序排序
    from sqlalchemy import desc
    users_order_by_id_desc = User.query.order_by(desc("id")).all()

    return jsonify({
        "users_order_by_id_desc": [user.to_dict() for user in users_order_by_id_desc]
    })
```

以上代码中，以User的id字段为例（可以换成任何其他的字段），详细地罗列了正序和倒序排序的方法，读者在开发过程中可自行选择合适的方法实现排序。



(2) query.group_by()方法是根据某个字段进行分组，分组的主要目的是获取分组后的数量、最大值、最小值、平均值、总和等。
因为提取的数据不再是某个模型，所以不能通过`<模型>.query`的方式获取，而是通过`db.session.query`来提取，如要获取所有用户名在表中存在的个数，那么可以通过以下代码实现。


```python
@app.route("/user/filter")
def user_filter():
    # 4. group_by方法：
    from sqlalchemy import func
    results = db.session.query(User.username, func.count(User.id)).group_by(User.username).all()
    users_group_by_username = [{"username": username, "count": count} for username, count in results]

    return jsonify({
        "users_group_by_username": users_group_by_username
    })
```


##### 常见的查询条件

过滤是数据提取的一个很重要的功能，除了直接使用==和!=关系运算符外，还可以使用以下常用的过滤条件进行过滤，但这些过滤条件只能通过filter方法实现。常用的过滤条件如下。




(1) like：模糊查询，使用方式与SQL语句中的like类似，可以在搜索字符左右两边添加%来匹配任意字符。contains方法相当于like在搜索字符左右两边都添加%，例如，contains("张")与like("%张%")是一样的效果。示例代码如下。


```python
    # 5.1. like
    users = User.query.filter(User.username.contains("Tang"))
    users = User.query.filter(User.username.like("%Tang%"))
```

示例

```python
@app.route("/user/filter")
def user_filter():
    users_filter_contains_l = User.query.filter(User.username.contains("Tang")).all()

    return jsonify({
        "users_filter_contains_l": [user.to_dict() for user in users_filter_contains_l]
    })
```

(2) in：判断值是否在指定数据集中，如果是就提取，否则就不提取。为了不与Python中的in关键字混淆，在in后加下画线，实际的方法名为in_，示例代码如下。


```python
    # 5.2. in
    users = User.query.filter(User.username.in_(["Ono Mai","Song Ziyi","Tang Lu"]))
```

示例

```python
@app.route("/user/filter")
def user_filter():
    users_filter_in_list = User.query.filter(User.username.in_(["Ono Mai", "Song Ziyi", "Tang Lu"])).all()

    return jsonify({
        "users_filter_in_list": [user.to_dict() for user in users_filter_in_list]
    })
```


(3) not in：作用与in相反。其使用方式是在in_方法所在代码表达式前添加(~)，示例代码如下。

```python
    # 5.3. not in
    users = User.query.filter(~User.username.in_(['张三']))
```


示例

```python
@app.route("/user/filter")
def user_filter():
    users_filter_in_list = User.query.filter(~User.username.in_(["Ono Mai", "Song Ziyi", "Tang Lu"])).all()

    return jsonify({
        "users_filter_in_list": [user.to_dict() for user in users_filter_in_list]
    })
```



(4) is null：判断值是否为空，如果为空就提取，否则就不提取。可以通过判断值是否为none，或通过is_方法实现，为了不与Python中的in关键字混淆，同样需要在is后加下画线，示例代码如下。


```python
    # 5.4. is null
    users = User.query.filter(User.username==None)
    users = User.query.filter(User.username.is_(None))
```

(5) is not null：作用与is null相反，实际的方法名为isnot，示例代码如下。


```python
    # 5.5. is not null
    users = User.query.filter(User.username != None)
    users = User.query.filter(User.username.isnot(None))
```


(6) and：用于同时满足多条件的查询，实际的方法名为and_，示例代码如下


```python
    # 5.6. and
    from sqlalchemy import and_
    users = User.query.filter(and_(User.username=="张三",User.id < 10))
```


示例
```python
@app.route("/user/filter")
def user_filter():
    from sqlalchemy import and_, collate
    # 使用 collate 函数来将用户名的比较规则设置为 'utf8_bin'，这样就可以进行大小写敏感的匹配
    users_filter_and = User.query.filter(and_(collate(User.username, 'utf8_bin').contains("Ch"), User.id < 50))
    return jsonify({
        "users_filter_and": [user.to_dict() for user in users_filter_and]
    })
```


(7) or：用于满足一个或多个条件的查询，实际的方法名为or_，示例代码如下。


```python
    # 5.7. or
    from sqlalchemy import or_
    users = User.query.filter(or_(User.username=="Tang Lu",User.username=="Tang Tin Wing"))
```


示例

```python
@app.route("/user/filter")
def user_filter():
    from sqlalchemy import or_
    users_filter_or = User.query.filter(or_(User.username == "Tang Lu", User.username == "Tang Tin Wing")).all()

    return jsonify({
        "users_filter_or": [user.to_dict() for user in users_filter_or]
    })
```


#### 3.update操作


更新操作分为两种，第一种针对一条数据，第二种针对多条数据。针对一条数据，可以直接修改对象的属性，然后执行commit操作即可，示例代码如下。

##### 对一条数据


```python
@app.route("/user/update")
def user_update():
    # 1. 修改一条数据
    user = User.query.get(1)
    user.username = "Chang Wing Sze-Rename"
    db.session.commit()
    return "数据修改成功！"
```



##### 对多条数据

针对修改多条数据的情况，则是通过调用filter或者filter_by方法获取BaseQuery对象，然后再调用update方法，实现批量修改的，示例代码如下。

```python
@app.route("/user/update")
def user_update():
    # 2. 批量修改数据
    User.query.filter(User.username.like("%张三%")).update({"password": User.password + "_被修改的"})
    db.session.commit()
    return "数据修改成功！"
```
以上代码先通过filter方法过滤数据，然后再调用update方法，在所有的password后面都添加"_被修改的"字符串，并且因为使用了like方法作为过滤条件，

所以需要指定synchronize_session参数为False，最后再调用commit()方法即可批量完成数据的修改。




#### 4.delete操作



删除操作也是分成两种。第一种是删除一条数据，第二种是删除多条数据。删除单条数据的操作方式非常简单，直接调用db.session.delete方法即可，示例代码如下。


#### 删除一条数据


```python
@app.route("/user/delete")
def user_delete():
    user = User.query.get(1)
    db.session.delete(user)
    db.session.commit()

    return jsonify({
        "message": "User deleted successfully",
        "status": 200
    })
```



#### 删除多条数据

删除多条数据的操作方式类似更新多条数据，通过BaseQuery的delete方法即可实现，示例代码如下。

```python
@app.route("/user/delete")
def user_delete():
    User.query.filter(User.username.contains("张三")).delete(synchronize_session=False)
    db.session.commit()
    return jsonify({
        "message": "User deleted successfully",
        "status": 200
    })
```



!!! abstract  "参考文献"

  [Flask-SQLAlchemy ORM操作数据库增删改查](https://www.cnblogs.com/yoyoketang/p/16617172.html)




## 5.3 表关系


关系型数据库的一个强大的功能，就是多张表之间可以建立关系。

如文章表中，通常需要保存作者数据，但是我们不需要直接把作者数据放到文章表中，而是通过外键引用用户表。

这种强大的表关系，可以存储非常复杂的数据，并且可以使查询非常迅速。

在Flask-SQLAlchemy中，同样也支持表关系的建立，表关系建立的前提，是通过数据库的外键实现的。表关系总体来讲可以分为3种：一对多（多对一）、一对一、多对多。


下面分别进行讲解。


### 5.3.1 关系数据库建模


数据库建模（Database Modeling）是指针对一个给定的应用环境构造数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足用户的应用需求。在现代敏捷开发方法的指导下，明确Web系统的业务需求后，关系数据库建模通常由以下两步完成。


- 设计E-R图：构造一个反映现实世界实体之间联系的模型。

- 关系表设计：将E-R图转换为关系表，并定义列类型，建立主键、外键等各种约束。




#### 1.设计E-R图


E-R图，即实体-关系（Entity-Relationship）图，是P.P.S.Chen于1976年提出的数据建模方法，由于其简单实用，得到了普遍应用，是目前描述信息结构最常用的方法。

E-R 图通过以下3种概念描述信息结构。

- 实体：客观存在的事物、事件、角色等，比如采购员、老师、课程、订单等。
- 实体属性：用于描述实体的特性，每个实体可以有多个属性，比如老师的性别、名字、住址等。
- 关系：反映两个实体之间客观存在的关系。


设计E-R图就是围绕着识别系统中的实体和明确实体之间关系而进行的。E-R图中两个实体（假设分别为实体A、实体B）的关系被分为以下3类。



- 一对一关系：实体A的任意一个实例至多只有一个实体B的实例与之关联；而实体B的任意一个实例也至多只有一个实体A的实例与之关联。**典型的一对一关系包括人与身份证、丈夫与妻子等。一对一关系在E-R图中被记为1∶1。**

- 一对多关系：实体A的任意实例可以有零个、一个或多个实体B的实例与之关联；而实体B的任意实例至多只与一个实体A的实例关联。**典型的一对多关系包括班级与学生、人与银行卡等。一对多关系在E-R图中被记为1∶N。**

- 多对多关系：实体A的任意一个实例可以与实体B中的任意多个实例关联；而实体B中的任意一个实例也可以与实体A中的任意多个实例关联。**典型的多对多关系包括老师和班级、学生与课程等。多对多关系在E-R图中被记为M∶N。**




在E-R图的绘制中，通常用**方块表示实体**，用**实体周围的圆圈表示属性**，用**实体之间的菱形表示关系**，图5.3是一个学校系统的E-R图示例。


![](https://raw.githubusercontent.com/hujianli94/Picgo-atlas/main/img/202309051548838.png)



图5.3中定义了4个实体和3个关系，分别是实体“老师”“课程”“学生”“学生证”。

实体的各个属性如图4.2中的圆圈部分所示。3个关系分别是：

课程与老师之间的一对多任教关系（假设学校只允许一个老师教一门课程，但一个课程可以有多个老师任教）；

课程与学生之间的多对多选课关系（每个课程可以有多个学生学习，每个学生可以选择多门课程）；

学生与学生证的一对一入学关系（每个学生在入学时办理唯一的学生证）。



#### 2.关系表设计-原生SQL


设计关系表可以直接使用Navicat工具进行建模。


在完成了数据需求分析和E-R图设计后，就可以进行关系表的具体设计了。将E-R图设计转变为关系表设计可按照如下步骤进行。


1. 数据库选型，例如MySQL、SQL Server、Oracle、PostgreSQL等。因为各种数据库支持的列类型略有不同，所以需要在物理表设计之前完成选型。
2. 将每个实体转换为一个数据表，将实体的属性转换为该表中的列，为每个列定义相应的数据类型。
3. 对于有1∶1关系的两个表，`为两个表设置相同的主键列。`
4. 对于1∶N关系的两个表，`在N表中添加一个外键列，该列与1表的主键相关联。`
5. 对于M∶N关系，`生成一个单独的表表示该关系，该关系的列由两个表的主键组成。`
6. 重新审核所有的表，对需要的地方添加约束，对常用的条件字段设置索引。


通过上述步骤，可以将图5.3中的实体关系模型转换为具体的关系表。

该图一共生成了5个表：4个实体表和1个关系表。假设数据库采用PostgreSQL，则转换后的表定义见表5.1、表5.2、表5.3、表5.4、表5.5。


表5.1　表定义——课程

| 表名        | course | 表的作用   | 定义实体“课程” |
| ----------- | ------ | ---------- | -------------- |
| 列名        | 类型   | 索引、约束 | 作用及备注     |
| id          | INT    | PK         | 唯一标识       |
| title       | TEXT   | NOT NULL   | 课程名         |
| period      | INT    | Index      | 学时           |
| description | TEXT   |            | 课程描述       |



表5.2　表定义——老师

| 表名      | teacher | 表的作用      | 定义实体“老师”          |
| --------- | ------- | ------------- | ----------------------- |
| 列名      | 类型    | 索引、约束    | 作用及备注              |
| id        | INT     | PK            | 唯一标识                |
| name      | TEXT    | NOT NULL      | 姓名                    |
| gender    | BOOL    | Index         | 性别True：男False：女   |
| address   | TEXT    |               | 住址                    |
| course_id | INT     | FK: course.id | 由于1:N关系所添加的外键 |


表5.3　表定义——学生

| 表名       | Student | 表的作用   | 定义实体“学生” |
| ---------- | ------- | ---------- | -------------- |
| 列名       | 类型    | 索引、约束 | 作用及备注     |
| student_id | INT     | PK         | 学号，唯一标识 |
| name       | TEXT    | NOT NULL   | 姓名           |
| age        | INT     | Index      | 年龄           |
| parent     | TEXT    |            | 家长           |



表5.4　表定义——学生证

| 表名       | card      | 表的作用   | 定义实体“学生证”       |
| ---------- | --------- | ---------- | ---------------------- |
| 列名       | 类型      | 索引、约束 | 作用及备注             |
| student_id | INT       | PK         | 学号，唯一标识         |
| startFrom  | TIMESTAMP |            | 注册日期、入学日期     |
| endTo      | TIMESTAMP |            | 本学生证有效期的截止日 |



表5.5　表定义——选课

| 表名       | enroll | 表的作用                   | 定义关系“学生：课程” |
| ---------- | ------ | -------------------------- | -------------------- |
| 列名       | 类型   | 索引、约束                 | 作用及备注           |
| student_id | INT    | PK, FK: student.student_id | 学生标识             |
| course_id  | INT    | PK, FK:course_id           | 课程标识             |

在以上表定义中，读者尤其应该注意关系的表达方法。

- 表student和表card通过设置相同的主键（即student_id）实现了1∶1关系。

- 表teacher中通过设置外键course_id实现了与课程的1∶N关系。

- 表enroll实现了“学生”与“课程”的M∶N关系。

考虑到不熟悉数据库理论的读者，这里将表4.1～表4.5中的键型、索引、约束解释如下。

- Index：索引，是对数据库表中一列或多列的值进行排序的一种结构。对常用的查询条件字段添加索引可显著提高SQL语句的性能。

- Constraint：约束，是对列数据取值的某种限定。常见的约束有主键、外键、非空、唯一等。

- PK：主键（primary key），唯一标识一条记录，不允许为空。在大多数数据库中主键列也是一个索引列。

- FK：外键（foreign key），是另一个表的主键，表示关联关系，可以是空字段。

- NOT NULL：非空约束，即不允许列值为空。




### 5.3.2 外键

外键是数据库的技术，Flask-SQLAlchemy中支持在创建ORM模型时就指定外键，创建外键是通过`db.ForeignKey`实现的。


如创建Article表，这张表有一个author_id字段，通过外键引用user表的id字段，用来保存文章的作者，那么Article的模型代码如下。

```python
class Article(db.Model):
    __tablename__ = "article"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(200),nullable=False)
    content = db.Column(db.Text,nullable=False)

    author_id = db.Column(db.Integer,db.ForeignKey("user.id"))
```


以上代码，除了添加常规的title、content属性外，还增加了一个author_id，author_id通过`db.ForeignKey("user.id")`引用了之前创建的user表的id字段。

这里有个细节需要注意，author_id因为引用user表的id字段，所以它的类型必须跟user表的id字段一致，否则会报错。


### 5.3.3 一对多关系

我们生活中有很多一对多的例子，如CSDN博客中的一篇文章只能属于一个作者，一个作者能发布多篇文章，作者和文章之间是一对多的关系，反过来文章和作者之间是多对一的关系。



> 1∶N关系的两个表，**在N表中添加一个外键列，该列与1表的主键相关联。**



大白话如下：

**一对多的关系，模型建立时候，`外健定义在多的一方`，将外健指向"一"的主键，外健名称最好取名"一"的`主键名+_+id`**



#### 1.建立关系

```python
class User(db.Model):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(100))
    password = db.Column(db.String(100))

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "password": self.password
        }


class Article(db.Model):
    __tablename__ = "article"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)

    author_id = db.Column(db.Integer, db.ForeignKey("user.id"))
    # Flask - SQLAlchemy提供了db.relationship来引用外键所指向的那个ORM模型。
    author = db.relationship("User")
```


我们添加了一个author属性，这个属性通过db.relationship与User模型建立了联系，以后通过Article的实例对象访问author时，如article.author，那么Flask-SQLAlchemy会自动根据外键author_id从user表中寻找数据，并形成User模型实例对象。


下面通过创建Article对象，并通过访问Article实例对象的author属性来关联User对象，示例代码如下。

```python
@app.route("/article/add")
def article_add():
    user = User.query.first()
    article = Article(title="aa", content="bb", author=user)
    db.session.add(article)
    db.session.commit()

    article = Article.query.filter_by(title="aa").first()
    print(article.author.username)
    return article.author.username
```

以上代码中，首先创建了一个article对象，并添加到数据库中，接下来再从数据库中提取，然后通过article.author.username访问到article对象的用户名。



例如：一个人有多个收件地址，这就是一对多关系


```python
class Person(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50))
    addresses = db.relationship('Address', backref='person',
                                lazy='dynamic')

class Address(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(50))
    person_id = db.Column(db.Integer, db.ForeignKey('person.id'))

```


`db.relationship()` 做了什么？

这个函数返回一个可以做许多事情的新属性。在本案例中，我们让它指向 Address 类并加载多个地址。它如何知道会返回不止一个地址？

因为 SQLALchemy 从您的声明中猜测了一个有用的默认值。 如果您想要一对一关系，您可以把 `uselist=False` 传给 relationship() 。


那么 backref 和 lazy 意味着什么了?

backref 是一个在 Address 类上声明新属性的简单方法。您也可以使用 my_address.person 来获取使用该地址(address)的人(person)。

lazy 决定了 SQLAlchemy 什么时候从数据库中加载数据:

- select (默认值) 就是说 SQLAlchemy 会使用一个标准的 select 语句必要时一次加载数据。
- joined 告诉 SQLAlchemy 使用 JOIN 语句作为父级在同一查询中来加载关系。
- subquery 类似 'joined' ，但是 SQLAlchemy 会使用子查询。
- dynamic 在有多条数据的时候是特别有用的。不是直接加载这些数据，SQLAlchemy 会返回一个查询对象，在加载数据前您可以过滤（提取）它们。





#### 2.建立双向关系



现在的Article模型可以通过author属性访问到对应的User实例对象，但是User实例对象无法访问到和其关联的所有Article实例对象。

因此为了实现双向关系绑定，还需要在User模型上添加一个`db.relationship`类型的articles属性，并且在User模型和Article模型双方的`db.relationship`上都需要添加一个`back_populates`参数，

用于绑定对方访问自己的属性，示例代码如下。

```python
class User(db.Model):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(100))
    password = db.Column(db.String(100))
    # 在ORM层面绑定两者之间的关系，第一个参数是绑定的表的类名，
    # 第二个参数back_populates是通过User反向访问时的字段名称
    articles = db.relationship("Article", back_populates="author")

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "password": self.password
        }


class Article(db.Model):
    __tablename__ = "article"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    author_id = db.Column(db.Integer, db.ForeignKey("user.id"))
    # 在ORM层面绑定两者之间的关系，第一个参数是绑定的表的类名，
    # 第二个参数back_populates是通过User反向访问时的字段名称
    author = db.relationship("User", back_populates="articles")
```


在User端绑定了articles属性后，现在双方都能通过属性直接访问到对方了，示例代码如下。

```python
@app.route("/article/add")
def article_add():
    user = User.query.first()
    article = Article(title="aa", content="bb", author=user)
    db.session.add(article)
    db.session.commit()

    article = Article.query.filter_by(title="aa").first()
    print(article.author.username)
    for article in user.articles:
        print(article.title)
    return article.author.username
```


#### 3.简化关系定义


以上User和Article模型中，通过在两边的`db.relationship`上传递`back_populates`参数来实现双向绑定，这种方式有点烦琐，

我们还可以通过只在一个模型上定义`db.relationship`类型属性，并且传递`backref`参数实现双向绑定，示例代码如下。


```python
class User(db.Model):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(100))
    password = db.Column(db.String(100))
    # articles = db.relationship("Article")

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "password": self.password
        }

class Article(db.Model):
    __tablename__ = "article"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    author_id = db.Column(db.Integer, db.ForeignKey("user.id"))
    # backref参数的功能更加强大，其可以自动给对方添加db.relationship的属性.
    author = db.relationship("User", backref="articles")
```


这种方式虽然方便，但是在模型比较多、项目团队人数较多的情况下，也容易造成困扰。

如User模型上根本没有看到定义的articles属性，但是却在Article模型上创建了，这着实会让人摸不着头脑。

**因此为了更加直观和方便团队协作，建议使用back_populates来实现双向绑定。**




!!! abstract  "参考文献"

  [Flask-SQLAlchemy 一对多关系](https://www.cnblogs.com/yoyoketang/p/16729771.html)





### 5.3.4 一对一关系


要实现一对一关系，只需要在一对多的基础之上，将“多”的那一端设置为“一”即可，在Flask-SQLAlchemy中，

通过给`db.relationship`传递`uselist=False`，**即可将“多”设置为“一”**，为了在数据库层面也实现一对一，还需要在外键上设置`unique=True`。

这里以用户拓展表为例。

在公司业务增长的情况下，需要存储用户的许多属性，但是有些属性是不常用的，为了提高网站的响应速度，我们会把那些不常用的属性放到拓展表中，只在需要的时候才访问。

**用户表和用户拓展表就是典型的一对一关系**，一个用户只能有一条拓展数据，一条拓展数据只能属于一个用户。

下面新增一个UserExtension模型，与原来的User模型建立一对一的关系，示例代码如下。


```python
class User(db.Model):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(100))
    password = db.Column(db.String(100))
    # articles = db.relationship("Article")
    extension = db.relationship("UserExtension", back_populates="user", uselist=False)

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "password": self.password
        }


class UserExtension(db.Model):
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    school = db.Column(db.String(100))
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), unique=True)
    user = db.relationship("User", back_populates="extension")

```

User和UserExtension的关系中，因为外键是添加到`UserExtension`模型上，因此User模型属于“多”的那一端，这时就设置uselist=False，即可将“多”转化为“一”。

为了在数据库层面也实现一对一，将UserExtension模型上的user_id属性设置为`unique=True`。此时如果要在一个User对象上添加多个UserExtension对象，那么就会抛出异常，示例代码如下。


```python
@app.route("/one2one")
def one2one():
    user = User.query.first()
    extension1 = UserExtension(school="清华大学", user=user)
    # extension2 = UserExtension(school="北京大学",user=user)
    db.session.add(extension1)
    # db.session.add(extension2)
    db.session.commit()
    return "一对一成功！"
```

上面的代码，如果打开注释会报错。



例如：学生和学生联系方式就是一对一的关系

```python


class Student(db.Model):
    __tablename__ = 'student'  # 数据库表名
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
    gender = db.Column(db.Enum("男", "女"), default=None, nullable=True)
    contact = db.relationship(
        'Contact', uselist=False, backref='student'
    )
    def save(self):
        """保存数据"""
        db.session.add(self)
        db.session.commit()


class Contact(db.Model):
    __tablename__ = 'contact'  # 数据库表名
    id = db.Column(db.Integer, primary_key=True)
    tel = db.Column(db.String(20), nullable=True)
    address = db.Column(db.String(150), nullable=True)
    user_id = db.Column(db.Integer, db.ForeignKey('student.id'))

    def save(self):
        """保存数据"""
        db.session.add(self)
        db.session.commit()

```



!!! abstract  "参考文献"

  [Flask-SQLAlchemy 一对一关系增删改查](https://www.cnblogs.com/yoyoketang/p/16723108.html)




### 5.3.5 多对多关系

> 对于M∶N关系，生成一个单独的表表示该关系，该关系的列由两个表的主键组成。


大白话：

**将多对多关系的`两张表的主键ID`拿出来，单独创建一个表，表名最好为`M_N_table`比较好识别**


**多对多关系在数据库层面是需要通过一张中间表来实现的**，在Flask-SQLAlchemy中也是一样。

这里以文章和标签为例，一篇文章可以添加多个标签，一个标签可以被多篇文章添加。


我们创建标签Tag类，示例代码如下。

```python
article_tag_table = db.Table(
    "article_tag_table",
    db.Column("article_id", db.Integer, db.ForeignKey("article.id"), primary_key=True),
    db.Column("tag_id", db.Integer, db.ForeignKey("tag.id"), primary_key=True)
)


class Tag(db.Model):
    __tablename__ = "tag"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(100))
    articles = db.relationship("Article", secondary=article_tag_table, back_populates="tags")


class Article(db.Model):
    __tablename__ = "article"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)

    author_id = db.Column(db.Integer, db.ForeignKey("user.id"))
    author = db.relationship("User", backref="articles")

    tags = db.relationship("Tag", secondary=article_tag_table, back_populates="articles")

```


为了实现Article和Tag之间的多对多关系，我们使用db.Table创建了一张中间表 article_tag_table，

并且添加了article_id和tag_id两个外键来分别与article和tag表进行关联。

然后在Article和Tag类中分别添加了tags和articles属性，用来建立双向关系，并且在`db.relationship`中传递`secondary=article_tag_table`参数来绑定中间表。

Article和Tag的多对多关系建立后，可以通过以下代码来添加数据。

```python
@app.route('/many2many')
def many2many():
    article1 = Article(title="11", content="aa")
    article2 = Article(title="22", content="bb")

    tag1 = Tag(name="python")
    tag2 = Tag(name="flask")

    article1.tags.append(tag1)
    article1.tags.append(tag2)

    article2.tags.append(tag1)
    article2.tags.append(tag2)

    db.session.add_all([article1, article2])
    db.session.commit()
    return "多对多数据添加成功！"

```


上述代码中首先分别创建了两个Article对象和两个Tag对象，然后把两个Tag对象分别添加到article1和article2中，最后通过`db.session.add_all`方法把article1和article2添加到会话中，然后执行commit操作。

因为两个Tag对象都已经与article1和article2进行关联了，在article1和article2被添加到会话中后，两个Tag对象也会被添加到会话中。

在多对多关系中，添加对象使用的是`append方法`，移除对象使用的是`remove方法`。




### 5.3.6 级联操作


级联操作(cascade)是在操作某个对象时，相关联的对象也会进行对应的操作。

在数据库层面的级联操作包括级联删除、级联更新等。

Flask-SQLAlchemy提供了比数据库更强大的级联操作，定义级联操作是通过对`db.relationship`传递`cascade`参数实现的，

这个参数的值可以为`all`、`save-update`、`merge`、`refresh-expire`、`expunge`、`delete`中的一个或者多个，

如果是多个，则通过英文逗号隔开，如`“save-update, delete”`。

**谁设置了cascade参数，谁就是父表，父表数据发生变化，相关联的从表也会执行相应操作**。


这里为了不影响之前的模型，我们创建两个新的ORM模型来讲解级联操作，示例代码如下。


```python
class Category(db.Model):
    __tablename__ = "category"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(100))
    newses = db.relationship("News", back_populates="category")


class News(db.Model):
    __tablename__ = "news"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    category_id = db.Column(db.Integer, db.ForeignKey("category.id"))
    category = db.relationship("Category", back_populates="newses")

```

以上代码中创建了两个模型，分别是`新闻分类模型Category`和`新闻模型News`，并且在双方都建立了关系。下面分别来讲解级联操作常用的值。



#### 1.save-update


save-update是默认选项，它的作用是当某个对象被添加到会话中时，与此对象相关的对象也会被添加进去，示例代码如下。

```python

class Category(db.Model):
    __tablename__ = "category"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(100))
    newses = db.relationship("News", back_populates="category",cascade="save-update")


class News(db.Model):
    __tablename__ = "news"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    category_id = db.Column(db.Integer, db.ForeignKey("category.id"))
    category = db.relationship("Category", back_populates="newses",cascade="save-update")
```

```python
@app.route("/save_update")
def save_update():
    category = Category(name="军事")
    news = News(title="新闻1", content="新闻内容1")
    news.category = category
    db.session.add(category)
    db.session.commit()
    return "success"
```


访问`http://127.0.0.1:5000/save_update`时，news表和category表数据都会更新。



#### 2.delete

delete表示当删除某个对象时，**被关联的所有对象都会被删除**，请慎重使用！！。

这个值默认在cascade中是没有的。



```python
class Category(db.Model):
    __tablename__ = "category"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(100))
    newses = db.relationship("News", back_populates="category")


class News(db.Model):
    __tablename__ = "news"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    category_id = db.Column(db.Integer, db.ForeignKey("category.id"))
    category = db.relationship("Category", back_populates="newses")
```

```python
@app.route('/delete')
def delete_view():
    news = News.query.first()
    db.session.delete(news)
    db.session.commit()
    return "success"
```

访问`http://127.0.0.1:5000/delete`时，news(新闻)表中的一条记录会被删除。



#### 3.delete-orphan

delete-orphan表示某个对象被父表解除关联时，此对象也会自动被删除。

当然，如果父表中的数据被删除，此对象也会被删除。

如某个News对象被从Category.newses上删除，则这个News对象也会被删除。将Category的newses属性修改为如下所示的代码。


```python
class Category(db.Model):
    __tablename__ = "category"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(100))
    newses = db.relationship("News", back_populates="category", cascade="save-update,delete,delete-orphan")


class News(db.Model):
    __tablename__ = "news"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    category_id = db.Column(db.Integer, db.ForeignKey("category.id"))
    category = db.relationship("Category", back_populates="newses", cascade="save-update")
```


然后再执行删除操作，示例代码如下。

```python
@app.route('/delete-orphan')
def delete_orphan_view():
    category = Category.query.first()
    news = News(title="新闻2", content="新闻内容2")
    category.newses.append(news)
    db.session.commit()

    # 将news从category中解除关联
    category.newses.remove(news)
    db.session.commit()
    return "success"
```


以上代码中，首先将news添加到`category.newses`中，然后通过commit操作提交到数据库中。

接着从`category.newses`中移除，这样就把news从category上解除了关联，因为在Category中定义newses属性时，设置了cascade为delete-orphan，那么一旦解除关联，news对象就成为孤儿(orphan)对象，即会自动从数据库中被删除。

**这个选项一般用在一对多关系上，不能用在多对多以及多对一关系上。**

如例子中的Category和News, Category属于“一”，News属于“多”。

删除分类，该分类下的新闻也被删除了，这符合常理，但是如果新闻被删除了，分类也跟着删除，这就会造成数据混乱。


访问`http://127.0.0.1:5000/delete-orphan`，此时会将新闻从分类中移除，分类中的新闻被删除，新闻也跟着删除。




#### 4.merge

merge是默认选项。

在使用session.merge合并对象时，会将使用了db.relationship相关联的对象也进行merge操作。

具体来说，在定义数据库表模型时，如果两个表之间存在主外键关系，并且你希望当父表中的某条记录发生修改时，关联的子表中的相应记录也能够自动更新，就可以使用 cascade="merge"。


```python
class Category(db.Model):
    __tablename__ = "category"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(100))
    newses = db.relationship("News", back_populates="category", cascade="merge")


class News(db.Model):
    __tablename__ = "news"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    category_id = db.Column(db.Integer, db.ForeignKey("category.id"))
    category = db.relationship("Category", back_populates="newses", cascade="save-update")
```


```python
@app.route("/merge")
def merge_view():
    news1 = News.query.first()

    category = Category(name="分类2")
    news2 = News(title="标题2", category=category)

    # 将news2.id设置为news1.id，在merge的时候就会根据news2的id去寻找需要merge的对象
    # 这里需要merge的就是news1，然后将news2上和news1上不同的数据复制到news1上
    news2.id = news1.id
    db.session.merge(news2)
    db.session.commit()

    return "新闻合并成功"
```

访问`http://127.0.0.1:5000/merge`





#### 5.expunge

进行移除操作时，会将相关联的对象也进行移除。这个操作只是将对象从session中移除，并不会真正地从数据库中删除。



我们首先将News模型中category属性的cascade参数修改为如下。

```python
class Category(db.Model):
    __tablename__ = "category"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(100))
    newses = db.relationship("News",back_populates="category",cascade="merge")


class News(db.Model):
    __tablename__ = "news"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(100))
    content = db.Column(db.Text)
    category_id = db.Column(db.Integer,db.ForeignKey("category.id"))
    category = db.relationship("Category",back_populates="newses", cascade="expunge")
```


然后执行以下操作。

```python
@app.route("/expunge")
def expunge_view():
    news = News.query.first()
    category = news.category

    db.session.expunge(news)
    category.name = '测试分类'
    db.session.commit()

    return "expunge success"
```

访问`http://127.0.0.1:5000/expunge`

上述代码中，使用`db.session.expunge方法`将news对象从session中移除，因为news和category级联关系中设置了expunge选项，

所以category对象也会跟着从session中移除，此时再去修改category.name的值，就不会同步到数据库中了。

我们可以在执行上述代码前观察第一条新闻分类的名称，执行完上述代码后再观察，会发现分类名称没有发生变化。


#### 6.all

all是对save-update、merge、expunge、delete的缩写，不包含delete-orphan。



#### 7.默认值

cascade在没有被修改时的默认值是save-update和merge。



!!! abstract  "参考文献"

  [Flask-SQLAlchemy 一对多关系级联删除](https://www.cnblogs.com/yoyoketang/p/16751295.html)





## 5.4 ORM模型迁移


ORM模型定义好后，是通过`db.create_all`将ORM模型映射到数据库中的。

这种方式是有局限性的，它只能识别到新增了模型后映射到数据库中的对于模型中字段的修改，对于类型的修改，无法识别到。


因此在实际开发中，都不会使用`db.create_all`来做ORM模型迁移，而是借助一个第三方插件`Flask-Migrate`来实现。

`Flask-Migrate`是基于`alembic`实现的，alembic是专门用来给SQLAlchemy的ORM模型做迁移的。

要使用Flask-Migrate，首先需要通过pip命令安装。

```shell
pip install flask-migrate
```


alembic会随着flask-migrate安装而自动安装。在完成flask-migrate安装后，接下来讲解如何配置。



### 5.4.1 创建迁移对象

首先看创建迁移对象的代码，如下所示。

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
app = Flask(__name__)
# ...
db = SQLAlchemy(app)
migrate = Migrate(app,db)
```

以上代码中，首先从flask_migrate包中导入Migrate类，然后实例化这个类，在实例化时传入app和db对象，并且赋值给migrate变量。

后续在执行迁移命令时，Flask-Migrate会自动读取app.py中的migrate变量，所以变量名必须为migrate。



### 5.4.2 初始化迁移环境

```shell
flask db init
```

命令执行完成后，会在项目的根路径下生成一个migrations文件夹，在这个文件夹下有以下文件或文件夹。

1. versions：文件夹，用于存放后面生成的迁移脚本文件。由于目前没有生成过任何迁移脚本，因此是一个空的文件夹。
2. alembic.ini：alembic的配置文件。
3. env.py：配合Flask项目进行迁移的Python文件。
4. script.py.mako：生成迁移脚本的模板文件。

以上4个文件或文件夹，除非你自己非常清楚要做什么，否则强烈建议不要自行修改里面的内容。到目前为止，初始化迁移环境的工作就已经完成。

此工作只需做一次，后续只要不断生成迁移脚本和映射脚本即可，无须重复初始化。


### 5.4.3 生成迁移脚本


```shell
flask db migrate -m "备注信息"
```
备注信息不是必需的，如果不想添加，则把-m参数以及后面的内容都删除即可。

在执行完以上命令后，可以看到versions文件夹中新增了一个Python脚本文件，这个脚本文件中记录了此次修改的变更内容。


### 5.4.4 执行迁移脚本

迁移脚本只是写好了表变更的内容，但是并没有更新数据库。因此还需要执行迁移脚本将这些改变真正映射到数据库中，执行迁移脚本的命令如下。

```shell
flask db upgrade
```


以上命令会自动从versions文件夹中寻找最新的迁移脚本文件，然后执行迁移脚本文件中的upgrade函数。在这步工作完成后，模型的修改就能真正映射到数据库中了。


使用flask-migrate做ORM模型迁移时，有一点需要注意，**被迁移的ORM模型必须被app.py直接或间接加载**。


如为了代码更加有序，**我们一般会把ORM模型放到models.py文件中**，如果这个models.py文件没有被app.py直接或间接加载，那么其中的ORM模型将不能被flask-migrate识别到，也就不会参与迁移。




### 5.4.5 总结-速记

执行迁移命令，先设置环境变量, 如果启动文件是app.py 这步可以省略。


设置环境变量指定启动文件

```shell 
#windows用 set 设置环境变量
set FLASK_APP=app.py 

# linux 用 export 设置环境变量
export FLASK_APP=app.py 
```




执行相关命令

```shell
flask db init     # 生成迁移文件夹  只执行一次
flask db migrate  # ⽣成迁移版本, 保存到迁移文件夹中
flask db upgrade  # 执行迁移
```



!!! abstract  "参考文献"

  [flask-migrate数据迁移](https://www.cnblogs.com/yoyoketang/p/16622333.html)






## 5.5 SQLAlchemy-serializer


SQLAlchemy-serializer（ORM序列化）


在前后端分离项目中，经常需要把ORM模型转化为字典，再将字典转化为JSON格式的字符串。

在遇到`sqlalchemy_serializer`之前，我都是通过类似Java中的反射原理，获取当前ORM模型的所有字段，然后写一个`to_dict`方法来将字段以及他的值封装成字典。大概的代码如下所示：

```python
def to_dict(self):
  return {c.name: str(getattr(self, c.name)) for c in self.__table__.columns}
```


示例代码如下：

```python
class User(db.Model):
    __tablename__ = "user"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(100))
    password = db.Column(db.String(100))
    # articles = db.relationship("Article")
    extension = db.relationship("UserExtension", back_populates="user", uselist=False)

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "password": self.password
        }

```

这种做法虽然一定程度上方便了开发，但也是带着枷锁跳舞，存在以下几个弊端：
1. 无法优雅的排除不需要序列化的字段。
2. 无法优雅的序列化多表之间的关系。

直到后来我遇到了`sqlalchemy_serializer`，眼前一亮，这不就是我苦苦寻找的ORM模型序列化库吗？使用他序列化ORM模型，让我带你看看有多爽!


### 5.5.1 安装

```shell
pip install SQLAlchemy-serializer
```


### 5.5.2 基本使用


如果想要让某个ORM模型能被序列化，那么只需要在定义模型的时候，让他继承自`sqlalchemy_serializer.SerializerMixin`即可，示例代码如下：


```python
from sqlalchemy_serializer import SerializerMixin

class UserModel(db.Model, SerializerMixin):
    __tablename__ = "user"
    id = db.Column(db.String(100), primary_key=True, default=shortuuid.uuid)
    email = db.Column(db.String(50), unique=True, nullable=False)
    username = db.Column(db.String(50), nullable=False)
    password = db.Column(db.String(200), nullable=False)
```


SerizlizerMixin会给ORM模型添加一个`to_dict`方法，此时你可以通过一行代码将ORM模型序列化成字典：

```python
user = UserModel.query.filter(User.username.contains("张三")).one()
user_dict = user.to_dict()
```

上述代码中将把`UsrModel`中所有字段都序列化成字典。





### 5.5.3 排除字段

模型中有的字段不需要被序列化，比如用户的密码，那么这时候可以通过设置`rules`参数，或者`only`参数来指定序列化规则。比如排除password，那么可以通过如下代码方式实现：

```python
user = UserModel.query.filter(...).one()
user_dict = user.to_dict(rules=('-password',))
```

上述代码中在调用to_dict方法的时候，传递了`rules`参数，并且设置了`-password`，其中的-号代表排除的意思，意思是不要序列化password。


如果在绝大部分场景下都不需要某些字段，可以把这个规则写在模型定义中，这样所有序列化的时候，都会遵循这个序列化规则。比如：

```python
class UserModel(db.Model, SerizlizerMixin):
    serialize_rules = ("-password", )
    __tablename__ = "user"
    id = db.Column(db.String(100), primary_key=True, default=shortuuid.uuid)
    email = db.Column(db.String(50), unique=True, nullable=False)
    username = db.Column(db.String(50), nullable=False)
    password = db.Column(db.String(200), nullable=False)
```


如果需要排除的字段太多了，我们可以通过设置serialize_only属性来标记仅仅序列化某些字段。比如：


```python
class UserModel(db.Model, SerizlizerMixin):
    # 只序列化id和username两个字段
    serialize_only = ("id", "username")
    __tablename__ = "user"
    id = db.Column(db.String(100), primary_key=True, default=shortuuid.uuid)
    email = db.Column(db.String(50), unique=True, nullable=False)
    username = db.Column(db.String(50), nullable=False)
    password = db.Column(db.String(200), nullable=False)
```



### 5.5.4 递归序列化模型和树

`sqlalchemy_serializer`会默认序列化定义好关系的模型，比如有UserModel和PostModel两个模型：


```python
class UserModel(db.Model, SerizlizerMixin):
    serialize_rules = ("-posts",)
    __tablename__ = "user"
    id = db.Column(db.String(100), primary_key=True, default=shortuuid.uuid)
    username = db.Column(db.String(50), nullable=False)
    
class PostModel(db.Model, SerializerMixin):
    __tablename__ = "post"
    id = db.Column(db.String(100), primary_key=True, default=shortuuid.uuid)
    title = db.Column(db.String(100), nullable=False)
    content = db.Column(db.Text, nullable=False)
    author_id = db.Column(db.String(100), db.ForeignKey("user.id"))
    
    author = db.relationship("UserModel", backref="posts")
```

在序列化PostModel的时候，也会自动递归序列化`author`，并且author的值有`id`和`username`两个字段。


这里有个细节需要注意，就是UserModel必须要排除posts。


因为PostModel中的author字段，通过backref给UserModel绑定了一个posts字段，如果不排除posts，那么在序列化author的时候，又会序列化posts，造成循环递归序列化。




### 5.5.5 高级用法

基本上学会以上用法后，99%的场景都没有问题了。

如果你在使用sqlalchemy_serializer还有其他业务需求，比如格式化日期的输出、字段扁平化等，那么可以再仔细阅读一下`sqlalchemy_serializer`的[官方文档](https://github.com/n0nSmoker/SQLAlchemy-serializer)。


- 格式化日期的输出

你可以定义一个自定义的序列化转换函数来处理日期字段。例如，假设你有一个 UserModel 模型类，其中包含一个 created_at 字段表示用户创建时间，你可以按照以下方式处理日期字段：

代码示例

```python
from sqlalchemy_serializer import SerializerMixin
from datetime import datetime

class UserModel(db.Model, SerializerMixin):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100))
    created_at = db.Column(db.DateTime)

    def to_dict(self):
        data = super().to_dict()
        data['created_at'] = self.created_at.strftime('%Y-%m-%d')
        return data
```

在上述示例中，我们通过继承 SerializerMixin 类，使 UserModel 模型类具备了序列化的功能。然后，我们重写了 `to_dict()` 方法，将 `created_at` 字段通过 `strftime()` 方法格式化为需要的日期字符串形式。


- 字段扁平化

如果你希望将嵌套的字段扁平化，可以在序列化时进行处理。例如，假设你的 UserModel 类中包含一个 `address` 字段，它是一个嵌套的字典类型，你希望将其中的子字段扁平化，可以按照以下方式实现：


代码示例

```python
from sqlalchemy_serializer import SerializerMixin

class UserModel(db.Model, SerializerMixin):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100))
    address = db.Column(db.JSON)

    def to_dict(self):
        data = super().to_dict()
        if 'address' in data:
            address_data = data['address']
            if 'city' in address_data:
                data['city'] = address_data['city']
            if 'street' in address_data:
                data['street'] = address_data['street']
            del data['address']
        return data
```

在上述示例中，在重写的 `to_dict()` 方法中，我们先通过 `super().to_dict()` 获取父类的序列化结果，然后对于 address 字段进行扁平化处理。我们将嵌套字典中的 `city` 和 `street` 字段提取到顶层，然后删除原始的 `address` 字段。





### 5.5.6 demo示例代码

```python
@app.route("/user/fetch")
def user_fetch():
    # 获取主键为1的User对象
    user = User.query.get(1)
    user_dict = user.to_dict() if user else None  # 如果user存在，则转换为字典，否则为None

    print("数据提取成功")
    response = jsonify({"user": user_dict})
    return response, 200

from sqlalchemy_serializer import SerializerMixin


class User(db.Model, SerializerMixin):
    __tablename__ = "user"
    # 排除序列化显示字段
    # serialize_rules = ("-password",)
    # 设置serialize_only属性来标记仅仅序列化
    serialize_only = ("id", "username")
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(100))
    password = db.Column(db.String(100))
    # articles = db.relationship("Article")
    extension = db.relationship("UserExtension", back_populates="user", uselist=False)
```


访问`http://127.0.0.1:5000/user/fetch`返回数据如下：



```json
{
  "user": {
    "id": 1,
    "username": "\u5f20\u4e09"
  }
}
```
