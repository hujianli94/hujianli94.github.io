# 1.Devops 与自动化运维的意义

## 1.1 为什么企业需要自动化运维?

总结一下自动化运维可能带来的好处？

- 消除无效率： 运维工作的手动工作，如果可以实现自动化，将显著提升效率水平
- 减少错误：使用自动化运维工具来完成常规操作可以将错误率大大降低
- 最大化员工使用：避免雇佣更多的员工来应对工作量增加的需求，同样一批人有自动化运维，就有更大的能量创造价值。
- 提高满意度水平: 自动化运维工具帮助 IT 运维，可以为内部员工和外部客户提供高水平支持，更好地拥抱 SLA。
- 降低成本：系统中断、人为错误、重复工作，会导致不菲的费用和代价，而自动化运维几乎可以将这些成本完全消除。

> 注意
> 服务品质协议（service-level agreement, SLA)是服务提供者与客户之间的一个正式合同，用于保证可计量的网络性能达到其所定义的品质。

## 1.2 Web 编程相关体系知识点

### 1.2.1 为什么要前后端分离?

对于传统的一体式 Web 架构，大家会发现，业务逻辑处理单独分离出来了，交由后端统一处理，如果从软件开发的层面上来理解，则前端与后端分别处理如下内容。

> 前端：负责 View 和 Controller 层。

> 后端：只负责 Model 层，进行业务处理和数据处理等。

（1）前后职责分离

前端倾向于呈现，着重处理用户体验相关的问题；后端则倾向于处理业务逻辑、数据处理和持久化等相关的问题。在设计清晰的情况下，后端只需要以数据为中心对业务处理算法负责，并按约定为前端提供 API；而前端则使用这些接口对用户体验负责即可。

（2）前后技术分离

前端可以不用了解后端技术，也不必关心后端具体的实现技术，只需要会 HTML、CSS、JavaScript 就能入手；而后端只需要关心后端的开发技术，这样就省去了学习前端技术的麻烦，连 Web 框架的学习研究都只需要关注 Web API 即可，而不用去关注基于页面视图的 MVC 技术（并不是说不需要 MVC 技术，Web API 的数据结构呈现也是 View），不用考虑特别复杂的数据组织和呈现。

（3）前后分离带来了用户体验和业务处理解耦

前端可以根据用户不同时期的体验需求迅速改版，对后端毫无影响。同理，后端进行的业务逻辑升级，数据持久方案变更，只要不影响到接口，前端也可以毫不知情。当然如果是需求变更引起了接口变化，那么前后端又需要在一起进行信息同步了。

（4）前后分离，可以分别归约两端的设计

后端只提供 API 服务，而不必考虑页面呈现的问题。实现 SOA 架构的 API 可以服务于各种前端，而不仅仅是 Web 前端，可以做到一套服务，各端使用。

> 注意
> 自动化运维的开发工作很多都会涉及 API 的封装，所以其更偏后端开发一些。

### 1.2.2 什么是 RESTful?

什么是 REST？

REST（Representational State Transfer）这个概念首次出现是在 2000 年 RoyThomas Fielding（他是 HTTP 规范的主要编写者之一）的博士论文中，它指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful 的。

要理解什么是 REST，我们需要理解如下的几个概念。REST 是"表现层状态转化"，它省略了主语。其实 "表现层" 指的是 "资源" 的 "表现层"。

那么什么是资源（Resources）呢？就是我们平常上网访问的一张图片、一个文档、一个视频等。这些资源我们通过 URI 来定位，也就是一个 URI 表示一个资源。

（1）表现层（Representation）

资源是做一个具体的实体信息，其可以有很多种展现方式。而把实体展现出来就是表现层，例如一个 txt 文本信息，可以输出成 html、json、xml 等格式，一个图片可以通过 jpg、png 等方式展现，这个就是表现层的意思。URI 确定一个资源，但是如何确定它的具体表现形式呢？应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段进行指定，这两个字段才是对“表现层”的描述。

（2）状态转化（State Transfer）

访问一个网站，就代表了客户端和服务器的一个互动过程。这个过程肯定会涉及数据和状态的变化。而 HTTP 是无状态的，那么这些状态肯定会保存在服务器端，所以如果客户端想要通知服务器端改变数据和状态的变化，则肯定是需要通过某种方式来通知它。客户端能通知服务器端的手段，只能是 HTTP。

具体来说，就是 HTTP 里面，有几个操作方式的动词。

HTTP 动词具体包括如下几个。

- GET：从服务器端取出资源（一项或多项）。
- POST：在服务器端新建一个资源。
- PUT：在服务器端更新资源（客户端提供改变后的完整资源）。
- PATCH：在服务器端更新资源（客户端提供改变的属性）。
- DELETE：从服务器端删除资源。
- HEAD：获取资源的元数据。
- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。

RESTful 用一句话可以总结为 URL 定位资源，用 HTTP 动词描述操作。符合 REST 原则的架构方式即称之为 RESTful。

综合上面的解释，我们下面来总结一下什么是 RESTful 架构。

每一个 URI 代表一种资源。

在客户端和服务器之间传递这种资源的某种表现层。

客户端通过 HTTP 动词，对服务器端资源进行操作，实现"表现层状态转化"。

（3）HTTP 状态码对于 HTTP 状态码，大家应该已经很熟了，即服务器向用户返回的状态码和提示信息，常见的 HTTP 状态码如表:

| 状态码 | HTTP 方法                              | 说明                                                                       |
| ------ | -------------------------------------- | -------------------------------------------------------------------------- |
|        |                                        |                                                                            |
|        |                                        |                                                                            |
| 2xx    | 请求成功                               |                                                                            |
| 200    | OK - [GET]                             | 服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。               |
| 201    | CREATED- [POST/PUT/PATCH]              | 用户新建或修改数据成功。                                                   |
| 202    | Accepted - [*]                         | 表示一个请求已经进入后台排队(异步任务)                                     |
| 204    | NO CONTENT - [DELETE]                  | 用户删除数据成功。                                                         |
|        |                                        |                                                                            |
|        |                                        |                                                                            |
| 3xx    | 重定向                                 |                                                                            |
| 301    | NO CONTENT -                           | 永久重定向                                                                 |
| 302    | NO CONTENT -                           | 临时重定向                                                                 |
|        |                                        |                                                                            |
|        |                                        |                                                                            |
| 4xx    | 客户端错误                             |                                                                            |
| 400    | INVALID REQUEST - [POST/PUT/PATCH]     | 用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 |
| 401    | Unauthorized - [*]                     | 表示用户没有权限（令牌、用户名、密码错误）。                               |
| 403    | Forbidden - [*]                        | 表示用户得到授权（与 401 错误相对），但是访问是被禁止的。                  |
| 404    | NOT FOUND - [*]                        | 用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。   |
| 406    | Not Acceptable - [GET]                 | 用户请求的格式不可得（比如用户请求 JSON 格式，但是只有 XML 格式）。        |
| 410    | Gone -[GET]                            | 用户请求的资源被永久删除，且不会再得到的。                                 |
| 422    | Unprocesable entity - [POST/PUT/PATCH] | 当创建一个对象时，发生一个验证错误。                                       |
|        |                                        |                                                                            |
|        |                                        |                                                                            |
| 5xx    | 客户端错误                             |                                                                            |
| 500    | INTERNAL SERVER ERROR - [*]            | 服务器发生错误，用户将无法判断发出的请求是否成功。                         |
| 501    | Not Implemented                        | 服务器不支持请求的功能，无法完成请求                                       |
| 503    | \*                                     | 服务器接收到无效请求                                                       |

### 1.2.3 Web 后台认证机制

HTTP Basic Auth

简言之， HTTP Basic Auth 简单点说就是每次请求 API 时都提供用户的 username 和 password ，是配合 RESTful API 使用的最简单的认证方式，只需提供用户名和密码即可， 但由于存在将用户名和密码暴露给第三方客户端的风险，因此在生产环境下， HTTP BasicAuth 被使用得越来越少 。 因此，在开发对外开放的 RESTful API 时，应尽量避免采用 HTTP Basic Auth 。

OAuth

OAuth(开放授权）是一个开放的授权标准，允许用户让第 三 方应用访问该用户在某－Web 服务上存储的私密的资源（如照片、视频、联系人列表），而无须将用户名和密码提供给第三方应用。

OAuth 允许用户提供一个令牌，而不是根据用户名和密码来访问他们存放在特定服务提供者处的数据 。 每一个令牌授权一个特定的第 三方系统（例如，视频编辑网站）在特定的时间段（例如，接下来的 2 个小时内 ）内访问特定的资源（例如仅仅是某一相册中的视频） 。 这样， OAuth 就使得用户可以授权第 三方网站访问他们存储在另外服务提供者处的某些特定信息，而非所有内容 。

Cookie Auth

Cookie 认证机制就是为一次请求认证在服务器端创建一个 Session 对象，同时在客户端的浏览器端创建一个 Cookie 对象； 通过客户端发送的 Cookie 对象与服务器端的 Session 对象进行匹配来实现状态管理。 默认情况下，当我们关闭浏览器的时候，Cookie 会被删除，但是可以通过修改 Cookie 的 expire time 使 Cookie 在一定时间内有效。

Token Auth

使用基于 Token 的身份验证方法时，服务器端不需要存储用户的登录记录。大概的流程如下所示 。

1). 客户端使用用户名与密码请求登录。

2). 服务器端收到请求，去验证用户名与密码

3). 验证成功后，服务器端会签发一个 Token，再把这个 Token 发送给客户端。

4). 客户端收到 Token 之后可以把它存储起来， 比如放在 Cookie 里或者 Local Storage 里。

5). 客户端每次向服务器端请求资源的时候都需要带着服务器端签发的 Token 。

6). 服务器端收到请求，然后去验证客户端请求中所携带的 Token ，如果验证成功，就向客户端返回请求的数据 。

Token Auth 的优点

Token 机制相对于 Cookie 机制来说，具有如下好处 。

支持跨域访问： Cookie 是不允许跨域访问的，这一点对 Token 机制来说是不存在的，Token 机制支持跨域访问的前提是用户认证信息通过 HTTP 头传输 。

无状态(也称服务器端可扩展行) : Token 机制在服务器端不需要存储 Session 信息，因为 Token 自身包含了所有登录用户的信息，因此只需要在客户端的 Cookie 或本地介质中存储状态信息即可 。

更适用 CDN ：可以通过内容分发网络请求你服务器端的所有资料（如 JavaScri pt 、HTML 及图片等），而你的服务器端只要提供 API 即可。

去藕 ：不需要绑定到 一个特定 的身份验证方案 。 Token 可以在任何地方生成，当你的 API 被调用的时候， 直接进行 Token 生成调用即可。

更适用于移动应用： 当我们的客户端是一个原生平台(iOS 、 Android 或 Wi ndows 8 等时， Cookie 是不被支持的（需要通过 Cookie 容器进行处理），这时采用 Token 认证机制就会简单得多。

CSRF：因为不再依赖于 Cookie，所以 Token 机制不需要考虑对 CSRF(跨站请求伪造)的防范。

性能： 一次网络往返时间（通过数据库查询 Session 信息）总比做一次 HMACSHA256 计算的 Token 验证和解析要费时得多。

不需要为登录页面做特殊处理： 如果使用的是 Protractor 做功能测试，那么我们 不再需要为登录页面做特殊处理。

基于标准化： 这个标准已经存在多个后端库（如 .NET 、 Ruby 、 Java 、 Python 和 PHP)和多家公司的支持（如 Firebase 、 Google 和 Microsoft） 。

参考文档： http://www.cnblogs.com/xiekeli/p/5607107.html

### 1.2.4 同步和异步、阻塞与非阻塞的区别

#### 同步与异步

所谓的同步，就是在发出一个“调用”时，在没有得到结果之前，该“调用”不返回； 但是一旦调用返回，就会得到返回值了。换句话来说就是“调用者”主动等待这个“调用”的结果。

而异步则正好相反，在发出“调用”之后这个“调用”就直接返回了，所以没有返回结果。

换句话说当一个异步过程发出“调用”之后，“调用者”不会立即得到结果，而是在“调用”发出之后， “被调用者”通过状态、通知来通知调用者，或通过回调函数来处理这个调用。

举例：

同步：
你打电话去报刊亭买报纸，你问报刊亭的老板,有抖音相关的报纸吗？老板就跟你说：我去查阅一下，你在电话这边一直等着。
然后老板开始找报纸，找报纸的过程可能是 1 个小时，也可能是 1 天，期间你一直等待着。老板找到后告诉你找到了，让你过来买。

异步：
你去报刊亭买报纸，你问报刊亭的老板,有抖音相关的报纸吗？老板就跟你说：你回去等我电话，我找到了就打你电话，就挂了电话，给了你一个通知，
老板找到后主动给你打电话，让你带钱过来拿报纸。

#### 阻塞与非阻塞

阻塞与非阻塞关注的是程序在等待调用结果（消息、返回值）时的状态。

阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才返回。

非阻塞调用是指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子：

阻塞： 当你打电话到报刊亭问有没有抖音相关的报纸的时候，你会一直把自己"挂起"，知道得到有没有这本书的结果。

非阻塞： 你不用考虑老板有没有找到报纸，你自己先去做别的事，当然偶尔过几分钟也会来检查老板有没有返回结果，这里的阻塞与非阻塞与是否同步异步无关，也与老板回答你结果的方式无关。期间你是可以处理其他事情的。

### 1.2.5 从事 Devops 应该掌握的语言

- shell

- Python

- Go

#### 比较 Python 与 Go

比较 Python 与 Go，看看 Go 语言的优势在哪里：

1）部署简单：Go 语言编译生成一个静态可执行文件，除了 glibc 之外再没有其他的外部依赖，这也是部署变得异常方便：目标机器上只需要一个基础的系统和必要的管理、监控工具，完全不用操心应用所需的各种包、库的依赖关系，大大减轻了维护的负担。

2）并发性好，天生支持高并发：Goroutine 和 Channel 使得编写高并发的服务端软件变得相当容易，很多情况下完全不需要考虑锁机制以及由此带来的各种问题。

单个 Go 应用也能有效地利用多个 CPU 核，其并行执行能力很好。是 Python 不能相比的，多线程和多进程的服务编写起来并不简单，而且由于 Python 全局锁 GIL 的原因，多线程并不能有效利用多核，只能用多进程的方式进行部署，在很多场景下这并不能有效的利用计算机资源，这也是饱受 Python 爱好者诟病的地方。

3）良好的语言设计：有其他语言基础能迅速上手，有大量标准库和三方库。Go 自带完善的工具链。

4)执行性能好: Go 语言虽然不如 C 和 Java，但是比原生 Pyhton 应用还是高一个数量级的，适合编写一些瓶颈业务，内存占用也非常低。

#### Go 语言的应用场景

Go 语言的应用场景:

1.服务器编程，如果之前使用 C 或者 C++进行服务器编程，那么使用 Go 来做也很合适。例如日志处理系统、数据打包、虚拟机处理、文件系统等

2.分布式存储、数据库代理器等

3.Key-Value 存储，例如工作中常见的 etcd

4.网络编程，目前这一块应用最广，包括 Web 应用、API 应用、下载应用等

5.内存数据库、前一段时间 google 开发 groupcache 等。

6.游戏服务端的开发。

7.云平台，目前国内很多云平台都使用 Go 开发，例如国外的 CloudFoundy、Apcera 云平台和国内的青云、七牛云等。

平常的 Devops 中，除了使用 Python 之外，还可以使用 Go 语言来编写某些项目需求，或自动化运维的 API。

### 1.2.6 从事 DevOps 工作应该掌握的工具

#### 版本控制管理(SCM)

Github、GitLab、SubVersion，考虑到汉化和网络方面的原因，国内企业在 Github 和 GitLab 之间进行选择的时候，一般是选择 GitLab

#### 构建工具

Ant、Gradle、Maven。Maven 除了以程序构建能力为特色之外，还提供了高级项目管理工具。

#### 持续集成

Jenkins，大名鼎鼎的软件，基本上是 CI 的代名词。Jenkins 是全球最留下的持续集成工具，国内某社区曾经调研 Jenkins 在国内的使用率为 70%左右。

#### 配置管理

Ansible、Chef、Puppet、SaltStack，这些都是自动化运维工作中常见的工具。

#### 虚拟化

Xen 或 KVM、Vagrant

#### 容器

Docker 、LXC 、第三方厂商如 AWS ,这里需要注意 Docker 与 Vagrant 的区别。

#### 服务注册与发现

zookeeper 、etcd 。

#### 日志管理

大家都很熟悉的 ELK。

#### 日志收集系统

Fluentd 、Hekao。

#### 压力测试

JMeter 、Blaze Meter 、loader.io。

#### 消息中间件

ActiveMQ 、RabbitMQ 。

事实上，很多 DevOps 工具在这里尚未罗列出来,在工具的选择上，需要结合公司业务需求和技术团队情况而定，毕竟适合自己的才是最好的。
