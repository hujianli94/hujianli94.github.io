# 3.IPv6-Unix 域套接字和网络接口

## 1.把本地端口转发到远程主机

有时，你需要创建一个本地端口转发器，把本地端口发送的流量全部重定向到特定的远程主机上。

利用这个功能，可以让用户只能访问特定的网站，而不能访问其他网站。

我们来编写一个本地端口转发脚本，把 8800 端口接收到的所有流量重定向到百度的首页（http://www.baidu.com）。

我们可以把本地主机和远程主机连同端口号一起传入脚本。简单起见，这里只指定本地端口号，因为我们知道 Web 服务器运行在 80 端口上。

`3_1_port_forwarding.py`

```python
#!/usr/bin/env python3
# Python Network Programming Cookbook, Second Edition -- Chapter - 3
# This program is optimized for Python 3.5.2 and newer versions.

import argparse
import asyncore
import socket

LOCAL_SERVER_HOST = 'localhost'
REMOTE_SERVER_HOST = 'www.baidu.com'
BUFSIZE = 4096


class PortForwarder(asyncore.dispatcher):

    def __init__(self, ip, port, remoteip, remoteport, backlog=5):
        """
        :param local_ip: 本地IP地址
        :param local_port: 本地端口
        :param remote_ip: 远程IP地址
        :param remote_port: 远程端口
        :param backlog:    监听队列的最大长度
        """
        super().__init__()
        self.remoteip = remoteip
        self.remoteport = remoteport
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind((ip, port))
        self.listen(backlog)

    def handle_accept(self):
        conn, addr = self.accept()
        print("Connected to:", addr)
        Sender(Receiver(conn), self.remoteip, self.remoteport)


class Receiver(asyncore.dispatcher):
    """
    接收类处理传入的客户端请求
    """

    def __init__(self, conn):
        super().__init__(conn)
        self.from_remote_buffer = b''
        self.to_remote_buffer = b''
        self.sender = None

    def handle_read(self):
        read = self.recv(BUFSIZE)
        self.from_remote_buffer += read

    def writable(self):
        return len(self.to_remote_buffer) > 0

    def handle_write(self):
        sent = self.send(self.to_remote_buffer)
        self.to_remote_buffer = self.to_remote_buffer[sent:]

    def handle_close(self):
        self.close()
        if self.sender:
            self.sender.close()

    def modify_request_headers(self, data):
        """
        HTTP 请求头可能需要特定的格式或包含某些必要的字段。你可以尝试在 Receiver 类中修改请求头。
        """
        # 添加或修改请求头
        headers = data.split(b'\r\n')
        modified_headers = []
        for header in headers:
            if header.lower().startswith(b'host:'):
                modified_headers.append(f"Host: {REMOTE_SERVER_HOST}".encode('utf-8'))
            else:
                modified_headers.append(header)
        return b'\r\n'.join(modified_headers) + b'\r\n\r\n'

    def handle_read(self):
        read = self.recv(BUFSIZE)
        if b'\r\n\r\n' in read:  # 检查是否为完整的 HTTP 请求
            request_line, headers = read.split(b'\r\n\r\n', 1)
            modified_request = self.modify_request_headers(request_line)
            self.from_remote_buffer = modified_request + headers
        else:
            self.from_remote_buffer += read


class Sender(asyncore.dispatcher):
    """
    发送类接收 接收类并处理向客户发送数据
    """

    def __init__(self, receiver, remoteaddr, remoteport):
        super().__init__()
        self.receiver = receiver
        receiver.sender = self
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect((remoteaddr, remoteport))

    def handle_read(self):
        read = self.recv(BUFSIZE)
        self.receiver.to_remote_buffer += read

    def writable(self):
        return len(self.receiver.from_remote_buffer) > 0

    def handle_write(self):
        sent = self.send(self.receiver.from_remote_buffer)
        self.receiver.from_remote_buffer = self.receiver.from_remote_buffer[sent:]

    def handle_close(self):
        self.close()
        self.receiver.close()


def main():
    parser = argparse.ArgumentParser(description='Stackless Socket Server Example')
    parser.add_argument('--local-host', action="store", dest="local_host", default=LOCAL_SERVER_HOST)
    parser.add_argument('--local-port', action="store", dest="local_port", type=int, required=True)
    parser.add_argument('--remote-host', action="store", dest="remote_host", default=REMOTE_SERVER_HOST)
    parser.add_argument('--remote-port', action="store", dest="remote_port", type=int, default=80)
    given_args = parser.parse_args()

    if not 1 <= given_args.local_port <= 65535:
        print("Invalid local port")
        return

    if not 1 <= given_args.remote_port <= 65535:
        print("Invalid remote port")
        return

    local_host, remote_host = given_args.local_host, given_args.remote_host
    local_port, remote_port = given_args.local_port, given_args.remote_port

    print(f"Starting port forwarding local {local_host}:{local_port} => remote {remote_host}:{remote_port}")
    PortForwarder(local_host, local_port, remote_host, remote_port)
    asyncore.loop()


if __name__ == "__main__":
    main()
```

原理分析

我们创建了一个端口转发类 PortForwarder ，继承自 asyncore.dispatcher 。

asyncore.dispatcher 类包装了一个套接字对象，还提供了一些帮助方法用于处理特定的事件，例如连接成功或客户端连接到服务器套接字。

你可以选择重定义这些方法，在上面的脚本中我们只重定义了 `handle_accept()` 方法。

另外两个类也继承自 asyncore.dispatcher 。 Receiver 类处理进入的客户端请求，Sender 类接收一个 Receiver 类实例，把数据发送给客户端。

如你所见，这两个类都重定义了 `handle_read()` 、 `handle_write()` 和 `writeable()` 三个方法，目的是实现远程主机和本地客户端之间的双向通信。

概括来说， PortForwarder 类在一个本地套接字中保存进入的客户端请求，然后把这个套接字传给 Sender 类实例，再使用 Receiver 类实例发起与远程主机指定端口之间的双向通信。

运行这个脚本后，会看到如下输出：

```sh
## server
# (py38) root@hujianli722# python 3_1_port_forwarding.py --local-port=8800
# Starting port forwarding local localhost:8800 => remote www.baidu.com:80
# Connected to: ('127.0.0.1', 38557)
```

现在打开浏览器，访问 http://localhost:8800。浏览器会把你带到百度的首页，在命令行中会输出类似下面的信息：

```sh
# client connected
# (py38) root@hujianli722# curl  localhost:8800
# <!DOCTYPE html>
# <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc> <div id=wrapper> <div id=head> <div class=head_wrapper> <div class=s_form> <div class=s_form_wrapper> <div id=lg> <img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129> </div> <form id=form name=f action=//www.baidu.com/s class=fm> <input type=hidden
# ...
# ....
```

## 2.通过 ICMP 查验网络中的主机

ICMP 查验（ICMP ping） 是你见过的最普通的网络扫描类型。

ICMP 查验做起来很简单，打开命令行或终端，输入 ping www.google.com 即可。

这在 Python 程序中又有什么难的呢？

这个攻略展示了一个简单的 Python 查验脚本。

你可以偷个懒，在 Python 脚本中调用系统中的 ping 命令，如下所示：

### 单线程

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import subprocess
import shlex

command_line = "ping -c 1 www.baidu.com"
args = shlex.split(command_line)
try:
    subprocess.check_call(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    print("Google web server is up!")
except subprocess.CalledProcessError:
    print("Failed to get ping.")
```

### 多线程

```python
# -*- coding: utf-8 -*-
import _thread
import time
from subprocess import Popen, PIPE
import sys

def ping_check(ip):
    check = Popen("ping {0} \n".format(ip), stdin=PIPE, stdout=PIPE, shell=True)
    data = check.stdout.read()  #数据
    data = data.decode("gbk")   #编码转换:byte->str
    if 'TTL' in data: #存活
        sys.stdout.write('%s is UP \n' % ip)

#主函数
if __name__ == '__main__':
    #寻找目标 ichunqiu  192.168.2.240
    for i in range(1,255):
        ip = '192.168.2.' + str(i)
        #多线程方法
        _thread.start_new_thread(ping_check, (ip, ))
        time.sleep(0.1)
```

然而，很多情况下，系统中的 ping 可执行文件不可用，或者无法访问。

### ping 命令的实现

此时，我们需要一个纯粹的 Python 脚本实现查验。注意，这个脚本要使用超级用户或者管理员的身份运行。

```python
#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
import select
import socket
import struct
import sys
import os
import time
import argparse

SUCCESS = 0
FAILED = 1

if sys.platform.startswith("win32"):
    timer = time.clock
else:
    timer = time.time


class Response():
    """
    Reponse of ping
    """

    def __init__(self):
        self.max_rtt = None
        self.min_rtt = None
        self.avg_rtt = None
        self.packet_lost = None
        self.ret_code = None
        self.messages = []

        self.packet_size = None
        self.timeout = None
        self.dest = None
        self.dest_ip = None

    # def __str__(self):
    #     return str(self.to_dict())

    def to_dict(self):
        return {
            "max_rtt": self.max_rtt,
            "min_rtt": self.min_rtt,
            "avg_rtt": self.avg_rtt,
            "packet_lost": self.packet_lost,
            "ret_code": self.ret_code,
            "packet_size": self.packet_size,
            "timeout": self.timeout,
            "dest": self.dest,
            "dest_ip": self.dest_ip,
        }

    def is_reached(self):
        return self.ret_code == SUCCESS

    def print_messages(self):
        for msg in self.messages:
            print(msg)


class Ping():

    def __init__(self, timeout=1000, packet_size=55, own_id=None, udp=False, bind=None, quiet=True):
        self.timeout = timeout
        self.packet_size = packet_size
        self.own_id = own_id
        self.udp = udp
        self.bind = bind
        self.quiet = quiet

        if own_id is None:
            self.own_id = os.getpid() & 0xFFFF

        self.max_wait = 1000  # ms
        self.seq_number = 0

        # self.icmp_echo_reply = 0
        self.icmp_echo = 8
        self.icmp_max_recv = 2048

    def _to_ip(self, addr):
        """
        If destination is not ip address, resolve it by using hostname
        """
        if self._is_valid_ip(addr):
            return addr
        return socket.gethostbyname(addr)

    def _is_valid_ip(self, addr):
        try:
            socket.inet_aton(addr)
        except socket.error:
            return False
        return True

    def _checksum(self, source_string):
        """
        A port of the functionality of in_cksum() from ping.c
        Ideally this would act on the string as a series of 16-bit ints (host
        packed), but this works.
        Network data is big-endian, hosts are typically little-endian
        """
        count_to = (int(len(source_string) / 2)) * 2
        sum = 0
        count = 0

        # Handle bytes in pairs (decoding as short ints)
        lo_byte = 0
        hi_byte = 0
        while count < count_to:
            if (sys.byteorder == "little"):
                lo_byte = source_string[count]
                hi_byte = source_string[count + 1]
            else:
                lo_byte = source_string[count + 1]
                hi_byte = source_string[count]
            try:  # For Python3
                sum = sum + (hi_byte * 256 + lo_byte)
            except:  # For Python2
                sum = sum + (ord(hi_byte) * 256 + ord(lo_byte))
            count += 2

        # Handle last byte if applicable (odd-number of bytes)
        # Endianness should be irrelevant in this case
        if count_to < len(source_string):  # Check for odd length
            lo_byte = source_string[len(source_string) - 1]
            try:  # For Python3
                sum += lo_byte
            except:  # For Python2
                sum += ord(lo_byte)

        sum &= 0xffffffff  # Truncate sum to 32 bits (a variance from ping.c, which
        # uses signed ints, but overflow is unlikely in ping)

        sum = (sum >> 16) + (sum & 0xffff)  # Add high 16 bits to low 16 bits
        sum += (sum >> 16)  # Add carry from above (if any)
        answer = ~sum & 0xffff  # Invert and truncate to 16 bits
        answer = socket.htons(answer)
        return answer

    def _parse_icmp_header(self, packet):
        """
        Parse icmp packet header to dict
        """
        p = struct.unpack("!BBHHH", packet[20:28])

        icmp_header = {}
        icmp_header["type"] = p[0]
        icmp_header["code"] = p[1]
        icmp_header["checksum"] = p[2]
        icmp_header["packet_id"] = p[3]
        icmp_header["sequence"] = p[4]
        return icmp_header

    def _parse_ip_header(self, packet):
        """
        Parse ip packet header to dict
        """
        p = struct.unpack("!BBHHHBBHII", packet[:20])

        ip_header = {}
        ip_header["version"] = p[0]
        ip_header["type"] = p[1]
        ip_header["length"] = p[2]
        ip_header["id"] = p[3]
        ip_header["flags"] = p[4]
        ip_header["ttl"] = p[5]
        ip_header["protocol"] = p[6]
        ip_header["checksum"] = p[7]
        ip_header["src_ip"] = p[8]
        return ip_header

    def _calc_delay(self, send_time, receive_time):
        """
        Calculate spending time between receveed time and sent time.
        If either sent time or received time is null value, returns -1
        """
        if not send_time or not receive_time:
            return -1
        return (receive_time - send_time) * 1000

    def _echo_message(self, message):
        """
        If quiet option is not enable, print message.
        """
        if self.quiet:
            return
        print(message)

    def _wait_until_next(self, delay):
        if self.max_wait > delay:
            time.sleep((self.max_wait - delay) / 1000)

    def ping(self, dest, times=1):
        """
        Ping to destination host (IP/Hostname)
        `dest` arg is indicate destination (both IP and hostname can be used) to ping.
        `times` args is indicate number of times that pings to destination

        Returns ping response that can be used for checking messages, some paramaeter
        and status such as success or failed.
        """
        response = Response()
        response.timeout = self.timeout
        response.dest = dest

        try:
            dest_ip = self._to_ip(dest)
        except socket.gaierror:
            msg = "ping: cannnot resolve {}: Unknown host".format(dest)
            response.messages.append(msg)
            self._echo_message(msg)
            return response

        if not dest_ip:
            response.ret_code = FAILED
            return response

        response.dest_ip = dest_ip

        # initialize sequence number
        self.seq_number = 0
        delays = []

        msg = "PING {} ({}): {} data bytes".format(dest, dest_ip, self.packet_size)
        response.messages.append(msg)
        self._echo_message(msg)

        for i in range(0, times):
            # create socket to send it
            try:
                my_socket = self.make_socket()
            except socket.error as e:
                etype, evalue, etb = sys.exc_info()
                if e.errno == 1:
                    # Operation not permitted - Add more information to traceback
                    msg = "{} - Note that ICMP messages can only be send from processes running as root.".format(evalue)
                else:
                    msg = str(evalue)
                self._echo_message(msg)
                response.messages.append(msg)
                response.ret_code = FAILED
                return response

            try:
                send_time = self.send(my_socket, dest_ip)
            except socket.error as e:
                msg = "General failure ({})".format(e.args[1])
                self._echo_message(msg)
                response.messages.append(msg)
                my_socket.close()
                return response

            if not send_time:
                response.ret_code = Ping.FAILED
                return response

            receive_time, packet_size, ip, ip_header, icmp_header = self.receive(my_socket)
            my_socket.close()
            delay = self._calc_delay(send_time, receive_time)

            # if receive_time value is 0, it means packet could not received
            if receive_time == 0:
                msg = "Request timeout for icmp_seq {}".format(self.seq_number)
                response.messages.append(msg)
                self._echo_message(msg)
                response.ret_code = FAILED
            else:
                msg = "{} bytes from {}: icmp_seq={} ttl={} time={:.3f} ms".format(
                    packet_size,
                    ip,
                    self.seq_number,
                    ip_header['ttl'],
                    delay
                )
                response.messages.append(msg)
                self._echo_message(msg)
                response.ret_code = SUCCESS
                delays.append(delay)

            response.packet_size = packet_size
            self.seq_number += 1

            self._wait_until_next(delay)

        response.max_rtt = max(delays) if delays else 0.0
        response.min_rtt = min(delays) if delays else 0.0
        response.avg_rtt = sum(delays) / len(delays) if delays else 0.0

        msg = "--- {} ping statistics ---".format(dest)
        response.messages.append(msg)
        self._echo_message(msg)

        msg = "{} packets transmitted, {} packets received, {:.1f}% packet loss".format(
            self.seq_number,
            len(delays),
            (self.seq_number - len(delays)) / self.seq_number * 100
        )
        response.messages.append(msg)
        self._echo_message(msg)

        msg = "round-trip min/avg/max = {:.3f}/{:.3f}/{:.3f} ms".format(
            response.min_rtt, response.avg_rtt, response.max_rtt
        )
        response.messages.append(msg)
        self._echo_message(msg)

        return response

    def make_socket(self):
        """
        Make socket
        """
        if self.udp:
            my_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_ICMP)
        else:
            my_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
        if self.bind:
            my_socket.bind((self.bind, 0))
        return my_socket

    def make_packet(self):
        # Header is type (8), code (8), checksum (16), id (16), sequence (16)
        checksum = 0

        # Make a dummy header with a 0 checksum.
        header = struct.pack(
            "!BBHHH", self.icmp_echo, 0, checksum, self.own_id, self.seq_number
        )

        pad_bytes = []
        start_val = 0x42
        for i in range(start_val, start_val + (self.packet_size - 8)):
            pad_bytes += [(i & 0xff)]  # Keep chars in the 0-255 range
        data = bytearray(pad_bytes)

        checksum = self._checksum(header + data)

        header = struct.pack(
            "!BBHHH", self.icmp_echo, 0, checksum, self.own_id, self.seq_number
        )
        return header + data

    def send(self, my_socket, dest):
        """
        Creates packet and send it to a destination
        Returns `send_time` that is packet send time represented in unix time.
        """
        packet = self.make_packet()
        send_time = timer()
        my_socket.sendto(packet, (dest, 1))
        return send_time

    def receive(self, my_socket):
        """
        receive icmp packet from a host where packet was sent.
        Returns receive time that is time of packet received, packet size, ip address,
        ip header and icmp header both are formatted in dict.
        If falied to receive packet, returns 0 and None
        """
        timeout = self.timeout / 1000
        while True:
            select_start = timer()
            inputready, outputready, exceptready = select.select([my_socket], [], [], timeout)
            select_duration = (timer() - select_start)
            if inputready == []:
                return 0, 0, 0, None, None

            packet, address = my_socket.recvfrom(self.icmp_max_recv)
            icmp_header = self._parse_icmp_header(packet)

            receive_time = timer()

            if icmp_header["packet_id"] == self.own_id:  # my packet
                ip_header = self._parse_ip_header(packet)
                ip = socket.inet_ntoa(struct.pack("!I", ip_header["src_ip"]))
                packet_size = len(packet) - 28
                return receive_time, packet_size, ip, ip_header, icmp_header

            timeout = timeout - select_duration

            if timeout <= 0:
                return 0, 0, 0, None, None


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Python ping')
    parser.add_argument('--target-host', action="store", dest="target_host", required=True)
    given_args = parser.parse_args()
    target_host = given_args.target_host
    # pinger = Ping()
    # response = pinger.ping(target_host)
    # # # 输出是否ping通
    # # print(response.is_reached())
    #
    # # 输出ping结果,默认ping 1 次
    # print(response.print_messages())

    # # 输出ping结果,默认ping 1 次
    # pinger = Ping(quiet=False)
    # print(pinger.ping(target_host))

    # # 输出ping结果,ping 3 次
    pinger = Ping(quiet=False)
    print(pinger.ping(target_host, times=3))
```

以超级用户的身份运行这个脚本，得到的输出如下所示：

```sh
# (wsl-base-py38) (py38) root@hujianli722# python 3_2_ping_remote_host.py --target-host=www.baidu.com
# PING www.baidu.com (183.240.98.198): 55 data bytes
# 47 bytes from 183.240.98.198: icmp_seq=0 ttl=52 time=17.569 ms
# 47 bytes from 183.240.98.198: icmp_seq=1 ttl=52 time=15.370 ms
# 47 bytes from 183.240.98.198: icmp_seq=2 ttl=52 time=15.256 ms
# --- www.baidu.com ping statistics ---
# 3 packets transmitted, 3 packets received, 0.0% packet loss
# round-trip min/avg/max = 15.256/16.065/17.569 ms
# <__main__.Response object at 0x7f14474ad5e0>
```

参考代码:

- https://github.com/satoshi03/pings.git

## 3.等待远程网络服务上线

有时，在网络服务恢复的过程中，可以运行一个脚本检查服务器何时再次上线。

```python
#!/usr/bin/env python
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import socket
import logging
import time
from time import time as now

DEFAULT_TIMEOUT = 120
DEFAULT_SERVER_HOST = 'localhost'
DEFAULT_SERVER_PORT = 22
CHECKHEALTH_INTERVAL = 2


class NetServiceChecker(object):
    """
    Wait for a network service to come online
    """

    def __init__(self, host, port, check_health_interval=None, timeout=DEFAULT_TIMEOUT):
        self.host = host
        self.port = port
        self.check_health_interval = check_health_interval
        self.timeout = timeout
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def __enter__(self):
        return self

    def end_wait(self):
        self.sock.close()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.sock.close()

    def check(self):
        """ check the service """
        if self.timeout:
            end_time = now() + self.timeout

        while True:
            time.sleep(2)
            try:
                if self.timeout:
                    next_timeout = end_time - now()
                    if next_timeout < 0:
                        return False
                    else:
                        print("setting socket next timeout %ss" % round(next_timeout))
                        self.sock.settimeout(next_timeout)
                self.sock.connect((self.host, self.port))
            # handle exceptions
            except socket.timeout as err:
                if self.timeout:
                    logging.error("Timeout occurred: {}".format(err))
                    return False
            except socket.gaierror as err:
                logging.error("Host not found: {}".format(err))
                return False
            except socket.error as err:
                logging.error("Socket error: {}".format(err))
                # return False
            else:  # if all goes well
                self.end_wait()
                return True


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    parser = argparse.ArgumentParser(description='Wait for Network Service')
    parser.add_argument('--host', action="store", dest="host", default=DEFAULT_SERVER_HOST)
    parser.add_argument('--port', action="store", dest="port", type=int, default=DEFAULT_SERVER_PORT)
    parser.add_argument('--check-health-interval', action="store", dest="check_health_interval",type=int,
                        default=CHECKHEALTH_INTERVAL)
    parser.add_argument('--timeout', action="store", dest="timeout", type=int, default=DEFAULT_TIMEOUT)
    given_args = parser.parse_args()
    host, port, timeout = given_args.host, given_args.port, given_args.timeout
    service_checker = NetServiceChecker(host, port, timeout=timeout)
    logging.info(f"Checking for network service {host}:{port}...")
    if service_checker.check():
        logging.info("Service is available again!")
```

如果在你的设备上运行着一个 sshd 服务，运行这个脚本后会看到如下输出,每间隔 2 秒，脚本就会检查一次。如果服务再次上线，脚本就会返回 True，否则会一直等待，直到超时为止。

```sh
# (wsl-base-py38) (py38) root@hujianli722# python 3_3_wait_for_remote_service.py
# INFO:root:Checking for network service localhost:22...
# setting socket next timeout 118s
# INFO:root:Service is available again!
```

现在停止 sshd 进程，再运行这个脚本，然后重启 sshd。此时看到的输出会有所不同，在我的设备上，输出如下：

```sh
# (wsl-base-py38) (py38) root@hujianli722# python 3_3_wait_for_remote_service.py
# INFO:root:Checking for network service localhost:22...
# setting socket next timeout 118s
# ERROR:root:Socket error: [Errno 111] Connection refused
# setting socket next timeout 116s
# ERROR:root:Socket error: [Errno 103] Software caused connection abort
# setting socket next timeout 114s
# ERROR:root:Socket error: [Errno 111] Connection refused
# setting socket next timeout 112s
# ERROR:root:Socket error: [Errno 103] Software caused connection abort
# setting socket next timeout 110s
# ERROR:root:Socket error: [Errno 111] Connection refused
# setting socket next timeout 108s
# ERROR:root:Socket error: [Errno 103] Software caused connection abort
# setting socket next timeout 106s
# INFO:root:Service is available again!
```

原理分析

上述脚本使用 argparse 模块接收用户的输入，处理主机名、端口和超时时间。

超时时间指等待所需网络服务的时间。

这个脚本创建了一个 NetServiceChecker 类实例，然后调用 check()方法。

这个方法计算等待的最后结束时间，并使用套接字的 `settimeout()` 方法控制每次循环的结束时间，即 next_timeout 。

然后 check() 方法调用套接字的 connect() 方法在超时时间到达之前测试所需的网络服务是否可用。

check() 方法还能捕获套接字超时异常，以及比较套接字超时时间和用户指定的超时时间。

## 4.枚举设备中的接口

在 Python 中列出设备中的网络接口并不难。有很多第三方库可以使用，只需几行代码即可。
不过，我们来看一下如何只使用套接字调用完成这一操作。

```python
#!/usr/bi
# n/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import fcntl
import socket
import struct
import os


def get_network_interfaces():
    """
    获取所有网络接口的名称
    """
    return os.listdir('/sys/class/net/')


def get_ip_address(interface):
    """
    获取指定网络接口的IP地址
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        info = fcntl.ioctl(sock.fileno(), 0x8915, struct.pack('256s', bytes(interface, 'utf-8')[:15]))
        return socket.inet_ntoa(info[20:24])
    except IOError:
        return None


def list_interfaces():
    """
    使用 fnctl 模块在你的设备中查询IP地址
    """
    try:
        interfaces = get_network_interfaces()
        for interface in interfaces:
            ip = get_ip_address(interface)
            if ip:
                print(f"Interface: {interface}, IP Address: {ip}")
            else:
                print(f"Interface: {interface} has no IP address")
    except Exception as e:
        print(f"An error occurred: {e}")


if __name__ == '__main__':
    list_interfaces()

```

上述脚本能列出网络接口，输出结果如下：

```sh
# (wsl-base-py38) (py38) root@hujianli722# python 3_4_list_network_interfaces.py
# Interface: eth0, IP Address: 172.22.xxx.xxx
# Interface: lo, IP Address: 127.0.0.1
# Interface: docker0, IP Address: 172.xx.0.1
```

## 5.找出设备中某个接口的 IP 地址

在 Python 网络应用程序中可能需要找出某个网络接口的 IP 地址。

你可以使用 fnctl 模块在你的设备中查询 IP 地址。

```python
#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import socket
import fcntl
import struct


def get_ip_address(ifname):
    """
    获取指定网络接口的IP地址。

    :param ifname: 网络接口名称
    :return: IP地址字符串
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        info = fcntl.ioctl(sock.fileno(), 0x8915, struct.pack('256s', bytes(ifname, 'utf-8')[:15]))
        return socket.inet_ntoa(info[20:24])
    except IOError:
        return None


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Python networking utils')
    parser.add_argument('--ifname', action="store", dest="ifname", required=True)
    given_args = parser.parse_args()
    ifname = given_args.ifname

    try:
        ip_address = get_ip_address(ifname)
        if ip_address:
            print(f"Interface [{ifname}] --> IP: {ip_address}")
        else:
            print(f"Interface [{ifname}] --> No IP address found")
    except Exception as e:
        print(f"An error occurred: {e}")
```

这个脚本的输出只有一行，如下所示：

```sh
# (wsl-base-py38) (py38) root@hujianli722# python 3_5_get_interface_ip_address.py --ifname=eth0
# Interface [eth0] --> IP: 172.22.xx.123
```

原理分析

上述脚本接收一个命令行参数：要查询的 IP 地址的网络接口名。

`get_ip_address()` 函数创建一个套接字对象，然后调用 fnctl.ioctl() 函数利用这个套接字对象查询 IP 信息。

注意,`socket.inet_ntoa()` 函数的作用是，把二进制数据转换成我们熟悉的人类可读的点分格式。
