# 3.IPv6-Unix 域套接字和网络接口

## 1.把本地端口转发到远程主机

有时，你需要创建一个本地端口转发器，把本地端口发送的流量全部重定向到特定的远程主机上。

利用这个功能，可以让用户只能访问特定的网站，而不能访问其他网站。

我们来编写一个本地端口转发脚本，把 8800 端口接收到的所有流量重定向到百度的首页（http://www.baidu.com）。

我们可以把本地主机和远程主机连同端口号一起传入脚本。简单起见，这里只指定本地端口号，因为我们知道 Web 服务器运行在 80 端口上。

`3_1_port_forwarding.py`

```python
#!/usr/bin/env python3
# Python Network Programming Cookbook, Second Edition -- Chapter - 3
# This program is optimized for Python 3.5.2 and newer versions.

import argparse
import asyncore
import socket

LOCAL_SERVER_HOST = 'localhost'
REMOTE_SERVER_HOST = 'www.baidu.com'
BUFSIZE = 4096


class PortForwarder(asyncore.dispatcher):

    def __init__(self, ip, port, remoteip, remoteport, backlog=5):
        """
        :param local_ip: 本地IP地址
        :param local_port: 本地端口
        :param remote_ip: 远程IP地址
        :param remote_port: 远程端口
        :param backlog:    监听队列的最大长度
        """
        super().__init__()
        self.remoteip = remoteip
        self.remoteport = remoteport
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind((ip, port))
        self.listen(backlog)

    def handle_accept(self):
        conn, addr = self.accept()
        print("Connected to:", addr)
        Sender(Receiver(conn), self.remoteip, self.remoteport)


class Receiver(asyncore.dispatcher):
    """
    接收类处理传入的客户端请求
    """

    def __init__(self, conn):
        super().__init__(conn)
        self.from_remote_buffer = b''
        self.to_remote_buffer = b''
        self.sender = None

    def handle_read(self):
        read = self.recv(BUFSIZE)
        self.from_remote_buffer += read

    def writable(self):
        return len(self.to_remote_buffer) > 0

    def handle_write(self):
        sent = self.send(self.to_remote_buffer)
        self.to_remote_buffer = self.to_remote_buffer[sent:]

    def handle_close(self):
        self.close()
        if self.sender:
            self.sender.close()

    def modify_request_headers(self, data):
        """
        HTTP 请求头可能需要特定的格式或包含某些必要的字段。你可以尝试在 Receiver 类中修改请求头。
        """
        # 添加或修改请求头
        headers = data.split(b'\r\n')
        modified_headers = []
        for header in headers:
            if header.lower().startswith(b'host:'):
                modified_headers.append(f"Host: {REMOTE_SERVER_HOST}".encode('utf-8'))
            else:
                modified_headers.append(header)
        return b'\r\n'.join(modified_headers) + b'\r\n\r\n'

    def handle_read(self):
        read = self.recv(BUFSIZE)
        if b'\r\n\r\n' in read:  # 检查是否为完整的 HTTP 请求
            request_line, headers = read.split(b'\r\n\r\n', 1)
            modified_request = self.modify_request_headers(request_line)
            self.from_remote_buffer = modified_request + headers
        else:
            self.from_remote_buffer += read


class Sender(asyncore.dispatcher):
    """
    发送类接收 接收类并处理向客户发送数据
    """

    def __init__(self, receiver, remoteaddr, remoteport):
        super().__init__()
        self.receiver = receiver
        receiver.sender = self
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect((remoteaddr, remoteport))

    def handle_read(self):
        read = self.recv(BUFSIZE)
        self.receiver.to_remote_buffer += read

    def writable(self):
        return len(self.receiver.from_remote_buffer) > 0

    def handle_write(self):
        sent = self.send(self.receiver.from_remote_buffer)
        self.receiver.from_remote_buffer = self.receiver.from_remote_buffer[sent:]

    def handle_close(self):
        self.close()
        self.receiver.close()


def main():
    parser = argparse.ArgumentParser(description='Stackless Socket Server Example')
    parser.add_argument('--local-host', action="store", dest="local_host", default=LOCAL_SERVER_HOST)
    parser.add_argument('--local-port', action="store", dest="local_port", type=int, required=True)
    parser.add_argument('--remote-host', action="store", dest="remote_host", default=REMOTE_SERVER_HOST)
    parser.add_argument('--remote-port', action="store", dest="remote_port", type=int, default=80)
    given_args = parser.parse_args()

    if not 1 <= given_args.local_port <= 65535:
        print("Invalid local port")
        return

    if not 1 <= given_args.remote_port <= 65535:
        print("Invalid remote port")
        return

    local_host, remote_host = given_args.local_host, given_args.remote_host
    local_port, remote_port = given_args.local_port, given_args.remote_port

    print(f"Starting port forwarding local {local_host}:{local_port} => remote {remote_host}:{remote_port}")
    PortForwarder(local_host, local_port, remote_host, remote_port)
    asyncore.loop()


if __name__ == "__main__":
    main()
```

原理分析

我们创建了一个端口转发类 PortForwarder ，继承自 asyncore.dispatcher 。

asyncore.dispatcher 类包装了一个套接字对象，还提供了一些帮助方法用于处理特定的事件，例如连接成功或客户端连接到服务器套接字。

你可以选择重定义这些方法，在上面的脚本中我们只重定义了 `handle_accept()` 方法。

另外两个类也继承自 asyncore.dispatcher 。 Receiver 类处理进入的客户端请求，Sender 类接收一个 Receiver 类实例，把数据发送给客户端。

如你所见，这两个类都重定义了 `handle_read()` 、 `handle_write()` 和 `writeable()` 三个方法，目的是实现远程主机和本地客户端之间的双向通信。

概括来说， PortForwarder 类在一个本地套接字中保存进入的客户端请求，然后把这个套接字传给 Sender 类实例，再使用 Receiver 类实例发起与远程主机指定端口之间的双向通信。

运行这个脚本后，会看到如下输出：

```sh
# server
(py38) root@hujianli722# python 3_1_port_forwarding.py --local-port=8800
Starting port forwarding local localhost:8800 => remote www.baidu.com:80
Connected to: ('127.0.0.1', 38557)
```

现在打开浏览器，访问 http://localhost:8800。浏览器会把你带到百度的首页，在命令行中会输出类似下面的信息：

```sh
# client connected
(py38) root@hujianli722# curl  localhost:8800
<!DOCTYPE html>
<!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc> <div id=wrapper> <div id=head> <div class=head_wrapper> <div class=s_form> <div class=s_form_wrapper> <div id=lg> <img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129> </div> <form id=form name=f action=//www.baidu.com/s class=fm> <input type=hidden
# ...
# ....
```

## 2.通过 ICMP 查验网络中的主机

ICMP 查验（ICMP ping） 是你见过的最普通的网络扫描类型。

ICMP 查验做起来很简单，打开命令行或终端，输入 ping www.google.com 即可。

这在 Python 程序中又有什么难的呢？

这个攻略展示了一个简单的 Python 查验脚本。

你可以偷个懒，在 Python 脚本中调用系统中的 ping 命令，如下所示：

### 单线程

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import subprocess
import shlex

command_line = "ping -c 1 www.baidu.com"
args = shlex.split(command_line)
try:
    subprocess.check_call(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    print("Google web server is up!")
except subprocess.CalledProcessError:
    print("Failed to get ping.")
```

### 多线程

```python
# -*- coding: utf-8 -*-
import _thread
import time
from subprocess import Popen, PIPE
import sys

def ping_check(ip):
    check = Popen("ping {0} \n".format(ip), stdin=PIPE, stdout=PIPE, shell=True)
    data = check.stdout.read()  #数据
    data = data.decode("gbk")   #编码转换:byte->str
    if 'TTL' in data: #存活
        sys.stdout.write('%s is UP \n' % ip)

#主函数
if __name__ == '__main__':
    #寻找目标 ichunqiu  192.168.2.240
    for i in range(1,255):
        ip = '192.168.2.' + str(i)
        #多线程方法
        _thread.start_new_thread(ping_check, (ip, ))
        time.sleep(0.1)
```

然而，很多情况下，系统中的 ping 可执行文件不可用，或者无法访问。

### ping 命令的实现

此时，我们需要一个纯粹的 Python 脚本实现查验。注意，这个脚本要使用超级用户或者管理员的身份运行。

```python
#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
import select
import socket
import struct
import sys
import os
import time
import argparse

SUCCESS = 0
FAILED = 1

if sys.platform.startswith("win32"):
    timer = time.clock
else:
    timer = time.time


class Response():
    """
    Reponse of ping
    """

    def __init__(self):
        self.max_rtt = None
        self.min_rtt = None
        self.avg_rtt = None
        self.packet_lost = None
        self.ret_code = None
        self.messages = []

        self.packet_size = None
        self.timeout = None
        self.dest = None
        self.dest_ip = None

    # def __str__(self):
    #     return str(self.to_dict())

    def to_dict(self):
        return {
            "max_rtt": self.max_rtt,
            "min_rtt": self.min_rtt,
            "avg_rtt": self.avg_rtt,
            "packet_lost": self.packet_lost,
            "ret_code": self.ret_code,
            "packet_size": self.packet_size,
            "timeout": self.timeout,
            "dest": self.dest,
            "dest_ip": self.dest_ip,
        }

    def is_reached(self):
        return self.ret_code == SUCCESS

    def print_messages(self):
        for msg in self.messages:
            print(msg)


class Ping():

    def __init__(self, timeout=1000, packet_size=55, own_id=None, udp=False, bind=None, quiet=True):
        self.timeout = timeout
        self.packet_size = packet_size
        self.own_id = own_id
        self.udp = udp
        self.bind = bind
        self.quiet = quiet

        if own_id is None:
            self.own_id = os.getpid() & 0xFFFF

        self.max_wait = 1000  # ms
        self.seq_number = 0

        # self.icmp_echo_reply = 0
        self.icmp_echo = 8
        self.icmp_max_recv = 2048

    def _to_ip(self, addr):
        """
        If destination is not ip address, resolve it by using hostname
        """
        if self._is_valid_ip(addr):
            return addr
        return socket.gethostbyname(addr)

    def _is_valid_ip(self, addr):
        try:
            socket.inet_aton(addr)
        except socket.error:
            return False
        return True

    def _checksum(self, source_string):
        """
        A port of the functionality of in_cksum() from ping.c
        Ideally this would act on the string as a series of 16-bit ints (host
        packed), but this works.
        Network data is big-endian, hosts are typically little-endian
        """
        count_to = (int(len(source_string) / 2)) * 2
        sum = 0
        count = 0

        # Handle bytes in pairs (decoding as short ints)
        lo_byte = 0
        hi_byte = 0
        while count < count_to:
            if (sys.byteorder == "little"):
                lo_byte = source_string[count]
                hi_byte = source_string[count + 1]
            else:
                lo_byte = source_string[count + 1]
                hi_byte = source_string[count]
            try:  # For Python3
                sum = sum + (hi_byte * 256 + lo_byte)
            except:  # For Python2
                sum = sum + (ord(hi_byte) * 256 + ord(lo_byte))
            count += 2

        # Handle last byte if applicable (odd-number of bytes)
        # Endianness should be irrelevant in this case
        if count_to < len(source_string):  # Check for odd length
            lo_byte = source_string[len(source_string) - 1]
            try:  # For Python3
                sum += lo_byte
            except:  # For Python2
                sum += ord(lo_byte)

        sum &= 0xffffffff  # Truncate sum to 32 bits (a variance from ping.c, which
        # uses signed ints, but overflow is unlikely in ping)

        sum = (sum >> 16) + (sum & 0xffff)  # Add high 16 bits to low 16 bits
        sum += (sum >> 16)  # Add carry from above (if any)
        answer = ~sum & 0xffff  # Invert and truncate to 16 bits
        answer = socket.htons(answer)
        return answer

    def _parse_icmp_header(self, packet):
        """
        Parse icmp packet header to dict
        """
        p = struct.unpack("!BBHHH", packet[20:28])

        icmp_header = {}
        icmp_header["type"] = p[0]
        icmp_header["code"] = p[1]
        icmp_header["checksum"] = p[2]
        icmp_header["packet_id"] = p[3]
        icmp_header["sequence"] = p[4]
        return icmp_header

    def _parse_ip_header(self, packet):
        """
        Parse ip packet header to dict
        """
        p = struct.unpack("!BBHHHBBHII", packet[:20])

        ip_header = {}
        ip_header["version"] = p[0]
        ip_header["type"] = p[1]
        ip_header["length"] = p[2]
        ip_header["id"] = p[3]
        ip_header["flags"] = p[4]
        ip_header["ttl"] = p[5]
        ip_header["protocol"] = p[6]
        ip_header["checksum"] = p[7]
        ip_header["src_ip"] = p[8]
        return ip_header

    def _calc_delay(self, send_time, receive_time):
        """
        Calculate spending time between receveed time and sent time.
        If either sent time or received time is null value, returns -1
        """
        if not send_time or not receive_time:
            return -1
        return (receive_time - send_time) * 1000

    def _echo_message(self, message):
        """
        If quiet option is not enable, print message.
        """
        if self.quiet:
            return
        print(message)

    def _wait_until_next(self, delay):
        if self.max_wait > delay:
            time.sleep((self.max_wait - delay) / 1000)

    def ping(self, dest, times=1):
        """
        Ping to destination host (IP/Hostname)
        `dest` arg is indicate destination (both IP and hostname can be used) to ping.
        `times` args is indicate number of times that pings to destination

        Returns ping response that can be used for checking messages, some paramaeter
        and status such as success or failed.
        """
        response = Response()
        response.timeout = self.timeout
        response.dest = dest

        try:
            dest_ip = self._to_ip(dest)
        except socket.gaierror:
            msg = "ping: cannnot resolve {}: Unknown host".format(dest)
            response.messages.append(msg)
            self._echo_message(msg)
            return response

        if not dest_ip:
            response.ret_code = FAILED
            return response

        response.dest_ip = dest_ip

        # initialize sequence number
        self.seq_number = 0
        delays = []

        msg = "PING {} ({}): {} data bytes".format(dest, dest_ip, self.packet_size)
        response.messages.append(msg)
        self._echo_message(msg)

        for i in range(0, times):
            # create socket to send it
            try:
                my_socket = self.make_socket()
            except socket.error as e:
                etype, evalue, etb = sys.exc_info()
                if e.errno == 1:
                    # Operation not permitted - Add more information to traceback
                    msg = "{} - Note that ICMP messages can only be send from processes running as root.".format(evalue)
                else:
                    msg = str(evalue)
                self._echo_message(msg)
                response.messages.append(msg)
                response.ret_code = FAILED
                return response

            try:
                send_time = self.send(my_socket, dest_ip)
            except socket.error as e:
                msg = "General failure ({})".format(e.args[1])
                self._echo_message(msg)
                response.messages.append(msg)
                my_socket.close()
                return response

            if not send_time:
                response.ret_code = Ping.FAILED
                return response

            receive_time, packet_size, ip, ip_header, icmp_header = self.receive(my_socket)
            my_socket.close()
            delay = self._calc_delay(send_time, receive_time)

            # if receive_time value is 0, it means packet could not received
            if receive_time == 0:
                msg = "Request timeout for icmp_seq {}".format(self.seq_number)
                response.messages.append(msg)
                self._echo_message(msg)
                response.ret_code = FAILED
            else:
                msg = "{} bytes from {}: icmp_seq={} ttl={} time={:.3f} ms".format(
                    packet_size,
                    ip,
                    self.seq_number,
                    ip_header['ttl'],
                    delay
                )
                response.messages.append(msg)
                self._echo_message(msg)
                response.ret_code = SUCCESS
                delays.append(delay)

            response.packet_size = packet_size
            self.seq_number += 1

            self._wait_until_next(delay)

        response.max_rtt = max(delays) if delays else 0.0
        response.min_rtt = min(delays) if delays else 0.0
        response.avg_rtt = sum(delays) / len(delays) if delays else 0.0

        msg = "--- {} ping statistics ---".format(dest)
        response.messages.append(msg)
        self._echo_message(msg)

        msg = "{} packets transmitted, {} packets received, {:.1f}% packet loss".format(
            self.seq_number,
            len(delays),
            (self.seq_number - len(delays)) / self.seq_number * 100
        )
        response.messages.append(msg)
        self._echo_message(msg)

        msg = "round-trip min/avg/max = {:.3f}/{:.3f}/{:.3f} ms".format(
            response.min_rtt, response.avg_rtt, response.max_rtt
        )
        response.messages.append(msg)
        self._echo_message(msg)

        return response

    def make_socket(self):
        """
        Make socket
        """
        if self.udp:
            my_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_ICMP)
        else:
            my_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
        if self.bind:
            my_socket.bind((self.bind, 0))
        return my_socket

    def make_packet(self):
        # Header is type (8), code (8), checksum (16), id (16), sequence (16)
        checksum = 0

        # Make a dummy header with a 0 checksum.
        header = struct.pack(
            "!BBHHH", self.icmp_echo, 0, checksum, self.own_id, self.seq_number
        )

        pad_bytes = []
        start_val = 0x42
        for i in range(start_val, start_val + (self.packet_size - 8)):
            pad_bytes += [(i & 0xff)]  # Keep chars in the 0-255 range
        data = bytearray(pad_bytes)

        checksum = self._checksum(header + data)

        header = struct.pack(
            "!BBHHH", self.icmp_echo, 0, checksum, self.own_id, self.seq_number
        )
        return header + data

    def send(self, my_socket, dest):
        """
        Creates packet and send it to a destination
        Returns `send_time` that is packet send time represented in unix time.
        """
        packet = self.make_packet()
        send_time = timer()
        my_socket.sendto(packet, (dest, 1))
        return send_time

    def receive(self, my_socket):
        """
        receive icmp packet from a host where packet was sent.
        Returns receive time that is time of packet received, packet size, ip address,
        ip header and icmp header both are formatted in dict.
        If falied to receive packet, returns 0 and None
        """
        timeout = self.timeout / 1000
        while True:
            select_start = timer()
            inputready, outputready, exceptready = select.select([my_socket], [], [], timeout)
            select_duration = (timer() - select_start)
            if inputready == []:
                return 0, 0, 0, None, None

            packet, address = my_socket.recvfrom(self.icmp_max_recv)
            icmp_header = self._parse_icmp_header(packet)

            receive_time = timer()

            if icmp_header["packet_id"] == self.own_id:  # my packet
                ip_header = self._parse_ip_header(packet)
                ip = socket.inet_ntoa(struct.pack("!I", ip_header["src_ip"]))
                packet_size = len(packet) - 28
                return receive_time, packet_size, ip, ip_header, icmp_header

            timeout = timeout - select_duration

            if timeout <= 0:
                return 0, 0, 0, None, None


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Python ping')
    parser.add_argument('--target-host', action="store", dest="target_host", required=True)
    given_args = parser.parse_args()
    target_host = given_args.target_host
    # pinger = Ping()
    # response = pinger.ping(target_host)
    # # # 输出是否ping通
    # # print(response.is_reached())
    #
    # # 输出ping结果,默认ping 1 次
    # print(response.print_messages())

    # # 输出ping结果,默认ping 1 次
    # pinger = Ping(quiet=False)
    # print(pinger.ping(target_host))

    # # 输出ping结果,ping 3 次
    pinger = Ping(quiet=False)
    print(pinger.ping(target_host, times=3))
```

以超级用户的身份运行这个脚本，得到的输出如下所示：

```sh
(wsl-base-py38) (py38) root@hujianli722# python 3_2_ping_remote_host.py --target-host=www.baidu.com
PING www.baidu.com (183.240.98.198): 55 data bytes
47 bytes from 183.240.98.198: icmp_seq=0 ttl=52 time=17.569 ms
47 bytes from 183.240.98.198: icmp_seq=1 ttl=52 time=15.370 ms
47 bytes from 183.240.98.198: icmp_seq=2 ttl=52 time=15.256 ms
--- www.baidu.com ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max = 15.256/16.065/17.569 ms
<__main__.Response object at 0x7f14474ad5e0>
```

参考代码:

- https://github.com/satoshi03/pings.git

## 3.等待远程网络服务上线

有时，在网络服务恢复的过程中，可以运行一个脚本检查服务器何时再次上线。

```python
#!/usr/bin/env python
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import socket
import logging
import time
from time import time as now

DEFAULT_TIMEOUT = 120
DEFAULT_SERVER_HOST = 'localhost'
DEFAULT_SERVER_PORT = 22
CHECKHEALTH_INTERVAL = 2


class NetServiceChecker(object):
    """
    Wait for a network service to come online
    """

    def __init__(self, host, port, check_health_interval=None, timeout=DEFAULT_TIMEOUT):
        self.host = host
        self.port = port
        self.check_health_interval = check_health_interval
        self.timeout = timeout
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def __enter__(self):
        return self

    def end_wait(self):
        self.sock.close()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.sock.close()

    def check(self):
        """ check the service """
        if self.timeout:
            end_time = now() + self.timeout

        while True:
            time.sleep(2)
            try:
                if self.timeout:
                    next_timeout = end_time - now()
                    if next_timeout < 0:
                        return False
                    else:
                        print("setting socket next timeout %ss" % round(next_timeout))
                        self.sock.settimeout(next_timeout)
                self.sock.connect((self.host, self.port))
            # handle exceptions
            except socket.timeout as err:
                if self.timeout:
                    logging.error("Timeout occurred: {}".format(err))
                    return False
            except socket.gaierror as err:
                logging.error("Host not found: {}".format(err))
                return False
            except socket.error as err:
                logging.error("Socket error: {}".format(err))
                # return False
            else:  # if all goes well
                self.end_wait()
                return True


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    parser = argparse.ArgumentParser(description='Wait for Network Service')
    parser.add_argument('--host', action="store", dest="host", default=DEFAULT_SERVER_HOST)
    parser.add_argument('--port', action="store", dest="port", type=int, default=DEFAULT_SERVER_PORT)
    parser.add_argument('--check-health-interval', action="store", dest="check_health_interval",type=int,
                        default=CHECKHEALTH_INTERVAL)
    parser.add_argument('--timeout', action="store", dest="timeout", type=int, default=DEFAULT_TIMEOUT)
    given_args = parser.parse_args()
    host, port, timeout = given_args.host, given_args.port, given_args.timeout
    service_checker = NetServiceChecker(host, port, timeout=timeout)
    logging.info(f"Checking for network service {host}:{port}...")
    if service_checker.check():
        logging.info("Service is available again!")
```

如果在你的设备上运行着一个 sshd 服务，运行这个脚本后会看到如下输出,每间隔 2 秒，脚本就会检查一次。如果服务再次上线，脚本就会返回 True，否则会一直等待，直到超时为止。

```sh
(wsl-base-py38) (py38) root@hujianli722# python 3_3_wait_for_remote_service.py
INFO:root:Checking for network service localhost:22...
setting socket next timeout 118s
INFO:root:Service is available again!
```

现在停止 sshd 进程，再运行这个脚本，然后重启 sshd。此时看到的输出会有所不同，在我的设备上，输出如下：

```sh
(wsl-base-py38) (py38) root@hujianli722# python 3_3_wait_for_remote_service.py
INFO:root:Checking for network service localhost:22...
setting socket next timeout 118s
ERROR:root:Socket error: [Errno 111] Connection refused
setting socket next timeout 116s
ERROR:root:Socket error: [Errno 103] Software caused connection abort
setting socket next timeout 114s
ERROR:root:Socket error: [Errno 111] Connection refused
setting socket next timeout 112s
ERROR:root:Socket error: [Errno 103] Software caused connection abort
setting socket next timeout 110s
ERROR:root:Socket error: [Errno 111] Connection refused
setting socket next timeout 108s
ERROR:root:Socket error: [Errno 103] Software caused connection abort
setting socket next timeout 106s
INFO:root:Service is available again!
```

原理分析

上述脚本使用 argparse 模块接收用户的输入，处理主机名、端口和超时时间。

超时时间指等待所需网络服务的时间。

这个脚本创建了一个 NetServiceChecker 类实例，然后调用 check()方法。

这个方法计算等待的最后结束时间，并使用套接字的 `settimeout()` 方法控制每次循环的结束时间，即 next_timeout 。

然后 check() 方法调用套接字的 connect() 方法在超时时间到达之前测试所需的网络服务是否可用。

check() 方法还能捕获套接字超时异常，以及比较套接字超时时间和用户指定的超时时间。

## 4.枚举设备中的接口

在 Python 中列出设备中的网络接口并不难。有很多第三方库可以使用，只需几行代码即可。
不过，我们来看一下如何只使用套接字调用完成这一操作。

```python
#!/usr/bi
# n/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import fcntl
import socket
import struct
import os


def get_network_interfaces():
    """
    获取所有网络接口的名称
    """
    return os.listdir('/sys/class/net/')


def get_ip_address(interface):
    """
    获取指定网络接口的IP地址
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        info = fcntl.ioctl(sock.fileno(), 0x8915, struct.pack('256s', bytes(interface, 'utf-8')[:15]))
        return socket.inet_ntoa(info[20:24])
    except IOError:
        return None


def list_interfaces():
    """
    使用 fnctl 模块在你的设备中查询IP地址
    """
    try:
        interfaces = get_network_interfaces()
        for interface in interfaces:
            ip = get_ip_address(interface)
            if ip:
                print(f"Interface: {interface}, IP Address: {ip}")
            else:
                print(f"Interface: {interface} has no IP address")
    except Exception as e:
        print(f"An error occurred: {e}")


if __name__ == '__main__':
    list_interfaces()

```

上述脚本能列出网络接口，输出结果如下：

```sh
(wsl-base-py38) (py38) root@hujianli722# python 3_4_list_network_interfaces.py
Interface: eth0, IP Address: 172.22.xxx.xxx
Interface: lo, IP Address: 127.0.0.1
Interface: docker0, IP Address: 172.xx.0.1
```

## 5.找出设备中某个接口的 IP 地址

在 Python 网络应用程序中可能需要找出某个网络接口的 IP 地址。

你可以使用 fnctl 模块在你的设备中查询 IP 地址。

```python
#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import socket
import fcntl
import struct


def get_ip_address(ifname):
    """
    获取指定网络接口的IP地址。

    :param ifname: 网络接口名称
    :return: IP地址字符串
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        info = fcntl.ioctl(sock.fileno(), 0x8915, struct.pack('256s', bytes(ifname, 'utf-8')[:15]))
        return socket.inet_ntoa(info[20:24])
    except IOError:
        return None


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Python networking utils')
    parser.add_argument('--ifname', action="store", dest="ifname", required=True)
    given_args = parser.parse_args()
    ifname = given_args.ifname

    try:
        ip_address = get_ip_address(ifname)
        if ip_address:
            print(f"Interface [{ifname}] --> IP: {ip_address}")
        else:
            print(f"Interface [{ifname}] --> No IP address found")
    except Exception as e:
        print(f"An error occurred: {e}")
```

这个脚本的输出只有一行，如下所示：

```sh
(wsl-base-py38) (py38) root@hujianli722# python 3_5_get_interface_ip_address.py --ifname=eth0
Interface [eth0] --> IP: 172.22.xx.123
```

原理分析

上述脚本接收一个命令行参数：要查询的 IP 地址的网络接口名。

`get_ip_address()` 函数创建一个套接字对象，然后调用 fnctl.ioctl() 函数利用这个套接字对象查询 IP 信息。

注意,`socket.inet_ntoa()` 函数的作用是，把二进制数据转换成我们熟悉的人类可读的点分格式。

## 6.探测设备中的接口是否开启

如果设备中有多个网络接口，在使用某个接口前你需要知道它的状态，例如，这个接口是否开启。这样才能保证把命令传递给处于激活状态的接口。

这个攻略是为 Linux 设备编写的，因此无法在 Windows 或 Mac 主机上运行。这个攻略用到了一
个著名的网络扫描工具—— nmap 。

在 nmap 的网站http://nmap.org/中可以了解更多信息。

需要 python-nmap 模块，可使用 pip 安装。

```sh
$ pip install python-nmap


# 在Ubuntu中安装nmap 工具
apt -y install nmap
```

我们可以创建一个套接字对象，然后获取接口的 IP 地址，再使用任何一种扫描技术探测接口的状态。

```python
#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import argparse
import socket
import struct
import fcntl
import nmap

# 定义要扫描的端口范围
SAMPLE_PORTS = '21-23'


def get_interface_status(ifname):
    # 使用with语句确保socket在使用后正确关闭
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        # 尝试获取接口的IP地址
        try:
            # 将字符串转换为字节对象
            ifname_bytes = ifname[:15].encode('utf-8')
            # 使用字节对象进行打包
            ip_address = socket.inet_ntoa(fcntl.ioctl(
                sock.fileno(),
                0x8915,  # SIOCGIFADDR, C socket library sockios.h
                struct.pack('256s', ifname_bytes)
            )[20:24])
        except IOError as e:
            print(f"Error getting interface address: {e}")
            return None

    # 使用nmap扫描指定的IP地址和端口
    nm = nmap.PortScanner()
    nm.scan(ip_address, SAMPLE_PORTS)
    return nm[ip_address].state()


if __name__ == '__main__':
    # 创建命令行参数解析器
    parser = argparse.ArgumentParser(description='Python networking utils')
    parser.add_argument('--ifname', action="store", dest="ifname", required=True)
    args = parser.parse_args()

    # 获取提供的网络接口名称
    ifname = args.ifname

    # 打印接口状态
    print(f"Interface [{ifname}] is: {get_interface_status(ifname)}")

```

如果运行这个脚本查询 eth0 的状态，会看到类似下面的输出：

```sh
(wsl-base-py38) (py38) root@hujianli722# python 3_6_find_network_interface_stat
Interface [eth0] is: up
```

这个攻略从命令行中读取接口名，然后将其传给 get_interface_status() 函数。

这个函数通过处理一个 UDP 套接字对象找到该接口的 IP 地址。

这个攻略需要第三方模块 nmap 的支持。我们可以使用 pip 从 PyPI 上安装这个模块。

nmap 扫描的实例 nm ，是通过调用 PortScanner() 创建的。

初步扫描本地 IP 后就能获取对应网络接口的状态。

## 7.检测网络中未开启的设备

如果有人给你网络中一些设备的 IP 地址，让你编写一个脚本定期找出哪些主机未开启，你可以编写一个网络扫描类型的程序，而无需在目标主机电脑中安装任何软件。

这个攻略需要安装 Scapy 库（2.2 以上版本），下载地址为: http://www.secdev.org/projects/scapy/files/scapy-latest.zip。

我们可以使用成熟的第三方网络分析库 Scapy 启动 ICMP 扫描。

需要 scapy 模块，可使用 pip 安装。

```sh
# 安装scapy
$ pip install scapy
```

```python
#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
# Requires scapy-2.2.0 or higher
# Visit: http://www.secdev.org/projects/scapy/files/scapy-latest.zip

import argparse
import time
import sched
from scapy.all import sr, IP, ICMP
import ipaddress

RUN_FREQUENCY = 5


# def parse_ip_range(ip_range):
#     """
#     Parses an IP range and returns a list of individual IP addresses.
#     """
#     ip_list = []
#     for ip in ip_range.split(","):
#         if "-" in ip:
#             start_ip, end_ip = ip.split("-")
#             start_ip = int(ipaddress.IPv4Address(start_ip))
#             end_ip = int(ipaddress.IPv4Address(end_ip))
#             for ip_int in range(start_ip, end_ip + 1):
#                 ip_list.append(str(ipaddress.IPv4Address(ip_int)))
#         else:
#             ip_list.append(ip)
#     return ip_list

def parse_ip_range(ip_range):
    """
    Parses an IP range and returns a list of individual IP addresses.
    """
    ip_list = []
    for ip in ip_range.split(","):
        if "-" in ip:
            start_ip, end_part = ip.split("-")
            start_ip_obj = ipaddress.IPv4Address(start_ip)
            start_ip_parts = start_ip_obj.exploded.split(".")
            end_ip = ".".join(start_ip_parts[:-1] + [end_part])
            end_ip_obj = ipaddress.IPv4Address(end_ip)

            start_ip_int = int(start_ip_obj)
            end_ip_int = int(end_ip_obj)

            for ip_int in range(start_ip_int, end_ip_int + 1):
                ip_list.append(str(ipaddress.IPv4Address(ip_int)))
        else:
            ip_list.append(ip)
    return ip_list


def detect_inactive_hosts(scan_hosts, scheduler):
    """
    Scans the network to find scan_hosts are live or dead
    scan_hosts can be like 192.168.0.1-120 to cover range.
    See Scapy docs for specifying targets.
    """
    try:
        ip_list = parse_ip_range(scan_hosts)
        print("Scanning {} hosts...".format(len(ip_list)))
        ans, unans = sr([IP(dst=ip) / ICMP() for ip in ip_list], retry=0, timeout=1)
        ans.summary(lambda s, r: r.sprintf("%IP.src% is alive"))
        inactive_hosts = [inactive.dst for inactive in unans]
        print("Total {} hosts are inactive".format(len(inactive_hosts)))

        # Schedule the next run
        scheduler.enter(RUN_FREQUENCY, 1, detect_inactive_hosts, (scan_hosts, scheduler))
    except KeyboardInterrupt:
        scheduler.cancel()
        raise


def main():
    parser = argparse.ArgumentParser(description='Python networking utils')
    parser.add_argument("--scan-hosts", action="store", dest="scan_hosts", required=True)
    args = parser.parse_args()
    scan_hosts = args.scan_hosts

    scheduler = sched.scheduler(time.time, time.sleep)
    scheduler.enter(1, 1, detect_inactive_hosts, (scan_hosts, scheduler))
    scheduler.run()


if __name__ == "__main__":
    main()
```

这个脚本的输出如下面的命令行所示：

```sh
(wsl-base-py38) (py38) root@hujianli722# python 3_7_detect_inactive_machines.py --scan-hosts 192.168.0.100-200
Scanning 101 hosts...
Begin emission
.**
Finished sending 101 packets
**
Received 5 packets, got 4 answers, remaining 97 packets
192.168.0.103 is alive
192.168.0.100 is alive
192.168.0.107 is alive
192.168.0.102 is alive
Total 97 hosts are inactive
Scanning 101 hosts...
Begin emission
***
Finished sending 101 packets
***
Received 6 packets, got 6 answers, remaining 95 packets
192.168.0.101 is alive
192.168.0.107 is alive
192.168.0.100 is alive
192.168.0.103 is alive
192.168.0.105 is alive
192.168.0.102 is alive
Total 95 hosts are inactive
```

上述脚本先从命令行中读取一组网络主机的地址，保存到变量 scan_hosts 中，然后创建一个日程表，每隔一秒运行一次 detect_inactive_hosts() 函数。

detect_inactive_hosts()函数的参数是 scan_hosts ，该函数调用了 Scapy 库的 sr() 函数。

detect_inactive_hosts() 函数再次调用 schedule.enter() 函数，以安排自己 5 秒钟之后再次运行。如此一来，我们就能定期执行扫描任务了。

Scapy 库的 sr() 函数接收的参数分别是 IP、协议和一些扫描控制信息。

在这个脚本中，把 scan_hosts 传给 IP() 方法，作为扫描的目标主机，协议指定为 ICMP。

协议还可使用 TCP 或 UDP。我们没有指定重试一次并把超时时间设为一秒，以便提升脚本的运行速度。你可以自己尝试，找
到符合需求的选项值。

扫描函数 sr() 在一个元组中返回有应答的主机和无应答的主机。我们获取了无应答的主机，构建成一个列表，然后打印出来。

## 8.使用相连的套接字执行基本的进程间通信

有时，两个脚本要通过两个进程彼此通信。在 Unix/Linux 中，有一个概念叫作“相连的套接字”，即 socketpair 。

这个脚本为 Unix/Linux 主机而编写，不适合在 Windows/Mac 中运行。

我们要在 test_socketpair() 函数中编写几行代码，测试套接字的 socketpair() 函数。

```python
#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
import socket
import os

BUFSIZE = 1024


def test_socketpair():
    """ Test Unix socketpair"""
    parent, child = socket.socketpair()

    try:
        pid = os.fork()
        if pid:
            print("@Parent, sending message...")
            child.close()
            parent.sendall(b"Hello from parent!")  # 使用bytes发送数据
            response = parent.recv(BUFSIZE)
            print("Response from child:", response)
            parent.close()

        else:
            print("@Child, waiting for message from parent")
            parent.close()
            message = child.recv(BUFSIZE)
            print("Message from parent:", message)
            child.sendall(b"Hello from child!!")  # 使用bytes发送数据
            child.close()
    except Exception as err:  # 使用as而不是逗号
        print("Error: %s" % err)  # 删除多余的空格


if __name__ == '__main__':
    test_socketpair()
```

上述脚本的输出如下所示：

```sh
# (wsl-base-py38) (py38) root@hujianli722# python 3_8_ipc_using_socketpairs.py
# @Parent, sending message...
# @Child, waiting for message from parent
# Message from parent: b'Hello from parent!'
# Response from child: b'Hello from child!!'
```

原理分析

socket.socketpair() 函数返回的是两个相连的套接字对象，这里我们把其中一个称为父套接字，另一个称为子套接字。

我们调用 os.fork() 方法派生出了另一个进程，其返回结果是父进程的 ID。

在各个进程中，先把另一个进程中的套接字关闭，然后在当前进程中的套接字上调用 sendall() 方法交换消息。

在 try-except 块中如果出现异常，就把错误打印出来。

## 9.使用 Unix 域套接字执行进程间通信

有时使用 Unix 域套接字（Unix Domain Socket，简称 UDS）处理两个进程之间的通信更方便。

在 Unix 中，一切都是文件。如果你需要一个这种进程间通信的例子，这个攻略可以给你一些帮助。

实战演练

我们要启动一个 UDS 服务器，绑定到一个文件系统路径上。然后启动一个 UDS 客户端，使用相同的路径和服务器通信。

`3_9a_unix_domain_socket_server.py`

Unix 域套接字服务器，如下所示：

```python
#!/usr/bin/env python
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import socket
import os
import time

SERVER_PATH = "/tmp/python_unix_socket_server"


def run_unix_domain_socket_server():
    if os.path.exists(SERVER_PATH):
        os.unlink(SERVER_PATH)
    print("Starting UNIX domain socket server.")
    server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        server.bind(SERVER_PATH)
        server.listen(1)
        while True:
            client, address = server.accept()
            try:
                data = client.recv(1024)
                if not data:
                    break
                print("-" * 20)
                print(data.decode())
                if data.decode().strip() == "DONE":
                    break
                response = "Message received. Data: " + data.decode().strip()
                # 将字符串转换为字节类型
                client.sendall(response.encode())
            finally:
                client.close()
    finally:
        server.close()
        os.unlink(SERVER_PATH)
    print("-" * 20)
    print("Server shutdown and path removed.")


if __name__ == '__main__':
    run_unix_domain_socket_server()
```

`3_9b_unix_domain_socket_client.py`

UDS 客户端，如下所示：

```python
#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 3
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import socket
import sys

SERVER_PATH = "/tmp/python_unix_socket_server"


def run_unix_domain_socket_client():
    """运行Unix域套接字客户端"""
    with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:
        # 连接到服务器正在监听的路径
        server_address = SERVER_PATH
        print(f"connecting to {server_address}")
        sock.connect(server_address)

        message = "This is the message. This will be echoed back!"
        print(f"Sending [{message}]")
        sock.sendall(message.encode())  # 确保消息被编码为字节串

        try:
            while True:
                data = sock.recv(16)
                if not data:
                    break
                print(f"Received [{data.decode()}]")
        except socket.timeout:
            print("No data received within the timeout period.")
        except socket.error as e:
            print(f"Socket error: {e}")
            sys.exit(1)


if __name__ == '__main__':
    run_unix_domain_socket_client()
```

服务器的输出如下所示：

```sh
(wsl-base-py38) (py38) root@hujianli722# python 3_9a_unix_domain_socket_server.py
Starting UNIX domain socket server.
--------------------
This is the message. This will be echoed back!
```

客户端的输出如下所示：

```sh
(wsl-base-py38) (py38) root@hujianli722# python 3_9b_unix_domain_socket_client.py
connecting to /tmp/python_unix_socket_server
Sending [This is the message. This will be echoed back!]
Received [Message received]
Received [. Data: This is ]
Received [the message. Thi]
Received [s will be echoed]
Received [ back!]
```

## 10.多线程实现端口扫描工具

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright: (c)  : @Time 2025/1/18 10  @Author  : hjl
# @Site    :
# @File    : 1_14_port_scan_process.py
# @Project: Python_Network_Programming_Cookbook
# @Software: PyCharm
# @Desc    :
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# 简单的端口扫描工具
import time
import socket
import threading
import argparse


def isIP(ip):
    ip_addr = ip.split('.')
    if len(ip_addr) != 4:
        return False
    for ipnum in ip_addr:
        if not (0 <= int(ipnum) < 255):
            return False
    else:
        return True


# 端口扫描工具
class scanThread(threading.Thread):
    def __init__(self, ip, port_min=0, port_max=65535):
        # 初始化。
        threading.Thread.__init__(self)
        self.port_max = port_max
        self.port_min = port_min
        self.ip = ip
        # assert isinstance(int,self.port_min) and isinstance(int,self.port_max)

    # 重写run
    def run(self):
        return self.__checker()

    # 检测
    def __checker(self):

        for port in range(self.port_min, self.port_max):
            self.__connect(port)

    # 连接
    def __connect(self, port):
        socket.setdefaulttimeout(1)
        self.sock = socket.socket()
        try:
            start_time = time.time()
            self.sock.connect((self.ip, port))
            end_time = time.time()
            connect_time = int(start_time - end_time)
            info = 'Find --> [IP]: %s, [PORT]: %s, [Connect Time]: %d' % (self.ip, port, connect_time)
            print(info)
            self.__save(info)
            self.sock.close()
        except:
            self.sock.close()

    def __save(self, info):
        try:
            with open('results.txt', 'a', encoding='utf-8') as f:
                f.write(info + '\n')
        except Exception as e:
            raise e


def parse_args():
    parser = argparse.ArgumentParser(description='Port scanner')
    parser.add_argument('--ip', type=str, required=True, help='IP address')
    parser.add_argument('--port_min', type=int, required=True, help='Minimum port number', default=0)
    parser.add_argument('--port_max', type=int, required=True, help='Maximum port number', default=65535)
    return parser.parse_args()


if __name__ == '__main__':
    args = parse_args()
    if isIP(args.ip) is False:
        raise ValueError('Please provide an IP address')
    ip, port_min, port_max = args.ip, args.port_min, args.port_max
    # 创建线程。
    scan = scanThread(ip, port_min, port_max)
    scan.start()
    scan.join()
    print('Scan is done')
    # 保存结果。
    print('The results are saved in results.txt')
```

## 11.多线程+队列 实现端口扫描

线程+队列实现端口扫描，代码如下：

```python
import socket
import threading
import time
import queue
import sys


class ScannerPort:
    class ScanPorts(threading.Thread):
        def __init__(self, ip, portlist, timeout):
            super().__init__()
            self.ip = ip
            self.portlist = portlist
            self.timeout = timeout

        def run(self):
            while True:
                if self.portlist.empty():
                    break
                ip = self.ip
                port = self.portlist.get()
                timeout = self.timeout

                try:
                    s = socket.socket()
                    s.settimeout(timeout)
                    result = s.connect_ex((ip, port))
                    if result == 0:
                        sys.stdout.write("% 6d [OPEN]\n" % port)
                except Exception as e:
                    print(e)
                finally:
                    s.close()


def main(ip, port_list, thread_num):
    start_time = time.time()
    port_queue = queue.Queue()
    timeout = 2

    for port in port_list:
        port_queue.put(port)

    threads = []
    for i in range(thread_num):
        thread = ScannerPort.ScanPorts(ip, port_queue, timeout)
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    print("耗时：", time.time() - start_time, "s")


def getportlist(string):
    top50 = [port for port in range(1, 51)]
    top100 = [port for port in range(1, 101)]
    top1000 = [port for port in range(1, 1001)]
    if string == "all":
        return list(range(1, 65536))
    if string == "top50":
        return top50
    elif string == "top100":
        return top100
    elif string == "top1000":
        return top1000
    else:
        print("--ports参数错误！程序退出！")
        exit()


def logo():
    logo = """
 _____  _____    ____  __  _  __  _  _____  _____  _____  _____  _____  _____
/ ___/ / ___|   / _ | | \ | | | \ | | | ____| | _ \ | _ \ / _ \ | _ \ |_  _|
| |___ | |    / /_| | |  \| | |  \| | | |__  | |_| | | |_| | | | | | | |_| |  | |
\___ \ | |    / ___ | | |\  | | |\  | | __| | _ / | ___/ | | | | | _ /  | |
 ___| | | |___  / /  | | | | \ | | | \ | | |___ | | \ \ | |   | |_| | | | \ \  | |
/_____/ \_____| /_/  |_| |_| \_| |_| \_| |_____| |_| \_\ |_|   \_____/ |_| \_\  |_|
 """
    print(logo)


def help():
    help = """
 --help/-h：
 --ip 需扫描的IP地址
    默认为: 127.0.0.1

 --ports 需扫描的端口列表
     top50 常用端口前50
     top100 常用端口前100
     top1000 常用端口前1000
     all 扫描所有端口

 --thread 扫描线程数
    默认为100

 格式: python scanport.py --ip 127.0.0.1 --port top50 --thread num
 """
    print(help)


if __name__ == "__main__":
    logo()
    args = sys.argv
    ip = "127.0.0.1"
    ports = list(range(1, 65535))
    string = "1-65535"
    thread_num = 100
    if "--help" in args or "-h" in args:
        help()
        exit()
    if "--ip" in args:
        ip = args[args.index("--ip") + 1]
        print("扫描的IP的地址为：", ip)
    if "--ports" in args:
        ports = getportlist(args[args.index("--ports") + 1])
        string = args[args.index("--ports") + 1]
        print("扫描的端口列表为：", string)
    if "--thread" in args:
        thread_num = int(args[args.index("--thread") + 1])
        print("扫描的线程数为：", thread_num)
    main(ip, ports, thread_num)
```
