# 5.Vue前端开发-下



## 大纲

- vue常用指令之数据双向绑定
- vue实例生命周期钩子
- Vue cli脚手架
- 前后端数据交互Axios
- Vue路由: vue-router




## vue常用指令之数据双向绑定

双向数据绑定：通过前面学习知道Vue是数据驱动的，数据驱动有一个精髓之处是数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。

### v-model

v-model指令提供表单输入绑定，可以在 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。

#### v-model: 表单输入

v-model.html


- 代码示例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>V-model</title>
    <script src="static/vue.js"></script>
</head>
<body>
<div id="v_model">
    <input type="text" v-model="msg">
    <p>{{msg}}</p>
</div>
<script>
    const VueApp = {
        data() {
            return {
                msg: ""
            }
        }
    }
    Vue.createApp(VueApp).mount('#v_model')
</script>
</body>
</html>
```

> v-model指令其实是一个语法糖，背后本质上包含v-bind和v-on两个操作。



#### v-model: 单选

v-model-select.html

- 示例代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>V-model-Select</title>
    <script src="static/vue.js"></script>
</head>
<body>
<div id="v_model">
    <input type="radio" value="Golang" v-model="msg">Golang <br>
    <input type="radio" value="Vue" v-model="msg">Vue <br>
    <p>选择： {{msg}}</p>
</div>
<script>
    const VueApp = {
        data() {
            return {
                msg: ""
            }
        }
    }
    Vue.createApp(VueApp).mount('#v_model')
</script>
</body>
</html>
```

#### v-model: 多选

v-model-selects.html

- 示例代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>V-model-selects</title>
    <script src="static/vue.js"></script>
</head>
<body>
<div id="v_model">
    <select v-model="selected" multiple>
        <option value="go">go</option>
        <option value="python">python</option>
        <option value="java">java</option>
    </select>
    <p>{{selected}}</p>
</div>
<script>
    const VueApp = {
        data() {
            return {
                selected: ""
            }
        }
    }
    Vue.createApp(VueApp).mount('#v_model')
</script>
</body>
</html>
```



#### 登录页面案例

v-model-login.html


- 示例代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>V-model-Login</title>
    <script src="static/vue.js"></script>
</head>
<body>
<div id="login">
    <div>
        欢迎访问Devops平台
        <br>
        用户名： <input type="text" v-model="form.username"> <br>
        密码： <input type="text" v-model="form.password"> <br>
        <button @click="loginBtn">登录</button>
    </div>
</div>
<script>
    const VueApp = {
        data() {
            return {
                form: {
                    username: '',
                    password: ''
                }
            }
        },
        methods: {
            loginBtn() {
                console.log(this.form)
            }
        }
    }
    Vue.createApp(VueApp).mount('#login')
</script>
</body>
</html>
```


### vue常见指令总结

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.231lmhehhp.webp){: .zoom}



## vue实例生命周期钩子


生命周期是指Vue实例从创建到销毁的过程。就是vue实例从开始创建、初始化数据、编译模板、挂载Dom、渲染->更新->渲染、卸载等⼀系列过程，在vue⽣命周期中提供了⼀系列的⽣命周期函数，如图所⽰


![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.2doffmxsia.webp){: .zoom}


![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.syog618y5.webp){: .zoom}


- 示例代码


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lifeCycle</title>
    <script src="static/vue.js"></script>
</head>
<body>
<div id="vue_lifecycle">
    {{counter}}
</div>
<script>
    const VueApp = {
        data() {
            return {
                counter: 0
            }
        },
        methods: {
            increament() {
                this.counter++
            }
        },
        created() {
            console.log('xxx')
        },
        mounted() {
            //在渲染完页面之后执行
            console.log('打开页面执行')
            this.increament()
        }
    }
    Vue.createApp(VueApp).mount('#vue_lifecycle')
</script>
</body>
</html>
```


## Vue cli脚手架


### vue cli脚手架介绍

到目前为止，已经会了Vue基本使用，但这种在HTML引用Vue.js的方式，简单的页面还是没问题的，如果用Vue开发整个前端项目，组建Vue项目结构及配置还是比较复杂的，例如引入各种js文件、打包上线等。

因此，为了提高开发效率，官方开发了VueCli脚手架快捷搭建开发环境。


Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：
- 通过 @vue/cli 实现的交互式的项目脚手架。
- 通过 @vue/cli + @vue/cli-service-global 实现的零配置原型开发。


- 一个运行时依赖 (@vue/cli-service)，该依赖：
  - 可升级；
  - 基于 webpack 构建，并带有合理的默认配置；
  - 可以通过项目内的配置文件进行配置；
  - 可以通过插件进行扩展。

- 一个丰富的官方插件集合，集成了前端生态中最好的工具。
- 一套完全图形化的创建和管理 Vue.js 项目的用户界面。


Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。



### 认识NPM

在使用Vue Cli之前，需先了解一些关于NPM的知识点：

- **NPM（Node Package Manager，Node包管理器），**存放JavaScript代码共享中心，是目前最大的JavaScript仓库。类似于Linux yum仓库。

- 可能你会联想到Node.js，Node.js是服务端的JavaScript，类似于Gin、Django，NPM是基于Node.js开发的软件。

- 随着Node.js兴起，生态圈的JS库都纷纷向NPM官方仓库发布，所以现在，大都是使用 npm install 命令来安装JS库，而不必再去它们官网下载了。


安装Node.js，默认已经内置npm，下载对应软件包直接安装即可。 http://nodejs.cn/download/



|命令|描述|
|----|--------|
|npm -v|查看版本|
|npm install <模块名>|安装模块|
|npm install -g <模块名>|可以直接在命令行里使用|
|npm list -g|查看所有全局安装的模块|
|npm list <模块名>|查看某个模块的版本号|
|npm install -g <模块名>@<版本号>|更新模块版本|
|npm install -save <模块名>|在package,json文件中写入依赖<br>(npm5版本之前需要指定，之后版本无需再加-save选项)|
|npm config|管理npm的配置路径|
|npm run serve|运行项目|
|npm run build|打包项目|


- 配置淘宝npm仓库

```sh
npm config set registry https://registry.npm.taobao.org --global 
npm config get registry

# 清空 npm缓存
npm cache clean --force
```


### vue cli脚手架的使用

Vue Cli脚手架使用步骤：
- 安装nodeJS TLS版本：  https://nodejs.org/
- 命令安装：npm install -g @vue/cli
- 检查版本：vue -V
- 创建项目：vue create <项目名称>


![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.5j3xel6j98.webp){: .zoom}




- 运行项目，访问

```sh
cd hello-vue
npm run serve
```

#### 目录结构及其介绍


|目录/文件|	说明|
|-----|-----|
|node_modules|	项目开发依赖的一些模块，不用管|
|public|主要存放首页、favicon|
|src	|源码目录，这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：<br>assets: 放入资源，例如图片、CSS等<br>components: 公共组件目录<br>routes: 前端路由<br>store: 应用级数据（state）Vuex<br>views: 单页面组件目录<br>App.vue： 项目的入口文件（根组件<br>main.js: 项目的全局配置，在任意一个文件中都有效的|
|gitignore文件	|git提交忽略文件|
|babel.config.js|	babel配置，例如es5转es6|
|package.json|	项目配置文件。npm包配置文件，里面定义了项目的npm脚本，依赖包等信息|
|README.md|	项目的说明文档，markdown格式|


![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.4uanukmeir.webp){: .zoom}


#### 使用IDE创建项目


创建 vue3 项目

![CsxpamMCxp](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/CsxpamMCxp.8aczqxvf4l.webp){: .zoom}




启动运行项目

![F52ePggUGe](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/F52ePggUGe.67x72vwyy9.webp){: .zoom}






### 全新的Web开发构建工具-Vite


Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器解析import,

在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。

同时，Vite 不仅对 Vue 文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。在生产环境下使用 Rollup 打包。



Vite具有以下特点：

- 快速的冷启动；
- 即时热模块更新(hot module replacement, HMR);
- 真正按需编译。

Vite 是在推出 Vue3.0 时开发的，目前仅支持 Vue3.x ,这意味着与 Vue3.0 不兼容的库也不能与 Vite 一起使用。


#### 使用Vite

与Vue CLI类似，Vite也提供用npm或yarm命令生成项目结构的方式。选择一个目录，打开命令提示符窗口，依次执行下面的命令构建脚手架项目，并启动项目。

```sh
npm init vite-app <project-name>
cd <project-name>
npm install
npm run dev
```

如果使用yam,则依次执行下面的命令。
```sh
yarn create vite-app <project-name>
cd <project-name>
yarn
yarn dev
```


创建项目 vite 项目

```sh
#------------------------ 创建项目vite项目 ------------------------------
# npm 6.x
npm init vite@latest vue3-admin --template vue

# npm 7+, 需要额外的双横线：
npm init vite@latest vue3-admin -- --template vue

# yarn
yarn create vite vue3-admin --template vue

# pnpm
pnpm create vite vue3-admin -- --template vue
```



```sh
#------------------------ vite生成ts项目 ------------------------------
npm init vite@latest my-vue-app --template vue-ts

# npm 7+, 需要额外的双横线：
npm init vite@latest my-vue-app -- --template vue-ts

# yarn
yarn create vite my-vue-app --template vue-ts

# pnpm
pnpm create vite my-vue-app -- --template vue-ts
```


安装依赖并运行项目
```sh
cd projectName
npm install
npm run dev
```

可以发现，Vite生成的脚手架项目的目录结构与Vue CLI生成的项目目录结构很类似，确实是这样的，而且开发方式也基本相同。

不过Vite项目的默认配置文件是vite.config.js,.而不是vue.config.js。


package.json 文件的内容如下所示：

```js
{
  "name": "hello-vue",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.6.7",
    "vue": "^3.4.15",
    "vue-router": "^4.0.13"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.3",
    "vite": "^5.0.11"
  }
}
```

如果要构建生产环境下应用的发布版本，则只需要在终端窗口中执行下面的命令即可。
```sh
npm run build
```

虽然 Vite 的作者已经在背后做了很多工作，让我们能够沿用基于 Vue CLI 建立的脚手架项目的开发习惯，但仍然会有一些细微的差别，详细的介绍请参看 Vite 源码库的 GitHub 网址：https://github.com/vitejs/vite。



#### 使用IDE创建项目

创建 vite 项目

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/62Mn2MVQ3T.7zq5xsla93.webp){: .zoom}



启动运行项目

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.13lidm3r4k.webp){: .zoom}





### vue组件

#### 组件介绍


**组件:** 一段独立的，能代表页面某一个部分的代码片段，拥有自己独立的数据、JavaScript脚本、以及CSS样式。

组件是可复用的Vue实例，在开发过程中可以把经常重复的功能，封装为组件，达到快捷开发的目的。


组件的好处：

- 提高开发效率
- 方便重复使用
- 易于管理和维护

通常一个应用会以一棵嵌套的组件树的形式来组织，如图所示。

例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.5q75a0xvxd.webp){: .zoom}



#### 文件格式

Vue单文件格式（又名*.vue文件，缩写为SFC）是一种特殊的文件格式，它允许将Vue组件的模板、逻辑与样式封装在单个文件中。


正如所见，Vue SFC是经典的HTML、CSS与JavaScript三个经典组合的自然延伸。每个*.vue文件由三种类型的顶层代码块组成：`<template>`、`<script>`与`<style>`:

```js
<template>部分定义了组件的模板


<script>部分是一个标准的JavaScript模块。它应该导出一个Vue组件定义作为其默认导出。


<style>部分定义了与此组件关联的CSS
```







#### 修改默认页面配置


- 修改 `components/HelloWorld.vue`


```html
<template>
  <div class="hello">
    <h1>{{ msg }}</h1>
    这是hello world 子组件内容
  </div>
</template>

<script>
export default {
  name: "HelloWorld",
  props: {
    msg: String,
  },
};
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
h3 {
  margin: 40px 0 0;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  display: inline-block;
  margin: 0 10px;
}

a {
  color: #42b983;
}
</style>
```


- 修改 `views/HomeView.vue`

```html
<template>
  <div class="home">
    <img alt="Vue logo" src="../assets/logo.svg"/>
    <HelloWorld msg="欢迎使用Vue"/>
  </div>
</template>

<script>
// @ is an alias to /src
import HelloWorld from "@/components/HelloWorld.vue";

export default {
  name: "HomeView",
  components: {
    HelloWorld,
  },
};
</script>
```


- 修改 `views/AboutView.vue`


```html
<script>
export default {
  name: "AboutView"
}
</script>

<template>
  <div class="about">
    这是关于页面
  </div>
</template>

<style scoped>

</style>
```


- 修改 `App.vue`


```html
<script setup>
</script>

<template>
  <nav>
    <router-link to="/">首页</router-link>
    |
    <router-link to="/about">关于</router-link>
  </nav>
  <router-view/>
</template>

<style scoped>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
}

nav {
  padding: 30px;
}

nav a {
  font-weight: bold;
  color: #2c3e50;
}

nav a.router-link-exact-active {
  color: #42b983;
}
</style>
```


- 效果展示


![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.64dl4svdw4.webp){: .zoom}



#### 组件使用

使用具体流程：

1、在 src/views 目录里开发一个组件文件（首字母大写）: NewView.vue

> 可以在创建的时候关闭语法检查，右侧飘红的地方右键，选择Customize Highlighting Level配置成None就可以


```html
<script>
export default {
  name: "NewView"
}
</script>

<template>
  <p> 这是一个新的页面 </p>
</template>

<style scoped>

</style>
```


2、在 router/index.js 中新增/new , /new2 路由: new2是懒加载，一般用这种方式


```js
import {createRouter, createWebHashHistory} from "vue-router";

const Home = () => import("../views/HomeView.vue");
const About = () => import("../views/AboutView.vue");

const NewView = () => import("../views/NewView.vue");

const routes = [
        {
            path: "/",
            name: "root",
            component: Home,
        },
        {
            path: "/home",
            name: "home",
            component: Home,
        },
        {
            path: "/about",
            name: "about",
            // route level code-splitting
            // this generates a separate chunk (about.[hash].js) for this route
            // which is lazy-loaded when the route is visited.
            component: About,
        },
        {
            path: "/new",
            name: "new",
            component: NewView,
        },
        {
            path: "/new2",
            name: "new2",
            component: () =>
                import(/* webpackChunkName: "about" */ "../views/NewView.vue"),
        },
    ];

const router = createRouter({
    history: createWebHashHistory(),
    routes,
});

export default router;
```


3、调整全局配置 vite.config.js 文件，关闭eslint语法检查


```js
import {fileURLToPath, URL} from 'node:url'

import {defineConfig} from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
    // other configurations...
    esbuild: {
        jsx: 'preserve' // Disable ESLint syntax checking
    },
    plugins: [
        vue(),
    ],
    resolve: {
        alias: {
            '@': fileURLToPath(new URL('./src', import.meta.url))
        }
    }
})
```


4、页面测试

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.7zq5xg0pjv.webp){: .zoom}




开发组件  -->  注册组件  --> 使用组件





5、将HelloWorld 注册到 views/NewView.vue 中

```html
<template>
  <p>这是一个新的页面</p>
  <HelloWorld></HelloWorld>
</template>

<script>
import HelloWorld from "@/components/HelloWorld.vue";

export default {
  name: "NewView",
  components: {
    HelloWorld,
  }
}
</script>


<style scoped>

</style>
```

6、调整App.vue 加入新页面配置

```html
<script setup>
</script>

<template>
  <nav>
    <router-link to="/">首页</router-link>
    |
    <router-link to="/about">关于</router-link>
    |
    <router-link to="/new">新页面</router-link>
  </nav>
  <router-view/>
</template>

<!-- .....其余不动.. -->
```



7、测试

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.361b1bpkoj.webp){: .zoom}



8、创建 `component/Test.vue` 组件

```html
<template>
  <div class="test"></div>
</template>

<script>
export default {
  name: "Test"
}
</script>

<style scoped>
.test {
  width: 200px;
  height: 200px;
  background: orange;
}
</style>
```


9、在 `views/NewView` 中注册 Test 组件

```html
<template>
  <div class="new">
    <p>这是一个新的页面</p>
    <HelloWorld></HelloWorld>
    <Test></Test>
  </div>
</template>

<script>
import HelloWorld from "@/components/HelloWorld.vue";
import Test from "@/components/Test.vue";

export default {
  name: "NewView",
  components: {
    HelloWorld,
    Test
  }
}
</script>


<style scoped>
.new {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
</style>
```

10、效果展示

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.1ov5zpb9s6.webp){: .zoom}



#### 组件注册


为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。上述是局部注册，只能在当前模板中使用。

**全局注册：**声明一次，在任何vue文件模板中使用，一般使用该组件的地方多时使用

**局部注册：**在使用组件的vue文件中声明和使用，一般只需要解耦代码时使用(使用较多) ， 上述8,9 示例就是局部注册的典型应用




全局注册示例



- 在 main.js 注册 `components/Test.vue`


```js
import './assets/main.css'

import {createApp} from 'vue'
import App from './App.vue'
import router from './router'
import Test from './components/Test.vue'


const app = createApp(App)
app.component('Test', Test)
app.use(router).mount("#app");
```

- 在 `views/AboutView.vue` 中引用全局的 Test 组件

```html
<script>
export default {
  name: "AboutView"
}
</script>

<template>
  <div class="about">
    这是关于页面
  </div>
  <Test></Test>
</template>

<style scoped>
.about {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
</style>
```


- 效果展示

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.lt2is46v.webp){: .zoom}



#### 组件传参

学习了组件用法，就像一种嵌套引用关系，在这个关系中，经常会涉及相互传数据的需求，即父组件传子组件，子组件传父组件。

父、子组件的关系可以总结为： **prop 向下传递，事件向上传递**。

父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息，如右图所示：

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.26l7oalb3m.webp){: .zoom}



##### 父传子示例

示例1

- 父组件 `views/HomeView.vue`

```html
<template>
  <div class="home">
    <img alt="Vue logo" src="../assets/logo.svg"/>
    <HelloWorld msg="欢迎使用Vue"/>
  </div>
</template>

<script>
// @ is an alias to /src
import HelloWorld from "@/components/HelloWorld.vue";

export default {
  name: "HomeView",
  components: {
    HelloWorld,
  },
};
</script>


<style scoped>
.home {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

.logo-container {
  margin-bottom: 20px;
}
</style>
```


- 子组件 `views/HelloWorld.vue`

```html
<template>
  <div class="hello">
    <h1>{{ msg }}</h1>>
    这是hello world 子组件内容
  </div>
</template>

<script>
export default {
  name: "HelloWorld",
  props: {
    msg: String,
  },
};
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
h3 {
  margin: 40px 0 0;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  display: inline-block;
  margin: 0 10px;
}

a {
  color: #42b983;
}
</style>
```



示例2

1.views/NewView.vue 父组件代码


```html
<template>
  <div class="new">
    <p>这是一个新的页面</p>
    <HelloWorld></HelloWorld>
    <Test msg="我是NewView传递的数据"></Test>
    <!--    //后端数据到子组件需要bind-->
    <Test :msg="msg"></Test>
  </div>
</template>

<script>
import HelloWorld from "@/components/HelloWorld.vue";
import Test from "@/components/Test.vue";

export default {
  name: "NewView",
  components: {
    HelloWorld,
    Test
  },
  data() {
    return {
      msg: "你好，这是父组件传递的内容"
    }
  }
}
</script>


<style scoped>
.new {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
</style>
```

2.Components/Test.vue 子组件接收

```html
<template>
  <div class="test">
    {{ msg }}
  </div>
</template>

<script>
export default {
  name: "Test",
  props: {
    msg: String,
  },
}
</script>

<style scoped>
.test {
  width: 200px;
  height: 200px;
  background: orange;
}
</style>
```


3.效果展示

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.1754b4zmlq.webp){: .zoom}




##### 子传父示例


1.子组件代码： `components/Test.vue`

```html
<template>
  <div class="test">
    {{ msg }} <br>
  </div>
  <button @click="btn">传递数据到父组件</button>
</template>

<script>
export default {
  name: "Test",
  props: {
    msg: String,
  },
  data() {
    return {
      hello: "这是Test子组件的数据"
    }
  },
  methods: {
    btn() {
      this.$emit("hello", this.hello)
    }
  }
}
</script>

<style scoped>
.test {
  width: 200px;
  height: 200px;
  background: orange;
}
</style>
```

2.父组件代码：`views/NewView.vue`


```html
<template>
  <div class="new">
    <p>这是一个新的页面</p>
    <HelloWorld></HelloWorld>
    <Test msg="我是NewView传递的数据"></Test>
    <Test :msg="msg" @hello="result"></Test>
    <p>这是子组件传递到父组件的数据： {{ childData }}</p>
  </div>
</template>

<script>
import HelloWorld from "@/components/HelloWorld.vue";
import Test from "@/components/Test.vue";

export default {
  name: "NewView",
  components: {
    HelloWorld,
    Test
  },
  methods: {
    //父组件接收子组件传递的数据并放到函数的第一个位置参数
    result(data) {
      console.log(data)
      this.childData = data
    }
  },
  data() {
    return {
      msg: "你好，这是父组件传递的内容",
      childData: ''
    }
  }
}
</script>

<style scoped>
.new {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
</style>
```

3.效果展示

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.9rj4sjo5xn.png){: .zoom}



## 前后端数据交互Axios


### 介绍

在前端页面展示的数据大多数都是通过访问一个API获取的，做这件事的方法有好几种，例如jquery ajax、vue-resource、axios，而vue-resource是vue插件，但3版本不再更新，目前官方推荐主流的axios，aixos是一个http请求库。


官方文档：  http://www.axios-js.com/zh-cn/docs/



### Axios的使用

使用流程：

1.安装axios：`npm install axios`


2.在 main.js 文件中全局注册

```js
import './assets/main.css'

import {createApp} from 'vue'
import App from './App.vue'
import router from './router'
import Test from './components/Test.vue'
//导入axios
import axios from 'axios'

const app = createApp(App)
//全局注册子组件
app.component('Test', Test)
//注册axios到全局
app.config.globalProperties.$axios = axios;
app.use(router).mount("#app");
```


### Axios使用之GET

3.在 `components/Test.vue` 组件中通过 axios 请求 http://www.aliangedu.com.cn/test-table/user.json 获取测试数据并在 console 展示

```html
<template>
  <div class="test">
    {{ msg }} <br>
  </div>
  <table border="1px">
    <thead>
    <tr>
      <th>姓名</th>
      <th>邮箱</th>
      <th>城市</th>
      <th>性别</th>
    </tr>
    </thead>
    <tbody>
    <tr v-for="row in axiosData" :key="row.id">
      <td>{{ row.username }}</td>
      <td>{{ row.email }}</td>
      <td>{{ row.city }}</td>
      <td>{{ row.sex }}</td>
    </tr>
    </tbody>
  </table>
  <button @click="btn">传递数据到父组件</button>
</template>

<script>
export default {
  name: "Test",
  props: {
    msg: String,
  },
  data() {
    return {
      hello: "这是Test子组件的数据",
      axiosData: ''
    }
  },
  methods: {
    btn() {
      this.$emit("hello", this.hello)
    },
    getData() {
      this.$axios.get('http://www.aliangedu.com.cn/test-table/user.json')
          .then(response => {
                this.axiosData = response.data.data
                console.log(response.data)
              }
          )
    }
  },
  mounted() {
    this.getData()
  }
}
</script>

<style scoped>
.test {
  width: 200px;
  height: 200px;
  background: orange;
}
</style>
```


4.效果展示

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.60tz7bqfsm.png){: .zoom}



### Axios使用之POST


1.创建 `views/LoginView.vue` 页面

```html
<template>
  <div class="login">
    <img src="../assets/devops.png" alt="Vue logo">
    <h1>欢迎访问devops平台</h1>
    <br>
    <div class="input-row">
      <span>用户名：</span>
      <input type="text" name="username" v-model="form.username">
    </div>
    <div class="input-row">
      <span>密码：</span>
      <input type="text" name="password" v-model="form.password">
    </div>
    <button @click="loginBtn">登录</button>
    <p style="color: red" v-if="notice">用户名或者密码不能为空</p>
  </div>
</template>

<script>
export default {
  name: "LoginView",
  data() {
    return {
      form: {
        username: '',
        password: ''
      },
      notice: false
    }
  },
  methods: {
    loginBtn() {
      if (this.form.username == '' || this.form.password == '') {
        this.notice = true
      } else {
        this.notice = false;
        console.log(this.form)
        this.$axios.post('http://127.0.0.1:8000/api', this.form)
      }
    }
  }
}
</script>

<style scoped>
.login {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

.input-row {
  display: flex;
  align-items: center;
}

.input-row span {
  margin-right: 10px;
}
</style>
```


2.配置 `router/index.js` 路由

```js
// ...
const routes = [
    {
        path: "/",
        name: "root",
        component: Home,
    },
// ....
    {
        path: "/login",
        name: "login",
        component: () =>
            import(/* webpackChunkName: "about" */ "../views/LoginView.vue"),
    },
];

const router = createRouter({
    history: createWebHistory(),
    routes,
});

export default router;
```



3.配置 App.vue 上的登录跳转

```html
<template>
  <nav>
    <router-link to="/">首页</router-link>
    |
    <router-link to="/about">关于</router-link>
    |
    <router-link to="/new">新页面</router-link>
    |
    <router-link to="/login">登录</router-link>
  </nav>
  <router-view/>
</template>
<!-- ....其余不动.... -->
```


4.页面测试

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.7zq5xoj9sg.webp){: .zoom}




#### Axios异常处理

很多时候我们可能并没有从 API 获取想要的数据。这可能是由于很多种因素引起的，比如 axios 调用可能由于多种原因而失败，包括但不限于：

- API 不工作了；
- 请求发错了；
- API 没有按我们预期的格式返回信息。


1.可以使用catch异常处理这些问题

```html
<template>
  <div class="login">
    <img src="../assets/devops.png" alt="Vue logo">
    <h1>欢迎访问devops平台</h1>
    <br>
    <div class="input-row">
      <span>用户名：</span>
      <input type="text" name="username" v-model="form.username">
    </div>
    <div class="input-row">
      <span>密码：</span>
      <input type="text" name="password" v-model="form.password">
    </div>
    <button @click="loginBtn">登录</button>
    <p style="color: red" v-if="erros">连接服务器异常，请稍后再试</p>
  </div>
</template>

<script>
export default {
  name: "LoginView",
  data() {
    return {
      form: {
        username: '',
        password: ''
      },
      erros: false
    }
  },
  methods: {
    loginBtn() {
      console.log(this.form)
      this.$axios.post('http://127.0.0.1:8000/api', this.form)
          .then(response => {
            console.log(response.data.code)
          })
          .catch(error => {
            this.erros = true
            console.log(error)
          })
    }
  }
}
</script>

<style scoped>
.login {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

.input-row {
  display: flex;
  align-items: center;
}

.input-row span {
  margin-right: 10px;
}
</style>
```


2.效果展示

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.8z69ausv1h.png){: .zoom}




#### Axios 全局默认值

在实际开发中，几乎每个组件都会用到 axios 发起数据请求，如果每次都填写完整的请求路径，不利于后期维护。


这时可以设置全局 axios 默认值。


1.新增 axios 全局配置: main.js


```js
import './assets/main.css'

import {createApp} from 'vue'
import App from './App.vue'
import router from './router'
import Test from './components/Test.vue'
//导入axios
import axios from 'axios'

const app = createApp(App)
//全局注册子组件
app.component('Test', Test)
//注册axios到全局
//注册axios到全局
app.config.globalProperties.$axios = axios;
//axios全局配置
axios.defaults.baseURL = "http://www.aliangedu.com.cn";
axios.defaults.timeout = 5000;
app.use(router).mount("#app");
```

2.修改 `components/Test.vue` 的 axios get 配置，去掉域名

```html
<template>
  <div class="test">
    {{ msg }} <br>
  </div>
  <table border="1px">
    <thead>
    <tr>
      <th>姓名</th>
      <th>邮箱</th>
      <th>城市</th>
      <th>性别</th>
    </tr>
    </thead>
    <tbody>
    <tr v-for="row in axiosData" :key="row.id">
      <td>{{ row.username }}</td>
      <td>{{ row.email }}</td>
      <td>{{ row.city }}</td>
      <td>{{ row.sex }}</td>
    </tr>
    </tbody>
  </table>
  <button @click="btn">传递数据到父组件</button>
</template>

<script>
export default {
  name: "Test",
  props: {
    msg: String,
  },
  data() {
    return {
      hello: "这是Test子组件的数据",
      axiosData: ''
    }
  },
  methods: {
    btn() {
      this.$emit("hello", this.hello)
    },
    getData() {
      this.$axios.get('/test-table/user.json')
          .then(response => {
                this.axiosData = response.data.data
                console.log(response.data)
              }
          )
    }
  },
  mounted() {
    this.getData()
  }
}
</script>

<style scoped>
.test {
  width: 200px;
  height: 200px;
  background: orange;
}
</style>
```

3.效果展示： 还是可以获取到数据

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.b8mvs2bcv.webp){: .zoom}




#### Axios 自定义实例默认值

有时候服务端接口有多个地址，就会涉及请求的域名不同、配置不同等，这时自定义实例可以很好解决。


1.创建 `src/api/http.js`

```js
import axios from "axios"

const instance = axios.create({
    baseURL: 'http://www.aliangedu.com.cn/',
    timeout: 5000
})

export default instance
```

2.创建 `src/api/http2.js`

```js
import axios from "axios"

const instance = axios.create({
    baseURL: 'http://api.aliangedu.com.cn/',
    timeout: 5000
})

export default instance
```

3.全局注册：`main.js`

```js
import './assets/main.css'

import {createApp} from 'vue'
import App from './App.vue'
import router from './router'
import Test from './components/Test.vue'
//导入axios, 重新封装的axios
import axios from "./api/http";
import axios2 from "./api/http2";

const app = createApp(App)
//全局注册子组件
app.component('Test', Test)

//注册axios到全局
app.config.globalProperties.$axios = axios;
app.config.globalProperties.$axios2 = axios2;
app.use(router).mount("#app");
```

4.使用 axios 和 axios2 的时候再 vue 的 components ,或者 views 中应用即可

```html
<template>
  <div class="test">
    {{ msg }} <br>
  </div>
  <table border="1px">
    <thead>
    <tr>
      <th>姓名</th>
      <th>邮箱</th>
      <th>城市</th>
      <th>性别</th>
    </tr>
    </thead>
    <tbody>
    <tr v-for="row in axiosData" :key="row.id">
      <td>{{ row.username }}</td>
      <td>{{ row.email }}</td>
      <td>{{ row.city }}</td>
      <td>{{ row.sex }}</td>
    </tr>
    </tbody>
  </table>
  <button @click="btn">传递数据到父组件</button>
</template>

<script>
export default {
  name: "Test",
  props: {
    msg: String,
  },
  data() {
    return {
      hello: "这是Test子组件的数据",
      axiosData: ''
    }
  },
  methods: {
    btn() {
      this.$emit("hello", this.hello)
    },
    getData() {
      //this.$axios2.get('/test-table/user.json')
      this.$axios.get('/test-table/user.json')
          .then(response => {
                this.axiosData = response.data.data
                console.log(response.data)
              }
          )
    }
  },
  mounted() {
    this.getData()
  }
}
</script>

<style scoped>
.test {
  width: 200px;
  height: 200px;
  background: orange;
}
</style>
```

#### Axios拦截器

拦截器可以拦截每一次请求和响应，然后进行相应的处理。

请求拦截应用场景：

- 发起请求前添加header




响应拦截应用场景：

- 统一处理API响应状态码200或非200的提示消息

- 统一处理catch异常提示信息


![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.7i04952j17.webp){: .zoom}


1.`src/api/http.js`

```js
import axios from "axios"

const instance = axios.create({
    baseURL: 'http://www.aliangedu.com.cn/',
    timeout: 5000
})
//请求拦截器
instance.interceptors.request.use(config => {
    //在请求api之前做什么
    //config.headers['X-Custom-Header'] = '123456'
    console.log(config)
    return config;
}, error => {
    return Promise.reject(error)
})
//响应拦截器
instance.interceptors.response.use(response => {
    //处理响应数据
    if (response.data.code != 200) {
        alert("服务端响应错误!!")
    }
    return response
}, error => {
    //处理catch的地方
    alert('请求接口错误')
    return Promise.reject(error)
})

export default instance
```




- example示例


`.env.prod`

```sh
NODE_ENV=prod
 
VUE_APP_CURRENTMODE=build
 
VUE_APP_BASEURL=http://api.scajy.cn/
```


```js
import axios from 'axios'
import { ElMessage } from 'element-plus'

const instance = axios.create({
  // api请求地址，根据实际需求修改
  baseURL: process.env.VUE_APP_BASEURL,
  // timeout: 30000   // 超时时间，默认是ms秒单位
  // headers: {'X-Custom-Header': 'foobar'}
})

// 拦截器：请求拦截
instance.interceptors.request.use(
  config => {
    // 在请求被发送之前做些什么
    const token = window.sessionStorage.getItem('token')
    if (token) {
      config.headers = {
        Authorization: 'token  ' + token
      }
    }
    return config
  },
  error => {
    // 处理请求错误
    return Promise.reject(error)
  }
)

// 拦截器： 响应拦截
instance.interceptors.response.use(
  response => {
    // console.log('响应拦截处理');
    if (response.data.code == 400) {
      ElMessage.warning('错误请求: ' + response.data.msg)
    } else if (response.data.code == 401) {
      ElMessage.warning('未授权，请重新登录')
    } else if (response.data.code == 403) {
      ElMessage.warning('拒绝访问')
    } else if (response.data.code == 404) {
      ElMessage.warning('请求错误,未找到该资源')
    } else if (response.data.code == 405) {
      ElMessage.warning('请求方法未允许')
    } else if (response.data.code == 408) {
      ElMessage.warning('请求超时')
    } else if (response.data.code == 500) {
      ElMessage.warning('服务器端出错:' + response.data.msg)
    } else if (response.data.code == 501) {
      ElMessage.warning('网络未实现')
    } else if (response.data.code == 502) {
      ElMessage.warning('网络错误')
    } else if (response.data.code == 503) {
      ElMessage.warning('服务不可用')
    } else if (response.data.code == 504) {
      ElMessage.warning('网络超时')
    } else if (response.data.code != 200) {
      ElMessage.warning(response.data.msg) // 这里应根据后端返回消息显示
    }
    return response
  },
  error => {
    // 处理响应错误（catch）
    ElMessage.error('请求服务端接口错误：' + error.message)
    return Promise.reject(error)
  }
)

// 导出实例
export default instance
```

## Vue路由: vue-router


### 介绍

Vue Router 是 Vue.js (opens new window)官方的路由管理器。它和 Vue.js 的核心深度集成，包含的功能有：

- 嵌套的路由/视图表
- 模块化的、基于组件的路由配置
- 路由参数、查询、通配符
- 基于 Vue.js 过渡系统的视图过渡效果
- 细粒度的导航控制


#### vue-router的安装

1.在用脚手架创建项目时已经选择安装上了，如果刚开始没有，通过npm安装：

```sh
npm install vue-router@4 -g
```


2.进入项目目录执行 `vue add router`, 安装完后会有router目录：

```sh
cd vue3-devops
vue add router
```


#### 使用流程

1.开发页面（组件）

2.定义路由

3.组件使用路由


![](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.9gwazjxdxi.webp){: .zoom}



### 路由传参

URL传参：一般用于页面跳转，将当前数据传递到新页面，例如详情页



**params传参**

- 配置路由： `{path: ‘/user/:id’, component: about}`
- 传递方式：`<router-link to=“/user/6/”></router-link>`
- 传递后路径：`/user/6`
- 接收参数：`$route.params.id`





**query传参**

- 配置路由： `{path: ‘/user/’, component: about}`
- 传递方式：`<router-link to=”{path: ‘/about ‘, query:{id:6}}”></router-link>`
- 传递后路径：`/user?id=6`
- 接收参数：`$route.query.id`



#### 基于params传参示例

1.新增 `views/ArticleList.vue`

```html
<template>
  <div class="article_list">
    文章列表
    <ul>
      <li v-for="row in articleList" :key="row.id">
        <router-link :to="/article_detail/+row.id">{{ row.title }}</router-link>
      </li>
    </ul>
  </div>

</template>

<script>
export default {
  name: "ArticleList",
  data() {
    return {
      articleList: [
        {id: 1, title: 'Python'},
        {id: 2, title: 'Golang'},
        {id: 3, title: 'Vue'},
        {id: 4, title: 'Devops'},
      ]
    }
  }
}
</script>

<style scoped>
.article_list {
  width: 200px;
  height: 200px;
  text-align: center;
}
</style>
```


2.新增 `views/ArticleDetail.vue`

```html
<template>
  文章详情
  <div>
    这是文章文章id： {{ article_id }}内容
  </div>
</template>

<script>
export default {
  name: "ArticleDetail",
  data() {
    return {
      article_id: ""
    }
  },
  mounted() {
    //请求API携带的文章id获取后端数据
    this.article_id = this.$route.params.id;
  }
}
</script>

<style scoped>

</style>
```

3.配置路由 `router/index.js`


```js
import {createRouter, createWebHistory} from 'vue-router'
import HomeView from '../views/HomeView.vue'


const routes = [
    {
        path: '/',
        name: 'home',
        component: HomeView
    },
    {
        path: '/about',
        name: 'about',
        // route level code-splitting
        // this generates a separate chunk (about.[hash].js) for this route
        // which is lazy-loaded when the route is visited.
        component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue')
    },
    {
        path: "/article_list",
        name: "article_list",
        component: () => import(/* webpackChunkName: "about" */ "../views/ArticleList.vue"),
    },
    {
        path: "/article_detail/:id",
        name: "article_detail",
        component: () => import(/* webpackChunkName: "about" */ "../views/ArticleDetail.vue"),
    }
]

const router = createRouter({
    history: createWebHistory(process.env.BASE_URL),
    routes
})

export default router
```

4.效果展示

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.lt2r8flw.webp){: .zoom}



#### 基于query传参示例


1. 修改 `views/ArticleList.vue`


```html
<template>
  <div class="article_list">
    文章列表
    <ul>
      <li v-for="row in articleList" :key="row.id">
        <!--                <router-link :to="/article_detail/+row.id">{{row.title}}</router-link>-->
        <router-link :to="/article_detail/+'?id='+row.id">{{ row.title }}</router-link>
      </li>
    </ul>
  </div>

</template>

<script>
export default {
  name: "ArticleList",
  data() {
    return {
      articleList: [
        {id: 1, title: 'Python'},
        {id: 2, title: 'Golang'},
        {id: 3, title: 'Vue'},
        {id: 4, title: 'Devops'},
      ]
    }
  }
}
</script>

<style scoped>
.article_list {
  width: 200px;
  height: 200px;
  text-align: center;
}
</style>
```

2.修改 `views/ArticleDetail.vue`

```html
<template>
  文章详情
  <div>
    这是文章文章id： {{ article_id }}内容
  </div>
</template>

<script>
export default {
  name: "ArticleDetail",
  data() {
    return {
      article_id: ""
    }
  },
  mounted() {
    //请求API携带的文章id获取后端数据
    // this.article_id = this.$route.params.id;
    this.article_id = this.$route.query.id;
  }
}
</script>

<style scoped>

</style>
```

3.配置路由`router/index.js`

```js
import {createRouter, createWebHistory} from 'vue-router'
import HomeView from '../views/HomeView.vue'


const routes = [
    {
        path: '/',
        name: 'home',
        component: HomeView
    },
    {
        path: '/about',
        name: 'about',
        // route level code-splitting
        // this generates a separate chunk (about.[hash].js) for this route
        // which is lazy-loaded when the route is visited.
        component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue')
    },
    {
        path: "/article_list",
        name: "article_list",
        component: () => import(/* webpackChunkName: "about" */ "../views/ArticleList"),
    },
    {
        // path: "/article_detail/:id",  //params传参的方式
        path: "/article_detail",
        name: "article_detail",
        component: () => import(/* webpackChunkName: "about" */ "../views/ArticleDetail.vue"),
    },

]

const router = createRouter({
    history: createWebHistory(process.env.BASE_URL),
    routes
})

export default router
```


4.效果展示

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.5fkbl6urmm.webp){: .zoom}



### Vue-router导航守卫


正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。简单来说，就是在路由跳转时候的一些钩子，当从一个页面跳转到另一个页面时，可以在跳转前、中、后做一些事情。

- 可以使用 router.beforeEach 注册一个全局前置守卫：

```js
// 定义导航守卫
router.beforeEach((to, from) => {
    console.log(from);
    console.log(to)
})
```

#### 每个守卫方法接收参数：

- to：即将要进入的目标，是一个路由对象
- from：当前导航正要离开的路由，也是一个路由对象
- next：可选，是一个方法



#### 可以返回的值如下：

- false：取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。
- 一个路由地址：通过一个路由地址跳转到一个不同的地址。



#### 导航守卫经典应用场景

在网站开发中，使用导航守卫一个普遍需求：**登录验证，**即在没有登录的情况下，访问任何页面都跳转到登录页面。

1.修改`router/index.js` , 配置登录的导航守卫

```js
// ....
// 定义导航守卫
router.beforeEach((to, from, next) => {
    console.log(to)
    console.log(from)
    //无需登录即可访问的页面
    if (to.path == "/") {
        return next()
    }
    //需要登录才可以访问的页面
    const token = '';
    if (token) {
        next(); //正常跳转
    } else {
        alert("先登录在访问")
        // return next('/login')
    }
})
```



2.效果展示

![image](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/image.99t345nm16.webp){: .zoom}




示例1:


当没有token，为未登录状态时，强制跳转到登录页

```js
// ....
// 为路由对象，添加 beforeEach 导航守卫
router.beforeEach((to, form, next) => {
  /*
   to 将要访问的路径
   from 代表从那个路径跳转而来
   next 是一个函数，表示放行
      next() 放行   next('/login') 强制跳转
  */

  // 如果用户访问的登录页，直接放行
  if (to.path === '/login') return next()
  // 从 sessionStorage 中获取到 保存的 token 值
  const tokenStr = window.sessionStorage.getItem('token')
  // 没有token，强制跳转到登录页
  if (!tokenStr) return next('/login')
  next()
})

```


示例2

如果访问非登录界面，且户会话信息不存在，代表未登录，则跳转到登录界面


```js

// ....
router.beforeEach((to, from, next) => {
  // 登录界面登录成功之后，会把用户信息保存在会话
  // 存在时间为会话生命周期，页面关闭即失效。
  let token = Cookies.get('token')
  let userName = sessionStorage.getItem('user')
  if (to.path === '/login') {
    // 如果是访问登录界面，如果用户会话信息存在，代表已登录过，跳转到主页
    if(token) {
      next({ path: '/' })
    } else {
      next()
    }
  } else {
    if (!token) {
      // 如果访问非登录界面，且户会话信息不存在，代表未登录，则跳转到登录界面
      next({ path: '/login' })
    } else {
      // 加载动态菜单和路由
      addDynamicMenuAndRoutes(userName, to, from)
      next()
    }
  }
})
```

