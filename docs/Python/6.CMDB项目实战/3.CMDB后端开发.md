# 3.CMDB后端开发


## 企业项目开发流程

![1707100340914](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100340914.webp){: .zoom}



## 项目背景

目前运维管理存在痛点：随着业务增长，服务器数量越来越多，资产信息通过Excel记录，人工管理低效，易于出错。


## CMDB介绍

- 配置管理数据库（Configuration Management Database，CMDB），是一个逻辑数据库，包含了应用生命周期的信息，例如服务器、物理关系、通信关系、依赖关系等。

- CMDB存储与管理企业IT架构中设备的各种配置信息，它与所有运维服务和应用发布流程都紧密相联，支持这些流程的运转、发挥配置信息的价值，同时依赖于相关流程保证数据的准确性。CMDB可以实现高度的自动化，减少人为错误的发生、降低人员成本，CMDB是实现运维自动化的基础。

- CMDB资产

![1707100437351](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100437351.webp){: .zoom}



### CMDB数据存储需要注意的事项

- CMDB的目的是为了在其他流程或应用之间共享数据的，如果一个应用或流程需要对某类数据单独使用的话，则不建议将这类数据存入CMDB中，存在自身应用即可。
- 动态数据不建议存储在CMDB中，例如CPU使用率、内存使用率，因为这类数据更新过于频繁。
- 如果没有任何流程、应用及人员，需要对特定的数据进行使用，则没有必要放到CMDB中存储。



### 技术选型

![1707100589501](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100589501.webp){: .zoom}



前端技术栈

- Vue3
- Vue-router
- Element Plus
- Axios


后端技术栈

- python
- Django DRF
- mysql


### 整体设计

![1707100822692](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100822692.webp){: .zoom}



## 数据库设计

![1707105493241](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707105493241.webp){: .zoom}



### 机房管理

表名：cmdb_idc

| 字段         | 类型                  | 空   | 名称     |
|--------------|-----------------------|------|---------|
| id           | INTEGER               | 否   | 自增长ID |
| name         | VARCHAR(30)（unique） | 否   | 机房名称 |
| city         | VARCHAR(20)           | 否   | 城市     |
| provider     | VARCHAR(20)           | 否   | 运营商   |
| note         | TEXT                  | 是   | 备注     |
| create_time  | DATETIME              | 否   | 创建时间 |


### 主机分组

表名：cmdb_server_group

| 字段名       | 类型       | 允许为空 | 名称     |
| ------------ | ---------- | -------- | -------- |
| id           | INTEGER    | 否       | 自增长ID |
| name         | VARCHAR(30)| 否       | 分组名称 |
| note         | TEXT       | 是       | 备注     |
| create_time  | DATETIME   | 否       | 创建时间 |


### 主机管理

表名：cmdb_server

| 字段名              | 类型            | 允许为空 | 名称                     |
| -------------------| --------------- | -------- | ------------------------ |
| id                 | INTEGER         | 否       | 自增长ID                 |
| idc                | IDC表一对多关系 | 否       | IDC机房                  |
| server_group       | 分组表多对多关系 | 否       | 主机分组                 |
| credential         | 凭据表一对多     | 否       | 凭据ID                   |
| name               | VARCHAR(30)     | 否       | 名称，默认与主机名一样   |
| hostname           | VARCHAR(30)     | 否       | 主机名，唯一标识符       |
| ssh_ip             | VARCHAR(40)     | 否       | SSH IP                   |
| ssh_port           | INTEGER         | 否       | SSH端口                  |
| machine_type       | VARCHAR(20)     | 是       | 机器类型（虚拟机、云主机、物理机） |
| os_version         | VARCHAR(30)     | 是       | 系统版本                 |
| public_ip          | JSON            | 是       | 公网IP（列表存储，会有多个ip） |
| private_ip         | JSON            | 否       | 内网IP（列表存储）        |
| cpu_num            | VARCHAR(10)     | 是       | CPU数量                  |
| cpu_model          | VARCHAR(100)    | 是       | CPU型号                  |
| memory             | VARCHAR(30)     | 是       | 内存                     |
| disk               | JSON            | 是       | 硬盘（列表存储，包含设备、容量、硬盘类型） |
| put_shelves_date   | DATE            | 是       | 上架日期，默认为系统启动时间 |
| off_shelves_date   | DATE            | 是       | 下架日期                 |
| expire_datetime    | DATETIME        | 是       | 租约过期时间             |
| is_verified        | VARCHAR(10)     | 是       | SSH验证状态（已验证，未验证） |
| note               | TEXT            | 是       | 备注                     |
| update_time        | DATETIME        | 是       | 更新时间                 |
| create_time        | DATETIME        | 否       | 创建时间                 |


### 系统配置:凭据管理

表名：system_config_credential

| 字段名        | 类型       | 允许为空 | 名称         |
| -------------| ---------- | -------- | ------------ |
| id           | INTEGER    | 否       | 自增长ID     |
| name         | VARCHAR(30)| 否       | 名称         |
| auth_mode    | VARCHAR(30)| 否       | 认证方式，key、pass |
| username     | VARCHAR(20)| 否       | 用户名       |
| password     | VARCHAR(30)| 是       | 密码         |
| private_key  | TEXT       | 是       | 私钥         |
| note         | TEXT       | 是       | 备注         |
| update_time  | DATETIME   | 否       | 更新时间     |
| create_time  | DATETIME   | 否       | 创建时间     |



## API 平台开发


### 接口设计

| 请求路径                            | HTTP方法       | 功能                            | 备注                               |
| -----------------------------------| -------------- | ------------------------------- | ---------------------------------- |
| /api/cmdb/idc/                      | get, post, put, delete | 查看，创建，更新，删除         | IDC机房                            |
| /api/cmdb/server_group/             | get, post, put, delete | 查看，创建，更新，删除         | 主机分组                           |
| /api/cmdb/server/                   | get, post, put, delete | 查看，创建，更新，删除         | 服务器                            |
| /api/cmdb/create_host               | post           | 创建                            | 新建主机                           |
| /api/cmdb/host_collect              | get            | SSH连接采集主机配置                | SSH连接采集主机配置                  |
| /api/cmdb/excel_create_host         | get, post      | 下载excel模板文件，提交文件      | excel导入主机                      |
| /api/cmdb/tencent_cloud             | get            | 调用腾讯云ECS API获取                | 腾讯云云主机导入                     |
| /api/cmdb/aliyun_cloud              | get            | 调用阿里云ECS API获取                | 阿里云云主机导入                     |


## API平台雏形(上)


### 基础准备

1.pip需要安装的包

```sh
pip3 install django==3.2
pip3 install pymysql
pip3 install djangorestframework
pip3 install django-rest-swagger
pip3 install django-filter
pip3 install Markdown
pip3 install coreapi
pip3 install pillow
```

在命令行中发送请求，笔者推荐 [httpie](https://github.com/jakubroztocil/httpie#installation) 这个库，基于 Python 并且小巧美观。


```sh
pip install httpie
```


2.Pycharm创建项目



3.创建应用

```sh
(venv) > python manage.py startapp cmdb
(venv) > python manage.py startapp system_config
```


4.调整 `settings.py` 配置

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'django_filters',
    'cmdb',
    'system_config'
]
```

5.本地安装并启动 mysql，设置好数据库，用户

```sh
wanghui@kkkk ~ % mysql -uroot -proot
mysql> create database devops_backend;
```

6.配置mysql数据库

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'devops_backend',
        'USER': 'root',
        'PASSWORD': 'oschina',
        'HOST': '127.0.0.1',
        'PORT': '3306',
        # 第三方登录功能必须加上
        "OPTIONS": {"init_command": "SET default_storage_engine=INNODB", "charset": "utf8mb4"},
    }
}
```

7.devops_api/init.py 配置默认的pymysql为驱动

```python
import pymysql

pymysql.install_as_MySQLdb()
```

### cmdb数据库model和system_config数据库model设置


1.system_config model配置： `devops_api/system_config/models.py`

```python
from django.db import models

class Credential(models.Model):
    auth_choice = (
        (1, "密码"),
        (2, "秘钥")
    )
    name = models.CharField(max_length=30, verbose_name="凭据名称")
    username = models.CharField(max_length=20, verbose_name="用户名")
    auth_mode = models.IntegerField(choices=auth_choice, default=1, verbose_name="认证方式")
    password = models.CharField(max_length=50, blank=True, verbose_name="密码")
    private_key = models.TextField(blank=True, verbose_name="私钥")
    note = models.TextField(blank=True, verbose_name="备注")
    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    update_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        db_table = "system_config_credential"
        verbose_name_plural = "凭据管理"
        ordering = ('-id',)

    def __str__(self):
        return self.name
```

2.cmdb model配置: `devops_api/cmdb/models.py`

```python
from django.db import models
from system_config.models import Credential

class Idc(models.Model):
    '''
    idc表
    '''
    name = models.CharField(max_length=64,unique=True,verbose_name="idc名称")
    city = models.CharField(max_length=64, verbose_name="城市")
    provider = models.CharField(max_length=64,verbose_name="提供商")
    note = models.TextField(null=True, blank=True, verbose_name="备注")
    create_time = models.DateTimeField(auto_now_add=True,verbose_name="创建时间")

    class Meta:
        db_table = 'cmdb_idc'
        verbose_name_plural = 'idc机房'
        ordering = ('-id',)

    def __str__(self):
        return self.name

class ServerGroup(models.Model):
    '''
    主机分组
    '''
    name = models.CharField(max_length=64,unique=True,verbose_name="分组名称")
    note = models.TextField(null=True,blank=True,verbose_name="备注")
    create_time = models.DateTimeField(auto_now_add=True,verbose_name="创建时间")

    class Meta:
        db_table = "cmdb_server_group"
        verbose_name_plural = "服务器分组"
        ordering = ('-id',)

    def __str__(self):
        return self.name

class Server(models.Model):
    '''
    服务器组
    '''
    idc = models.ForeignKey(Idc, on_delete=models.PROTECT, verbose_name="IDC机房")
    server_group = models.ManyToManyField(ServerGroup, default="Default", verbose_name="主机分组")
    credential = models.ForeignKey(Credential,on_delete=models.PROTECT, verbose_name="SSH凭据")

    hostname = models.CharField(max_length=30, unique=True, verbose_name="主机名")
    name = models.CharField(max_length=30, unique=True, verbose_name="名称")

    ssh_ip = models.GenericIPAddressField(verbose_name="SSH IP")
    ssh_port = models.IntegerField(verbose_name="SSH端口")
    note = models.TextField(blank=True, null=True, verbose_name="备注")

    machine_type = models.CharField(max_length=30, blank=True,
                                    choices=(('vm', '虚拟机'), ('cloud_vm', '云主机'), ('physical_machine', '物理机')),
                                    verbose_name="机器类型")
    os_version = models.CharField(max_length=50, blank=True, null=True, verbose_name="系统版本")
    public_ip = models.JSONField(max_length=100, blank=True, null=True, verbose_name="公网IP")
    private_ip = models.JSONField(max_length=100, blank=True, null=True, verbose_name="内网IP")
    cpu_num = models.CharField(max_length=10, blank=True, null=True, verbose_name="CPU")
    cpu_model = models.CharField(max_length=100, blank=True, null=True, verbose_name="CPU型号")
    memory = models.CharField(max_length=30, blank=True, null=True, verbose_name="内存")
    disk = models.JSONField(max_length=200, blank=True, null=True, verbose_name="硬盘")
    network = models.CharField(max_length=200, blank=True, null=True, verbose_name="带宽")
    put_shelves_date = models.DateField(null=True, blank=True, verbose_name="上架日期")
    off_shelves_date = models.DateField(null=True, blank=True, verbose_name="下架日期")
    expire_datetime = models.DateTimeField(blank=True, null=True, verbose_name="租约过期时间")
    is_verified = models.CharField(max_length=10, blank=True, choices=(('verified', '已验证'), ('unverified', '未验证')),
                                   default='unverified', verbose_name="SSH验证状态")
    update_time = models.DateTimeField(auto_now_add=True, verbose_name="更新时间")
    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")

    class Meta:
        db_table = "cmdb_server"
        verbose_name_plural = "主机管理"
        ordering = ('-id',)

    def __str__(self):
        return self.hostname
```


3.同步数据

```sh
(venv) > python manage.py makemigrations 
(venv) > python manage.py migrate
```


### 定义序列化器

cmdb序列化器的定义： `devops_api/cmdb/serializers.py`

```python
from .models import Idc,ServerGroup,Server
from rest_framework import serializers

class IdcSerializers(serializers.ModelSerializer):
    class Meta:
        model = Idc
        fields = '__all__'
        read_only_fields = ("id",)

class ServerGroupSerializers(serializers.ModelSerializer):
    class Meta:
        model = ServerGroup
        fields = '__all__'
        read_only_fields = ("id",)
        
class ServerSerializers(serializers.ModelSerializer):
    class Meta:
        model = Server
        fields = '__all__'
        read_only_fields = ("id",)
```

System_config序列化器的定义： `devops_api/system_config/serializers.py`

```python
from .models import Credential
from rest_framework import serializers


class CredentialSerializer(serializers.ModelSerializer):
    class Meta:
        model = Credential
        fields = '__all__'
        read_only_fields = ("id",)
```


### 定义视图

1.定义cmdb视图： `devops_api/cmdb/views.py`

```python
from cmdb.models import Idc, ServerGroup, Server
from cmdb.serializers import IdcSerializers, ServerGroupSerializers, ServerSerializers
from rest_framework.viewsets import ModelViewSet


class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers


class ServerViewSet(ModelViewSet):
    queryset = Server.objects.all()
    serializer_class = ServerSerializers
```


2.定义system_config视图： `devops_api/system_config/views.py`

```python
from rest_framework.viewsets import ModelViewSet
from system_config.models import Credential
from system_config.serializers import CredentialSerializer


class CredentialViewSet(ModelViewSet):
    queryset = Credential.objects.all()
    serializer_class = CredentialSerializer
```



### 动态路由

1.注册cmdb和credentials的路由： `devops_api/devops_api/urls.py`

```python
from django.contrib import admin
from django.urls import path, include
from cmdb.views import IdcViewSet, ServerGroupViewSet, ServerViewSet
from system_config.views import CredentialViewSet
from rest_framework import routers
router = routers.DefaultRouter()
router.register(r'cmdb/idc', IdcViewSet, basename="idc")
router.register(r'cmdb/server_group', ServerGroupViewSet, basename="server_group")
router.register(r'cmdb/server', ServerViewSet, basename="server")
router.register(r'config/credential', CredentialViewSet, basename="credential")
urlpatterns = [
    path('admin/', admin.site.urls),
]

urlpatterns += [
    path('api/', include(router.urls))
]
```

2.查看接口

- http://127.0.0.1:8000/api/


```sh
C:\Users\18793> http http://127.0.0.1:8000/api/
HTTP/1.1 200 OK
Allow: GET, HEAD, OPTIONS
Content-Length: 239
Content-Type: application/json
Date: Tue, 20 Feb 2024 05:55:48 GMT
Referrer-Policy: same-origin
Server: WSGIServer/0.2 CPython/3.11.5
Vary: Accept, Cookie
X-Content-Type-Options: nosniff
X-Frame-Options: DENY

{
    "cmdb/idc": "http://127.0.0.1:8000/api/cmdb/idc/",
    "cmdb/server": "http://127.0.0.1:8000/api/cmdb/server/",
    "cmdb/server_group": "http://127.0.0.1:8000/api/cmdb/server_group/",
    "config/credential": "http://127.0.0.1:8000/api/config/credential/"
}
```



### 新增接口数据


#### idc数据

> http://127.0.0.1:8000/api/cmdb/idc/


查看接口数据

```sh
$ http http://127.0.0.1:8000/api/cmdb/idc/
# ...
[]
```

新增接口数据

```sh
$ http POST http://127.0.0.1:8000/api/cmdb/idc/ Content-Type:application/json name="酒仙桥兆唯机房" city="北京" provider="电信" note=""
# ....
{
    "city": "北京",
    "create_time": "2024-02-20T05:57:43.948797Z",
    "id": 1,
    "name": "酒仙桥兆唯机房",
    "note": "",
    "provider": "电信"
}
$ http POST http://127.0.0.1:8000/api/cmdb/idc/ Content-Type:application/json name="百度云机房" city="上海" provider="电信" note=""
$ http POST http://127.0.0.1:8000/api/cmdb/idc/ Content-Type:application/json name="腾讯云机房" city="深圳" provider="移到" note=""
$ http POST http://127.0.0.1:8000/api/cmdb/idc/ Content-Type:application/json name="阿里云机房" city="杭州" provider="联通" note=""
```


#### server-group数据

> http://127.0.0.1:8000/api/cmdb/server_group/


查看接口数据

```sh
$ http http://127.0.0.1:8000/api/cmdb/server_group/
# ...
[]
```


新增接口数据

```sh

$ http POST http://127.0.0.1:8000/api/cmdb/server_group/ Content-Type:application/json name="运维开发服务器" note=""
$ http POST http://127.0.0.1:8000/api/cmdb/server_group/ Content-Type:application/json name="k8s集群" note=""
$ http POST http://127.0.0.1:8000/api/cmdb/server_group/ Content-Type:application/json name="小程序项目" note=""
$ http POST http://127.0.0.1:8000/api/cmdb/server_group/ Content-Type:application/json name="搜索服务" note=""
```


#### credential数据

> http://127.0.0.1:8000/api/config/credential/


查看接口数据

```sh
$ http http://127.0.0.1:8000/api/config/credential/
# ...
[]
```

新增接口数据

用户名/秘钥认证
```sh
http --ignore-stdin --form --timeout 3600 POST 'http://127.0.0.1:8000/api/config/credential/' \
 'name'='ssh-cert' \
 'username'='ubuntu' \
 'auth_mode'='2' \
 'password'= \
 'private_key'='-----BEGIN RSA PRIVATE KEY-----
MIIEoQIBAAKCAQEAyrPhiJrgQae+Qlgbs+PBG7lhJ2q4y3F5dvOzmz9PCTGOu/yM
mkIw0/w4JVrQGE2VKv591v14fK5gS3Wv7NEF6qnaUsQep03GXFTWTKD+Kb32bmEd
5y+uMReiuRLOeAj2e3XDSEAdUXcIH7bSj1qIIDbmSI2E04HVezXM/qt548Q6J6Lp
IzQFJu4EprcGNPsrtvHusfpnva+FbuH0XX+xLuNILQDx9hWo5gQv5ynl0KcCk19k
LjlAiZnXTETrPKq/y/uPGf84g1NXfW+FRZFDY1sDnAEygr/N/e7jD5vv8dK1YH8j
M9/oK11zaks+lbp5jrVkHBdxM5r8BzRmQP1GbQIBIwKCAQB/acD2x8ApRN390Pt4
Y0YurwneQxUSKhHVvcFaRQ0buMAeZDsfIkqT4F3OVlbqtGxkKvADesDDZksoHhbP
XtCE38sPc/YCwyw6CXDCc9L1qprmS6xlbm198Zl7pWvWbAilX/cXeMH4sThOcurA
ggxsBUBK3JyiNFpNckZW73EwE9HjRMP8qMD0lowqzJg4W6KWEzZFe6Ugfw1Y2cI5
1nlW653wVkvlY/d4UpPYf8FE0PySZV/7srA1UKPNDVTHYO6j4p1VnIapoe6GbOBT
76d/q5/8vOhISwL/GWvGPR/EuWzyuZRkgPYbD1dCHx9UNKZdNPn+8xXUn+lnXrdr
U08LAoGBAPiUs1lK9K8vGIxzD9Y+26JFvQ+D2bUtRxZQLpG94zVd1Gy/PANF7otW
E8gOhE1QfRhsr8xa1aEIX5+rMVDX0ZquTmwBZ8QGRc9uzx27epxvPyy0xjoSk73v
jGEAIlt5QRsc2aXdUeUo/D2P6HbvwREmTglBd+IYs7yZZaQfkQmdAoGBANDApRI6
pzpEK8fBBJriR++Cc2XuIc7Fb8Kc+9wsUulSaXdvajAgTeVQhE4XfUIeUcyyJZZl
3p5yOe038sIQYdgBrVdWNbWGdKPbrV++vEsGFm+mmhKIy/+nFygORuHuJMoHT7Qr
BqoF4BPCpaFxdxnrZIdQqHgC0ZHsQ7WZlj8RAoGBAONGIFGjneH/LGMnXu/EcQlk
VRV/3P1rOa4AKpPgz7vDgGNtA6s4n5VWA3UUljgPE0mH8S/eBSWD/6fs+eODfc9A
R7M0fCDvysxIDdIKfrrpXlTCiVmqlbT4RdUHb96avy67SqZGsUaL3046biOZYA+t
/jRZHSZ8/Bol2UWZNCYLAoGAcVKiwMDBLkJDpvPAq9nsiVVx2D9xcD9LTGPZLmE0
UsZWgqoyVKPSg8yfmBthQSZm63amsLr1MXE1Y4TFnIyM4vmYnSAryPE4AS4cSesz
BCfgSz0vEWA0OlNkV5K4w8prviE55XZxVPvgCrofZkTo4i9T1G2dSHaPBhKLKBGM
E5sCgYAvmY+EabyJ50p2Mz0D7hfhritORLSvZkjKDggv2VvTb6J3LSzeYD9jgFA1
K0oxRjlyIk/MZchTJHKu/+10L0EIo85SGjDfedu0KBe7SDS2l/7W0XqYtjvuE6dy
xxxxxxxxxx
-----END RSA PRIVATE KEY-----
' \
 'note'=
```



用户名/密码认证

```sh
$ http POST http://127.0.0.1:8000/api/config/credential/ Content-Type:application/json name="ssh-pwd" username="root" auth_mode:=1 password="123456" private_key="" note=""
```



#### server数据

> http://127.0.0.1:8000/api/cmdb/server/


查看接口数据

```sh
$ http http://127.0.0.1:8000/api/cmdb/server/
# ....
[]
```

新增接口数据

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/cmdb/server/' \
--header 'Content-Type: application/json' \
--data-raw '{
	"hostname": "gdc-ci-base",
    "name": "baiducloud-cce-dev",
	"ssh_ip": "192.168.240.23",
	"ssh_port": 27312,
	"note": "",
	"machine_type": "vm",
	"os_version": "",
	"public_ip": ["106.12.43.56"],
	"private_ip": ["192.168.240.23"],
	"cpu_num": "",
	"cpu_model": "",
	"memory": "",
	"disk": [""],
    "network": "",
	"put_shelves_date": null,
	"off_shelves_date": null,
	"expire_datetime": null,
	"is_verified": "unverified",
	"idc": 2,
	"credential": 1,
	"server_group": [1]
}'
```


### 分页


1.定义分页lib，`devops_api/libs/pagination.py`


```python
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response
from collections import OrderedDict


class MyPagination(PageNumberPagination):
    page_size = 6  # 默认每页显示多少条
    page_query_param = 'page_num'  # 指定查询第几页（页码），默认 page
    page_size_query_param = 'page_size'  # 定义每页显示多少条
    max_page_size = 50  # 每页最多显示多少条

    # def get_paginated_response(self, data):
    #     code = 200
    #     msg = "成功"
    #     return Response(OrderedDict([
    #         ('code', code),
    #         ('msg', msg),
    #         ('count', self.page.paginator.count),
    #         # ('next', self.get_next_link()),
    #         # ('previous', self.get_previous_link()),
    #         ('data', data)
    #     ]))
    def get_paginated_response(self, data):
        code = 200
        msg = "成功"
        return Response(OrderedDict([
            ('code', code),
            ('msg', msg),
            ('count', self.page.paginator.count),
            ('next', self.get_next_link()),
            ('data', data)
        ]))
```


2.settings配置引用自定义分页(最后追加)： `devops_api/devops_api/settings.py`

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'libs.pagination.MyPagination'
}
```


### 过滤,搜索和排序

1.Cmdb视图中新增搜索和排序的字段: `devops_api/cmdb/views.py`

```python
from cmdb.models import Idc, ServerGroup, Server
from cmdb.serializers import IdcSerializers, ServerGroupSerializers, ServerSerializers
from rest_framework.viewsets import ModelViewSet
from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend


class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name", 'provider',)
    filterset_fields = ("city",)
    ordering_fields = ("id",)


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name",)
    filterset_fields = ("name",)
    ordering_fields = ("id",)


class ServerViewSet(ModelViewSet):
    queryset = Server.objects.all()
    serializer_class = ServerSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("hostname",)
    filterset_fields = ("hostname",)
    ordering_fields = ("id",)
```


2.credentials视图中新增搜索，过滤，排序字段：`devops_api/system_config/views.py`


```python
from rest_framework.viewsets import ModelViewSet
from system_config.models import Credential
from system_config.serializers import CredentialSerializer
from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend


class CredentialViewSet(ModelViewSet):
    queryset = Credential.objects.all()
    serializer_class = CredentialSerializer
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name",)
    filterset_fields = ("name",)
    ordering_fields = ("id",)
```


3.测试case

- 搜索: http://127.0.0.1:8000/api/cmdb/idc/?search=电信

```sh
$ http http://127.0.0.1:8000/api/cmdb/idc/?search=电信
# ....
{
    "code": 200,
    "count": 2,
    "data": [
        {
            "city": "上海",
            "create_time": "2024-02-20T10:04:29.258890Z",
            "id": 2,
            "name": "百度云机房",
            "note": "",
            "provider": "电信"
        },
        {
            "city": "北京",
            "create_time": "2024-02-20T10:04:15.370487Z",
            "id": 1,
            "name": "酒仙桥兆唯机房",
            "note": "",
            "provider": "电信"
        }
    ],
    "msg": "成功",
    "next": null
}
```

- 过滤: http://127.0.0.1:8000/api/cmdb/idc/?city=北京

```sh
$ http http://127.0.0.1:8000/api/cmdb/idc/?city=北京
# ....
{
    "code": 200,
    "count": 1,
    "data": [
        {
            "city": "北京",
            "create_time": "2024-02-20T10:04:15.370487Z",
            "id": 1,
            "name": "酒仙桥兆唯机房",
            "note": "",
            "provider": "电信"
        }
    ],
    "msg": "成功",
    "next": null
}
```


- 排序(逆序): http://127.0.0.1:8000/api/cmdb/idc/?ordering=-id

```sh
$ http http://127.0.0.1:8000/api/cmdb/idc/?ordering=-id
# ....
{
    "code": 200,
    "count": 4,
    "data": [
        {
            "city": "杭州",
            "create_time": "2024-02-20T10:04:42.758506Z",
            "id": 4,
            "name": "阿里云机房",
            "note": "",
            "provider": "联通"
        },
        {
            "city": "深圳",
            "create_time": "2024-02-20T10:04:35.774786Z",
            "id": 3,
            "name": "腾讯云机房",
            "note": "",
            "provider": "移到"
        },
        {
            "city": "上海",
            "create_time": "2024-02-20T10:04:29.258890Z",
            "id": 2,
            "name": "百度云机房",
            "note": "",
            "provider": "电信"
        },
        {
            "city": "北京",
            "create_time": "2024-02-20T10:04:15.370487Z",
            "id": 1,
            "name": "酒仙桥兆唯机房",
            "note": "",
            "provider": "电信"
        }
    ],
    "msg": "成功",
    "next": null
}
```


### 接口安全机制


目的是解决RESTful接口的用户认证和权限管理问题。

DRF框架中提供了3种认证方案：

● BasicAuthentication：基本的用户密码方式

● SessionAuthentication：Session会话认证，比如，Django的Admin后台管理系统就是用的这种认证方式。

● TokenAuthentication：使用Token令牌的HTTP身份认证。Token适用于前后端分离的项目。



#### 基于DRF框架实现Token认证


##### 1.配置应用

安装rest_framework.authtoken应用，并配置 REST_FRAMEWORK 项,同时还需要在 Django REST framework 中设置加密因子（secret key）：

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'django_filters',
    'cmdb',
    'system_config',
    'rest_framework.authtoken'
]

REST_FRAMEWORK = {
    # 分页
    'DEFAULT_PAGINATION_CLASS': 'libs.pagination.MyPagination',
    # 认证
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.TokenAuthentication',
    ],
    # 权限
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated'  # 登录后就能访问所有API
    ],
}
```


然后进行数据迁移，就会在数据表中生成authtoken_token表，用于保存应用生成的用户token：

```sh
python manage.py makemigrations
python manage.py migrate
```


##### 2.自定义token认证返回值

`devops_api/libs/token_auth.py`

```python
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from rest_framework.response import Response

class CustomAuthToken(ObtainAuthToken):

    def post(self, request, *args, **kwargs):
        serializer = self.serializer_class(data=request.data,
                                           context={'request': request})
        if serializer.is_valid():
            user = serializer.validated_data['user']
            token, created = Token.objects.get_or_create(user=user)
            res = {'code': 200,'msg': '认证成功','token': token.key,'username': user.username,}
            return Response(res)
        else:
            res = {'code': 500,'msg': '用户名或密码错误！'}
            return Response(res)
```


##### 3.定义路由

`devops_api/devops_api/urls.py`

```python
from django.contrib import admin
from django.urls import path, include,re_path
from cmdb.views import IdcViewSet, ServerGroupViewSet, ServerViewSet
from system_config.views import CredentialViewSet
from rest_framework import routers
router = routers.DefaultRouter()
# cmdb项目相关接口
router.register(r'cmdb/idc', IdcViewSet, basename="idc")
router.register(r'cmdb/server_group', ServerGroupViewSet, basename="server_group")
router.register(r'cmdb/server', ServerViewSet, basename="server")
# credentials项目接口
router.register(r'config/credential', CredentialViewSet, basename="credential")
# token接口
from libs import token_auth


urlpatterns = [
    path('admin/', admin.site.urls),
    re_path('^api/login/$', token_auth.CustomAuthToken.as_view()),
]

urlpatterns += [
    path('api/', include(router.urls))
]
```

##### 4.创建django superuser
```sh
$ python manage.py createsuperuser
```

##### 5.apipost请求测试

```sh
$ http post http://127.0.0.1:8000/api/login/ username=admin password=oschina
# ....
{
    "code": 200,
    "msg": "认证成功",
    "token": "2819d61e6f69914305bd819894e06f920c2eca04",
    "username": "admin"
}
```


##### 6.根据token访问接口测试

```sh
$ http http://127.0.0.1:8000/api/cmdb/idc/
# ....
{
    "detail": "Authentication credentials were not provided."
}


$ http http://127.0.0.1:8000/api/cmdb/idc/ "Authorization: Token 2819d61e6f69914305bd819894e06f920c2eca04"
# ....
{
    "code": 200,
    "count": 4,
    "data": [
        {
            "city": "上海",
            "create_time": "2024-02-20T06:00:06.260580Z",
            "id": 4,
            "name": "百度云机房",
            "note": "",
            "provider": "电信"
        },
        {
            "city": "杭州",
            "create_time": "2024-02-20T05:59:46.028252Z",
            "id": 3,
            "name": "阿里云机房",
            "note": "",
            "provider": "电信"
        },
        {
            "city": "深圳",
            "create_time": "2024-02-20T05:59:28.496135Z",
            "id": 2,
            "name": "腾讯云机房",
            "note": "",
            "provider": "移动"
        },
        {
            "city": "北京",
            "create_time": "2024-02-20T05:57:43.948797Z",
            "id": 1,
            "name": "酒仙桥兆唯机房",
            "note": "",
            "provider": "电信"
        }
    ],
    "msg": "成功",
    "next": null
}
```


##### 7.修改密码接口

###### 路由配置

`devops_api/urls.py`

```python

# token接口
from libs import token_auth

urlpatterns = [
    path('admin/', admin.site.urls),
    re_path('^api/login/$', token_auth.CustomAuthToken.as_view()),
    re_path('^api/change_password/$', token_auth.ChangeUserPasswordView.as_view()),
    re_path('^api/userlist/$', token_auth.UserList.as_view()),
]
```

> 我们是基于django用户认证实现登录，因此判断密码是否正确和修改密码需要使用django自带的make_password加密和check_password验证。
>

###### 视图配置

`devops_api/libs/token_auth.py`

```python
############### 导入user认证的token认证模块 ######################
from rest_framework.authtoken.views import ObtainAuthToken  # 导入authtoken认证模块
from rest_framework.authtoken.models import Token  # 导入Token
from rest_framework.response import Response  # 导入Response的json返回格式

############### 导入user修改密码模块 #################
from rest_framework.views import APIView
from django.contrib.auth.models import User
from django.contrib.auth.hashers import make_password, check_password
from rest_framework.permissions import AllowAny
import json


# 登陆认证
class CustomAuthToken(ObtainAuthToken):
    permission_classes = (AllowAny,)  # AllowAny 允许所有用户（登录不需要身份认证）

    def post(self, request, *args, **kwargs):
        serializer = self.serializer_class(data=request.data, context={'request': request})

        if serializer.is_valid():
            user = serializer.validated_data['user']
            token, created = Token.objects.get_or_create(user=user)
            res = {'code': 200, 'msg': '认证成功', 'token': token.key, 'username': user.username, }
            return Response(res)
        else:
            res = {'code': 500, 'msg': '用户名或密码错误！', }
            return Response(res)


# 修改密码
class ChangeUserPasswordView(APIView):
    def post(self, request, *args, **kwargs):

        # 获取用户名
        username = request.data.get("username")

        # 获取旧密码和新密码
        old_password = request.data.get("old_password")
        new_password = request.data.get("new_password")
        try:
            user = User.objects.get(username=username)
        except:
            res = {'code': 500, 'msg': '用户不存在！'}
            return Response(res)

        if check_password(old_password, user.password):
            user.password = make_password(new_password)
            user.save()
            res = {'code': 200, 'msg': '修改密码成功'}
        else:
            res = {'code': 500, 'msg': '原密码不正确！'}
        return Response(res)


# 获取用户信息
class UserList(APIView):
    def post(self, request, *args, **kwargs):
        # 获取用户名
        username = request.data.get("username")

        user_list = User.objects.get(username=username)
        result = {
            'username': user_list.username,
            'email': user_list.email,
        }
        res = {'code': 200, 'msg': '获取用户成功', 'data': result}
        return Response(res)
```

###### 修改密码接口测试
 
需要在post的header种加上Authentication 认证头信息，否则就是403

```sh
$ http POST http://127.0.0.1:8000/api/change_password/ username=admin old_password=oschina123 new_password=oschina
# ....
{
    "detail": "Authentication credentials were not provided."
}


$ http POST http://127.0.0.1:8000/api/change_password/ Authorization:"Token f19690670e8d5997503c60cfa17fed01a36de51a" username=admin old_password=oschina123 new_password=oschina
# ...
{
    "code": 200,
    "msg": "修改密码成功"
}
```




####  基于DRF框架实现JWT认证


具体使用参考如下文档

- [Django-Vue搭建个人博客：JWT身份验证](https://www.dusaiphoto.com/article/93/)

- https://www.cnblogs.com/Edmondhui/p/18020833

- https://blog.csdn.net/achen_m/article/details/135370882

- https://zhuanlan.zhihu.com/p/339409769


- [DjangoRestFramework实现JWT登录，并将token缓存到redis中](https://www.cnblogs.com/iread9527/p/12685770.html)




## API平台雏形(下)

### 服务器信息采集

- 前端采集功能实现流程图

![1707191015462](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707191015462.webp){: .zoom}


- 服务器自动上报或主动采集工作流程

![1707191058598](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707191058598.webp){: .zoom}



**采集方式**


Agent方式： 在每台服务器部署，周期采集并提交API。也可以下发任务。速度快。

- 缺点：提前部署
- 应用场景：适合服务器数量多




SSH访问：通过paramiko连接各个机器，执行命令，获取数据并提交API

- 缺点：慢
- 应用场景：适合服务器数量少




Ansible类工具：也是基于ssh通信，功能完善，速度快，开发成本低。

- 缺点：依赖工具
- 应用场景：适合熟悉ansible的



### 服务器配置采集脚本


- 采集内容

| 字段              | 名称           | 获取方式                                 |
|-------------------|----------------|------------------------------------------|
| hostname          | 主机名         | socket模块获取                           |
| machine_type      | 机器类型       | 从dmesg中提取标识                        |
| os_version        | 系统版本       | /etc/issue                               |
| public_ip         | 公网IP地址     | 调用接口判断公网还是内网，云主机无需判断 |
| intranet_ip       | 内网IP地址     |                                          |
| cpu_num           | CPU数量        | /proc/cpuinfo                            |
| cpu_model         | CPU型号        | /proc/cpuinfo                            |
| memory            | 内存           | /proc/meminfo                            |
| disk              | 硬盘           | lsblk                                    |
| put_shelves_date  | 上架日期       | 默认以系统启动时间，后期人工再改         |


- 采集脚本


```python
#!/usr/bin/python
# coding: utf-8
# describe：CMDB采集脚本，对python版本和执行用户没要求
# 解决python执行编码问题
import sys

import socket, fcntl, struct
from datetime import datetime, date, timedelta
import os, json

try:
    from urllib import request
except:
    import urllib2 as request
import logging

# 当前目录
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# 日志配置
log_file = os.path.join(BASE_DIR, "collect.log")
logging.basicConfig(level=logging.INFO, filename=log_file, format="%(asctime)s - [%(levelname)s] %(message)s")


def get_ip_address(nic):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack('256s', nic[:15]))[20:24])


class GetData():
    def __init__(self):
        self.result = {}

    # 解析文件
    def parse_file(self, file, name):
        with open(file) as f:
            for line in f.readlines():
                key, value = line.split(":")
                key = key.strip()
                value = value.strip()
                if key == name:
                    return value

    def hostname(self):
        hostname = socket.gethostname()
        hostname_backup = '/tmp/.hostname'
        if os.path.isfile(hostname_backup) and os.path.getsize(hostname_backup) != 0:
            with open(hostname_backup) as f:
                hostname = f.read().strip()
        else:
            with open(hostname_backup, 'w') as f:
                f.write(hostname)
        return hostname

    def machine_type(self):
        result = os.popen("dmesg |grep -i virtual |grep -ci hardware")
        if int(result.read()) >= 1:
            type = "physical_machine"  # 物理机
        else:
            result = os.popen("dmesg |grep -i virtual |grep -ci kvm")
            if int(result.read()) >= 1:
                type = "cloud_vm"  # 云主机
            else:
                type = "vm"  # 虚拟机
        return type

    # 获取系统版本，兼容centos7和Ubuntu

    def os_version(self):
        if os.name == "posix" and os.uname().sysname == "Linux":
            with open("/etc/os-release") as f:
                for line in f:
                    if line.startswith("PRETTY_NAME"):
                        os_version = line.split('=')[1].strip('"')
                        return os_version
            os_version = ""
        else:
            os_version = ""
        return os_version

    # 系统启动时间
    def system_up_time(self):
        with open("/proc/uptime") as f:
            s = f.read().split(".")[0]  # 启动有多少秒
        up_time = datetime.now() - timedelta(seconds=float(s))  # 当前时间减去启动秒
        return date.strftime(up_time, '%Y-%m-%d')

    def public_ip(self):
        private_ip = self.private_ip()
        ip_api_url = ['http://ip.renfei.net', 'http://ifconfig.me/ip']
        ip_list = []
        try:
            req = request.Request(url=ip_api_url[0])
            res = request.urlopen(req)
            ip = json.loads(res.read().decode())['clientIP']
        except:
            req = request.Request(url=ip_api_url[1])
            res = request.urlopen(req)
            ip = res.read().decode()
        if ip in private_ip:
            ip.append(ip)
            return ip_list
        else:
            ip_list.append('%s' % ip)
            return ip_list

    def private_ip(self):
        nic_prefix = ['eth', 'en', 'em']  # 常见网卡名前缀
        ip_list = []
        with open("/proc/net/dev") as f:
            for s in f.readlines():
                name = s.split(':')[0].strip()
                for p in nic_prefix:
                    if name.startswith(p):
                        result = os.popen("ip addr show %s |awk -F'[ /]' '/inet /{print $6}'" % name)
                        ip_list.append(result.read().strip())
        return ip_list

    def cpu_num(self):
        result = os.popen("lscpu |grep 'CPU(s):' |awk '{print $2}'")
        for c in result.read().strip().split('\n'):
            c = c.split()
            cpu = c[0]
            return "%s核" % cpu

    def cpu_model(self):
        model = self.parse_file("/proc/cpuinfo", "model name")
        return model

    def memory(self):
        total = self.parse_file("/proc/meminfo", "MemTotal")
        total = round(float(total.split()[0]) / 1024 / 1024, 1)  # 转GB单位
        return "%sG" % total

    def disk(self):
        disk = []
        result = os.popen("lsblk |awk '$6~/disk/{print $1,$4,$5}'")
        for d in result.read().strip().split('\n'):
            d = d.split()
            device = d[0]
            size = d[1]
            if int(d[2]) == 0:
                type = "HDD"
            else:
                type = "SSD"
            disk.append({'device': '/dev/%s' % device, 'size': size, 'type': type})
        return disk

    def network(self):
        nic_prefix = ['eth', 'en', 'em']  # 常见网卡名前缀
        with open("/proc/net/dev") as f:
            for s in f.readlines():
                name = s.split(':')[0].strip()
                for p in nic_prefix:
                    if name.startswith(p):
                        result = os.popen("ethtool %s | awk '/Speed/ {print $2}'|awk -F'b' '{print $1}'" % name)
                        result = result.read().strip()
                        return result

    def get_all(self):
        """
        这里字段必须与API对应
        """
        self.result = {
            "hostname": self.hostname(),
            "os_version": self.os_version(),
            # "public_ip": self.public_ip(),
            "private_ip": self.private_ip(),
            "cpu_num": self.cpu_num(),
            "cpu_model": self.cpu_model(),
            "memory": self.memory(),
            "disk": self.disk(),
            "network": self.network(),
            "put_shelves_date": self.system_up_time(),  # 上架时间默认设置系统启动时间
        }
        json_data = json.dumps(self.result)
        return json_data


if __name__ == "__main__":
    data = GetData()
    try:
        print(data.get_all())
    except Exception as e:
        result = {'code': 500, 'msg': '采集脚本执行失败！错误：%s' % e}
        print(json.dumps(result))
```


执行效果如下:

```sh
$ python3 local_host_collect_linux.py |python3 -m json.tool
{
    "hostname": "gdc-ci-base",
    "os_version": "Ubuntu 20.04 LTS\"\n",
    "private_ip": [
        "192.168.240.23"
    ],
    "cpu_num": "16\u6838",
    "cpu_model": "Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz",
    "memory": "62.8G",
    "disk": [
        {
            "device": "/dev/vda",
            "size": "100G",
            "type": "HDD"
        },
        {
            "device": "/dev/vdb",
            "size": "500G",
            "type": "HDD"
        },
        {
            "device": "/dev/vdc",
            "size": "500G",
            "type": "HDD"
        }
    ],
    "network": "Unknown!",
    "put_shelves_date": "2023-09-26"
}
```

**采集脚本什么时候工作**

1.新建主机并同步实现(SSH)

填写基本信息，确保主机名与目标主机一致 -> 点击确认 -> 请求测试接口(带上凭据id)，不通先关闭窗口，提示要操作什么，例如检查ip和端口，通的话修改数据库字段已验证，请求调用采集接口自动上报。


2.管理员点击同步实现(SSH)


3.周期性自动执行上报(Agent)

- 在第一次新建主机时候上传脚本并配置定时任务。
- 在装机后系统初始化自动配置
- 后期用ansible批量主机配置



### 在远程主机执行命令和上传文件

有了采集脚本，接下来就是如何让脚本能目标主机执行进行采集并获取入库。

这里采用 paramiko 实现 ssh 连接目标主机并执行采集脚本。

paramiko 模块是基于 Python 实现的 SSH 远程安全连接，用于SSH远程执行命令、文件传输等功能。

首先pip安装:

```sh
$ pip install paramiko
```

为更好学习该模块，我们下面写几个具体的示例来熟悉它的常用用法。

![1707198616668](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707198616668.webp){: .zoom}


#### SSH密码认证远程执行命令

```python
import paramiko

hostname = '192.168.1.120'
port = 22
username = 'root'
password = 'p@ssw0rd'

# 绑定实例
ssh = paramiko.SSHClient()
# AutoAddPolicy()自动添加主机keys
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
# 连接主机信息
ssh.connect(hostname, port, username, password, timeout=5)
# 执行Shell命令，结果分别保存在标准输入，标准输出和标准错误
stdin, stdout, stderr = ssh.exec_command('ls -l')
stdout = stdout.read()
error = stderr.read()
# 判断stderr输出是否为空，为空则打印运行结果，不为空打印报错信息
if not error:
    print(stdout)
else:
    print(error)

ssh.close()
```

#### SSH密钥认证远程执行命令

口令是普遍的鉴权策略，为了提高安全性，还会用密钥对认证。

首选生成秘钥对, 并将公钥加到目标机器的 `~/.ssh/authorized_keys` 中

```python
import paramiko
import sys
hostname = '10.0.1.66'
port = 22
username = 'root'
key_file = '/Users/hujianli/.ssh/id_rsa'
# 将列表元素以空格拼接
cmd = " ".join(sys.argv[1:])
def ssh_command(command):
    ssh = paramiko.SSHClient()
    # 指定key文件
    key = paramiko.RSAKey.from_private_key_file(key_file)
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    # 使用key登录
    ssh.connect(hostname, port, username, pkey=key)
    stdin, stdout, stderr = ssh.exec_command(command)
    result = stdout.read()
    error = stderr.read()
    if not error:
        print(result)
    else:
        print(error)
    ssh.close()
if __name__ == "__main__":
    ssh_command (cmd)
```

#### 上传文件到远程服务器

- 代码示例

```python
import paramiko

hostname = '10.0.1.66'
port = 22
username = 'root'
password = '123456'
local_path = './ssh_key.py'
remote_path = '/tmp/ssh_key.py'
try:
    s = paramiko.Transport((hostname, port))
    s.connect(username = username, password=password)
    #key = paramiko.RSAKey.from_private_key(key_file)
    #transport.connect(username=username, pkey=key)
except Exception as e:
    print(e)
sftp = paramiko.SFTPClient.from_transport(s)
# 使用put()方法把本地文件上传到远程服务器
sftp.put(local_path, remote_path)
```

#### 封装ssh模块到django模块验证

1.在 `devops_api/lib` 项目路径下创建 `ssh.py` 模块文件

```python
import paramiko
from io import StringIO  # py2 from StringIO import StringIO
import os


class SSH():
    def __init__(self, ip, port, username, password=None, key=None):
        self.ip = ip
        self.port = port
        self.username = username
        self.password = password
        self.key = key

    def command(self, shell):
        # 绑定实例
        ssh = paramiko.SSHClient()
        # 允许连接不在known_hosts文件上的主机
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # 判断是密码登陆，还是密钥登陆
            if self.password:
                ssh.connect(hostname=self.ip, port=self.port, username=self.username, password=self.password, timeout=5)
            else:
                cache = StringIO(self.key)  # 将字符串通过StringIO转为file对象（self.key内容是从数据库查询的文本）
                key = paramiko.RSAKey.from_private_key(cache)  # 接收file对象
                # 使用key登录
                ssh.connect(hostname=self.ip, port=self.port, username=self.username, pkey=key)
            # 执行Shell命令，结果分别保存在标准输入，标准输出和标准错误
            stdin, stdout, stderr = ssh.exec_command(shell)
            stdout = stdout.read()
            error = stderr.read()
            # 判断stderr输出是否为空，为空则打印运行结果，不为空打印报错信息
            ssh.close()
            if not error:
                return {'code': 200, 'msg': '执行命令成功', 'data': stdout}
            else:
                return {'code': 500, 'msg': '执行命令失败', 'data': error}
        except Exception as e:
            return {'code': 500, 'msg': 'SSH连接失败! 错误信息： %s' % e}

    def scp(self, local_file, remote_file):
        # 绑定实例
        ts = paramiko.Transport((self.ip, self.port))
        try:
            if self.password:
                ts.connect(username=self.username, password=self.password)
            else:
                cache = StringIO(self.key)
                key = paramiko.RSAKey.from_private_key(cache)
                ts.connect(username=self.username, pkey=key)
            sftp = paramiko.SFTPClient.from_transport(ts)
            try:
                sftp.put(localpath=local_file, remotepath=remote_file)
                ts.close()
                return {'code': 200, 'msg': '上传文件成功'}
            except Exception as e:
                return {'code': 500, 'msg': '上传文件失败 %s' % e}
        except Exception as e:
            return {'code': 500, 'msg': 'SSH连接失败 %s' % e}

    # 新增一个ssh验证方法
    def test(self):
        result = self.command('ls')
        return result


if __name__ == '__main__':
    ssh = SSH('192.168.0.200', 22, 'root', '123456')
    ssh.test()
    local_file = os.path.join(os.getcwd(), 'local_host_collect_linux.py')
    result = ssh.scp(local_file, '/tmp/local_host_collect_linux.py')
    result = ssh.command('chmod +x /tmp/local_host_collect_linux.py')
    result = ssh.command('python /tmp/local_host_collect_linux.py')

    print(result)
```


### 新建主机功能


#### 表单新建主机接口

1.基本流程

![1707199575895](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707199575895.webp){: .zoom}


2.创建主机视图： `devops_api/cmdb/views.py`

```python
from cmdb.models import Idc, ServerGroup, Server
from cmdb.serializers import IdcSerializers, ServerGroupSerializers, ServerSerializers
from rest_framework.viewsets import ModelViewSet
from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.permissions import IsAuthenticated


class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ('name', 'city', 'provider')  # 指定可搜索的字段
    filterset_fields = ('name', 'city',)  # 指定可过滤的字段
    # 排序
    # 注意 filter_backends多了一个filters.OrderingFilter
    ordering_fields = ["id", "name"]

    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        try:
            self.perform_destroy(instance)
            res = {'code': 200, 'msg': '删除成功'}
        except Exception as e:
            res = {'code': 500, 'msg': '该IDC机房管理关联其他应用，请删除关联的应用再操作'}
        return Response(res)


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    filterset_fields = ('name',)  # 指定可过滤的字段
    search_fields = ('name',)  # 指定可搜索的字段
    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]
    # 排序
    # 注意 filter_backends多了一个filters.OrderingFilter
    ordering_fields = ["id", "name"]

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        try:
            self.perform_destroy(instance)
            res = {'code': 200, 'msg': '删除成功'}
        except Exception as e:
            res = {'code': 500, 'msg': '该主机分组关联其他应用，请删除关联的应用再操作'}
        return Response(res)


class ServerViewSet(ModelViewSet):
    queryset = Server.objects.all()
    serializer_class = ServerSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("hostname",)
    filterset_fields = ("hostname",)
    ordering_fields = ("id",)
    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]


from rest_framework.views import APIView
import os
from django.conf import settings
import json
from rest_framework.response import Response
from system_config.models import Credential
from libs.ssh import SSH


class CreateHostView(APIView):
    def post(self, request):
        idc_id = int(request.data.get('idc'))  # 机房id
        server_group_id_list = request.data.get('server_group')  # 分组id
        name = request.data.get('name')
        hostname = request.data.get('hostname')
        ssh_ip = request.data.get('ssh_ip')
        ssh_port = int(request.data.get('ssh_port'))
        credential_id = int(request.data.get('credential'))
        note = request.data.get('note')
        # 通过凭据ID获取用户名信息
        credential = Credential.objects.get(id=credential_id)
        username = credential.username

        if credential.auth_mode == 1:
            password = credential.password
            ssh = SSH(ssh_ip, ssh_port, username, password)
        else:
            private_key = credential.private_key
            ssh = SSH(ssh_ip, ssh_port, username, key=private_key)

        # 测试ssh链接是否成功
        result = ssh.test()
        if result['code'] == 200:
            local_file = os.path.join(settings.BASE_DIR, 'cmdb', 'files', 'local_host_collect_linux.py')
            remote_file = os.path.join('/tmp/local_host_collect_linux.py')
            ssh.scp(local_file, remote_file)
            result = ssh.command('python3 %s' % remote_file)
            print(result)
            # 服务器信息采集成功，入库
            if result['code'] == 200:
                idc = Idc.objects.get(id=idc_id)
                print(idc)
                server_obj = Server.objects.create(
                    idc=idc,
                    name=name,
                    credential=credential,
                    hostname=hostname,
                    ssh_ip=ssh_ip,
                    ssh_port=ssh_port,
                    is_verified='verified',
                    note=note
                )
                print(server_obj)
                for group_id in server_group_id_list:
                    group = ServerGroup.objects.get(id=group_id)
                    server_obj.server_group.add(group)
                # 服务器配置信息入库
                data = json.loads(result['data'])
                Server.objects.filter(hostname=hostname).update(**data)
                res = {'code': 200, 'msg': '添加主机成功，并同步配置'}
            else:
                res = {'code': 500, 'msg': '主机配置信息同步失败，错误信息： %s' % result['msg']}
        else:
            res = {'code': 500, 'msg': '错误信息： %s' % result['msg']}

        return Response(res)
```


3.主机远程采集入库： `devops_api/files/local_host_collect_linux.py`

使用 `local_host_collect_linux.py` 采集脚本




4.创建路由：`devops_api/devops_api/urls.py`

```python
from django.contrib import admin
from django.urls import path, include, re_path
from cmdb.views import IdcViewSet, ServerGroupViewSet, ServerViewSet, CreateHostView
from system_config.views import CredentialViewSet
from rest_framework import routers
from user_info.views import UserViewSet

from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

router = routers.DefaultRouter()
router.register(r'user', UserViewSet)
# cmdb项目相关接口
router.register(r'cmdb/idc', IdcViewSet, basename="idc")
router.register(r'cmdb/server_group', ServerGroupViewSet, basename="server_group")
router.register(r'cmdb/server', ServerViewSet, basename="server")
# credentials项目接口
router.register(r'config/credential', CredentialViewSet, basename="credential")

urlpatterns = [
    path('admin/', admin.site.urls),

    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    re_path('^api/cmdb/create_host/$', CreateHostView.as_view())
    # path('api/change-password/', ChangePasswordView.as_view()),
]

urlpatterns += [
    path('api/', include(router.urls))
]
```


5.httpie测试

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/cmdb/create_host/' \
--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MjAyOTc0LCJpYXQiOjE3MDcyMDI2NzQsImp0aSI6IjZjMjRmMjY3MDE4OTRiZWZhMDMzNzVjODVhMDkzODRhIiwidXNlcl9pZCI6MSwibmFtZSI6ImFkbWluIn0.RxXM137KOIsUKFv0KVtD7Hafm_pIMal8LI2zwxG2pkU' \
--form 'idc="4"' \
--form 'server_group="5"' \
--form 'name="gitee-sre1"' \
--form 'hostname="gitee-sre1"' \
--form 'ssh_ip="106.12.43.56"' \
--form 'ssh_port="27312"' \
--form 'credential="1"' \
--form 'note="sre开发服务器"'
```

测试成功返回如下内容

```sh
{
    "code": 200,
    "msg": "添加主机成功，并同步配置"
}
```

#### Excel 新建主机功能

- 根据excl模板下载，填写之后再导入Excel
- 需要安装xlrd: 

这里使用 `xlrd==1.2.0`版本，高版本有异常。

```sh
$ pip3 install xlrd==1.2.0
```

1.excel导入视图:  `devops_api/cmdb/views.py`

```python
class ExcelCreateHostView(APIView):
    # 下载主机导入模板.xlsx
    def get(self, request):
        file_name = 'local_server_host.xlsx'
        file_path = os.path.join(settings.BASE_DIR, 'cmdb', 'files', file_name)
        response = FileResponse(open(file_path, 'rb'))
        response['Content-Type'] = 'application/octet-stream'
        response['Content-Disposition'] = 'attachment;filename=%s' % file_name
        return response

    # 导入excel
    def post(self, request, *args, **kwargs):
        # 获取前端提交数据
        excel_file_obj = request.data['file']
        idc_id = int(request.data.get('idc'))
        server_group_id = request.data.get('server_group')

        # 直接自定义分隔符，把字符串转换为列表格式
        server_group_list_id = server_group_id.split(',')

        # 判断读取是否是excel文件
        try:
            data = xlrd.open_workbook(file_contents=excel_file_obj.read(), filename=None)
        except Exception as e:
            result = {'code': 500, 'msg': '请上传Excel文件！'}
            return Response(result)

        idc = Idc.objects.get(id=idc_id)
        # 打开第一个工作表
        table = data.sheets()[0]
        # 获取表的行数
        nrows = table.nrows
        try:
            for i in range(nrows):
                if i != 0:  # 跳过标题行
                    name = table.row_values(i)[0]
                    hostname = table.row_values(i)[1]
                    ssh_ip = table.row_values(i)[2]
                    ssh_port = table.row_values(i)[3]
                    note = table.row_values(i)[4]
                    server = Server.objects.create(
                        idc=idc,
                        name=name,
                        hostname=hostname,
                        ssh_ip=ssh_ip,
                        ssh_port=ssh_port,
                        note=note
                    )
                    # 添加多对多字段
                    for group_id in server_group_list_id:
                        group = ServerGroup.objects.get(id=group_id)  # 获取分组
                        server.server_group.add(group)  # 将服务器添加到分组
            result = {'code': 200, 'msg': 'excel导入主机成功'}
        except Exception as e:
            result = {'code': 500, 'msg': 'excel导入主机异常%s' % e}
        return Response(result)
```

2.调整cmdb的creadential字段可为空: `devops_api/cmdb/models.py`

```python
class Server(models.Model):
    '''
    服务器组
    '''
    idc = models.ForeignKey(Idc, on_delete=models.PROTECT, verbose_name="IDC机房")
    server_group = models.ManyToManyField(ServerGroup, default="Default", verbose_name="主机分组")
    credential = models.ForeignKey(Credential, on_delete=models.PROTECT, blank=True, null=True, verbose_name="SSH凭据")
    # ....
```

```sh
(venv) > python manage.py makemigrations 
(venv) > python manage.py migrate
```


3.设置路由: `devops_api/devops_api/urls.py`

```python
from django.contrib import admin
from django.urls import path, include, re_path
from cmdb.views import IdcViewSet, ServerGroupViewSet, ServerViewSet, CreateHostView, ExcelCreateHostView
# ...
urlpatterns = [
    path('admin/', admin.site.urls),
    # ....
    re_path('^api/cmdb/excel_create_host/$', ExcelCreateHostView.as_view())
    # path('api/change-password/', ChangePasswordView.as_view()),
]
```



postman 测试

![1707211457107](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707211457107.webp){: .zoom}





### 云主机导入功能

云主机采集很方便，无需agent脚本，直接通过云平台API获取即可。

![1707211595020](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707211595020.webp){: .zoom}



#### 阿里云

- 在线API调试平台: https://api.aliyun.com/
- 获取AceessKey文档: https://help.aliyun.com/document_detail/175967.html
- 获取AceessKey地址: https://ram.console.aliyun.com/manage/ak
- 安装sdk: pip install aliyun-python-sdk-ecs -i https://mirrors.aliyun.com/pypi/simple


1.阿里云信息获取模块脚本： `devops_api/libs/aliyun_cloud.py`


```python
from aliyunsdkcore.client import AcsClient
from aliyunsdkecs.request.v20140526 import DescribeRegionsRequest, DescribeInstancesRequest, DescribeZonesRequest, \
    DescribeDisksRequest
import json


class AliCloud():
    def __init__(self, secret_id, secret_key):
        self.secret_id = secret_id
        self.secret_key = secret_key

    def region_list(self):
        client = AcsClient(self.secret_id, self.secret_key)
        req = DescribeRegionsRequest.DescribeRegionsRequest()  # 获取地区
        try:
            resp = client.do_action_with_exception(req)
            resp = json.loads(resp.decode())
            resp = {'code': 200, 'data': resp}
            return resp
        except Exception as e:
            return {'code': '500', 'msg': e.get_error_msg()}

    def zone_list(self, region_id):
        client = AcsClient(self.secret_id, self.secret_key)
        req = DescribeZonesRequest.DescribeZonesRequest()
        req.add_query_param('RegionId', region_id)
        try:
            resp = client.do_action_with_exception(req)
            resp = json.loads(resp.decode())
            resp = {'code': 200, 'data': resp}
            return resp
        except Exception as e:
            return {'code': '500', 'msg': e.get_error_msg()}

    def instance_list(self, region_id):
        client = AcsClient(self.secret_id, self.secret_key)
        req = DescribeInstancesRequest.DescribeInstancesRequest()
        req.add_query_param('RegionId', region_id)
        try:
            resp = client.do_action_with_exception(req)
            resp = json.loads(resp.decode())
            resp = {'code': 200, 'data': resp}
            return resp
        except Exception as e:
            return {'code': '500', 'msg': e.get_error_msg()}

    def instance_disk(self, instance_id):
        client = AcsClient(self.secret_id, self.secret_key)
        req = DescribeDisksRequest.DescribeDisksRequest()
        req.add_query_param('InstanceId', instance_id)
        try:
            resp = client.do_action_with_exception(req)
            resp = json.loads(resp.decode())
            resp = {'code': 200, 'data': resp}
            return resp
        except Exception as e:
            return {'code': '500', 'msg': e.get_error_msg()}


if __name__ == '__main__':
    # 找个测试ak可以试试
    cloud = AliCloud("xxxxxxx", "xxxxxxxxxxx")
    result = cloud.region_list()
    result = cloud.zone_list('cn-hangzhou')
    result = cloud.instance_list("cn-hangzhou")
    result = cloud.instance_disk("i-bp1g28isv8irjtrwdxf4")
    print(result)
```


2.获取aliyun region 信息接口，提交服务器配置入库接口: `devops_api/cmdb/views.py`

```python
class AliyunCloudView(APIView):
    def get(self, request):
        # 获取region信息
        secret_id = request.query_params.get('secret_id')
        secret_key = request.query_params.get('secret_key')
        cloud = AliCloud(secret_id, secret_key)
        region_result = cloud.region_list()
        code = region_result['code']

        if code == 200:
            # 二次处理，固定字段名
            region = []
            for r in region_result['data']['Regions']['Region']:
                region.append({"region_id": r['RegionId'], 'region_name': r['LocalName']})
            res = {'code': 200, 'msg': '获取区域列表成功', 'data': region}
        else:
            res = {'code': 500, 'msg': '获取区域列表成功失败:%s' % region_result['msg']}
        return Response(res)

    def post(self, request, *args, **kwargs):
        """
        根据区域名称创建机房，再导入云主机（绑定机房）到数据库
        """
        # 凭据、IDC机房、主机分组、SSH连接地址（IP、端口）
        secret_id = request.data.get('secret_id')
        secret_key = request.data.get('secret_key')
        server_group_id = int(request.data.get('server_group'))
        region_id = request.data.get('region')  # 区域用于机房里的城市
        ssh_ip = request.data.get('ssh_ip')  # 用户选择使用内网（private）还是公网（public），下面判断对应录入
        ssh_port = int(request.data.get('ssh_port'))

        cloud = AliCloud(secret_id, secret_key)
        instance_result = cloud.instance_list(region_id)

        instance_list = []
        if instance_result['code'] == 200:
            instance_list = instance_result['data']['Instances']['Instance']
            if len(instance_list) == 0:
                res = {'code': 500, 'msg': '该区域未发现云主机，请重新选择！'}
                return Response(res)
        elif instance_result['code'] == 500:
            res = {'code': 500, 'msg': '%s' % instance_result['msg']}
            return Response(res)

        # InstanceSet中可用区字段值是英文，例如 ap-beijing-1
        # 先获取可用区英文与中文对应，下面遍历主机再获取中文名
        zone_result = cloud.zone_list(region_id)
        zone_dict = {}
        for z in zone_result['data']['Zones']['Zone']:
            zone_dict[z['ZoneId']] = z['LocalName']

        # 获取主机所在可用区
        # 可用区用于机房里的机房名称
        zone_set = set()
        for host in instance_list:
            zone = host['ZoneId']  # 可用区，例如 ap-beijing-1
            zone_set.add(zone_dict[zone])  # 获取中文名

        # 根据可用区创建机房
        for zone in zone_set:
            # 如果存在不创建
            idc = Idc.objects.filter(name=zone)
            if not idc:
                city = ""
                region_list = cloud.region_list()['data']['Regions']['Region']
                for r in region_list:  # 获取区域对应中文名
                    if r['RegionId'] == region_id:
                        city = r['LocalName']
                Idc.objects.create(
                    name=zone,
                    city=city,
                    provider="阿里云"
                )

        # 导入云主机信息到数据库
        for host in instance_list:
            zone = host['ZoneId']
            instance_id = host['InstanceId']  # 实例ID
            # hostname = host['HostName']
            instance_name = host['InstanceName']  # 机器名称
            os_version = host['OSName']

            private_ip_list = host['NetworkInterfaces']['NetworkInterface'][0]['PrivateIpSets']['PrivateIpSet']
            private_ip = []
            for ip in private_ip_list:
                private_ip.append(ip['PrivateIpAddress'])

            public_ip = host['PublicIpAddress']['IpAddress']
            cpu = "%s核" % host['Cpu']
            memory = "%sG" % (int(host['Memory']) / 1024)

            # 硬盘信息需要单独获取
            disk = []
            disk_list = cloud.instance_disk(instance_id)['data']['Disks']['Disk']
            for d in disk_list:
                disk.append({'device': d['Device'], 'size': '%sG' % d['Size'], 'type': None})

            create_date = time.strftime("%Y-%m-%d", time.strptime(host['CreationTime'], "%Y-%m-%dT%H:%MZ"))
            # 2022-01-30T04:51Z 需要转换才能存储
            expired_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(host['ExpiredTime'], "%Y-%m-%dT%H:%MZ"))

            # 创建服务器
            idc_name = zone_dict[zone]
            idc = Idc.objects.get(name=idc_name)  # 一对多

            if ssh_ip == "public":
                ssh_ip = public_ip[0]
            elif ssh_ip == "private":
                ssh_ip = private_ip[0]

            data = {'idc': idc,
                    'name': instance_name,
                    'hostname': instance_id,
                    'ssh_ip': ssh_ip,
                    'ssh_port': ssh_port,
                    'machine_type': 'cloud_vm',
                    'os_version': os_version,
                    'public_ip': public_ip,
                    'private_ip': private_ip,
                    'cpu_num': cpu,
                    'memory': memory,
                    'disk': disk,
                    'put_shelves_date': create_date,
                    'expire_datetime': expired_time,
                    'is_verified': 'verified'}
            # 如果instance_id不存在才创建
            server = Server.objects.filter(hostname=instance_id)
            if not server:
                server = Server.objects.create(**data)
                # 分组多对多
                group = ServerGroup.objects.get(id=server_group_id)  # 根据id查询分组
                server.server_group.add(group)  # 将服务器添加到分组
            else:
                server.update(**data)

        res = {'code': 200, 'msg': '导入云主机成功'}
        return Response(res)
```

3.添加路由： `devops_api/devops_api/urls.py`


```python
from cmdb.views import CreateHostView,ExcelCreateHostView,AliyunCloudView

urlpatterns = [
    path('admin/', admin.site.urls),
    re_path('^api/login/$', CustomAuthToken.as_view()),
    re_path('^api/change_password/$', token_auth.ChangeUserPasswordView.as_view()),
    re_path('^api/cmdb/create_host/$', CreateHostView.as_view()),
    re_path('^api/cmdb/excel_create_host/$', ExcelCreateHostView.as_view()),
    re_path('^api/cmdb/aliyun_cloud/$', AliyunCloudView.as_view())
]
# ....
```

4.阿里云创建资源测试：创建一个只读全局的账号，并获取 access id ,secert_key



5.postman post 测试

`http://127.0.0.1:8000/api/cmdb/aliyun_cloud/`



#### 腾讯云

- 在线API调试平台: https://console.cloud.tencent.com/api/explorer
- API文档: https://cloud.tencent.com/document/product/296/19850
- Python SDK: https://github.com/TencentCloud/tencentcloud-sdk-python
- 获取AceessKey地址: https://console.cloud.tencent.com/cam/capi
- 安装腾讯云sdk: pip install tencentcloud-sdk-python -i https://mirrors.tencent.com/pypi/simple/


1.腾讯云信息获取脚本: `devops_api/libs/tencent_cloud.py`

```python
from tencentcloud.common import credential
from tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException
from tencentcloud.cvm.v20170312 import cvm_client, models


class TCloud():
    def __init__(self, secret_id, secret_key):
        self.secret_id = secret_id
        self.secret_key = secret_key
        self.cred = credential.Credential(self.secret_id, self.secret_key)

    def region_list(self):
        client = cvm_client.CvmClient(self.cred, None)
        req = models.DescribeRegionsRequest()  # 获取地区
        try:
            resp = client.DescribeRegions(
                req)  # resp=[{"Region": "ap-guangzhou", "RegionName": "华南地区(广州)", "RegionState": "AVAILABLE"}, ]
            resp.code = 200
            return resp
        except TencentCloudSDKException as e:
            return {'code': '500', 'msg': e.message}

    def zone_list(self, region_id):
        client = cvm_client.CvmClient(self.cred, region_id)
        req = models.DescribeZonesRequest()
        try:
            resp = client.DescribeZones(req)
            resp.code = 200
            return resp
        except TencentCloudSDKException as e:
            return {'code': '500', 'msg': e.message}

    def instance_list(self, region_id):
        client = cvm_client.CvmClient(self.cred, region_id)  # 获取北京区域
        req = models.DescribeInstancesRequest()
        # req.InstanceIds = "ins-1511w4tn" #根据实例id获取
        try:
            resp = client.DescribeInstances(req)
            resp.code = 200
            return resp
        except TencentCloudSDKException as e:
            return {'code': '500', 'msg': e.message}


if __name__ == '__main__':
    cloud = TCloud("AKIDKUP3QWNxGI4ZnkQpwnMgiTxA7mAH8i02", "nJYWDtJSKwGJ5aokPownMegRu61f27wU")
    # result = cloud.region_list()
    # result = cloud.zone_list("ap-beijing")
    result = cloud.instance_list("ap-beijing")
    print(result)
```


2.获取腾讯云主机region, 示例信息接口: `devops_api/cmdb/views.py`

```python
class TencentCloudView(APIView):
    """
    腾讯云获取云主机信息
    """

    def get(self, request):
        """
        返回所有区域
        """
        secret_id = request.query_params.get('secret_id')
        secret_key = request.query_params.get('secret_key')

        # cloud = TencentCloud("AKIDKUP3QWNxGI4ZnkQpwnMgiTxA7mAH8i02", "nJYWDtJSKwGJ5aokPownMegRu61f27wU")
        cloud = TCloud(secret_id, secret_key)
        region_result = cloud.region_list()

        code = region_result.code
        if code == 200:
            # 二次处理，固定字段名，与阿里云的一致
            region = []
            for r in region_result.RegionSet:
                region.append({"region_id": r.Region, 'region_name': r.RegionName})
            res = {'code': code, 'msg': '获取区域列表成功！', 'data': region}
        else:
            res = {'code': code, 'msg': region_result.msg}
        return Response(res)

    def post(self, request, *args, **kwargs):
        """
        根据区域名称创建机房，再导入云主机（关联机房）到数据库
        """
        secret_id = request.data.get('secret_id')
        secret_key = request.data.get('secret_key')
        server_group_id = int(request.data.get('server_group'))
        region_id = request.data.get('region')
        ssh_ip = request.data.get('ssh_ip')
        ssh_port = int(request.data.get('ssh_port'))

        cloud = TCloud(secret_id, secret_key)
        instance_result = cloud.instance_list(region_id)

        instance_list = []
        if instance_result.code == 200:
            instance_list = instance_result.InstanceSet
            if instance_result.TotalCount == 0:
                res = {'code': 500, 'msg': '该区域未发现云主机，请重新选择！'}
                return Response(res)
        elif instance_result.code == 500:
            res = {'code': 500, 'msg': '%s' % instance_result['msg']}
            return Response(res)

        # InstanceSet中可用区字段值是英文
        # 先获取可用区英文与中文对应，下面遍历主机再获取中文名
        zone_result = cloud.zone_list(region_id)
        zone_dict = {}
        for z in zone_result.ZoneSet:
            zone_dict[z.Zone] = z.ZoneName

        # 获取主机所在可用区
        # 可用区，机房表：机房名称
        host_zone_set = set()
        for host in instance_list:
            zone = host.Placement.Zone  # 可用区，例如 ap-beijing-1
            host_zone_set.add(zone_dict[zone])  # 获取中文名

        # 根据可用区创建机房
        for zone in host_zone_set:
            # 如果存在不创建
            idc = Idc.objects.filter(name=zone)
            if not idc:
                city = ""
                region_result = cloud.region_list()
                for r in region_result.RegionSet:  # 获取区域对应中文名
                    if r.Region == region_id:
                        city = r.RegionName

                Idc.objects.create(
                    name=zone,
                    city=city,
                    provider="腾讯云"
                )

        # 导入云主机信息到数据库
        for host in instance_list:
            zone = host.Placement.Zone
            instance_id = host.InstanceId  # 实例ID
            instance_name = host.InstanceName  # 机器名称

            os_version = host.OsName
            private_ip = host.PrivateIpAddresses
            public_ip = host.PublicIpAddresses
            cpu = "%s核" % host.CPU
            memory = "%sG" % host.Memory

            disk = [{'device': 'None', 'size': host.SystemDisk.DiskSize, 'type': 'None'}]  # 默认保存是系统盘
            data_list = host.DataDisks
            if data_list:
                for d in data_list:
                    disk.append({'device': 'None', 'size': d.DiskSize, 'type': 'None'})

            create_date = time.strftime("%Y-%m-%d", time.strptime(host.CreatedTime, "%Y-%m-%dT%H:%M:%SZ"))
            expired_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(host.ExpiredTime, "%Y-%m-%dT%H:%M:%SZ"))
            # state = host.InstanceState

            # 创建服务器
            idc_name = zone_dict[zone]
            idc = Idc.objects.get(name=idc_name)

            if ssh_ip == "public":
                ssh_ip = public_ip[0]  # 使用第一个IP连接
            elif ssh_ip == "private":
                ssh_ip = private_ip[0]

            # 如果instance_id不存在才创建
            data = {'idc': idc,
                    'name': instance_name,
                    'hostname': instance_id,
                    'ssh_ip': ssh_ip,
                    'ssh_port': ssh_port,
                    'machine_type': 'cloud_vm',
                    'os_version': os_version,
                    'public_ip': public_ip,
                    'private_ip': private_ip,
                    'cpu_num': cpu,
                    'memory': memory,
                    'disk': disk,
                    'put_shelves_date': create_date,
                    'expire_datetime': expired_time,
                    'is_verified': 'verified'}
            server = Server.objects.filter(hostname=instance_id)
            if not server:
                server = Server.objects.create(**data)
                # 分组多对多
                group = ServerGroup.objects.get(id=server_group_id)  # 根据id查询分组
                server.server_group.add(group)  # 将服务器添加到分组
            else:
                server.update(**data)

        res = {'code': 200, 'msg': '导入云主机成功'}
        return Response(res)
```

3.路由配置: `devops_api/devops_api/urls.py`


```python
# ...
from cmdb.views import CreateHostView,ExcelCreateHostView,AliyunCloudView,TencentCloudView
# ...
urlpatterns = [
    path('admin/', admin.site.urls),
    re_path('^api/login/$', CustomAuthToken.as_view()),
    re_path('^api/change_password/$', token_auth.ChangeUserPasswordView.as_view()),
    re_path('^api/cmdb/create_host/$', CreateHostView.as_view()),
    re_path('^api/cmdb/excel_create_host/$', ExcelCreateHostView.as_view()),
    re_path('^api/cmdb/aliyun_cloud/$', AliyunCloudView.as_view()),
    re_path('^api/cmdb/tencent_cloud/$', TencentCloudView.as_view()),
]
# ...
```

4.Postman post 接口测试

`http://127.0.0.1:8000/api/cmdb/tencent_cloud/`



### 数据同步接口开发

- 主要用于将主机信息同步更新到数据库

1. 创建同步视图: `devops_api/cmdb/views.py`

```python
class HostCollectView(APIView):
    def get(self, request):
        hostname = request.query_params.get('hostname')
        server = Server.objects.get(hostname=hostname)
        ssh_ip = server.ssh_ip
        ssh_port = server.ssh_port

        # 未绑定凭据并且没有选择凭据
        credential_id = request.query_params.get('credential_id')
        if not server.credential and not credential_id:
            result = {'code': 500, 'msg': '未发现凭据，请选择！'}
            return Response(result)
        elif server.credential:
            credential_id = int(server.credential.id)
        elif credential_id:
            credential_id = int(request.query_params.get('credential_id'))

        credential = Credential.objects.get(id=credential_id)

        username = credential.username
        if credential.auth_mode == 1:
            password = credential.password
            ssh = SSH(ssh_ip, ssh_port, username, password=password)
        else:
            private_key = credential.private_key
            ssh = SSH(ssh_ip, ssh_port, username, key=private_key)

        # 先SSH基本测试
        test = ssh.test()
        if test['code'] == 200:
            local_file = os.path.join(settings.BASE_DIR, 'cmdb', 'files', 'cloud_host_collect_linux.py')
            remote_file = os.path.join('/tmp/cloud_host_collect_linux.py')
            ssh.scp(local_file, remote_file)
            result = ssh.command('python %s' %remote_file)

            if result['code'] == 200:  # 采集脚本执行成功
                # 再进一步判断客户端采集脚本提交结果

                data = json.loads(result['data'])
                Server.objects.filter(hostname=hostname).update(**data)

                # 更新凭据ID
                server = Server.objects.get(hostname=hostname)
                server.credential = credential
                server.is_verified = 'verified'
                server.save()

                result = {'code': 200, 'msg': '主机配置同步成功'}

            else:
                result = {'code': 500, 'msg': '主机配置同步失败！错误：%s' %result['msg']}
        else:
            result = {'code': 500, 'msg': 'SSH连接异常！错误：%s' %test['msg']}
        return Response(result)
```

2.修改路由: `devops_api/devops_api/urls.py`

```python
# ...
from cmdb.views import CreateHostView,ExcelCreateHostView,AliyunCloudView,TencentCloudView,HostCollectView
# ...
urlpatterns = [
    path('admin/', admin.site.urls),
    re_path('^api/login/$', CustomAuthToken.as_view()),
    re_path('^api/change_password/$', token_auth.ChangeUserPasswordView.as_view()),
    re_path('^api/cmdb/create_host/$', CreateHostView.as_view()),
    re_path('^api/cmdb/excel_create_host/$', ExcelCreateHostView.as_view()),
    re_path('^api/cmdb/aliyun_cloud/$', AliyunCloudView.as_view()),
    re_path('^api/cmdb/tencent_cloud/$', TencentCloudView.as_view()),
    re_path('^api/cmdb/host_collect/$', HostCollectView.as_view()),
]
# ...
```

3.验证: 找个本地虚拟机故意改错配置： `4核改1核`

4.Postman 同步测试

5.检查是否同步成功




### 启用接口文档

参考：

[DRF 自动生成接口文档 coreapi和drf-yasg](https://www.cnblogs.com/LYPZX/p/14083849.html)

https://www.cnblogs.com/LYPZX/p/14083849.html

https://www.cnblogs.com/kangssssh/p/17107149.html#
