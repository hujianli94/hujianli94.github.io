# 3.CMDB后端开发


## 企业项目开发流程

![1707100340914](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100340914.webp){: .zoom}



## 项目背景

目前运维管理存在痛点：随着业务增长，服务器数量越来越多，资产信息通过Excel记录，人工管理低效，易于出错。


## CMDB介绍

- 配置管理数据库（Configuration Management Database，CMDB），是一个逻辑数据库，包含了应用生命周期的信息，例如服务器、物理关系、通信关系、依赖关系等。

- CMDB存储与管理企业IT架构中设备的各种配置信息，它与所有运维服务和应用发布流程都紧密相联，支持这些流程的运转、发挥配置信息的价值，同时依赖于相关流程保证数据的准确性。CMDB可以实现高度的自动化，减少人为错误的发生、降低人员成本，CMDB是实现运维自动化的基础。

- CMDB资产

![1707100437351](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100437351.webp){: .zoom}



### CMDB数据存储需要注意的事项

- CMDB的目的是为了在其他流程或应用之间共享数据的，如果一个应用或流程需要对某类数据单独使用的话，则不建议将这类数据存入CMDB中，存在自身应用即可。
- 动态数据不建议存储在CMDB中，例如CPU使用率、内存使用率，因为这类数据更新过于频繁。
- 如果没有任何流程、应用及人员，需要对特定的数据进行使用，则没有必要放到CMDB中存储。



### 技术选型

![1707100589501](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100589501.webp){: .zoom}



前端技术栈

- Vue3
- Vue-router
- Element Plus
- Axios


后端技术栈

- python
- Django DRF
- mysql


### 整体设计

![1707100822692](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100822692.webp){: .zoom}



## 数据库设计

![1707105493241](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707105493241.webp){: .zoom}



### 机房管理

表名：cmdb_idc

| 字段         | 类型                  | 空   | 名称     |
|--------------|-----------------------|------|---------|
| id           | INTEGER               | 否   | 自增长ID |
| name         | VARCHAR(30)（unique） | 否   | 机房名称 |
| city         | VARCHAR(20)           | 否   | 城市     |
| provider     | VARCHAR(20)           | 否   | 运营商   |
| note         | TEXT                  | 是   | 备注     |
| create_time  | DATETIME              | 否   | 创建时间 |


### 主机分组

表名：cmdb_server_group

| 字段名       | 类型       | 允许为空 | 名称     |
| ------------ | ---------- | -------- | -------- |
| id           | INTEGER    | 否       | 自增长ID |
| name         | VARCHAR(30)| 否       | 分组名称 |
| note         | TEXT       | 是       | 备注     |
| create_time  | DATETIME   | 否       | 创建时间 |


### 主机管理

表名：cmdb_server

| 字段名              | 类型            | 允许为空 | 名称                     |
| -------------------| --------------- | -------- | ------------------------ |
| id                 | INTEGER         | 否       | 自增长ID                 |
| idc                | IDC表一对多关系 | 否       | IDC机房                  |
| server_group       | 分组表多对多关系 | 否       | 主机分组                 |
| credential         | 凭据表一对多     | 否       | 凭据ID                   |
| name               | VARCHAR(30)     | 否       | 名称，默认与主机名一样   |
| hostname           | VARCHAR(30)     | 否       | 主机名，唯一标识符       |
| ssh_ip             | VARCHAR(40)     | 否       | SSH IP                   |
| ssh_port           | INTEGER         | 否       | SSH端口                  |
| machine_type       | VARCHAR(20)     | 是       | 机器类型（虚拟机、云主机、物理机） |
| os_version         | VARCHAR(30)     | 是       | 系统版本                 |
| public_ip          | JSON            | 是       | 公网IP（列表存储，会有多个ip） |
| private_ip         | JSON            | 否       | 内网IP（列表存储）        |
| cpu_num            | VARCHAR(10)     | 是       | CPU数量                  |
| cpu_model          | VARCHAR(100)    | 是       | CPU型号                  |
| memory             | VARCHAR(30)     | 是       | 内存                     |
| disk               | JSON            | 是       | 硬盘（列表存储，包含设备、容量、硬盘类型） |
| put_shelves_date   | DATE            | 是       | 上架日期，默认为系统启动时间 |
| off_shelves_date   | DATE            | 是       | 下架日期                 |
| expire_datetime    | DATETIME        | 是       | 租约过期时间             |
| is_verified        | VARCHAR(10)     | 是       | SSH验证状态（已验证，未验证） |
| note               | TEXT            | 是       | 备注                     |
| update_time        | DATETIME        | 是       | 更新时间                 |
| create_time        | DATETIME        | 否       | 创建时间                 |


### 系统配置： 凭据管理

表名：system_config_credential

| 字段名        | 类型       | 允许为空 | 名称         |
| -------------| ---------- | -------- | ------------ |
| id           | INTEGER    | 否       | 自增长ID     |
| name         | VARCHAR(30)| 否       | 名称         |
| auth_mode    | VARCHAR(30)| 否       | 认证方式，key、pass |
| username     | VARCHAR(20)| 否       | 用户名       |
| password     | VARCHAR(30)| 是       | 密码         |
| private_key  | TEXT       | 是       | 私钥         |
| note         | TEXT       | 是       | 备注         |
| update_time  | DATETIME   | 否       | 更新时间     |
| create_time  | DATETIME   | 否       | 创建时间     |



## API 平台开发


### 接口设计

| 请求路径                            | HTTP方法       | 功能                            | 备注                               |
| -----------------------------------| -------------- | ------------------------------- | ---------------------------------- |
| /api/cmdb/idc/                      | get, post, put, delete | 查看，创建，更新，删除         | IDC机房                            |
| /api/cmdb/server_group/             | get, post, put, delete | 查看，创建，更新，删除         | 主机分组                           |
| /api/cmdb/server/                   | get, post, put, delete | 查看，创建，更新，删除         | 服务器                            |
| /api/cmdb/create_host               | post           | 创建                            | 新建主机                           |
| /api/cmdb/host_collect              | get            | SSH连接采集主机配置                | SSH连接采集主机配置                  |
| /api/cmdb/excel_create_host         | get, post      | 下载excel模板文件，提交文件      | excel导入主机                      |
| /api/cmdb/tencent_cloud             | get            | 调用腾讯云ECS API获取                | 腾讯云云主机导入                     |
| /api/cmdb/aliyun_cloud              | get            | 调用阿里云ECS API获取                | 阿里云云主机导入                     |


## API平台雏形(上)


### 基础准备

1.pip需要安装的包

```sh
pip3 install django==3.2
pip3 install pymysql
pip3 install djangorestframework
pip3 install django-rest-swagger
pip3 install django-filter
pip3 install Markdown
```

在命令行中发送请求，笔者推荐 [httpie](https://github.com/jakubroztocil/httpie#installation) 这个库，基于 Python 并且小巧美观。


```sh
pip install httpie
```


2.Pycharm创建项目



3.创建应用

```sh
(venv) > python manage.py startapp cmdb
(venv) > python manage.py startapp system_config
```


4.调整 `settings.py` 配置

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'django_filters',
    'cmdb',
    'system_config'
]
```

5.本地安装并启动 mysql，设置好数据库，用户

```sh
wanghui@kkkk ~ % mysql -uroot -proot
mysql> create database devops_backend;
```

6.配置mysql数据库

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'devops_backend',
        'USER': 'root',
        'PASSWORD': 'oschina',
        'HOST': '127.0.0.1',
        'PORT': '3306',
        # 第三方登录功能必须加上
        "OPTIONS": {"init_command": "SET default_storage_engine=INNODB", "charset": "utf8"},
    }
}
```

7.devops_api/init.py 配置默认的pymysql为驱动

```python
import pymysql

pymysql.install_as_MySQLdb()
```

### cmdb数据库model和system_config数据库model设置


1.system_config model配置： `devops_api/system_config/models.py`

```python
from django.db import models

class Credential(models.Model):
    auth_choice = (
        (1, "密码"),
        (2, "秘钥")
    )
    name = models.CharField(max_length=30, verbose_name="凭据名称")
    username = models.CharField(max_length=20, verbose_name="用户名")
    auth_mode = models.IntegerField(choices=auth_choice, default=1, verbose_name="认证方式")
    password = models.CharField(max_length=50, blank=True, verbose_name="密码")
    private_key = models.TextField(blank=True, verbose_name="私钥")
    note = models.TextField(blank=True, verbose_name="备注")
    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    update_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        db_table = "system_config_credential"
        verbose_name_plural = "凭据管理"
        ordering = ('-id',)

    def __str__(self):
        return self.name
```

2.cmdb model配置: `devops_api/cmdb/models.py`

```python
from django.db import models
from system_config.models import Credential

class Idc(models.Model):
    '''
    idc表
    '''
    name = models.CharField(max_length=64,unique=True,verbose_name="idc名称")
    city = models.CharField(max_length=64, verbose_name="城市")
    provider = models.CharField(max_length=64,verbose_name="提供商")
    note = models.TextField(null=True, blank=True, verbose_name="备注")
    create_time = models.DateTimeField(auto_now_add=True,verbose_name="创建时间")

    class Meta:
        db_table = 'cmdb_idc'
        verbose_name_plural = 'idc机房'
        ordering = ('-id',)

    def __str__(self):
        return self.name

class ServerGroup(models.Model):
    '''
    主机分组
    '''
    name = models.CharField(max_length=64,unique=True,verbose_name="分组名称")
    note = models.TextField(null=True,blank=True,verbose_name="备注")
    create_time = models.DateTimeField(auto_now_add=True,verbose_name="创建时间")

    class Meta:
        db_table = "cmdb_server_group"
        verbose_name_plural = "服务器分组"
        ordering = ('-id',)

    def __str__(self):
        return self.name

class Server(models.Model):
    '''
    服务器组
    '''
    idc = models.ForeignKey(Idc, on_delete=models.PROTECT, verbose_name="IDC机房")
    server_group = models.ManyToManyField(ServerGroup, default="Default", verbose_name="主机分组")
    credential = models.ForeignKey(Credential,on_delete=models.PROTECT, verbose_name="SSH凭据")

    hostname = models.CharField(max_length=30, unique=True, verbose_name="主机名")
    name = models.CharField(max_length=30, unique=True, verbose_name="名称")

    ssh_ip = models.GenericIPAddressField(verbose_name="SSH IP")
    ssh_port = models.IntegerField(verbose_name="SSH端口")
    note = models.TextField(blank=True, null=True, verbose_name="备注")

    machine_type = models.CharField(max_length=30, blank=True,
                                    choices=(('vm', '虚拟机'), ('cloud_vm', '云主机'), ('physical_machine', '物理机')),
                                    verbose_name="机器类型")
    os_version = models.CharField(max_length=50, blank=True, null=True, verbose_name="系统版本")
    public_ip = models.JSONField(max_length=100, blank=True, null=True, verbose_name="公网IP")
    private_ip = models.JSONField(max_length=100, blank=True, null=True, verbose_name="内网IP")
    cpu_num = models.CharField(max_length=10, blank=True, null=True, verbose_name="CPU")
    cpu_model = models.CharField(max_length=100, blank=True, null=True, verbose_name="CPU型号")
    memory = models.CharField(max_length=30, blank=True, null=True, verbose_name="内存")
    disk = models.JSONField(max_length=200, blank=True, null=True, verbose_name="硬盘")
    network = models.CharField(max_length=200, blank=True, null=True, verbose_name="带宽")
    put_shelves_date = models.DateField(null=True, blank=True, verbose_name="上架日期")
    off_shelves_date = models.DateField(null=True, blank=True, verbose_name="下架日期")
    expire_datetime = models.DateTimeField(blank=True, null=True, verbose_name="租约过期时间")
    is_verified = models.CharField(max_length=10, blank=True, choices=(('verified', '已验证'), ('unverified', '未验证')),
                                   default='unverified', verbose_name="SSH验证状态")
    update_time = models.DateTimeField(auto_now_add=True, verbose_name="更新时间")
    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")

    class Meta:
        db_table = "cmdb_server"
        verbose_name_plural = "主机管理"
        ordering = ('-id',)

    def __str__(self):
        return self.hostname
```


3.同步数据

```sh
(venv) > python manage.py makemigrations 
(venv) > python manage.py migrate
```


### 定义序列化器

cmdb序列化器的定义： `devops_api/cmdb/serializers.py`

```python
from .models import Idc,ServerGroup,Server
from rest_framework import serializers

class IdcSerializers(serializers.ModelSerializer):
    class Meta:
        model = Idc
        fields = '__all__'
        read_only_fields = ("id",)

class ServerGroupSerializers(serializers.ModelSerializer):
    class Meta:
        model = ServerGroup
        fields = '__all__'
        read_only_fields = ("id",)
        
class ServerSerializers(serializers.ModelSerializer):
    class Meta:
        model = Server
        fields = '__all__'
        read_only_fields = ("id",)
```

System_config序列化器的定义： `devops_api/system_config/serializers.py`

```python
from .models import Credential
from rest_framework import serializers


class CredentialSerializer(serializers.ModelSerializer):
    class Meta:
        model = Credential
        fields = '__all__'
        read_only_fields = ("id",)
```


### 定义视图

1.定义cmdb视图： `devops_api/cmdb/views.py`

```python
from cmdb.models import Idc, ServerGroup, Server
from cmdb.serializers import IdcSerializers, ServerGroupSerializers, ServerSerializers
from rest_framework.viewsets import ModelViewSet


class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers


class ServerViewSet(ModelViewSet):
    queryset = Server.objects.all()
    serializer_class = ServerSerializers
```


2.定义system_config视图： `devops_api/system_config/views.py`

```python
from rest_framework.viewsets import ModelViewSet
from system_config.models import Credential
from system_config.serializers import CredentialSerializer


class CredentialViewSet(ModelViewSet):
    queryset = Credential.objects.all()
    serializer_class = CredentialSerializer
```



### 动态路由

1.注册cmdb和credentials的路由： `devops_api/devops_api/urls.py`

```python
from django.contrib import admin
from django.urls import path, include
from cmdb.views import IdcViewSet, ServerGroupViewSet, ServerViewSet
from system_config.views import CredentialViewSet
from rest_framework import routers
router = routers.DefaultRouter()
router.register(r'cmdb/idc', IdcViewSet, basename="idc")
router.register(r'cmdb/server_group', ServerGroupViewSet, basename="server_group")
router.register(r'cmdb/server', ServerViewSet, basename="server")
router.register(r'config/credential', CredentialViewSet, basename="credential")
urlpatterns = [
    path('admin/', admin.site.urls),
]

urlpatterns += [
    path('api/', include(router.urls))
]
```

2.查看接口

- http://127.0.0.1:8000/api/


```sh
$ http http://127.0.0.1:8000/api/
# ....

{
    "cmdb/idc": "http://127.0.0.1:8000/api/cmdb/idc/",
    "cmdb/server": "http://127.0.0.1:8000/api/cmdb/server/",
    "cmdb/server_group": "http://127.0.0.1:8000/api/cmdb/server_group/",
    "config/credential": "http://127.0.0.1:8000/api/config/credential/",
    "user": "http://127.0.0.1:8000/api/user/"
}
```


### 新增接口数据


#### idc 数据

> http://127.0.0.1:8000/api/cmdb/idc/


查看接口数据

```sh
http http://127.0.0.1:8000/api/cmdb/idc/
```

新增接口数据

```sh
http POST http://127.0.0.1:8000/api/cmdb/idc/ \
    Content-Type:application/json \
    name="酒仙桥兆唯机房" \
    city="北京" \
    provider="电信" \
    note=""
```


#### server-group 数据

> http://127.0.0.1:8000/api/cmdb/server_group/


查看接口数据

```sh
http http://127.0.0.1:8000/api/cmdb/server_group/
```

新增接口数据

```sh
http POST http://127.0.0.1:8000/api/cmdb/idc/ \
    Content-Type:application/json \
    name="k8s集群" \
    note=""
```


#### credential 数据

> http://127.0.0.1:8000/api/config/credential/


查看接口数据

```sh
http http://127.0.0.1:8000/api/config/credential/
```

新增接口数据

```sh
# 用户名/密码认证
http POST http://127.0.0.1:8000/api/config/credential/ \
    Content-Type:application/json \
    name="ssh-pwd" \
    username="root" \
    auth_mode:=1 \
    password="123456" \
    private_key="" \
    note=""

# 用户名/秘钥认证
http --ignore-stdin --form --follow --timeout 3600 POST 'http://127.0.0.1:8000/api/config/credential/' \
 'name'='ssh-cert' \
 'username'='ubuntu' \
 'auth_mode'='2' \
 'password'= \
 'private_key'='-----BEGIN RSA PRIVATE KEY-----
MIIEoQIBAAKCAQEAyrPhiJrgQae+Qlgbs+PBG7lhJ2q4y3F5dvOzmz9PCTGOu/yM
mkIw0/w4JVrQGE2VKv591v14fK5gS3Wv7NEF6qnaUsQep03GXFTWTKD+Kb32bmEd
5y+uMReiuRLOeAj2e3XDSEAdUXcIH7bSj1qIIDbmSI2E04HVezXM/qt548Q6J6Lp
IzQFJu4EprcGNPsrtvHusfpnva+FbuH0XX+xLuNILQDx9hWo5gQv5ynl0KcCk19k
LjlAiZnXTETrPKq/y/uPGf84g1NXfW+FRZFDY1sDnAEygr/N/e7jD5vv8dK1YH8j
M9/oK11zaks+lbp5jrVkHBdxM5r8BzRmQP1GbQIBIwKCAQB/acD2x8ApRN390Pt4
Y0YurwneQxUSKhHVvcFaRQ0buMAeZDsfIkqT4F3OVlbqtGxkKvADesDDZksoHhbP
XtCE38sPc/YCwyw6CXDCc9L1qprmS6xlbm198Zl7pWvWbAilX/cXeMH4sThOcurA
ggxsBUBK3JyiNFpNckZW73EwE9HjRMP8qMD0lowqzJg4W6KWEzZFe6Ugfw1Y2cI5
1nlW653wVkvlY/d4UpPYf8FE0PySZV/7srA1UKPNDVTHYO6j4p1VnIapoe6GbOBT
76d/q5/8vOhISwL/GWvGPR/EuWzyuZRkgPYbD1dCHx9UNKZdNPn+8xXUn+lnXrdr
U08LAoGBAPiUs1lK9K8vGIxzD9Y+26JFvQ+D2bUtRxZQLpG94zVd1Gy/PANF7otW
E8gOhE1QfRhsr8xa1aEIX5+rMVDX0ZquTmwBZ8QGRc9uzx27epxvPyy0xjoSk73v
jGEAIlt5QRsc2aXdUeUo/D2P6HbvwREmTglBd+IYs7yZZaQfkQmdAoGBANDApRI6
pzpEK8fBBJriR++Cc2XuIc7Fb8Kc+9wsUulSaXdvajAgTeVQhE4XfUIeUcyyJZZl
3p5yOe038sIQYdgBrVdWNbWGdKPbrV++vEsGFm+mmhKIy/+nFygORuHuJMoHT7Qr
BqoF4BPCpaFxdxnrZIdQqHgC0ZHsQ7WZlj8RAoGBAONGIFGjneH/LGMnXu/EcQlk
VRV/3P1rOa4AKpPgz7vDgGNtA6s4n5VWA3UUljgPE0mH8S/eBSWD/6fs+eODfc9A
R7M0fCDvysxIDdIKfrrpXlTCiVmqlbT4RdUHb96avy67SqZGsUaL3046biOZYA+t
/jRZHSZ8/Bol2UWZNCYLAoGAcVKiwMDBLkJDpvPAq9nsiVVx2D9xcD9LTGPZLmE0
UsZWgqoyVKPSg8yfmBthQSZm63amsLr1MXE1Y4TFnIyM4vmYnSAryPE4AS4cSesz
BCfgSz0vEWA0OlNkV5K4w8prviE55XZxVPvgCrofZkTo4i9T1G2dSHaPBhKLKBGM
E5sCgYAvmY+EabyJ50p2Mz0D7hfhritORLSvZkjKDggv2VvTb6J3LSzeYD9jgFA1
K0oxRjlyIk/MZchTJHKu/+10L0EIo85SGjDfedu0KBe7SDS2l/7W0XqYtjvuE6dy
lrv6WDHJo/clJNzCm/3tdia2TRdhUYbRr8F1oZkkcmgeDs2x5g==
-----END RSA PRIVATE KEY-----
' \
 'note'=
```



#### server数据

> http://127.0.0.1:8000/api/cmdb/server/


查看接口数据

```sh
http http://127.0.0.1:8000/api/cmdb/server/

{
    "code": 200,
    "msg": "成功",
    "count": 0,
    "data": []
}
```

新增接口数据

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/cmdb/server/' \
--header 'Content-Type: application/json' \
--data-raw '{
	"hostname": "gdc-ci-base",
  "name": "baiducloud-cce-dev",
	"ssh_ip": "192.168.240.23",
	"ssh_port": 27312,
	"note": "",
	"machine_type": "vm",
	"os_version": "",
	"public_ip": ["106.12.43.56"],
	"private_ip": ["192.168.240.23"],
	"cpu_num": "",
	"cpu_model": "",
	"memory": "",
	"disk": [""],
    "network": "",
	"put_shelves_date": null,
	"off_shelves_date": null,
	"expire_datetime": null,
	"is_verified": "unverified",
	"idc": 4,
	"credential": 1,
	"server_group": [5]
}'
```


### 分页


1.定义分页lib，`devops_api/libs/pagination.py`


```python
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response
from collections import OrderedDict


class MyPagination(PageNumberPagination):
    page_size = 6  # 默认每页显示多少条
    page_query_param = 'page_num'  # 指定查询第几页（页码），默认 page
    page_size_query_param = 'page_size'  # 定义每页显示多少条
    max_page_size = 50  # 每页最多显示多少条

    def get_paginated_response(self, data):
        code = 200
        msg = "成功"
        return Response(OrderedDict([
            ('code', code),
            ('msg', msg),
            ('count', self.page.paginator.count),
            # ('next', self.get_next_link()),
            # ('previous', self.get_previous_link()),
            ('data', data)
        ]))

```


2.settings配置引用自定义分页(最后追加)： `devops_api/devops_api/settings.py`

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'libs.pagination.MyPagination'
}
```


### 过滤,搜索和排序

1.Cmdb视图中新增搜索和排序的字段: `devops_api/cmdb/views.py`

```python
from cmdb.models import Idc, ServerGroup, Server
from cmdb.serializers import IdcSerializers, ServerGroupSerializers, ServerSerializers
from rest_framework.viewsets import ModelViewSet
from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend


class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name", 'provider',)
    filterset_fields = ("city",)
    ordering_fields = ("id",)


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name",)
    filterset_fields = ("name",)
    ordering_fields = ("id",)


class ServerViewSet(ModelViewSet):
    queryset = Server.objects.all()
    serializer_class = ServerSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("hostname",)
    filterset_fields = ("hostname",)
    ordering_fields = ("id",)
```


2.credentials视图中新增搜索，过滤，排序字段：`devops_api/system_config/views.py`


```python
from rest_framework.viewsets import ModelViewSet
from system_config.models import Credential
from system_config.serializers import CredentialSerializer
from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend


class CredentialViewSet(ModelViewSet):
    queryset = Credential.objects.all()
    serializer_class = CredentialSerializer
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name",)
    filterset_fields = ("name",)
    ordering_fields = ("id",)
```


3.测试case

- 搜索: http://127.0.0.1:8000/api/cmdb/idc/?search=电信

```sh
http http://127.0.0.1:8000/api/cmdb/idc/?search=电信
```

- 过滤: http://127.0.0.1:8000/api/cmdb/idc/?city=北京

```sh
http http://127.0.0.1:8000/api/cmdb/idc/?city=北京
```

- 排序(逆序): http://127.0.0.1:8000/api/cmdb/idc/?ordering=-id

```sh
http http://127.0.0.1:8000/api/cmdb/idc/?ordering=-id
```


### token认证

可以使用`Django REST framework的Token生成`的方式去实现，但数据库中会自动生成一张 authtoken_token 表.

Django REST framework的Token这个有如下缺点：

- Django REST framework所自建的Token表，可以发现这个表格只有三个字段（不算ID字段）：记录Token内容的key字段，记录生成Token时间的created字段，以及外键user_id字段。缺少了一个Token的有效期时间字段。

- 从原理上来说，有效期时间字段并没有存在的必要，但是从网络安全的角度上来看，这个字段却是必不可少的。试想，如果一个Token字符串没有有效期限制，只要网络请求被抓包，被黑客获取了一条Token，那么与获取到用户的账号和密码是没有区别的。所以，Django RESTframework的Token，第一个局限性就是其自建的Token表缺少记录有效期时间的字段。

- 第二个局限性表现在不利于分布式部署或多个系统使用一套验证，Token表只能放在一台服务器上，如果每一次数据请求都要查询一次数据库的整个用户表，那么对于服务器来说将是很大的消耗。试想一下，假如一个平台有四五亿用户，用户任何一次点赞的操作，都要在四五亿数量级的数据表中完成一次查询，那将是一件多么麻烦的事情啊！



所以使用Json Web Token机制，便可以解决这些问题，`jangorestframework-simplejwt` 这个库就可以满足。


1.首先 pip 安装 djangorestframework-simplejwt 这个 jwt 库：

```sh
(venv) > pip install djangorestframework-simplejwt
```



2.修改配置文件，使 JWT 为默认的验证机制：`devops_api/devops_api/settings.py`

```python
REST_FRAMEWORK = {
    # 分页
    'DEFAULT_PAGINATION_CLASS': 'libs.pagination.MyPagination',
    # 认证
    'DEFAULT_AUTHENTICATION_CLASSES': (
        # 'rest_framework.authentication.SessionAuthentication',
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    # 权限
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated'  # 登录后就能访问所有API
    ],
}
```

3.在根路由中添加 Token 的获取和刷新地址：`devops_api/devops_api/urls.py`

```python
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

urlpatterns = [
    # ...
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]
```


视图类里面加上认证、权限配置: `devops_api/cmdb/views.py`

```python
from rest_framework.permissions import IsAuthenticated
class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name", 'provider',)
    filterset_fields = ("city",)
    ordering_fields = ("id",)
    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name",)
    filterset_fields = ("name",)
    ordering_fields = ("id",)
    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]
# .....
```


这就完成了，毫无痛苦，这就是用一个优秀轮子的好处。


4.测试

加入实验数据。建立超级用户，用户名 root，密码 oschina123：

```sh
(venv) > python manage.py createsuperuser
Username (leave blank to use '18793'): admin
Email address: 1@1.com
Password:
Password (again):
Superuser created successfully.
```

没有通过token访问一律返回如下：

```sh
http http://127.0.0.1:8000/api/cmdb/idc/

# ....
{
    "detail": "Authentication credentials were not provided."
}
```


首先，携带用户名和密码发送一个 POST 请求，以获取 Token：

```sh
http post http://127.0.0.1:8000/api/token/ username=hujianli password=oschina123
# ....
{
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTg3NjQyLCJpYXQiOjE3MDcxODczNDIsImp0aSI6ImJlZjdmNjRkMjE3MTRkMTU4MjJmZDFjOWU4MTM1MWEyIiwidXNlcl9pZCI6MiwibmFtZSI6Imh1amlhbmxpIn0.u3EuUbadrxQOKT-Cgv_nCIJDMQM2W9z_y1YIdlEefkM",
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcwNzI3Mzc0MiwiaWF0IjoxNzA3MTg3MzQyLCJqdGkiOiIxOTRmYThjZGI4ODQ0ZWRjYTQ2MDlkOThmN2I3NTJhOSIsInVzZXJfaWQiOjIsIm5hbWUiOiJodWppYW5saSJ9.8qEojhm8O0f6KCzxP-Yd1t8qqBDuO7XO-XZJQhzPUnc"
}
```


> 注意：开启 JWT 后，Session 验证就自动失效了。也就是说，除了申请 Token 时会用到账户密码，其他时候的身份验证都不再需要它们了。

Session 和 JWT 哪个好？将会话移至客户端意味着摆脱了对服务器端会话的依赖，但这会带来如何安全存储、运输令牌等一系列挑战。不能够一概而论，而是要根据你的项目实际需求。

关于这个话题更深入的讨论，请移步[Stackoverflow](https://stackoverflow.com/questions/43452896/authentication-jwt-usage-vs-session)。



拿到 Token 后，就可以用 Token 作为你的身份令牌，进行正常的资源请求了：

> Postman 有一个专门的标签页 (Authorization) 用于填写令牌。此标签页的 Type 栏选择 Bearer Token 即可。


httpie方法如下

```sh
http GET http://127.0.0.1:8000/api/cmdb/idc/ Authorization:"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTg4NzYxLCJpYXQiOjE3MDcxODg0NjEsImp0aSI6IjAyMjY1OWJiNmQ1OTRmMTVhNWI4MDMxMDAzZDM4MzNiIiwidXNlcl9pZCI6MiwibmFtZSI6Imh1amlhbmxpIn0.Yd_IysNjAxHVMyKKH1aD90EYMg0IQg8BWQvQeg5yiZE"
{
    "code": 200,
    "count": 4,
    "data": [
        {
            "city": "上海",
            "create_time": "2024-02-05T07:24:56.379214Z",
            "id": 4,
            "name": "百度云机房",
            "note": "",
            "provider": "电信"
        },
        {
            "city": "上海",
            "create_time": "2024-02-05T06:56:08.069825Z",
            "id": 3,
            "name": "深圳机房",
            "note": "",
            "provider": "电信"
        },
        {
            "city": "北京",
            "create_time": "2024-02-05T06:55:54.921968Z",
            "id": 2,
            "name": "天坛蜗牛机房",
            "note": "",
            "provider": "蜗牛"
        },
        {
            "city": "北京",
            "create_time": "2024-02-05T06:55:03.610000Z",
            "id": 1,
            "name": "酒仙桥兆唯机房",
            "note": "",
            "provider": "电信"
        }
    ],
    "msg": "成功"
}
```

通过 token 访问后我们拿到想要的数据了。


令牌具有过期时间（默认为5分钟，可在配置中修改），过期之后就不能再使用了，但是可用刷新令牌再获取一个新的令牌：

```sh
{
    "detail": "Given token not valid for any token type",
    "code": "token_not_valid",
    "messages": [
        {
            "token_class": "AccessToken",
            "token_type": "access",
            "message": "Token is invalid or expired"
        }
    ]
}
```

令牌具有过期时间（默认为5分钟，可在配置中修改），过期之后就不能再使用了，但是可用刷新令牌再获取一个新的令牌,刷新token

```sh
http POST http://127.0.0.1:8000/api/token/refresh/ Content-Type:"application/json" refresh="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcwNzI3NTIzNiwiaWF0IjoxNzA3MTg4ODM2LCJqdGkiOiI5MTg2NjY4Yzk5ZGQ0YTI2OTE2MTgxMjhiMjY1ZTZjZCIsInVzZXJfaWQiOjIsIm5hbWUiOiJodWppYW5saSJ9.TdXEGmP6Pn7jTpLmmfebA4s6YQgUI2JICYboCGw97Oc"

# ....
{
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTg5MTgxLCJpYXQiOjE3MDcxODg4MzYsImp0aSI6ImU5ZTgyZDZmY2U1YzRhMGI5OTY2MDBmMTQyMjYwMDU0IiwidXNlcl9pZCI6MiwibmFtZSI6Imh1amlhbmxpIn0.Ptg3DmSjDsV6wW62sago_7XN8WlAsUIZxT8osqa4PGk"
}
```


有效期

Token 默认有效期很短，只有 5 分钟。你可以通过修改 Django 的配置文件进行更改：

```python
from datetime import timedelta

# SIMPLE_JWT Token 默认有效期
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=10),
}
```

自定义令牌(token) 定制返回格式



继承auth_user表完成签发登录，但是它的返回格式太固定了只有Token，但是我们想自定义格式呢？

如：

```js
{
  'code': 200,
  'msg': '登录成功',
  'username': self.user.username,
  'token':'fdsafsfsafsadf'
}
```

1.写个序列化类，重写validate ，返回什么，前端看到什么 `devops_api/libs/simplejwt_tokenObtainPairSerializer.py`


```python
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer


class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    '在荷载中添加自定义内容'

    @classmethod
    def get_token(cls, user):
        """
        重写get_token方法，它返回的token中就是荷载的内容
        自定义返回格式
        """
        token = super().get_token(user)  # 签发用户
        token['name'] = user.username  # 往荷载里面添加用户名称
        return token

    def validate(self, attrs):
        old_data = super().validate(attrs)
        data = {'code': 200,
                'msg': '登录成功',
                'username': self.user.username,
                'refresh': old_data['refresh'],
                'access': old_data['access']
                }
        return data
```

2.在settings配置文件中配置

```python
SIMPLE_JWT = {
    "TOKEN_OBTAIN_SERIALIZER": "libs.simplejwt_tokenObtainPairSerializer.MyTokenObtainPairSerializer",
}
```

效果如下:

```sh
http post http://127.0.0.1:8000/api/token/ username=hujianli password=oschina123
# ....
{
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTg5MzA1LCJpYXQiOjE3MDcxODkwMDUsImp0aSI6ImE3MDFmYTRiMjNjMzRkNWJiYzIwZWMyMTM2NDE2Njk0IiwidXNlcl9pZCI6MiwibmFtZSI6Imh1amlhbmxpIn0.n3CfnvkxwaUHwpwQpkj09JaxVwrgQk5JbAhvogi9dhU",
    "code": 200,
    "msg": "登录成功",
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcwNzI3NTQwNSwiaWF0IjoxNzA3MTg5MDA1LCJqdGkiOiI3MDY3ZjZkMjEyZDY0MWI1YmJlODIwNTJjNmVjYTMyOSIsInVzZXJfaWQiOjIsIm5hbWUiOiJodWppYW5saSJ9.yuMXI9nzeAaeJ9c7kMTLMw2i2gPLc4JDhlyNuPWxU4Y",
    "username": "hujianli"
}
```

参考文献

https://blog.csdn.net/achen_m/article/details/135370882

https://zhuanlan.zhihu.com/p/339409769



### 用户管理

创建应用

```sh
(venv) > python manage.py startapp user_info
```

用户管理涉及到对密码的操作，因此新写一个序列化器，覆写 `def create(...)` 和 `def update(...)` 方法：

`devops_api/user_info/serializers.py`

```python
from django.contrib.auth.models import User
from rest_framework import serializers


class ChangePasswordSerializer(serializers.Serializer):
    old_password = serializers.CharField(required=True)
    new_password = serializers.CharField(required=True, min_length=8)
    confirm_password = serializers.CharField(required=True, min_length=8)

    def validate(self, data):
        if data['new_password'] != data['confirm_password']:
            raise serializers.ValidationError({'error': 'New password and confirm password must be same.'})
        return data


class UserDescSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = [
            'id',
            'username',
            'last_login',
            'date_joined'
        ]


class UserRegisterSerializer(serializers.ModelSerializer):
    url = serializers.HyperlinkedIdentityField(view_name='user-detail', lookup_field='username')

    class Meta:
        model = User
        fields = [
            'url',
            'id',
            'username',
            'password',
            'is_superuser'
        ]
        extra_kwargs = {
            'password': {'write_only': True},
            'is_superuser': {'read_only': True}
        }

    def create(self, validated_data):
        user = User.objects.create_user(**validated_data)
        return user

    def update(self, instance, validated_data):
        if 'password' in validated_data:
            password = validated_data.pop('password')
            instance.set_password(password)
        return super().update(instance, validated_data)


class UserDetailSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = [
            'id',
            'username',
            'last_name',
            'first_name',
            'email',
            'last_login',
            'date_joined'
        ]
```

用户管理同样涉及的权限问题，因此新建 `devops_api/user_info/permissions.py`

```python
from rest_framework.permissions import BasePermission, SAFE_METHODS


# 自定义一个权限类
class IsSelfOrReadOnly(BasePermission):
    """
    自定义的权限类继承了 BasePermission 这个基础的父类，并实现了父类中的钩子方法 def has_permission。
    此方法在每次请求到来时被唤醒执行，
    里面简单判断了请求的种类是否安全（即不更改数据的请求），如果安全则直接通过，不安全则只允许管理员用户通过。
    """

    def has_object_permission(self, request, view, obj):
        # 对所有人允许 GET, HEAD, OPTIONS 请求
        if request.method in SAFE_METHODS:
            return True
        # 否则就判断请求的用户是否是管理员用户，如果是管理员用户则返回True，否则返回False
        return obj == request.user
```


铺垫工作做好了，最后就是写视图集：

```python
from rest_framework import viewsets, status
from rest_framework.permissions import AllowAny, IsAuthenticatedOrReadOnly

from user_info.serializers import UserRegisterSerializer
from user_info.permissions import IsSelfOrReadOnly

# 视图集除了默认的增删改查外，还可以有其他的自定义动作
from rest_framework.decorators import action
from rest_framework.response import Response
from user_info.serializers import UserDetailSerializer, ChangePasswordSerializer
from rest_framework.permissions import IsAuthenticated
from django.contrib.auth.models import User
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from django.contrib.auth import get_user_model

User = get_user_model()

# import logging
#
# logger = logging.getLogger(__name__)


class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserRegisterSerializer
    # 这里的lookup_field属性，和序列化器中对应起来。
    lookup_field = 'username'

    def get_permissions(self):
        """
        注册用户的 POST 请求是允许所有人都可以操作的，但其他类型的请求（比如修改、删除）就必须是本人才行了，
        permission_classes 接受列表，因此可以同时定义多个权限，权限之间是 and 关系。
        """
        if self.request.method == 'POST':
            self.permission_classes = [AllowAny]
        elif self.request.method == 'GET':
            # 设置需要身份认证才能访问
            self.permission_classes = [IsAuthenticated]
        else:
            self.permission_classes = [IsAuthenticatedOrReadOnly, IsSelfOrReadOnly]
        return super().get_permissions()

    @action(detail=False, methods=['post'])
    def change_password(self, request):
        serializer = ChangePasswordSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        user = request.user
        # logger.error('Wrong old password. User: %s', user.username)
        old_password = serializer.validated_data.get('old_password')
        new_password = serializer.validated_data.get('new_password')

        if not user.check_password(old_password):
            res = {'code': 500, 'msg': '原密码不正确！'}
            return Response(res)
        try:
            validate_password(new_password)
        except ValidationError as e:
            return Response({'error': e.messages}, status=status.HTTP_400_BAD_REQUEST)

        # 修改密码
        user.set_password(new_password)
        user.save()
        res = {'code': 200, 'msg': '修改密码成功'}
        return Response(res)

    @action(detail=True, methods=['get'])
    def info(self, request, username=None):
        """
        获取用户详细信息
        """
        queryset = User.objects.get(username=username)
        serializer = UserDetailSerializer(queryset, many=False)
        return Response(serializer.data)

    @action(detail=False)
    def sorted(self, request):
        """
        按照用户名字母从 A 到 Z 进行排序，然后使用 DRF 的分页机制来处理结果。
        如果有许多用户记录，则返回分页过的结果；否则，直接返回整个列表。
        """
        # 倒序
        # users = User.objects.all().order_by('-username')
        users = User.objects.all().order_by('username')

        page = self.paginate_queryset(users)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(users, many=True)
        return Response(serializer.data)
```

视图集除了默认的增删改查外，还可以有其他的自定义动作。

- 修改用户密码
- 获取用户详细信息
- 按照用户名字母从 A 到 Z 进行排序



获取用户信息

```sh
http GET http://127.0.0.1:8000/api/user/ Authorization:"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTg5NDgyLCJpYXQiOjE3MDcxODkxODIsImp0aSI6ImUyZGI4OTFhZmJlMTRjNGE4ZjM3NGEwZDNjNzgwYTZjIiwidXNlcl9pZCI6MiwibmFtZSI6Imh1amlhbmxpIn0.gG6fqw6U6tTfpPtkuv_rBUlcmLY31ecLmPTwpKdrWPE"

# ....

{
    "code": 200,
    "count": 4,
    "data": [
        {
            "id": 1,
            "is_superuser": true,
            "url": "http://127.0.0.1:8000/api/user/admin/",
            "username": "admin"
        },
        {
            "id": 2,
            "is_superuser": false,
            "url": "http://127.0.0.1:8000/api/user/hujianli/",
            "username": "hujianli"
        },
        {
            "id": 3,
            "is_superuser": false,
            "url": "http://127.0.0.1:8000/api/user/hu1/",
            "username": "hu1"
        },
        {
            "id": 4,
            "is_superuser": false,
            "url": "http://127.0.0.1:8000/api/user/wu1/",
            "username": "wu1"
        }
    ],
    "msg": "成功"
}
```




### 限制用户权限


- 用户未登录

```sh
http http://127.0.0.1:8000/api/cmdb/idc/
# ...

{
    "detail": "Authentication credentials were not provided."
}
```


- 普通用户登录 GET请求查看用户

在后台中创建一个普通用户 hujianli，用普通用户身份进行请求：

```sh
http GET http://127.0.0.1:8000/api/user/ Authorization:"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTkwMzEzLCJpYXQiOjE3MDcxOTAwMTMsImp0aSI6ImQwMTMxZTRhNTRiZTRhZjQ5OGM2Zjk3YmE0MWY4MGU1IiwidXNlcl9pZCI6MiwibmFtZSI6Imh1amlhbmxpIn0.u6hFtMLesJA7zbKl-6ptkWDmDuf7TPaPFUFir9Cmxqk"
# .....
{
    "code": 200,
    "count": 4,
    "data": [
        {
            "id": 1,
            "is_superuser": true,
            "url": "http://127.0.0.1:8000/api/user/admin/",
            "username": "admin"
        },
        {
            "id": 2,
            "is_superuser": false,
            "url": "http://127.0.0.1:8000/api/user/hujianli/",
            "username": "hujianli"
        },
        {
            "id": 3,
            "is_superuser": false,
            "url": "http://127.0.0.1:8000/api/user/hu1/",
            "username": "hu1"
        },
        {
            "id": 4,
            "is_superuser": false,
            "url": "http://127.0.0.1:8000/api/user/wu1/",
            "username": "wu1"
        }
    ],
    "msg": "成功"
}
```


- 普通用户登录 POST请求 注册用户
  
所有人都有权限注册用户。



### 修改密码接口

1.序列化配置： `devops_api/urer_info/serializers.py`

```python
from rest_framework import serializers
class ChangePasswordSerializer(serializers.Serializer):
    old_password = serializers.CharField(required=True)
    new_password = serializers.CharField(required=True, min_length=8)
    confirm_password = serializers.CharField(required=True, min_length=8)

    def validate(self, data):
        if data['new_password'] != data['confirm_password']:
            raise serializers.ValidationError({'error': 'New password and confirm password must be same.'})
        return data
```

2.视图类配置

```python
from rest_framework.decorators import action
from rest_framework.response import Response
from user_info.serializers import UserDetailSerializer, ChangePasswordSerializer
from rest_framework.permissions import IsAuthenticated
from django.contrib.auth.models import User
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
# .....
    @action(detail=False, methods=['post'])
    def change_password(self, request):
        serializer = ChangePasswordSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        user = request.user
        # logger.error('Wrong old password. User: %s', user.username)
        old_password = serializer.validated_data.get('old_password')
        new_password = serializer.validated_data.get('new_password')

        if not user.check_password(old_password):
            res = {'code': 500, 'msg': '原密码不正确！'}
            return Response(res)
        try:
            validate_password(new_password)
        except ValidationError as e:
            return Response({'error': e.messages}, status=status.HTTP_400_BAD_REQUEST)

        # 修改密码
        user.set_password(new_password)
        user.save()
        res = {'code': 200, 'msg': '修改密码成功'}
        return Response(res)
```

3.修改密码接口测试： 需要在post的header种加上Authentication 认证头信息，否则就是403


```sh
curl --location --request POST 'http://127.0.0.1:8000/api/user/change_password/' \
--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTkxMDYyLCJpYXQiOjE3MDcxOTA3NjIsImp0aSI6ImRjMmI4MTZhMDg2MTRlNzY5NWExYmQxNzU5MTI5ZDZjIiwidXNlcl9pZCI6MiwibmFtZSI6Imh1amlhbmxpIn0.YqLObY__dRou6cjqP1qVqqLVhvIjnQAmPCYp4lNhiTE' \
--header 'Content-Type: application/json' \
--data-raw '{
    "old_password": "oschina123",
    "new_password": "oschina123456",
    "confirm_password": "oschina123456"
}'
```

返回信息如下

```js
{
    "code": 200,
    "msg": "修改密码成功"
}
```


## API平台雏形(下)



### 服务器信息采集

- 前端采集功能实现流程图

![1707191015462](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707191015462.webp){: .zoom}


- 服务器自动上报或主动采集工作流程

![1707191058598](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707191058598.webp){: .zoom}



**采集方式**


Agent方式： 在每台服务器部署，周期采集并提交API。也可以下发任务。速度快。

- 缺点：提前部署
- 应用场景：适合服务器数量多




SSH访问：通过paramiko连接各个机器，执行命令，获取数据并提交API

- 缺点：慢
- 应用场景：适合服务器数量少




Ansible类工具：也是基于ssh通信，功能完善，速度快，开发成本低。

- 缺点：依赖工具
- 应用场景：适合熟悉ansible的



### 服务器配置采集脚本


- 采集内容

| 字段              | 名称           | 获取方式                                 |
|-------------------|----------------|------------------------------------------|
| hostname          | 主机名         | socket模块获取                           |
| machine_type      | 机器类型       | 从dmesg中提取标识                        |
| os_version        | 系统版本       | /etc/issue                               |
| public_ip         | 公网IP地址     | 调用接口判断公网还是内网，云主机无需判断 |
| intranet_ip       | 内网IP地址     |                                          |
| cpu_num           | CPU数量        | /proc/cpuinfo                            |
| cpu_model         | CPU型号        | /proc/cpuinfo                            |
| memory            | 内存           | /proc/meminfo                            |
| disk              | 硬盘           | lsblk                                    |
| put_shelves_date  | 上架日期       | 默认以系统启动时间，后期人工再改         |


- 采集脚本


```python
#!/usr/bin/python
# coding: utf-8
# describe：CMDB采集脚本，对python版本和执行用户没要求
# 解决python执行编码问题
import sys

import socket, fcntl, struct
from datetime import datetime, date, timedelta
import os, json

try:
    from urllib import request
except:
    import urllib2 as request
import logging

# 当前目录
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# 日志配置
log_file = os.path.join(BASE_DIR, "collect.log")
logging.basicConfig(level=logging.INFO, filename=log_file, format="%(asctime)s - [%(levelname)s] %(message)s")


def get_ip_address(nic):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack('256s', nic[:15]))[20:24])


class GetData():
    def __init__(self):
        self.result = {}

    # 解析文件
    def parse_file(self, file, name):
        with open(file) as f:
            for line in f.readlines():
                key, value = line.split(":")
                key = key.strip()
                value = value.strip()
                if key == name:
                    return value

    def hostname(self):
        hostname = socket.gethostname()
        hostname_backup = '/tmp/.hostname'
        if os.path.isfile(hostname_backup) and os.path.getsize(hostname_backup) != 0:
            with open(hostname_backup) as f:
                hostname = f.read().strip()
        else:
            with open(hostname_backup, 'w') as f:
                f.write(hostname)
        return hostname

    def machine_type(self):
        result = os.popen("dmesg |grep -i virtual |grep -ci hardware")
        if int(result.read()) >= 1:
            type = "physical_machine"  # 物理机
        else:
            result = os.popen("dmesg |grep -i virtual |grep -ci kvm")
            if int(result.read()) >= 1:
                type = "cloud_vm"  # 云主机
            else:
                type = "vm"  # 虚拟机
        return type

    # 获取系统版本，兼容centos7和Ubuntu

    def os_version(self):
        if os.name == "posix" and os.uname().sysname == "Linux":
            with open("/etc/os-release") as f:
                for line in f:
                    if line.startswith("PRETTY_NAME"):
                        os_version = line.split('=')[1].strip('"')
                        return os_version
            os_version = ""
        else:
            os_version = ""
        return os_version

    # 系统启动时间
    def system_up_time(self):
        with open("/proc/uptime") as f:
            s = f.read().split(".")[0]  # 启动有多少秒
        up_time = datetime.now() - timedelta(seconds=float(s))  # 当前时间减去启动秒
        return date.strftime(up_time, '%Y-%m-%d')

    def public_ip(self):
        private_ip = self.private_ip()
        ip_api_url = ['http://ip.renfei.net', 'http://ifconfig.me/ip']
        ip_list = []
        try:
            req = request.Request(url=ip_api_url[0])
            res = request.urlopen(req)
            ip = json.loads(res.read().decode())['clientIP']
        except:
            req = request.Request(url=ip_api_url[1])
            res = request.urlopen(req)
            ip = res.read().decode()
        if ip in private_ip:
            ip.append(ip)
            return ip_list
        else:
            ip_list.append('%s' % ip)
            return ip_list

    def private_ip(self):
        nic_prefix = ['eth', 'en', 'em']  # 常见网卡名前缀
        ip_list = []
        with open("/proc/net/dev") as f:
            for s in f.readlines():
                name = s.split(':')[0].strip()
                for p in nic_prefix:
                    if name.startswith(p):
                        result = os.popen("ip addr show %s |awk -F'[ /]' '/inet /{print $6}'" % name)
                        ip_list.append(result.read().strip())
        return ip_list

    def cpu_num(self):
        result = os.popen("lscpu |grep 'CPU(s):' |awk '{print $2}'")
        for c in result.read().strip().split('\n'):
            c = c.split()
            cpu = c[0]
            return "%s核" % cpu

    def cpu_model(self):
        model = self.parse_file("/proc/cpuinfo", "model name")
        return model

    def memory(self):
        total = self.parse_file("/proc/meminfo", "MemTotal")
        total = round(float(total.split()[0]) / 1024 / 1024, 1)  # 转GB单位
        return "%sG" % total

    def disk(self):
        disk = []
        result = os.popen("lsblk |awk '$6~/disk/{print $1,$4,$5}'")
        for d in result.read().strip().split('\n'):
            d = d.split()
            device = d[0]
            size = d[1]
            if int(d[2]) == 0:
                type = "HDD"
            else:
                type = "SSD"
            disk.append({'device': '/dev/%s' % device, 'size': size, 'type': type})
        return disk

    def network(self):
        nic_prefix = ['eth', 'en', 'em']  # 常见网卡名前缀
        with open("/proc/net/dev") as f:
            for s in f.readlines():
                name = s.split(':')[0].strip()
                for p in nic_prefix:
                    if name.startswith(p):
                        result = os.popen("ethtool %s | awk '/Speed/ {print $2}'|awk -F'b' '{print $1}'" % name)
                        result = result.read().strip()
                        return result

    def get_all(self):
        """
        这里字段必须与API对应
        """
        self.result = {
            "hostname": self.hostname(),
            "os_version": self.os_version(),
            # "public_ip": self.public_ip(),
            "private_ip": self.private_ip(),
            "cpu_num": self.cpu_num(),
            "cpu_model": self.cpu_model(),
            "memory": self.memory(),
            "disk": self.disk(),
            "network": self.network(),
            "put_shelves_date": self.system_up_time(),  # 上架时间默认设置系统启动时间
        }
        json_data = json.dumps(self.result)
        return json_data


if __name__ == "__main__":
    data = GetData()
    try:
        print(data.get_all())
    except Exception as e:
        result = {'code': 500, 'msg': '采集脚本执行失败！错误：%s' % e}
        print(json.dumps(result))

```

执行效果如下:

```sh
$ python3 local_host_collect_linux.py |python3 -m json.tool
{
    "hostname": "gdc-ci-base",
    "os_version": "Ubuntu 20.04 LTS\"\n",
    "private_ip": [
        "192.168.240.23"
    ],
    "cpu_num": "16\u6838",
    "cpu_model": "Intel(R) Xeon(R) Gold 6271C CPU @ 2.60GHz",
    "memory": "62.8G",
    "disk": [
        {
            "device": "/dev/vda",
            "size": "100G",
            "type": "HDD"
        },
        {
            "device": "/dev/vdb",
            "size": "500G",
            "type": "HDD"
        },
        {
            "device": "/dev/vdc",
            "size": "500G",
            "type": "HDD"
        }
    ],
    "network": "Unknown!",
    "put_shelves_date": "2023-09-26"
}
```

**采集脚本什么时候工作**

1.新建主机并同步实现(SSH)

填写基本信息，确保主机名与目标主机一致 -> 点击确认 -> 请求测试接口(带上凭据id)，不通先关闭窗口，提示要操作什么，例如检查ip和端口，通的话修改数据库字段已验证，请求调用采集接口自动上报。


2.管理员点击同步实现(SSH)


3.周期性自动执行上报(Agent)

- 在第一次新建主机时候上传脚本并配置定时任务。
- 在装机后系统初始化自动配置
- 后期用ansible批量主机配置



### 在远程主机执行命令和上传文件

有了采集脚本，接下来就是如何让脚本能目标主机执行进行采集并获取入库。

这里采用 paramiko 实现 ssh 连接目标主机并执行采集脚本。

paramiko 模块是基于 Python 实现的 SSH 远程安全连接，用于SSH远程执行命令、文件传输等功能。

首先pip安装:

```sh
$ pip3 install paramiko
```

为更好学习该模块，我们下面写几个具体的示例来熟悉它的常用用法。

![1707198616668](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707198616668.webp){: .zoom}


#### SSH密码认证远程执行命令

```python
import paramiko

hostname = '192.168.1.120'
port = 22
username = 'root'
password = 'p@ssw0rd'

# 绑定实例
ssh = paramiko.SSHClient()
# AutoAddPolicy()自动添加主机keys
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
# 连接主机信息
ssh.connect(hostname, port, username, password, timeout=5)
# 执行Shell命令，结果分别保存在标准输入，标准输出和标准错误
stdin, stdout, stderr = ssh.exec_command('ls -l')
stdout = stdout.read()
error = stderr.read()
# 判断stderr输出是否为空，为空则打印运行结果，不为空打印报错信息
if not error:
    print(stdout)
else:
    print(error)

ssh.close()
```

#### SSH密钥认证远程执行命令

口令是普遍的鉴权策略，为了提高安全性，还会用密钥对认证。

首选生成秘钥对, 并将公钥加到目标机器的 `~/.ssh/authorized_keys` 中

```python
import paramiko
import sys
hostname = '10.0.1.66'
port = 22
username = 'root'
key_file = '/Users/hujianli/.ssh/id_rsa'
# 将列表元素以空格拼接
cmd = " ".join(sys.argv[1:])
def ssh_command(command):
    ssh = paramiko.SSHClient()
    # 指定key文件
    key = paramiko.RSAKey.from_private_key_file(key_file)
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    # 使用key登录
    ssh.connect(hostname, port, username, pkey=key)
    stdin, stdout, stderr = ssh.exec_command(command)
    result = stdout.read()
    error = stderr.read()
    if not error:
        print(result)
    else:
        print(error)
    ssh.close()
if __name__ == "__main__":
    ssh_command (cmd)
```

#### 上传文件到远程服务器

- 代码示例

```python
import paramiko

hostname = '10.0.1.66'
port = 22
username = 'root'
password = '123456'
local_path = './ssh_key.py'
remote_path = '/tmp/ssh_key.py'
try:
    s = paramiko.Transport((hostname, port))
    s.connect(username = username, password=password)
    #key = paramiko.RSAKey.from_private_key(key_file)
    #transport.connect(username=username, pkey=key)
except Exception as e:
    print(e)
sftp = paramiko.SFTPClient.from_transport(s)
# 使用put()方法把本地文件上传到远程服务器
sftp.put(local_path, remote_path)
```

#### 封装ssh模块到django模块验证

1.在 `devops_api/lib` 项目路径下创建 `ssh.py` 模块文件

```python
import paramiko
from io import StringIO  # py2 from StringIO import StringIO
import os


class SSH():
    def __init__(self, ip, port, username, password=None, key=None):
        self.ip = ip
        self.port = port
        self.username = username
        self.password = password
        self.key = key

    def command(self, shell):
        # 绑定实例
        ssh = paramiko.SSHClient()
        # 允许连接不在known_hosts文件上的主机
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # 判断是密码登陆，还是密钥登陆
            if self.password:
                ssh.connect(hostname=self.ip, port=self.port, username=self.username, password=self.password, timeout=5)
            else:
                cache = StringIO(self.key)  # 将字符串通过StringIO转为file对象（self.key内容是从数据库查询的文本）
                key = paramiko.RSAKey.from_private_key(cache)  # 接收file对象
                # 使用key登录
                ssh.connect(hostname=self.ip, port=self.port, username=self.username, pkey=key)
            # 执行Shell命令，结果分别保存在标准输入，标准输出和标准错误
            stdin, stdout, stderr = ssh.exec_command(shell)
            stdout = stdout.read()
            error = stderr.read()
            # 判断stderr输出是否为空，为空则打印运行结果，不为空打印报错信息
            ssh.close()
            if not error:
                return {'code': 200, 'msg': '执行命令成功', 'data': stdout}
            else:
                return {'code': 500, 'msg': '执行命令失败', 'data': error}
        except Exception as e:
            return {'code': 500, 'msg': 'SSH连接失败! 错误信息： %s' % e}

    def scp(self, local_file, remote_file):
        # 绑定实例
        ts = paramiko.Transport((self.ip, self.port))
        try:
            if self.password:
                ts.connect(username=self.username, password=self.password)
            else:
                cache = StringIO(self.key)
                key = paramiko.RSAKey.from_private_key(cache)
                ts.connect(username=self.username, pkey=key)
            sftp = paramiko.SFTPClient.from_transport(ts)
            try:
                sftp.put(localpath=local_file, remotepath=remote_file)
                ts.close()
                return {'code': 200, 'msg': '上传文件成功'}
            except Exception as e:
                return {'code': 500, 'msg': '上传文件失败 %s' % e}
        except Exception as e:
            return {'code': 500, 'msg': 'SSH连接失败 %s' % e}

    # 新增一个ssh验证方法
    def test(self):
        result = self.command('ls')
        return result


if __name__ == '__main__':
    ssh = SSH('192.168.0.200', 22, 'root', '123456')
    ssh.test()
    local_file = os.path.join(os.getcwd(), 'local_host_collect_linux.py')
    result = ssh.scp(local_file, '/tmp/local_host_collect_linux.py')
    result = ssh.command('chmod +x /tmp/local_host_collect_linux.py')
    result = ssh.command('python /tmp/local_host_collect_linux.py')

    print(result)
```


### 新建主机功能


#### 表单新建主机接口

1.基本流程

![1707199575895](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707199575895.webp){: .zoom}


2.创建主机视图： `devops_api/cmdb/views.py`

```python
from cmdb.models import Idc, ServerGroup, Server
from cmdb.serializers import IdcSerializers, ServerGroupSerializers, ServerSerializers
from rest_framework.viewsets import ModelViewSet
from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.permissions import IsAuthenticated


class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ('name', 'city', 'provider')  # 指定可搜索的字段
    filterset_fields = ('name', 'city',)  # 指定可过滤的字段
    # 排序
    # 注意 filter_backends多了一个filters.OrderingFilter
    ordering_fields = ["id", "name"]

    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        try:
            self.perform_destroy(instance)
            res = {'code': 200, 'msg': '删除成功'}
        except Exception as e:
            res = {'code': 500, 'msg': '该IDC机房管理关联其他应用，请删除关联的应用再操作'}
        return Response(res)


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    filterset_fields = ('name',)  # 指定可过滤的字段
    search_fields = ('name',)  # 指定可搜索的字段
    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]
    # 排序
    # 注意 filter_backends多了一个filters.OrderingFilter
    ordering_fields = ["id", "name"]

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        try:
            self.perform_destroy(instance)
            res = {'code': 200, 'msg': '删除成功'}
        except Exception as e:
            res = {'code': 500, 'msg': '该主机分组关联其他应用，请删除关联的应用再操作'}
        return Response(res)


class ServerViewSet(ModelViewSet):
    queryset = Server.objects.all()
    serializer_class = ServerSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("hostname",)
    filterset_fields = ("hostname",)
    ordering_fields = ("id",)
    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]


from rest_framework.views import APIView
import os
from django.conf import settings
import json
from rest_framework.response import Response
from system_config.models import Credential
from libs.ssh import SSH


class CreateHostView(APIView):
    def post(self, request):
        idc_id = int(request.data.get('idc'))  # 机房id
        server_group_id_list = request.data.get('server_group')  # 分组id
        name = request.data.get('name')
        hostname = request.data.get('hostname')
        ssh_ip = request.data.get('ssh_ip')
        ssh_port = int(request.data.get('ssh_port'))
        credential_id = int(request.data.get('credential'))
        note = request.data.get('note')
        # 通过凭据ID获取用户名信息
        credential = Credential.objects.get(id=credential_id)
        username = credential.username

        if credential.auth_mode == 1:
            password = credential.password
            ssh = SSH(ssh_ip, ssh_port, username, password)
        else:
            private_key = credential.private_key
            ssh = SSH(ssh_ip, ssh_port, username, key=private_key)

        # 测试ssh链接是否成功
        result = ssh.test()
        if result['code'] == 200:
            local_file = os.path.join(settings.BASE_DIR, 'cmdb', 'files', 'local_host_collect_linux.py')
            remote_file = os.path.join('/tmp/local_host_collect_linux.py')
            ssh.scp(local_file, remote_file)
            result = ssh.command('python3 %s' % remote_file)
            print(result)
            # 服务器信息采集成功，入库
            if result['code'] == 200:
                idc = Idc.objects.get(id=idc_id)
                print(idc)
                server_obj = Server.objects.create(
                    idc=idc,
                    name=name,
                    credential=credential,
                    hostname=hostname,
                    ssh_ip=ssh_ip,
                    ssh_port=ssh_port,
                    is_verified='verified',
                    note=note
                )
                print(server_obj)
                for group_id in server_group_id_list:
                    group = ServerGroup.objects.get(id=group_id)
                    server_obj.server_group.add(group)
                # 服务器配置信息入库
                data = json.loads(result['data'])
                Server.objects.filter(hostname=hostname).update(**data)
                res = {'code': 200, 'msg': '添加主机成功，并同步配置'}
            else:
                res = {'code': 500, 'msg': '主机配置信息同步失败，错误信息： %s' % result['msg']}
        else:
            res = {'code': 500, 'msg': '错误信息： %s' % result['msg']}

        return Response(res)
```


3.主机远程采集入库： `devops_api/files/local_host_collect_linux.py`

使用 `local_host_collect_linux.py` 采集脚本




4.创建路由：`devops_api/devops_api/urls.py`

```python
from django.contrib import admin
from django.urls import path, include, re_path
from cmdb.views import IdcViewSet, ServerGroupViewSet, ServerViewSet, CreateHostView
from system_config.views import CredentialViewSet
from rest_framework import routers
from user_info.views import UserViewSet

from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

router = routers.DefaultRouter()
router.register(r'user', UserViewSet)
# cmdb项目相关接口
router.register(r'cmdb/idc', IdcViewSet, basename="idc")
router.register(r'cmdb/server_group', ServerGroupViewSet, basename="server_group")
router.register(r'cmdb/server', ServerViewSet, basename="server")
# credentials项目接口
router.register(r'config/credential', CredentialViewSet, basename="credential")

urlpatterns = [
    path('admin/', admin.site.urls),

    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    re_path('^api/cmdb/create_host/$', CreateHostView.as_view())
    # path('api/change-password/', ChangePasswordView.as_view()),
]

urlpatterns += [
    path('api/', include(router.urls))
]
```


5.httpie测试

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/cmdb/create_host/' \
--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MjAyOTc0LCJpYXQiOjE3MDcyMDI2NzQsImp0aSI6IjZjMjRmMjY3MDE4OTRiZWZhMDMzNzVjODVhMDkzODRhIiwidXNlcl9pZCI6MSwibmFtZSI6ImFkbWluIn0.RxXM137KOIsUKFv0KVtD7Hafm_pIMal8LI2zwxG2pkU' \
--form 'idc="4"' \
--form 'server_group="5"' \
--form 'name="gitee-sre1"' \
--form 'hostname="gitee-sre1"' \
--form 'ssh_ip="106.12.43.56"' \
--form 'ssh_port="27312"' \
--form 'credential="1"' \
--form 'note="sre开发服务器"'
```

测试成功返回如下内容

```sh
{
    "code": 200,
    "msg": "添加主机成功，并同步配置"
}
```

#### Excel 新建主机功能

- 根据excl模板下载，填写之后再导入Excel
- 需要安装xlrd: 

这里使用 `xlrd==1.2.0`版本，高版本有异常。

```sh
$ pip3 install xlrd==1.2.0
```

1.excel导入视图:  `devops_api/cmdb/views.py`

```python
class ExcelCreateHostView(APIView):
    # 下载主机导入模板.xlsx
    def get(self, request):
        file_name = 'local_server_host.xlsx'
        file_path = os.path.join(settings.BASE_DIR, 'cmdb', 'files', file_name)
        response = FileResponse(open(file_path, 'rb'))
        response['Content-Type'] = 'application/octet-stream'
        response['Content-Disposition'] = 'attachment;filename=%s' % file_name
        return response

    # 导入excel
    def post(self, request, *args, **kwargs):
        # 获取前端提交数据
        excel_file_obj = request.data['file']
        idc_id = int(request.data.get('idc'))
        server_group_id = request.data.get('server_group')

        # 直接自定义分隔符，把字符串转换为列表格式
        server_group_list_id = server_group_id.split(',')

        # 判断读取是否是excel文件
        try:
            data = xlrd.open_workbook(file_contents=excel_file_obj.read(), filename=None)
        except Exception as e:
            result = {'code': 500, 'msg': '请上传Excel文件！'}
            return Response(result)

        idc = Idc.objects.get(id=idc_id)
        # 打开第一个工作表
        table = data.sheets()[0]
        # 获取表的行数
        nrows = table.nrows
        try:
            for i in range(nrows):
                if i != 0:  # 跳过标题行
                    name = table.row_values(i)[0]
                    hostname = table.row_values(i)[1]
                    ssh_ip = table.row_values(i)[2]
                    ssh_port = table.row_values(i)[3]
                    note = table.row_values(i)[4]
                    server = Server.objects.create(
                        idc=idc,
                        name=name,
                        hostname=hostname,
                        ssh_ip=ssh_ip,
                        ssh_port=ssh_port,
                        note=note
                    )
                    # 添加多对多字段
                    for group_id in server_group_list_id:
                        group = ServerGroup.objects.get(id=group_id)  # 获取分组
                        server.server_group.add(group)  # 将服务器添加到分组
            result = {'code': 200, 'msg': 'excel导入主机成功'}
        except Exception as e:
            result = {'code': 500, 'msg': 'excel导入主机异常%s' % e}
        return Response(result)
```

2.调整cmdb的creadential字段可为空: `devops_api/cmdb/models.py`

```python
class Server(models.Model):
    '''
    服务器组
    '''
    idc = models.ForeignKey(Idc, on_delete=models.PROTECT, verbose_name="IDC机房")
    server_group = models.ManyToManyField(ServerGroup, default="Default", verbose_name="主机分组")
    credential = models.ForeignKey(Credential, on_delete=models.PROTECT, blank=True, null=True, verbose_name="SSH凭据")
    # ....
```

```sh
(venv) > python manage.py makemigrations 
(venv) > python manage.py migrate
```


3.设置路由: `devops_api/devops_api/urls.py`

```python
from django.contrib import admin
from django.urls import path, include, re_path
from cmdb.views import IdcViewSet, ServerGroupViewSet, ServerViewSet, CreateHostView, ExcelCreateHostView
# ...
urlpatterns = [
    path('admin/', admin.site.urls),
    # ....
    re_path('^api/cmdb/excel_create_host/$', ExcelCreateHostView.as_view())
    # path('api/change-password/', ChangePasswordView.as_view()),
]
```



postman 测试

![1707211457107](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707211457107.webp){: .zoom}





### 云主机导入功能

云主机采集很方便，无需agent脚本，直接通过云平台API获取即可。

![1707211595020](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707211595020.webp){: .zoom}



#### 阿里云

- 在线API调试平台: https://api.aliyun.com/
- 获取AceessKey文档: https://help.aliyun.com/document_detail/175967.html
- 获取AceessKey地址: https://ram.console.aliyun.com/manage/ak
- 安装sdk: pip install aliyun-python-sdk-ecs -i https://mirrors.aliyun.com/pypi/simple


1.阿里云信息获取模块脚本： `devops_api/libs/aliyun_cloud.py`


```python
from aliyunsdkcore.client import AcsClient
from aliyunsdkecs.request.v20140526 import DescribeRegionsRequest, DescribeInstancesRequest, DescribeZonesRequest, \
    DescribeDisksRequest
import json


class AliCloud():
    def __init__(self, secret_id, secret_key):
        self.secret_id = secret_id
        self.secret_key = secret_key

    def region_list(self):
        client = AcsClient(self.secret_id, self.secret_key)
        req = DescribeRegionsRequest.DescribeRegionsRequest()  # 获取地区
        try:
            resp = client.do_action_with_exception(req)
            resp = json.loads(resp.decode())
            resp = {'code': 200, 'data': resp}
            return resp
        except Exception as e:
            return {'code': '500', 'msg': e.get_error_msg()}

    def zone_list(self, region_id):
        client = AcsClient(self.secret_id, self.secret_key)
        req = DescribeZonesRequest.DescribeZonesRequest()
        req.add_query_param('RegionId', region_id)
        try:
            resp = client.do_action_with_exception(req)
            resp = json.loads(resp.decode())
            resp = {'code': 200, 'data': resp}
            return resp
        except Exception as e:
            return {'code': '500', 'msg': e.get_error_msg()}

    def instance_list(self, region_id):
        client = AcsClient(self.secret_id, self.secret_key)
        req = DescribeInstancesRequest.DescribeInstancesRequest()
        req.add_query_param('RegionId', region_id)
        try:
            resp = client.do_action_with_exception(req)
            resp = json.loads(resp.decode())
            resp = {'code': 200, 'data': resp}
            return resp
        except Exception as e:
            return {'code': '500', 'msg': e.get_error_msg()}

    def instance_disk(self, instance_id):
        client = AcsClient(self.secret_id, self.secret_key)
        req = DescribeDisksRequest.DescribeDisksRequest()
        req.add_query_param('InstanceId', instance_id)
        try:
            resp = client.do_action_with_exception(req)
            resp = json.loads(resp.decode())
            resp = {'code': 200, 'data': resp}
            return resp
        except Exception as e:
            return {'code': '500', 'msg': e.get_error_msg()}


if __name__ == '__main__':
    # 找个测试ak可以试试
    cloud = AliCloud("xxxxxxx", "xxxxxxxxxxx")
    result = cloud.region_list()
    result = cloud.zone_list('cn-hangzhou')
    result = cloud.instance_list("cn-hangzhou")
    result = cloud.instance_disk("i-bp1g28isv8irjtrwdxf4")
    print(result)
```


2.获取aliyun region 信息接口，提交服务器配置入库接口: `devops_api/cmdb/views.py`

```python
class AliyunCloudView(APIView):
    def get(self, request):
        # 获取region信息
        secret_id = request.query_params.get('secret_id')
        secret_key = request.query_params.get('secret_key')
        cloud = AliCloud(secret_id, secret_key)
        region_result = cloud.region_list()
        code = region_result['code']

        if code == 200:
            # 二次处理，固定字段名
            region = []
            for r in region_result['data']['Regions']['Region']:
                region.append({"region_id": r['RegionId'], 'region_name': r['LocalName']})
            res = {'code': 200, 'msg': '获取区域列表成功', 'data': region}
        else:
            res = {'code': 500, 'msg': '获取区域列表成功失败:%s' % region_result['msg']}
        return Response(res)

    def post(self, request, *args, **kwargs):
        """
        根据区域名称创建机房，再导入云主机（绑定机房）到数据库
        """
        # 凭据、IDC机房、主机分组、SSH连接地址（IP、端口）
        secret_id = request.data.get('secret_id')
        secret_key = request.data.get('secret_key')
        server_group_id = int(request.data.get('server_group'))
        region_id = request.data.get('region')  # 区域用于机房里的城市
        ssh_ip = request.data.get('ssh_ip')  # 用户选择使用内网（private）还是公网（public），下面判断对应录入
        ssh_port = int(request.data.get('ssh_port'))

        cloud = AliCloud(secret_id, secret_key)
        instance_result = cloud.instance_list(region_id)

        instance_list = []
        if instance_result['code'] == 200:
            instance_list = instance_result['data']['Instances']['Instance']
            if len(instance_list) == 0:
                res = {'code': 500, 'msg': '该区域未发现云主机，请重新选择！'}
                return Response(res)
        elif instance_result['code'] == 500:
            res = {'code': 500, 'msg': '%s' % instance_result['msg']}
            return Response(res)

        # InstanceSet中可用区字段值是英文，例如 ap-beijing-1
        # 先获取可用区英文与中文对应，下面遍历主机再获取中文名
        zone_result = cloud.zone_list(region_id)
        zone_dict = {}
        for z in zone_result['data']['Zones']['Zone']:
            zone_dict[z['ZoneId']] = z['LocalName']

        # 获取主机所在可用区
        # 可用区用于机房里的机房名称
        zone_set = set()
        for host in instance_list:
            zone = host['ZoneId']  # 可用区，例如 ap-beijing-1
            zone_set.add(zone_dict[zone])  # 获取中文名

        # 根据可用区创建机房
        for zone in zone_set:
            # 如果存在不创建
            idc = Idc.objects.filter(name=zone)
            if not idc:
                city = ""
                region_list = cloud.region_list()['data']['Regions']['Region']
                for r in region_list:  # 获取区域对应中文名
                    if r['RegionId'] == region_id:
                        city = r['LocalName']
                Idc.objects.create(
                    name=zone,
                    city=city,
                    provider="阿里云"
                )

        # 导入云主机信息到数据库
        for host in instance_list:
            zone = host['ZoneId']
            instance_id = host['InstanceId']  # 实例ID
            # hostname = host['HostName']
            instance_name = host['InstanceName']  # 机器名称
            os_version = host['OSName']

            private_ip_list = host['NetworkInterfaces']['NetworkInterface'][0]['PrivateIpSets']['PrivateIpSet']
            private_ip = []
            for ip in private_ip_list:
                private_ip.append(ip['PrivateIpAddress'])

            public_ip = host['PublicIpAddress']['IpAddress']
            cpu = "%s核" % host['Cpu']
            memory = "%sG" % (int(host['Memory']) / 1024)

            # 硬盘信息需要单独获取
            disk = []
            disk_list = cloud.instance_disk(instance_id)['data']['Disks']['Disk']
            for d in disk_list:
                disk.append({'device': d['Device'], 'size': '%sG' % d['Size'], 'type': None})

            create_date = time.strftime("%Y-%m-%d", time.strptime(host['CreationTime'], "%Y-%m-%dT%H:%MZ"))
            # 2022-01-30T04:51Z 需要转换才能存储
            expired_time = time.strftime("%Y-%m-%d %H:%M:%S", time.strptime(host['ExpiredTime'], "%Y-%m-%dT%H:%MZ"))

            # 创建服务器
            idc_name = zone_dict[zone]
            idc = Idc.objects.get(name=idc_name)  # 一对多

            if ssh_ip == "public":
                ssh_ip = public_ip[0]
            elif ssh_ip == "private":
                ssh_ip = private_ip[0]

            data = {'idc': idc,
                    'name': instance_name,
                    'hostname': instance_id,
                    'ssh_ip': ssh_ip,
                    'ssh_port': ssh_port,
                    'machine_type': 'cloud_vm',
                    'os_version': os_version,
                    'public_ip': public_ip,
                    'private_ip': private_ip,
                    'cpu_num': cpu,
                    'memory': memory,
                    'disk': disk,
                    'put_shelves_date': create_date,
                    'expire_datetime': expired_time,
                    'is_verified': 'verified'}
            # 如果instance_id不存在才创建
            server = Server.objects.filter(hostname=instance_id)
            if not server:
                server = Server.objects.create(**data)
                # 分组多对多
                group = ServerGroup.objects.get(id=server_group_id)  # 根据id查询分组
                server.server_group.add(group)  # 将服务器添加到分组
            else:
                server.update(**data)

        res = {'code': 200, 'msg': '导入云主机成功'}
        return Response(res)
```

3.添加路由： `devops_api/devops_api/urls.py`


```python
from cmdb.views import CreateHostView,ExcelCreateHostView,AliyunCloudView

urlpatterns = [
    path('admin/', admin.site.urls),
    re_path('^api/login/$', CustomAuthToken.as_view()),
    re_path('^api/change_password/$', token_auth.ChangeUserPasswordView.as_view()),
    re_path('^api/cmdb/create_host/$', CreateHostView.as_view()),
    re_path('^api/cmdb/excel_create_host/$', ExcelCreateHostView.as_view()),
    re_path('^api/cmdb/aliyun_cloud/$', AliyunCloudView.as_view())
]
# ....
```

4.阿里云创建资源测试：创建一个只读全局的账号，并获取 access id ,secert_key



5.postman post 测试




#### 腾讯云

- 在线API调试平台: https://console.cloud.tencent.com/api/explorer
- API文档: https://cloud.tencent.com/document/product/296/19850
- Python SDK: https://github.com/TencentCloud/tencentcloud-sdk-python
- 获取AceessKey地址: https://console.cloud.tencent.com/cam/capi
- 安装腾讯云sdk: pip install tencentcloud-sdk-python -i https://mirrors.tencent.com/pypi/simple/


1.腾讯云信息获取脚本: `devops_api/libs/tencent_cloud.py`

```python

```