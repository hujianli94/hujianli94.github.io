# 3.CMDB后端开发-上


## 企业项目开发流程

![1707100340914](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100340914.webp){: .zoom}



## 项目背景

目前运维管理存在痛点：随着业务增长，服务器数量越来越多，资产信息通过Excel记录，人工管理低效，易于出错。


## CMDB介绍

- 配置管理数据库（Configuration Management Database，CMDB），是一个逻辑数据库，包含了应用生命周期的信息，例如服务器、物理关系、通信关系、依赖关系等。

- CMDB存储与管理企业IT架构中设备的各种配置信息，它与所有运维服务和应用发布流程都紧密相联，支持这些流程的运转、发挥配置信息的价值，同时依赖于相关流程保证数据的准确性。CMDB可以实现高度的自动化，减少人为错误的发生、降低人员成本，CMDB是实现运维自动化的基础。

- CMDB资产

![1707100437351](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100437351.webp){: .zoom}



### CMDB数据存储需要注意的事项

- CMDB的目的是为了在其他流程或应用之间共享数据的，如果一个应用或流程需要对某类数据单独使用的话，则不建议将这类数据存入CMDB中，存在自身应用即可。
- 动态数据不建议存储在CMDB中，例如CPU使用率、内存使用率，因为这类数据更新过于频繁。
- 如果没有任何流程、应用及人员，需要对特定的数据进行使用，则没有必要放到CMDB中存储。



### 技术选型

![1707100589501](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100589501.webp){: .zoom}



前端技术栈

- Vue3
- Vue-router
- Element Plus
- Axios


后端技术栈

- python
- Django DRF
- mysql


### 整体设计

![1707100822692](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707100822692.webp){: .zoom}



## 数据库设计

![1707105493241](https://cdn.jsdelivr.net/gh/hujianli94/picx-images-hosting@master/1707105493241.webp){: .zoom}



### 机房管理

表名：cmdb_idc

| 字段         | 类型                  | 空   | 名称     |
|--------------|-----------------------|------|---------|
| id           | INTEGER               | 否   | 自增长ID |
| name         | VARCHAR(30)（unique） | 否   | 机房名称 |
| city         | VARCHAR(20)           | 否   | 城市     |
| provider     | VARCHAR(20)           | 否   | 运营商   |
| note         | TEXT                  | 是   | 备注     |
| create_time  | DATETIME              | 否   | 创建时间 |


### 主机分组

表名：cmdb_server_group

| 字段名       | 类型       | 允许为空 | 名称     |
| ------------ | ---------- | -------- | -------- |
| id           | INTEGER    | 否       | 自增长ID |
| name         | VARCHAR(30)| 否       | 分组名称 |
| note         | TEXT       | 是       | 备注     |
| create_time  | DATETIME   | 否       | 创建时间 |


### 主机管理

表名：cmdb_server

| 字段名              | 类型            | 允许为空 | 名称                     |
| -------------------| --------------- | -------- | ------------------------ |
| id                 | INTEGER         | 否       | 自增长ID                 |
| idc                | IDC表一对多关系 | 否       | IDC机房                  |
| server_group       | 分组表多对多关系 | 否       | 主机分组                 |
| credential         | 凭据表一对多     | 否       | 凭据ID                   |
| name               | VARCHAR(30)     | 否       | 名称，默认与主机名一样   |
| hostname           | VARCHAR(30)     | 否       | 主机名，唯一标识符       |
| ssh_ip             | VARCHAR(40)     | 否       | SSH IP                   |
| ssh_port           | INTEGER         | 否       | SSH端口                  |
| machine_type       | VARCHAR(20)     | 是       | 机器类型（虚拟机、云主机、物理机） |
| os_version         | VARCHAR(30)     | 是       | 系统版本                 |
| public_ip          | JSON            | 是       | 公网IP（列表存储，会有多个ip） |
| private_ip         | JSON            | 否       | 内网IP（列表存储）        |
| cpu_num            | VARCHAR(10)     | 是       | CPU数量                  |
| cpu_model          | VARCHAR(100)    | 是       | CPU型号                  |
| memory             | VARCHAR(30)     | 是       | 内存                     |
| disk               | JSON            | 是       | 硬盘（列表存储，包含设备、容量、硬盘类型） |
| put_shelves_date   | DATE            | 是       | 上架日期，默认为系统启动时间 |
| off_shelves_date   | DATE            | 是       | 下架日期                 |
| expire_datetime    | DATETIME        | 是       | 租约过期时间             |
| is_verified        | VARCHAR(10)     | 是       | SSH验证状态（已验证，未验证） |
| note               | TEXT            | 是       | 备注                     |
| update_time        | DATETIME        | 是       | 更新时间                 |
| create_time        | DATETIME        | 否       | 创建时间                 |


### 系统配置： 凭据管理

表名：system_config_credential

| 字段名        | 类型       | 允许为空 | 名称         |
| -------------| ---------- | -------- | ------------ |
| id           | INTEGER    | 否       | 自增长ID     |
| name         | VARCHAR(30)| 否       | 名称         |
| auth_mode    | VARCHAR(30)| 否       | 认证方式，key、pass |
| username     | VARCHAR(20)| 否       | 用户名       |
| password     | VARCHAR(30)| 是       | 密码         |
| private_key  | TEXT       | 是       | 私钥         |
| note         | TEXT       | 是       | 备注         |
| update_time  | DATETIME   | 否       | 更新时间     |
| create_time  | DATETIME   | 否       | 创建时间     |



## API 平台开发


### 接口设计

| 请求路径                            | HTTP方法       | 功能                            | 备注                               |
| -----------------------------------| -------------- | ------------------------------- | ---------------------------------- |
| /api/cmdb/idc/                      | get, post, put, delete | 查看，创建，更新，删除         | IDC机房                            |
| /api/cmdb/server_group/             | get, post, put, delete | 查看，创建，更新，删除         | 主机分组                           |
| /api/cmdb/server/                   | get, post, put, delete | 查看，创建，更新，删除         | 服务器                            |
| /api/cmdb/create_host               | post           | 创建                            | 新建主机                           |
| /api/cmdb/host_collect              | get            | SSH连接采集主机配置                | SSH连接采集主机配置                  |
| /api/cmdb/excel_create_host         | get, post      | 下载excel模板文件，提交文件      | excel导入主机                      |
| /api/cmdb/tencent_cloud             | get            | 调用腾讯云ECS API获取                | 腾讯云云主机导入                     |
| /api/cmdb/aliyun_cloud              | get            | 调用阿里云ECS API获取                | 阿里云云主机导入                     |


## API平台雏形(上)


### 基础准备

1.pip需要安装的包

```sh
pip3 install django==3.2
pip3 install pymysql
pip3 install djangorestframework
pip3 install django-rest-swagger
pip3 install django-filter
pip3 install Markdown
```

2.Pycharm创建项目



3.创建应用

```sh
(venv) > python manage.py startapp cmdb
(venv) > python manage.py startapp system_config
```


4.调整 `settings.py` 配置

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'django_filters',
    'cmdb',
    'system_config'
]
```

5.本地安装并启动 mysql，设置好数据库，用户

```sh
wanghui@kkkk ~ % mysql -uroot -proot
mysql> create database devops_backend;
```

6.配置mysql数据库

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'devops_backend',
        'USER': 'root',
        'PASSWORD': 'oschina',
        'HOST': '127.0.0.1',
        'PORT': '3306',
        # 第三方登录功能必须加上
        "OPTIONS": {"init_command": "SET default_storage_engine=INNODB", "charset": "utf8"},
    }
}
```

7.devops_api/init.py 配置默认的pymysql为驱动

```python
import pymysql

pymysql.install_as_MySQLdb()
```

### cmdb数据库model和system_config数据库model设置


1.system_config model配置： `devops_api/system_config/models.py`

```python
from django.db import models

class Credential(models.Model):
    auth_choice = (
        (1, "密码"),
        (2, "秘钥")
    )
    name = models.CharField(max_length=30, verbose_name="凭据名称")
    username = models.CharField(max_length=20, verbose_name="用户名")
    auth_mode = models.IntegerField(choices=auth_choice, default=1, verbose_name="认证方式")
    password = models.CharField(max_length=50, blank=True, verbose_name="密码")
    private_key = models.TextField(blank=True, verbose_name="私钥")
    note = models.TextField(blank=True, verbose_name="备注")
    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    update_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        db_table = "system_config_credential"
        verbose_name_plural = "凭据管理"
        ordering = ('-id',)

    def __str__(self):
        return self.name
```

2.cmdb model配置: `devops_api/cmdb/models.py`

```python
from django.db import models
from system_config.models import Credential

class Idc(models.Model):
    '''
    idc表
    '''
    name = models.CharField(max_length=64,unique=True,verbose_name="idc名称")
    city = models.CharField(max_length=64, verbose_name="城市")
    provider = models.CharField(max_length=64,verbose_name="提供商")
    note = models.TextField(null=True, blank=True, verbose_name="备注")
    create_time = models.DateTimeField(auto_now_add=True,verbose_name="创建时间")

    class Meta:
        db_table = 'cmdb_idc'
        verbose_name_plural = 'idc机房'
        ordering = ('-id',)

    def __str__(self):
        return self.name

class ServerGroup(models.Model):
    '''
    主机分组
    '''
    name = models.CharField(max_length=64,unique=True,verbose_name="分组名称")
    note = models.TextField(null=True,blank=True,verbose_name="备注")
    create_time = models.DateTimeField(auto_now_add=True,verbose_name="创建时间")

    class Meta:
        db_table = "cmdb_server_group"
        verbose_name_plural = "服务器分组"
        ordering = ('-id',)

    def __str__(self):
        return self.name

class Server(models.Model):
    '''
    服务器组
    '''
    idc = models.ForeignKey(Idc, on_delete=models.PROTECT, verbose_name="IDC机房")
    server_group = models.ManyToManyField(ServerGroup, default="Default", verbose_name="主机分组")
    credential = models.ForeignKey(Credential,on_delete=models.PROTECT, verbose_name="SSH凭据")

    hostname = models.CharField(max_length=30, unique=True, verbose_name="主机名")
    name = models.CharField(max_length=30, unique=True, verbose_name="名称")

    ssh_ip = models.GenericIPAddressField(verbose_name="SSH IP")
    ssh_port = models.IntegerField(verbose_name="SSH端口")
    note = models.TextField(blank=True, null=True, verbose_name="备注")

    machine_type = models.CharField(max_length=30, blank=True,
                                    choices=(('vm', '虚拟机'), ('cloud_vm', '云主机'), ('physical_machine', '物理机')),
                                    verbose_name="机器类型")
    os_version = models.CharField(max_length=50, blank=True, null=True, verbose_name="系统版本")
    public_ip = models.JSONField(max_length=100, blank=True, null=True, verbose_name="公网IP")
    private_ip = models.JSONField(max_length=100, blank=True, null=True, verbose_name="内网IP")
    cpu_num = models.CharField(max_length=10, blank=True, null=True, verbose_name="CPU")
    cpu_model = models.CharField(max_length=100, blank=True, null=True, verbose_name="CPU型号")
    memory = models.CharField(max_length=30, blank=True, null=True, verbose_name="内存")
    disk = models.JSONField(max_length=200, blank=True, null=True, verbose_name="硬盘")
    put_shelves_date = models.DateField(null=True, blank=True, verbose_name="上架日期")
    off_shelves_date = models.DateField(null=True, blank=True, verbose_name="下架日期")
    expire_datetime = models.DateTimeField(blank=True, null=True, verbose_name="租约过期时间")
    is_verified = models.CharField(max_length=10, blank=True, choices=(('verified', '已验证'), ('unverified', '未验证')),
                                   default='unverified', verbose_name="SSH验证状态")
    update_time = models.DateTimeField(auto_now_add=True, verbose_name="更新时间")
    create_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")

    class Meta:
        db_table = "cmdb_server"
        verbose_name_plural = "主机管理"
        ordering = ('-id',)

    def __str__(self):
        return self.hostname
```


3.同步数据

```sh
(venv) > python manage.py makemigrations 
(venv) > python manage.py migrate
```


### 定义序列化器

cmdb序列化器的定义： `devops_api/cmdb/serializers.py`

```python
from .models import Idc,ServerGroup,Server
from rest_framework import serializers

class IdcSerializers(serializers.ModelSerializer):
    class Meta:
        model = Idc
        fields = '__all__'
        read_only_fields = ("id",)

class ServerGroupSerializers(serializers.ModelSerializer):
    class Meta:
        model = ServerGroup
        fields = '__all__'
        read_only_fields = ("id",)
        
class ServerSerializers(serializers.ModelSerializer):
    class Meta:
        model = Server
        fields = '__all__'
        read_only_fields = ("id",)
```

System_config序列化器的定义： `devops_api/system_config/serializers.py`

```python
from .models import Credential
from rest_framework import serializers


class CredentialSerializer(serializers.ModelSerializer):
    class Meta:
        model = Credential
        fields = '__all__'
        read_only_fields = ("id",)
```


### 定义视图

1.定义cmdb视图： `devops_api/cmdb/views.py`

```python
from cmdb.models import Idc, ServerGroup, Server
from cmdb.serializers import IdcSerializers, ServerGroupSerializers, ServerSerializers
from rest_framework.viewsets import ModelViewSet


class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers


class ServerViewSet(ModelViewSet):
    queryset = Server.objects.all()
    serializer_class = ServerSerializers
```


2.定义system_config视图： `devops_api/system_config/views.py`

```python
from rest_framework.viewsets import ModelViewSet
from system_config.models import Credential
from system_config.serializers import CredentialSerializer


class CredentialViewSet(ModelViewSet):
    queryset = Credential.objects.all()
    serializer_class = CredentialSerializer
```



### 动态路由

1.注册cmdb和credentials的路由： `devops_api/devops_api/urls.py`

```python
from django.contrib import admin
from django.urls import path, include
from cmdb.views import IdcViewSet, ServerGroupViewSet, ServerViewSet
from system_config.views import CredentialViewSet
from rest_framework import routers
router = routers.DefaultRouter()
router.register(r'cmdb/idc', IdcViewSet, basename="idc")
router.register(r'cmdb/server_group', ServerGroupViewSet, basename="server_group")
router.register(r'cmdb/server', ServerViewSet, basename="server")
router.register(r'config/credential', CredentialViewSet, basename="credential")
urlpatterns = [
    path('admin/', admin.site.urls),
]

urlpatterns += [
    path('api/', include(router.urls))
]
```

2.查看接口

- http://127.0.0.1:8000/api/


### 新增接口数据


#### idc 数据

> http://127.0.0.1:8000/api/cmdb/idc/


查看接口数据

```sh
curl --location --request GET 'http://127.0.0.1:8000/api/cmdb/idc/'
```

新增接口数据

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/cmdb/idc/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name": "酒仙桥兆唯机房",
    "city": "北京",
    "provider": "电信",
    "note": ""
}'
# .....
```


#### server-group 数据

> http://127.0.0.1:8000/api/cmdb/server_group/


查看接口数据

```sh
curl --location --request GET 'http://127.0.0.1:8000/api/cmdb/server_group/'
```

新增接口数据

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/cmdb/server_group' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name": "k8s集群",
    "note": ""
}'
# ....
```

#### credential 数据

> http://127.0.0.1:8000/api/config/credential/


查看接口数据

```sh
curl --location --request GET 'http://127.0.0.1:8000/api/config/credential/'
```

新增接口数据

```sh
# 用户名/密码认证
curl --location --request POST 'http://127.0.0.1:8000/api/config/credential/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name": "ssh-pwd",
    "username": "root",
    "auth_mode": 1,
    "password": "123456",
    "private_key": "",
    "note": ""
}'

# 用户名/秘钥认证
curl --location --request POST 'http://127.0.0.1:8000/api/config/credential/' \
--form 'name="ssh-cert"' \
--form 'username="ubuntu"' \
--form 'auth_mode="2"' \
--form 'password=""' \
--form 'private_key="-----BEGIN RSA PRIVATE KEY-----
MIIEoQIBAAKCAQEAyrPhiJrgQae+Qlgbs+PBG7lhJ2q4y3F5dvOzmz9PCTGOu/yM
......
-----END RSA PRIVATE KEY-----
"' \
--form 'note=""'
```



#### server数据

> http://127.0.0.1:8000/api/cmdb/server/


查看接口数据

```sh
curl --location --request GET 'http://127.0.0.1:8000/api/cmdb/server/'
```

新增接口数据

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/cmdb/server/' \
--header 'Content-Type: application/json' \
--data-raw '{
	"hostname": "gdc-ci-base",
    "name": "baiducloud-cce-dev",
	"ssh_ip": "192.168.240.23",
	"ssh_port": 27312,
	"note": "",
	"machine_type": "vm",
	"os_version": "",
	"public_ip": ["106.12.43.56"],
	"private_ip": ["192.168.240.23"],
	"cpu_num": "",
	"cpu_model": "",
	"memory": "",
	"disk": [""],
	"put_shelves_date": null,
	"off_shelves_date": null,
	"expire_datetime": null,
	"is_verified": "unverified",
	"idc": 4,
	"credential": 1,
	"server_group": [5]
}'
```


## API平台雏形(下)

### 分页


1.定义分页lib，`devops_api/libs/pagination.py`


```python
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response
from collections import OrderedDict


class MyPagination(PageNumberPagination):
    page_size = 6  # 默认每页显示多少条
    page_query_param = 'page_num'  # 指定查询第几页（页码），默认 page
    page_size_query_param = 'page_size'  # 定义每页显示多少条
    max_page_size = 50  # 每页最多显示多少条

    def get_paginated_response(self, data):
        code = 200
        msg = "成功"
        return Response(OrderedDict([
            ('code', code),
            ('msg', msg),
            ('count', self.page.paginator.count),
            # ('next', self.get_next_link()),
            # ('previous', self.get_previous_link()),
            ('data', data)
        ]))

```


2.settings配置引用自定义分页(最后追加)： `devops_api/devops_api/settings.py`

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'libs.pagination.MyPagination'
}
```


### 过滤,搜索和排序

1.Cmdb视图中新增搜索和排序的字段: `devops_api/cmdb/views.py`

```python
from cmdb.models import Idc, ServerGroup, Server
from cmdb.serializers import IdcSerializers, ServerGroupSerializers, ServerSerializers
from rest_framework.viewsets import ModelViewSet
from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend


class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name", 'provider',)
    filterset_fields = ("city",)
    ordering_fields = ("id",)


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name",)
    filterset_fields = ("name",)
    ordering_fields = ("id",)


class ServerViewSet(ModelViewSet):
    queryset = Server.objects.all()
    serializer_class = ServerSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("hostname",)
    filterset_fields = ("hostname",)
    ordering_fields = ("id",)
```


2.credentials视图中新增搜索，过滤，排序字段：`devops_api/system_config/views.py`


```python
from rest_framework.viewsets import ModelViewSet
from system_config.models import Credential
from system_config.serializers import CredentialSerializer
from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend


class CredentialViewSet(ModelViewSet):
    queryset = Credential.objects.all()
    serializer_class = CredentialSerializer
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name",)
    filterset_fields = ("name",)
    ordering_fields = ("id",)
```


3.测试case

- 搜索: http://127.0.0.1:8000/api/cmdb/idc/?search=电信

```sh
curl --location --request GET 'http://127.0.0.1:8000/api/cmdb/idc/?search=电信'
```

- 过滤: http://127.0.0.1:8000/api/cmdb/idc/?city=北京

```sh
curl --location --request GET 'http://127.0.0.1:8000/api/cmdb/idc/?city=北京'
```

- 排序(逆序): http://127.0.0.1:8000/api/cmdb/idc/?ordering=-id

```sh
curl --location --request GET 'http://127.0.0.1:8000/api/cmdb/idc/?ordering=-id'
```


### token认证

可以使用`Django REST framework的Token生成`的方式去实现，但数据库中会自动生成一张 authtoken_token 表.

Django REST framework的Token这个有如下缺点：

- Django REST framework所自建的Token表，可以发现这个表格只有三个字段（不算ID字段）：记录Token内容的key字段，记录生成Token时间的created字段，以及外键user_id字段。缺少了一个Token的有效期时间字段。

- 从原理上来说，有效期时间字段并没有存在的必要，但是从网络安全的角度上来看，这个字段却是必不可少的。试想，如果一个Token字符串没有有效期限制，只要网络请求被抓包，被黑客获取了一条Token，那么与获取到用户的账号和密码是没有区别的。所以，Django RESTframework的Token，第一个局限性就是其自建的Token表缺少记录有效期时间的字段。

- 第二个局限性表现在不利于分布式部署或多个系统使用一套验证，Token表只能放在一台服务器上，如果每一次数据请求都要查询一次数据库的整个用户表，那么对于服务器来说将是很大的消耗。试想一下，假如一个平台有四五亿用户，用户任何一次点赞的操作，都要在四五亿数量级的数据表中完成一次查询，那将是一件多么麻烦的事情啊！



所以使用Json Web Token机制，便可以解决这些问题，`jangorestframework-simplejwt` 这个库就可以满足。


1.首先 pip 安装 djangorestframework-simplejwt 这个 jwt 库：

```sh
(venv) > pip install djangorestframework-simplejwt
```



2.修改配置文件，使 JWT 为默认的验证机制：`devops_api/devops_api/settings.py`

```python
REST_FRAMEWORK = {
    # 分页
    'DEFAULT_PAGINATION_CLASS': 'libs.pagination.MyPagination',
    # 认证
    'DEFAULT_AUTHENTICATION_CLASSES': (
        # 'rest_framework.authentication.SessionAuthentication',
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    # 权限
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated'  # 登录后就能访问所有API
    ],
}
```

3.在根路由中添加 Token 的获取和刷新地址：`devops_api/devops_api/urls.py`

```python
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

urlpatterns = [
    # ...
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]
```


视图类里面加上认证、权限配置: `devops_api/cmdb/views.py`

```python
from rest_framework.permissions import IsAuthenticated
class IdcViewSet(ModelViewSet):
    queryset = Idc.objects.all()
    serializer_class = IdcSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name", 'provider',)
    filterset_fields = ("city",)
    ordering_fields = ("id",)
    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]


class ServerGroupViewSet(ModelViewSet):
    queryset = ServerGroup.objects.all()
    serializer_class = ServerGroupSerializers
    filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]
    search_fields = ("name",)
    filterset_fields = ("name",)
    ordering_fields = ("id",)
    # 认证&权限配置
    # authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]
# .....
```


这就完成了，毫无痛苦，这就是用一个优秀轮子的好处。


4.测试

加入实验数据。建立超级用户，用户名 root，密码 oschina123：

```sh
(venv) > python manage.py createsuperuser
Username (leave blank to use '18793'): admin
Email address: 1@1.com
Password:
Password (again):
Superuser created successfully.
```

没有通过token访问一律返回如下：

```sh
{
    "detail": "Authentication credentials were not provided."
}
```


首先，携带用户名和密码发送一个 POST 请求，以获取 Token：

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/token/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "username": "admin",
    "password": "oschina123"
}'
```

返回数据如下：

```json
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcwNzIwNjkyMSwiaWF0IjoxNzA3MTIwNTIxLCJqdGkiOiI2YWRjZmM1ZTllYjg0YWQ5YmExODRlYzM5NDVjYTg0NyIsInVzZXJfaWQiOjF9.IPBkrG0CzeHD2-Zu2Hi4agBB0fXhtdeWWJ2hDQIBmG0",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTIwODIxLCJpYXQiOjE3MDcxMjA1MjEsImp0aSI6ImZjOGU2YTFkMjM3NTRjYzRiZWU3MDA5NThjNzg1NWQ2IiwidXNlcl9pZCI6MX0.z2qZd_VY4ZNEWE7GYJbrqEJf6Yc4WAH_Mb2jKAEx9mE"
}
```


> 注意：开启 JWT 后，Session 验证就自动失效了。也就是说，除了申请 Token 时会用到账户密码，其他时候的身份验证都不再需要它们了。

Session 和 JWT 哪个好？将会话移至客户端意味着摆脱了对服务器端会话的依赖，但这会带来如何安全存储、运输令牌等一系列挑战。不能够一概而论，而是要根据你的项目实际需求。

关于这个话题更深入的讨论，请移步[Stackoverflow](https://stackoverflow.com/questions/43452896/authentication-jwt-usage-vs-session)。



拿到 Token 后，就可以用 Token 作为你的身份令牌，进行正常的资源请求了：

> Postman 有一个专门的标签页 (Authorization) 用于填写令牌。此标签页的 Type 栏选择 Bearer Token 即可。


```sh
curl --location --request GET 'http://127.0.0.1:8000/api/cmdb/idc/' \
--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTIyMzQwLCJpYXQiOjE3MDcxMjIwNDAsImp0aSI6Ijc4MDBhYjFkZjE4YTQ1Y2I4YjI2NzNhMzk1NTQ5NTVkIiwidXNlcl9pZCI6MX0.MJtfBGuQYeFwqulKi_1d1VSxbjDYg8OPllABsEEYRzg'
```

通过 token 访问后我们拿到想要的数据了。


令牌具有过期时间（默认为5分钟，可在配置中修改），过期之后就不能再使用了，但是可用刷新令牌再获取一个新的令牌：

```sh
{
    "detail": "Given token not valid for any token type",
    "code": "token_not_valid",
    "messages": [
        {
            "token_class": "AccessToken",
            "token_type": "access",
            "message": "Token is invalid or expired"
        }
    ]
}
```

令牌具有过期时间（默认为5分钟，可在配置中修改），过期之后就不能再使用了，但是可用刷新令牌再获取一个新的令牌,刷新token

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/token/refresh/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcwNzk4Njg5MCwiaWF0IjoxNzA3MTIyODkwLCJqdGkiOiI1ZGZjOGRhOTQ3NjI0ZGMxYTI2OGM2ZjVjMWRjM2EyMiIsInVzZXJfaWQiOjF9.9tDvlGjIiVnQU-hhwcsL02wZec8981ayoKFmFHiHEAc"
}'
```


有效期

Token 默认有效期很短，只有 5 分钟。你可以通过修改 Django 的配置文件进行更改：

```python
from datetime import timedelta

# SIMPLE_JWT Token 默认有效期
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=10),
}
```

自定义令牌(token) 定制返回格式



继承auth_user表完成签发登录，但是它的返回格式太固定了只有Token，但是我们想自定义格式呢？

如：

```js
{
  'code': 200,
  'msg': '登录成功',
  'username': self.user.username,
  'token':'fdsafsfsafsadf'
}
```

1.写个序列化类，重写validate ，返回什么，前端看到什么 `devops_api/libs/simplejwt_tokenObtainPairSerializer.py`


```python
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer


class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    '在荷载中添加自定义内容'

    @classmethod
    def get_token(cls, user):
        """
        重写get_token方法，它返回的token中就是荷载的内容
        自定义返回格式
        """
        token = super().get_token(user)  # 签发用户
        token['name'] = user.username  # 往荷载里面添加用户名称
        return token

    def validate(self, attrs):
        old_data = super().validate(attrs)
        data = {'code': 200,
                'msg': '登录成功',
                'username': self.user.username,
                'refresh': old_data['refresh'],
                'access': old_data['access']
                }
        return data
```

2.在settings配置文件中配置

```python
SIMPLE_JWT = {
    "TOKEN_OBTAIN_SERIALIZER": "libs.simplejwt_tokenObtainPairSerializer.MyTokenObtainPairSerializer",
}
```

效果如下:

```sh
curl --location --request POST 'http://127.0.0.1:8000/api/token/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "username": "admin",
    "password": "oschina123"
}'
```

```sh
{
    "code": 200,
    "msg": "登录成功",
    "username": "admin",
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcwNzIxMDUyMSwiaWF0IjoxNzA3MTI0MTIxLCJqdGkiOiJhZTQxODcxMmViNDk0MzhjOWMxMDY4ZDM5NGMzYTRkNCIsInVzZXJfaWQiOjEsIm5hbWUiOiJhZG1pbiJ9.xdrczzwksddsc0rjJlqAQufe2ePffrhNk9vYaCrh2vs",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzA3MTI0NDIxLCJpYXQiOjE3MDcxMjQxMjEsImp0aSI6ImQ4ZDAxYzBiZDk4YTRhNmQ5NDk2ZGRjZjM3NTliZWJlIiwidXNlcl9pZCI6MSwibmFtZSI6ImFkbWluIn0.XLjVjq43p6o7hKu8gwYEQyy3jCv1o9OAdk9-pcnxZZI"
}
```




参考文献

https://blog.csdn.net/achen_m/article/details/135370882

https://zhuanlan.zhihu.com/p/339409769




### 用户管理

创建应用

```sh
(venv) > python manage.py startapp user_info
```

用户管理涉及到对密码的操作，因此新写一个序列化器，覆写 `def create(...)` 和 `def update(...)` 方法：

`devops_api/user_info/serializers.py`

```python

```





### 修改密码接口

1.路由配置： `devops_api/urls.py`

```python

```
