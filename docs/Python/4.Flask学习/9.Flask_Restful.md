# 9.Flask_Restful

## RESTful 架构的实例

### Restful API 规范

restful api 是用于在前端与后台进行通信的一套规范。使用这个规范可以让前后端开发变得更加轻松。以下将讨论这套规范的一些设计细节。

#### 协议：

采用 http 或者 https 协议。

#### 数据传输格式：

数据之间传输的格式应该都使用 json，而不使用 xml。

#### url 链接：

url 链接中，不能有动词，只能有名词。并且对于一些名词，如果出现复数，那么应该在后面加 s。
比如：获取文章列表，应该使用`/articles/`，而不应该使用/get_article/

#### HTTP 请求的方法：

1. GET：从服务器上获取资源。
2. POST：在服务器上新创建一个资源。
3. PUT：在服务器上更新资源。（客户端提供所有改变后的数据）
4. PATCH：在服务器上更新资源。（客户端只提供需要改变的属性）
5. DELETE：从服务器上删除资源。

示例如下：

- GET /users/：获取所有用户。
- POST /user/：新建一个用户。
- GET /user/id/：根据 id 获取一个用户。
- PUT /user/id/：更新某个 id 的用户的信息（需要提供用户的所有信息）。
- PATCH /user/id/：更新某个 id 的用户信息（只需要提供需要改变的信息）。
- DELETE /user/id/：删除一个用户。

#### 状态码：

| 状态码 | 原生描述              | 描述                                                                       |
| :----- | :-------------------- | :------------------------------------------------------------------------- |
| 200    | OK                    | 服务器成功响应客户端的请求。                                               |
| 400    | INVALID REQUEST       | 用户发出的请求有错误，服务器没有进行新建或修改数据的操作                   |
| 401    | Unauthorized          | 用户没有权限访问这个请求                                                   |
| 403    | Forbidden             | 因为某些原因禁止访问这个请求                                               |
| 404    | NOT FOUND             | 用户发送的请求的 url 不存在                                                |
| 406    | NOT Acceptable        | 用户请求不被服务器接收（比如服务器期望客户端发送某个字段，但是没有发送）。 |
| 500    | Internal server error | 服务器内部错误，比如出现了 bug                                             |

参考文献：

- https://www.yuque.com/young_tim/zdpreg/di-shi-si-zhang-ff1a-flask_di-yi-jie-ff1a-restful-api-gui-fan

`ext.py`

引入插件的操作实体类需在 etx.py 中实例化，防止循环引用

```python
'''
ext.py文件：把db变量放到一个单独的文件，而不是放在主app文件。

这样做的目的是为了在大型项目中如果db被多个模型文件引用的话，会造成from your_app import db这样的方式，但是往往也在your_app.py中也会引入模型文件定义的类，这
就造成了循环引用。

所以最好的办法是把它放在不依赖其他模块的独立文件中。
'''
from flask_apscheduler import APScheduler

# db
db = SQLAlchemy()
```

`models/todo.py`

首先定义模型，如下示例

```python
from flask import url_for
from sqlalchemy.exc import SQLAlchemyError

from ext import db


class Todo(db.Model):
    """
    任务清单表
    """
    __tablename__ = 'todo'
    id = db.Column(db.Integer, autoincrement=True, primary_key=True, nullable=False)
    title = db.Column(db.String(60), nullable=False)
    description = db.Column(db.String(60), nullable=False)
    done = db.Column(db.Boolean, nullable=False)

    def get(self, id):
        return self.query.filter_by(id=id).first()

    def add(self, user):
        db.session.add(user)
        return session_commit()

    def update(self):
        return session_commit()

    def delete(self, id):
        self.query.filter_by(id=id).delete()
        return session_commit()

    def to_json(self):
        json_post = {
            # 蓝图名称+视图函数名称
            'url': url_for('todo_v1.get_tasks_list', id=self.id, _external=True),
            'title': self.title,
            'description': self.description,
            'done': self.done
        }
        return json_post


def session_commit():
    try:
        db.session.commit()
    except SQLAlchemyError as e:
        db.session.rollback()
        reason = str(e)
        return reason
```

### jsonify 函数

jsonify 的作用是把数据序列化成 JSON，并且在声明返回头部 application/json，
它返回一个 Response 对象它使用 json.dumps 序列化数据, 但是 args 和 kwargs 会被作为数据，而不是参数。

主要功能

1.如果返回值是一个字典，那么会调用 jsonify() 来产生一个响应

2.jsonify 返回的 Response 的 headers 属性为：Content-Type: application/json ，是标准的 json 格式。

3.jsonify 自动去除了 JSON 格式中逗号冒号间的空格，起到了压缩数据的作用。

示例代码

```python
from flask import request, abort, jsonify
from . import todo_v1_bp
from ext import db
from app.models.todo import Todo
from flask_jwt_extended import jwt_required


@todo_v1_bp.route('/tasks', methods=['GET'])
# 需要验证token
@jwt_required()
def get_tasks_list():
    """
    查看所有任务
    """
    tasks_list = Todo.query.all()
    return jsonify({"count": len(tasks_list), 'tasks': [tasks.to_json() for tasks in tasks_list]}), 200


@todo_v1_bp.route('/tasks/<int:id>', methods=['GET'])
# 需要验证token
@jwt_required()
def get_task(id):
    """
    查看单条任务
    """
    task = Todo.query.get_or_404(id)
    return jsonify(task.to_json()), 200


@todo_v1_bp.route('/tasks', methods=['POST'])
# 需要验证token
@jwt_required()
def create_task():
    """
    创建单条任务
    """
    if not request.json or not 'title' in request.json or not 'description' in request.json:
        abort(400)
    new_todo = Todo()
    new_todo.title = request.json['title']
    new_todo.description = request.json['description']
    new_todo.done = False
    db.session.add(new_todo)
    db.session.commit()
    return jsonify({'task': new_todo.to_json()}), 201


@todo_v1_bp.route('/tasks/<int:id>', methods=['PUT'])
# 需要验证token
@jwt_required()
def update_task(id):
    """
    更新单条任务
    """
    if not request.json:
        abort(400)
    new_todo = Todo.query.get_or_404(id)
    if 'title' in request.json:
        new_todo.title = request.json['title']

    if 'description' in request.json:
        new_todo.description = request.json['description']

    if 'done' in request.json and type(request.json['done']) is not bool:
        new_todo.done = request.json['done']

    Todo.update(new_todo)
    return jsonify({'task': new_todo.to_json()}), 201


@todo_v1_bp.route('/tasks/<int:id>', methods=['DELETE'])
# 需要验证token
@jwt_required()
def delete_task(id):
    """
    删除单条任务
    """
    if not id:
        abort(400)
    post = Todo.query.get_or_404(id)
    Todo.delete(post, id)
    return jsonify({'msg': "删除成功"}), 200
```

### Flask-RESTful

#### 说明

Flask-RESTful 是一个快速实现 restful api 开发的扩展库，使用比较方便。

#### 安装

```sh
pip install flask-restful
```

#### 文档

[官方文档](https://flask-restful.readthedocs.io/en/latest/)

```python
from flask import abort

from flask_restful import Resource, reqparse, fields, marshal, marshal_with
from flask_httpauth import HTTPBasicAuth
from app.models.todo import Todo
from ext import db, jwt
from flask_jwt_extended import jwt_required

# auth = HTTPBasicAuth()

# 格式化输出数据，输出的json格式如下
todo_fields = {
    'id': fields.Integer,
    'title': fields.String,
    'description': fields.String,
    'done': fields.Boolean,
    'uri': fields.Url(absolute=True)
}

todo_list_fields = {
    'count': fields.Integer,
    'todos': fields.List(fields.Nested(todo_fields)),
}


class TaskListAPI(Resource):
    # HTTP 基本身份验
    # decorators = [auth.login_required]

    def __init__(self):
        self.reqparse = reqparse.RequestParser()
        self.reqparse.add_argument('title', type=str, required=True, help='No task title provided', location='json')
        self.reqparse.add_argument('description', type=str, required=True, help='=No mission description',
                                   location='json')
        self.reqparse.add_argument('done', type=int, default=0, location='json')
        super(TaskListAPI, self).__init__()

    # 查看所有任务列表
    # 需要验证token
    @jwt_required()
    def get(self):
        tasks_list = Todo.query.all()
        return marshal({
            'count': len(tasks_list),
            'tasks': [marshal(t, todo_fields) for t in tasks_list]
        }, todo_list_fields)

    # 创建新任务
    # todo_fields的json格式化输出
    @marshal_with(todo_fields)
    # 需要验证token
    @jwt_required()
    def post(self):
        # if not request.json or not 'title' in request.json:
        #     abort(400)
        # param strict: if req includes args not in parser, throw 400 BadRequest exception
        args = self.reqparse.parse_args(strict=True)
        todo = Todo(**args)
        db.session.add(todo)
        db.session.commit()
        return todo


class TaskAPI(Resource):
    # HTTP 基本身份验
    # decorators = [auth.login_required]

    def __init__(self):
        self.reqparse = reqparse.RequestParser()
        self.reqparse.add_argument('title', type=str, location='json')
        self.reqparse.add_argument('description', type=str, location='json')
        self.reqparse.add_argument('done', type=bool, location='json')
        super(TaskAPI, self).__init__()

    # 查看某个任务
    @marshal_with(todo_fields)
    # 需要验证token
    @jwt_required()
    def get(self, id):
        if not id:
            abort(400)
        todo = Todo.query.get_or_404(id)
        return todo

    # 更新某个任务
    @marshal_with(todo_fields)
    # 需要验证token
    @jwt_required()
    def put(self, id):
        if not id:
            abort(400)
        post = Todo.query.get_or_404(id)
        args = self.reqparse.parse_args(strict=True)
        if args["title"]:
            post.title = args["title"]
        if args["description"]:
            post.description = args["description"]
        if args["done"]:
            post.done = args["done"]

        # 第二种实现方式
        # if 'title' in request.json:
        #     post.title = request.json['title']
        #
        # if 'description' in request.json:
        #     post.description = request.json['description']
        #
        # if 'done' in request.json:
        #     post.done = request.json['done']
        db.session.add(post)
        db.session.commit()
        return post, 201

    # 删除某个任务
    @marshal_with(todo_fields)
    # 需要验证token
    @jwt_required()
    def delete(self, id):
        if not id:
            abort(400)
        post = Todo.query.get_or_404(id)
        db.session.delete(post)
        db.session.commit()
        # return post
        return {"code": 204, 'message': "删除成功"}, 204
```

### Flask-RESTPlus

#### 说明

是一个专门用来开发 rest api 的扩展库，基本功能与 Flask-RESTful 无异，但是比其更强大

Flask-restfull 是 flask 框架开发接口的一个框架，Flask-RESTPlus 是 Flask-restfull 升级版，功能做了一些优化，主要是可以生成 swagger 在线文档了。

#### 安装

```sh
pip install flask-restplus
```

#### 文档

[官方文档](https://flask-restplus.readthedocs.io/en/stable/)

参考文档

- https://www.jiege.tech/extensions/flask-restplus.html

#### 不推荐理由

主要原因是 werkzeug 这个模块不兼容，由于 Flask-RESTPlus 的作者很久没更新了，小伙伴们都找不到这个作者了，这个项目也被放弃了.
在 github 上可以看到https://github.com/noirbizarre/flask-restplus

为了让这个项目继续更新下去，现在用 Flask-RESTX 代替了。

Flask-RESTX 官网地址https://flask-restx.readthedocs.io/en/latest/quickstart.html

Flask-RESTX github 地址https://github.com/python-restx/flask-restx

网上看到关于 Flask-RESTPlus 的教程是比较老的版本了，最新的 flask 2.2.2 版本并不支持，所以这个还没入门的小伙伴可以直接放弃，去学 Flask-RESTX。

### Flask-RESTX

#### 说明

Flask-restfull 是 flask 框架开发接口的一个框架，Flask-RESTPlus 是 Flask-restfull 升级版，可以生成 swagger 在线文档了。
但是 Flask-RESTPlus 这个项目不再维护了，迁移到 Flask-RESTX 了。Flask-RESTX 与 Flask-RESTPlus 的 API 保持 100% 兼容。

#### 安装

Flask-RESTX 目前最新版本 0.5.1 （但是不支持最新的 flask 2.2.2 版本）
以下是可以用的匹配版本

```sh
Flask==2.0.1
flask-restx==0.5.1
Werkzeug==2.0.1
```

#### 文档

https://www.cnblogs.com/yoyoketang/p/16653838.html

### 参考示例

flask crud demo

- https://gitee.com/Flask-devops/todo

Flask 小项目

- https://gitee.com/Flask-devops/flask_progress

flask 简单权限系统

- https://github.com/tyler2350/flask-restful-demo

- https://gitee.com/Flask-devops/flask-restful-api-template-v2.0
