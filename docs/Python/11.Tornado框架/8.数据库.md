# 8.数据库

与 Django 框架相比，Tornado 没有自带 ORM，对于数据库需要自己去适配。我们使用 MySQL 数据库。

在 Tornado3.0 版本以前提供 tornado.database 模块用来操作 MySQL 数据库，而从 3.0 版本开始，此模块就被独立出来，作为 torndb 包单独提供。

torndb 只是对 MySQLdb 的简单封装，不支持 Python 3。

所以如果在当前版本中使用 torndb 进行数据库操作，需要修改源代码，所以在此，我们使用 pymysql。

> 项目中如果要使用 ORM，可以使用 SQLAlchemy，但开发中，很少有人这么使用.
> 同时，tornado 强大的地方在于其异步非阻塞，所以我们后面关于数据库操作，不管是 mysql, mongodb 还是 redis 基本都是异步读写操作。

## MySQL

### 安装

```bash
pip install pymysql
```

`mysql.py`代码:

```python
import pymysql

class MySQL(object):
    def __init__(self, host, user, pwd, name):
        self.host = host
        self.user = user
        self.pwd = pwd
        self.name = name
        self.data = None
        self.last_sql = None

    def connect(self):
        self.db = pymysql.Connect(host=self.host, user=self.user, passwd=self.pwd, db=self.name)
        self.cursor = self.db.cursor(cursor = pymysql.cursors.DictCursor)

    def close(self):
        self.cursor.close()
        self.db.close()

    def get_one(self, sql):
        try:
            self.connect()
            self.cursor.execute(sql)
            res = self.cursor.fetchone()
            self.data = res
            self.last_sql = sql
            self.close()
        except Exception as e:
            print("错误:%s" % e)

        # 链式模式
        return self

    def get_all(self, sql):
        try:
            self.connect()
            self.cursor.execute(sql)
            res = self.cursor.fetchall()
            self.last_sql = sql
            self.data = res
            self.close()
        except Exception as e:
            print("错误:%s" % e)
        return self

    def insert(self, sql):
        return self.execute(sql)

    def update(self, sql):
        return self.execute(sql)

    def delete(self, sql):
        return self.execute(sql)

    def execute(self, sql):
        try:
            self.connect()
            self.last_sql = sql
            count = self.cursor.execute(sql)
            self.db.commit()
            self.data = count
            self.close()
        except Exception as e:
            print("错误:%s" % e)
            self.db.rollback()
        return self
```

`server.py`，代码：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright: (c)  : @Time 2025/1/4 20  @Author  : hjl
# @Site    :
# @File    : server.py
# @Project: tornado-project
# @Software: PyCharm
# @Desc    :
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from tornado import ioloop
from tornado import web
from mysql import MySQL
from tornado.web import Union, unicode_type, escape, utf8
# 当tornado启动debug模式以后会自动引入 autoreload模块，在保存编辑代码的时候自动重启项目
from tornado import autoreload

settings = {
    'debug': True,
}
mysql = {
    "host": "127.0.0.1",
    "user": "root",
    "pwd": "123456",
    "db": "student"
}
db = MySQL(mysql["host"], mysql["user"], mysql["pwd"], mysql["db"])


class HttpRequest(web.RequestHandler):
    # 默认情况下,tornado和flask以及django一样的,不能直接把列表数据转换成json结构
    def write(self, chunk: Union[str, bytes, dict, list]) -> None:
        if self._finished:
            raise RuntimeError("Cannot write() after finish()")
        if not isinstance(chunk, (bytes, unicode_type, dict, list)):
            message = "write() only accepts bytes, unicode, and dict objects"
            # if isinstance(chunk, list):
            #     message += (
            #         ". Lists not accepted for security reasons; see "
            #         + "http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.write"  # noqa: E501
            #     )
            raise TypeError(message)
        if isinstance(chunk, (dict, list)):
            chunk = escape.json_encode(chunk)
            self.set_header("Content-Type", "application/json; charset=UTF-8")
        chunk = utf8(chunk)
        self._write_buffer.append(chunk)


class Home(HttpRequest):
    def initialize(self):
        self.db = db

    def get(self):
        """查询一条数据"""
        # data = self.db.get_one("select * from tb_student where id = 10").data
        """查询多条数据"""
        # data = self.db.get_all("select * from tb_student where id > 5").data
        """添加一条数据"""
        # username = "xiaobai"
        # password = "123456"
        # nickname = "小白"
        # age = 16
        # sex = 1
        # email = "xiaobai@xiaobai.com"
        # sql = "INSERT INTO tb_student (username,password,nickname,age,sex,email) VALUES ('%s','%s','%s','%s','%s','%s');" % \
        #       (username,password,nickname, age,sex,email)
        # data = self.db.insert(sql).data
        # print(self.db.last_sql)
        # print(data)

        """添加多条"""
        # student_list = [
        #     {"username":"xiaohui1","password":"123456","nickname":"小辉1","age":16,"sex":1,"email":"xiaohuo1@qq.com"},
        #     {"username":"xiaohui2","password":"123456","nickname":"小辉2","age":16,"sex":1,"email":"xiaohuo2@qq.com"},
        #     {"username":"xiaohui3","password":"123456","nickname":"小辉3","age":16,"sex":1,"email":"xiaohuo3@qq.com"},
        #     {"username":"xiaohui4","password":"123456","nickname":"小辉4","age":16,"sex":1,"email":"xiaohuo4@qq.com"},
        # ]
        # table = "tb_student"
        #
        # fields = ",".join( student_list[0].keys() )
        # sql = "INSERT INTO %s (%s) VALUES " % (table,fields)
        #
        # for student in student_list:
        #     sql += "('%s','%s','%s','%s','%s','%s')," % \
        #            (student["username"],student["password"],student["nickname"],student["age"],student["sex"],student["email"])
        # sql = sql[:-1]
        # data = self.db.insert(sql).data
        # print(data)

        """更新"""
        # nickname = "小辉"
        # sql = "UPDATE tb_student set nickname='%s' WHERE id = 3" % (nickname)
        # data = self.db.update(sql).data
        # print(data)

        """删除"""
        # sql = "DELETE FROM tb_student WHERE id = 11"
        # data = self.db.delete(sql).data
        # print(data)

        self.write("Home.get")


# 设置路由列表
urls = [
    (r"/", Home),
]

if __name__ == "__main__":
    app = web.Application(urls, **settings)
    app.listen(port=8000)
    ioloop.IOLoop.current().start()
```
