# 1.理解与使用单例模式

单例模式一种常见的设计模式，并且也是最基础的设计模式，需要每个开发人员都熟练掌握。

当你希望在整个系统中，某个类只能出现一个实例时，就需要学会使用单例模式。

比较常见的场景是：某个项目的配置信息存放在一个配置文件中，通过一个 Config​ 的类来读取配置文件的信息。

如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 Config​ 对象的实例，这就导致系统中存在多个 Config​ 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 Config​ 这样的类，我们希望在程序运行期间只存在一个实例对象。

在 Python 中，可以用多种方法实现单例模式，常见的有：

- 通过使用模块
- 通过装饰器
- 通过`__new__`方法
- 通过元类

不同的方法，有不同的坑，对 Python 机制认识不够的同学，很容易踩到坑，本文用实例来详细说明一下这几种方法的区别，以及那些不容易被察觉的坑点，给出最佳的选择方案。

下面就详细说明以下这几种实现方法：

## 1. 通过使用模块

在 Python 中，Python 的模块就是天然的单例模式。

看如下示例：

```python
# 例如在config.py文件中定义Config类和实例
class Config:
    LOG_LEVEL = 'INFO'
    ...

config = Config()


# 然后在其他文件中，通过import导入此实例
from config import config

print(config.LOG_LEVEL)
# 输出结果：INFO
```

通过使用模块，可以获得一个单例对象，但是需要注意以下几点：

- 单例对象的初始化操作，可能会被多次执行。
- 单例对象无法实现动态更新。

在 Python 中，模块的加载机制是：当第一次导入某个模块时，Python 解释器会生成 .pyc​ 文件，当第二次导入时，直接加载 .pyc​ 文件，而不会再次执行模块代码。因此，在模块中定义的函数和数据，在第一次导入时，会执行一次，当第二次导入时，不会执行。

如上所示，通过在文件中先生成一个类实例，然后在别的文件中直接导入这个类实例，就实现了单例模式。

## 2. 通过装饰器

另外一种典型的用法是使用类装饰器，由于逻辑比较易懂，被广泛被开发人员使用。

如下是一个例子，在每次对 Config 实例化的时候，都会进入 Singleton 类装饰器，该装饰器维护一个 dict，key 为 cls，value 为 instance，每次实例化都检查该 cls 是否已经在 dict 中存在，若存在则直接将之前实例化的对象返回，如此来保证单例。

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from functools import wraps


def Singleton(cls):
    instance = {}

    @wraps(cls)
    def wrapper(*args, **kwargs):
        if cls not in instance:
            instance[cls] = cls(*args, **kwargs)
        return instance[cls]

    return wrapper


@Singleton
class Config(object):
    pass


cfg1 = Config()
cfg2 = Config()

print(cfg1 == cfg2)
```

运行后，输出结果 True​

**不过，这种方法虽然逻辑非常清晰易懂，但却有一个非常大的问题：经过 Singleton 装饰的后，其返回的是函数，因为无法被继承。**

装饰器由于本身机制的限制，在实例单例的同时也带来了一定的 “副作用”。

仔细一想，用装饰器实现单例的思路，不就是拦截实例对象的创建，来保证类只有唯一的实例嘛！

那我们只要换种方法，来拦截实例对象的创建不就行了。

通常的方法，有两种：

- `__new__` 方法
- 元类

## 3. 通过`__new__`方法

先说一下 new 方法，它是 Python 中的魔法方法之一。

很多人可能对他不是很熟悉，不过完全没有关系，你只要知道，当你在实例化的时候，是先执行类的 new 方法，再执行类的 init 即可。

因此，我们可以在 new 上做一些事情，使得类的实例只能存在一个。

如下是一个示例，在第一次实例的时候，会在 cls 上添加一个属性 \_instance​ 来保存第一个实例，后面再实例化时，就会返回第一次创建的时候，

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
class Config(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
            cls._instance = super().__new__(cls, *args, **kwargs)
        return cls._instance


cfg1 = Config()
cfg2 = Config()

print(cfg1 == cfg2)
```

运行后，输出结果 True​

细心的朋友，想必已经发现，如果有其他类继承了 Config 这个类，那么 \_instance​ 也同样会被子类继承过去，这会导致只要 Config 及其子类只能有一个实例，只要 Config 实例过了，其子类就不能再实例化了，但这显然不是我们所期望的。

有的朋友，可能会想到用双下划线的 \_\_instance​，这样就不会被继承了。

很遗憾的是，双下划线的属性，虽然不会被继承，但却有一个问题，就是属性名会被 Python 修改掉，变成 \_Config\_\_instance​，这样一样，我们在编写 new 时就无法使用 hasattr 来判断。

https://iswbm.com/zh/2024/06/01/understanding-and-using-the-singleton-pattern-in-python/
