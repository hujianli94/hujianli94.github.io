# 2.文本处理

正是由于系统管理员需要经常处理文本，Linux 才有了许多与文本处理相关的工具，如 grep、awk、sed、wc、tr、cut、cat 等。

文本处理是一个如此常见的需求，因此，我们应该掌握一种强大的文本处理工具并将其应用在日常的所有工作当中。

## 1 字符串常量

### 1.1 定义字符串

Python 可以使用单引号或双引号来定义字符串

```shell
In [1]: greet = "Hello, world"

In [2]: greet = 'Hello, world'
```

使用“\”加上一个可以显示的字符来定义。

```shell

In [5]: intro = 'He\'s a teacher'

In [6]: statement = "John said to me: \"Can you do me a favour tonight\""
```

除了使用转义符以外，还可以使用原始字符串（raw string）。

```python
import os

path = r"c:\next"
print(path)
print(os.path.isdir(path))
```

Python 的三引号定义字符串

```shell
In [1]: message = ''' Type "copyright", "credits" or "license" for more information.
   ...: object?   -> Details about 'object', use 'object??' for extra details.'''
In [2]: message = """ Type "copyright", "credits" or "license" for more information.
   ...: object?   -> Details about 'object', use 'object??' for extra details."""
```

### 1.2 字符串是不可变的有序集合

Python 字符串的不可变性.所以操作字符串时需要避免产生太多的中间结果.错误的操作.

用 for 循环和字符串的“+”操作连接字符串

```shell
In [1]: fruits = ['orange', 'apple', 'banana', 'pear']

In [2]: statement = fruits[0]

In [3]: for item in fruits[1:]:
   ...:     statement = statement + ", " + item
   ...:

In [4]: print(statement)
orange, apple, banana, pear
```

正确的操作

```shell
In [5]: ", ".join(fruits)
Out[5]: 'orange, apple, banana, pear'
```

字符串的索引

```shell
In [6]: s = "Hello,world"

In [7]: s[:5]
Out[7]: 'Hello'

In [8]: s[0:5]
Out[8]: 'Hello'

In [9]: s[6:]
Out[9]: 'world'

In [10]: s[::-1]
Out[10]: 'dlrow,olleH'

In [11]: s[0:5:2]
Out[11]: 'Hlo'


#置逆一个字符串
In [12]: s[::-1]
Out[12]: 'dlrow,olleH'

#使用reversed函数
In [13]: ''.join(reversed(s))
Out[13]: 'dlrow,olleH'
```

### 1.3 字符串函数

#### 1.通用操作

```shell
In [1]: s = "Hello,world"

In [2]: len(s)
Out[2]: 11

In [3]: "Hello" in s
Out[3]: True

In [4]: "Hello" not in s
Out[4]: False
```

#### 2.与大小写相关的方法

以下几个函数是与字符大小写相关的字符串处理函数：

| 函数         | 功能                                       |
| ------------ | ------------------------------------------ |
| s.upper      | 将字符串转换为大写                         |
| s.lower      | 将字符串转换为小写                         |
| s.isupper    | 判断字符串是否都为大写                     |
| s.islower    | 判断字符串是否都为小写                     |
| s.swapcase   | 将字符串中的大写转换为小写、小写转换为大写 |
| s.capitalize | 将首字母转换为大写                         |
| s.istitle    | 判断字符串是不是一个标题                   |

由于 Python 设计优秀，并拥有清晰的命名，所以，通过名字就能知道函数的作用。

如果通过名字无法知道函数的具体作用，则可以使用第二章介绍的 IPython 获取函数的帮助信息，如下所示：

```shell
In [1]: s = "hello, world"

In [2]: s.capitalize?
Signature: s.capitalize()
Docstring:
Return a capitalized version of the string.

More specifically, make the first character have upper case and the rest lower
case.
Type:      builtin_function_or_method
```

下面是使用 IPython 对 Python 中的字符串处理函数进行测试的例子：

```shell
In [1]: "lai ming xing".upper()
Out[1]: 'LAI MING XING'

In [2]: "Lai Ming Xing".upper()
Out[2]: 'LAI MING XING'

In [3]: "Lai Ming Xing".lower()
Out[3]: 'lai ming xing'

In [4]: "lai ming xing".isupper()
Out[4]: False

In [5]: "LAI MING XING".isupper()
Out[5]: True

In [6]: "Lai Ming Xing".swapcase()
Out[6]: 'lAI mING xING'

In [7]: "lai ming xing".capitalize()
Out[7]: 'Lai ming xing'

In [8]: "Lai ming xing".istitle()
Out[8]: False

In [9]: "Lai Ming Xing".istitle()
Out[9]: True
```

将字符串转换为大写或者小写是很实用的方法。例如，程序等待用户输入，在用户输入“yes”的时候，执行某项操作，否则就退出程序。
为了对用户更加友好，增强用户的体验感，程序应该在用户输入“yes”，“Yes”，“YES”，“yES”，“YeS”时都判断为真。
这个时候，我们可以将用户的输入全部转换为小写，然后与“yes”进行比较。如下所示：

```python
yes_or_no = input('Plese input yes or no : ')
if yes_or_no.lower() == "yes":
    print("continue do something")
else:
    print("exit...")
```

#### 3.判断类方法

Python 的字符串有很多以“is”开头的方法，如前面介绍的 istitle、isupper 和 islower。

这类方法都是判断类的方法，它们不会产生新的字符串，并且总是返回 True 或者 False。

其他常见的字符串判断类方法有：

| 方法        | 功能                                                                        |
| ----------- | --------------------------------------------------------------------------- |
| s.isalpha   | 如果字符串只包含字母，并且非空，则返回 True，否则返回 False                 |
| s.isalnum   | 如果字符串值包含字母和数字，并且非空，则返回 True，否则返回 False           |
| s.isspace   | 如果字符串值包含空格、制表符、换行符，并且非空，则返回 True，否则返回 False |
| s.isdecimal | 如果字符串只包含数字字符，并且非空，则返回 True，否则返回 False             |

下面是在 IPython 中测试的例子：

```shell
In [1]: "Python".isalpha()
Out[1]: True

In [2]: "Python 3.6".isalpha()
Out[2]: False

In [3]: "Python 3.6".isalnum()
Out[3]: False

In [4]: " \t\n".isspace()
Out[4]: True

In [5]: "Python 3.6".isdecimal()
Out[5]: False

In [6]: "3.6".isdecimal()
Out[6]: False

In [7]: "36".isdecimal()
Out[7]: True
```

#### 4.startswith 和 endswith

| 方法         | 功能                             |
| ------------ | -------------------------------- |
| s.startswith | 判断方法的参数是否为字符串的前缀 |
| s.endswith   | 判断方法的参数是否为字符串的后缀 |

```shell
In [5]: s = "hu jian li"

In [6]: s.startswith('hu')
Out[6]: True

In [7]: s.startswith('hua')
Out[7]: False

In [8]: s.startswith('hu j')
Out[8]: True

In [9]: s.endswith('li')
Out[9]: True
```

找出所有文本文件或 Python 文件，在 Python 中使用内置的字符串方法即可，非常方便。如下所示：

```shell
In [1]: import os

In [2]: [ item for item in os.listdir('.') if item.endswith('.py') ]
Out[2]: ['e.py', 'f.py', 'g.py']

In [3]: [ item for item in os.listdir('.') if item.endswith('.txt') ]
Out[3]: ['a.txt', 'b.txt', 'c.txt', 'd.txt']
```

下面就以 MongoDB 的日志为例演示 Python 中的前缀匹配。一个典型的 MongoDB 日志目录如下所示：

```shell
$ ls
mongod.log  mongod.log.2017-03-01T12-52-22  mongod.log.2017-03-01T12-52-23
mongod.log.2017-03-01T12-52-26  mongod.log.2017-03-01T12-52-27
```

这个时候，如果我们想要知道所有 MongoDB 日志文件占用的磁盘大小，可以使用如下命令：

```python
import os
mongod_logs = [item for item in os.listdir('/var/mongo/log') if item.startswith('mongod.log')]
sum_size = sum(os.path.getsize(os.path.join('/var/mongo/log', item)) for item in mongod_logs)
```

#### 5.查找类函数

| 方法     | 功能                                                 |
| -------- | ---------------------------------------------------- |
| s.find   | 查找子串出现在字符串中的位置，如果查找失败，返回-1   |
| s.index  | 与 find 函数类似，如果查找失败，抛出 ValueError 异常 |
| s.rfind  | 与 find 函数类似，区别在于 rfind 是从后向前查找      |
| s.rindex | 与 index 函数类似，区别在于 rindex 是从后向前查找。  |

```shell
In [1]:  s = "Return the lowest index in S where substring sub is found"

In [2]: s.find("in")
Out[2]: 18

In [3]: s.find("in",19)
Out[3]: 24

In [4]: s.find("not exists")
Out[4]: -1
```

对于判断一个字符串是否是另一个字符串的子串，正确的做法是使用 in 和 not in：

```shell
In [5]: 'in' in s
Out[5]: True

In [6]: 'not exists' in s
Out[6]: False

In [7]: 'not exists' not in s
Out[7]: True
```

find 函数最容易被错用的地方在于使用 find 函数判断一个子串是否出现在字符串中。如下所示：

**错误的用法**

```shell
In [1]: if "hello, world".find("not exists"):
   ...:     print(True)
   ...: else:
   ...:     print(False)
   ...:
True
```

### 1.4 案例：使用 Python 分析 Apache 的访问日志

一条典型的 Apache 默认格式的日志如下：

```shell
193.252.243.232 - - [29/Mar/2009:06:05:34 +0200] "GET /index.php HTTP/1.1" 200 8714 "-" "Mozilla/5.0 (compatible; PJBot/3.0; +http://crawl.pagesjaunes.fr/robot)" "-"
```

Apache 默认格式的日志包含 12 列，分别是：

1）客户端 IP；

2）远程登录名称；

3）认证的远程用户；

4）请求的时间；

5）UTC 时间差；

6）请求的 HTTP 方法；

7）请求的资源；

8）HTTP 协议；

9）HTTP 的状态码；

10）服务端发送的字节数；

11）访问来源；

12）客户浏览器信息（在本例中不具体拆分浏览器信息）。

对于前面这一行 Apache 日志，如果直接使用字符串的 split 函数进行拆分，那么，拆分以后获得的日志列表中，

下标为 0 的元素是用户的 IP，
下标为 6 的元素是用户请求的资源，
下标是 8 的元素是本次请求的 HTTP CODE。

如下所示：

```shell
In [1]: line = '193.252.243.232 - - [29/Mar/2009:06:05:34 +0200] "GET /index.php HTTP/1.1" 200 8714 "-" "Mozilla/5.0 (compatible; PJBot/3.0; +http://crawl.pagesjaunes.fr/robot)" "-"'
   ...:

In [2]: line.split()
Out[2]:
['193.252.243.232',
 '-',
 '-',
 '[29/Mar/2009:06:05:34',
 '+0200]',
 '"GET',
 '/index.php',
 'HTTP/1.1"',
 '200',
 '8714',
 '"-"',
 '"Mozilla/5.0',
 '(compatible;',
 'PJBot/3.0;',
 '+http://crawl.pagesjaunes.fr/robot)"',
 '"-"']

In [3]: line.split()[0]
Out[3]: '193.252.243.232'

In [4]: line.split()[6]
Out[4]: '/index.php'

In [5]: line.split()[7]
Out[5]: 'HTTP/1.1"'

In [6]: line.split()[8]
Out[6]: '200'
```

有了用户 IP 以后，我们可以很方便地获取到网站的 PV 和 UV（PV 是网站的访问请求数，UV 是网站的独立访客数）。
在这个例子中，假设 Apache 的访问日志存放在当前目录下的 access.log 文件中。我们打开日志文件，逐行进行遍历，然后使用字符串的 split 函数拆分每一行日志，拆分日志以后通过下标 0 获取到用户的 IP。如下所示：

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
from __future__ import print_function

ips = []
with open('access.log') as f:
    for line in f:
        ips.append(line.split()[0])

print("PV is {0}".format(len(ips)))
print("UV is {0}".format(len(set(ips))))
```

我们将解析出来的 IP 添加到一个列表之中，那么，列表的长度就是网站的访问数。
当我们要求 UV 时，只需要对刚才的列表进行去重，然后统计去重以后的元素个数，就得到了 UV。

对于这个需求，在 Python 中可以通过将列表保存到一个集合中的方式来实现。

集合天然就拥有去重功能，很适合用来实现这里的需求。

接下来看另外一个需求，找到网站中最热的资源。所谓最热的资源就是这个网站中，被访问的最多的资源。这个信息对于工程师来说非常有用。工程师知道哪些资源是比较热门的资源以后，可以对这些资源的访问进行额外的优化（如缓存、反向代码、CDN 等技术手段）。

要统计网站中最热的资源，显然需要对访问日志中请求的资源进行统计。在 Python 中，可以使用一个字典来保存资源的热度，例如，字典的键是资源的名称，字典的值是访问的次数。除了使用字典来保存资源的热度以外，Python 中还可以使用 collections.Counter 保存资源的热度。

Counter 是 dict 的子类，使用方式与字典类似。对于普通的计数功能，Counter 比字典更加好用。如下所示

```shell
In [1]: from collections import Counter

In [2]: c = Counter('abcba')

In [3]: c
Out[3]: Counter({'a': 2, 'b': 2, 'c': 1})

In [4]: c['a']+=1

In [5]: c['d']+=1

In [6]: c
Out[6]: Counter({'a': 3, 'b': 2, 'c': 1, 'd': 1})

In [7]: c.most_common?
Signature: c.most_common(n=None)
Docstring:
List the n most common elements and their counts from the most
common to the least.  If n is None, then list all element counts.

>>> Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]
File:      ~/anaconda3/lib/python3.9/collections/__init__.py
Type:      method

In [8]: c.most_common(2)
Out[8]: [('a', 3), ('b', 2)]

In [9]:
```

对于 Counter 来说，如果一个键不存在于计数器中，直接对这个键进行运算也不会报错，如上面这段代码中的“c['d']+=1”。
此外，Counter 作为一个计数器，还提供一个名为 most_common 的函数，用来显示 Counter 中取值最大的几个元素。

下面的代码使用 Counter 统计网站中最热门的十项资源：

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
from __future__ import print_function
from collections import Counter

c = Counter()
with open('access.log') as f:
    for line in f:
        c[line.split()[6]] += 1

print("Popular resources : {0}".format(c.most_common(10)))
```

接下来看一个与用户体验相关的问题。

网站的用户体验非常重要，如果用户访问网站经常出错，不但会导致用户口碑变差、降低营收，还会导致用户流失，对公司造成较大的伤害。

长此以往，甚至可能导致公司倒闭。因此，网站的出错比例是很重要的一份数据。要统计用户访问出错的比例，可以通过统计每个请求的 HTTP CODE 得到。

在 HTTP 协议中，如果 HTTP CODE 为 2xx 或 3xx，则视为访问正确，如果 HTTP CODE 为 4xx 或 5xx，则视为访问出错。

因此，统计网站的出错比例，就是统计出错的请求占总请求数的比例。如下所示：

```python
#!/usr/bin/python
#-*-coding: UTF-8 -*-
from __future__ import print_function

d = {}
with open('access.log') as f:
    for line in f:
        key = line.split()[8]
        d.setdefault(key, 0)
        d[key] += 1

sum_requests= 0
error_requests= 0

for key, val in d.iteritems():
    if int(key) >= 400:
        error_requests+= val
    sum_requests+= val

print('error rate: {0:.2f}%'.format(error_requests * 100.0 / sum_requests))
```

我们已经使用 Python 分析了网站的 UV、PV、最热门的资源和出错的比例。
此外，通过 Apache 的访问日志，还可以统计网站每小时的流量并以此找到网站的请求高峰，以及分析浏览器字段统计用户使用的浏览器类型等。

### 1.5 字符串格式化

在 Python 中，存在两种格式化字符串的方法，即%表达式和 format 函数。
%表达式从 Python 诞生之日就开始存在了，是基于 C 语言的 printf 模型，目前还广泛使用。
format 函数是 Python2.6 和 Python3.0 新增加的技术，是 Python 独有的方法，并且和字符串格式化表达式的功能有不少的重叠。

虽然%表达式目前还广泛使用，但是，format 函数才是字符串格式化的未来，%表达式在 Python 未来的版本中可能会被弃用。

#### 1.format 函数

我们通过下面的例子来学习 format 函数的使用方法。

通过{}来表示一个占位符，Python 会自动将 format 函数的参数依次传递给{}占位符。

```shell
In [1]: "{} is better than {}. {} is better than {}.".format('Beautiful', 'ugly', 'Explicit', 'implicit')
Out[1]: 'Beautiful is better than ugly. Explicit is better than implicit.'
```

也可以通过下标的方式来访问 format 函数的参数，如下所示：

```shell
In [2]: "{0} is better than {1}. {2} is better than {3}.".format('Beautiful', 'ugly', 'Explicit', 'implicit')
Out[2]: 'Beautiful is better than ugly. Explicit is better than implicit.'
```

通过下标访问参数以后，一个参数可以出现多次，如下所示：

```shell
In [3]: "Beautiful is {0} than ugly. Explicit is {0} than implicit.".format ('better')
Out[3]: 'Beautiful is better than ugly. Explicit is better than implicit.'
```

在参数较少的情况下，通过占位符或下标的形式访问 format 函数的参数并没有什么问题。如果参数较多就不太适合了，这个时候，可以使用解释性更强的关键字参数形式。如下所示：

```shell
In [4]: d = dict(good1='Beautiful', bad1='ugly', good2='Explicit', bad2='implicit')

In [5]: "{good1} is better than {bad1}. {good2} is better than {bad2}.".format(**d)
Out[5]: 'Beautiful is better than ugly. Explicit is better than implicit.'
```

format 函数也可以直接访问对象的属性，如下所示：

```shell
In [6]: from collections import namedtuple
   ...:

In [7]: Person = namedtuple('Person', 'name age sex')

In [8]: xm =  Person('Xiaoming', 20, 'male')
   ...:

In [9]: "{p.name} {p.age} old this year".format(p=xm)
Out[9]: 'Xiaoming 20 old this year'
```

下面的例子分别是对 format 函数的精度、符号、宽度、对齐方式、字符填充、逗号分隔等格式进行测试：

```shell
In [10]:  "{:.2f}".format(3.1415926)
Out[10]: '3.14'

In [11]: "{:+.2f}".format(3.1415926)
Out[11]: '+3.14'

In [12]: "{:10.2f}".format(3.1415926)
Out[12]: '      3.14'

In [13]: "{:^10.2f}".format(3.1415926)
Out[13]: '   3.14   '

In [14]: "{:_^10.2f}".format(3.1415926)
Out[14]: '___3.14___'

In [15]: "{:,}".format(1234567)
Out[15]: '1,234,567'

In [16]: "{:_^+20,.2f}".format(1234.5678)
Out[16]: '_____+1,234.57______'
```

#### 2.插值格式字符串

Python 3.6 添加了一种新的特性，叫作插值格式字符串（interpolated formatstring，简称 f-string），可以解决上面提到的所有问题。新语法特性要求在格式字符串的前面加字母 f 作为前缀，这跟字母 b 与字母 r 的用法类似，也就是分别表示字节形式的字符串与原始的（或者说未经转义的）字符串的前缀。

```python
key = "my_var"
value = 1.234

formatted = f'{key} = {value}'
print(formatted)
```

```python
pantry = [
    ("avocados", 1.25),
    ("bananas", 2.5),
    ("cherries", 15)
]


#  %的方式格式化
for i, (item, count) in enumerate(pantry):
    print("#%d: %-10s = %d" % (
        i + 1,
        item.title(),
        round(count)))
print("*" * 100)

# format函数格式化
for i, (item, count) in enumerate(pantry):
    print("#{}: {:<10s} ={}".format(
        i + 1,
        item.title(),
        round(count)))
print("*" * 100)

# 插值格式字符串
for i, (item, count) in enumerate(pantry):
    print(f"#{i + 1}: {item.title():<10s} ={round(count)}")

#或者写多行
for i, (item, count) in enumerate(pantry):
    print(f"#{i + 1}: "
          f"{item.title():<10s} ="
          f"{round(count)}")
```

在%方法中%s 只能替代字符串类型，而在 format 中不需要理会数据类型；

```shell
# 1、按照默认顺序，不指定位置
print("{} {}".format("hello","world"))
>>> hello world

# 2、设置指定位置，可以多次使用
print("{0} {1} {0}".format("hello","or"))
>>> hello or hello

# 3、使用列表格式化
person = {"name":"opcai","age":20}
print("My name is {name} . I am {age} years old .".format(**person))
>>> My name is opcai . I am 20 years old .

# 4、通过列表格式化
stu = ["opcai","linux","MySQL","Python"]
print("My name is {0[0]} , I love {0[1]} !".format(stu))
>>> My name is opcai , I love linux !
```

#### 3.textwrap

1. 自动换行：使用 textwrap.wrap() 函数可以将长文本按照指定的宽度自动进行换行。

```python
import textwrap

sample_string = '''Python is an interpreted high-level programming language for
general-purpose programming. Created by Guido van Rossum and first released in 			1991, Python has a design philosophy that emphasizes code readability,
notably using significant whitespace.'''

w = textwrap.wrap(text=sample_string, width=30)
print(w)
```

2. 填充文本：使用 textwrap.fill() 函数可以将文本按照指定的宽度进行换行，并自动填充每行的缩进。

```python
import textwrap

sample_string = '''Python is an interpreted high-level programming language.'''
w = textwrap.fill(text=sample_string, width=50)

print(w)
```

3. 缩进文本：使用 textwrap.indent() 函数可以给文本添加指定的缩进。

```python
import textwrap

text = "This is a long piece of text that needs to be wrapped."
indented_text = textwrap.indent(text, prefix="    ")

print(indented_text)
```

4. 去除缩进：使用 textwrap.dedent()函数可以去除文本中的缩进。

```python
import textwrap

text = """
    This is a long piece of text
    that has unnecessary indentation.
"""

dedented_text = textwrap.dedent(text)

print(dedented_text)
```

## 2 正则表达式

需要同时使用“：”和“.”进行 split，这对于 Python 内置的字符串函数来说，就显得比较棘手了。这个时候，可以使用更具有表达能力的正则表达式：

```shell
In [1]: data = "Last login: Thu Mar  2 10:04:52 2017 from 114.113.197.131"

In [2]: import re; re.split('[:.]\s*', data)
Out[2]: ['Last login', 'Thu Mar  2 10', '04', '52 2017 from 114', '113', '197', '131']
```

正则表达式是个处理文本的强大工具，在文本处理程序中广泛使用，如 Office world、OpenOffice、Vim 和 Emacs。

正则表达式在 Linux 命令行中使用更加广泛，大部分文本处理工具都支持正则表达式，如 grep，awk，sed 等。正因为正则表达式强大的表达能力，不仅软件工程师使用正则表达式，部分电脑爱好者也开始学习正则表达式，希望通过正则表达式节约文本处理的时间。

### 2.1 正则表达式的基本语法

| 正则表达式模式 | 描述                                             | 示例                                                        |
| -------------- | ------------------------------------------------ | ----------------------------------------------------------- |
| \d             | 匹配任意一个数字字符                             | `\d` 可以匹配到字符串中的数字字符，如 "123"                 |
| \w             | 匹配任意一个字母数字字符                         | `\w` 可以匹配到字符串中的字母和数字字符，如 "a1b2c3"        |
| \s             | 匹配任意一个空白字符                             | `\s` 可以匹配到字符串中的空格、制表符等空白字符             |
| ^              | 匹配输入字符串的开始位置                         | `^abc` 可以匹配以 "abc" 开始的字符串                        |
| $              | 匹配输入字符串的结束位置                         | `xyz$` 可以匹配以 "xyz" 结束的字符串                        |
| [...]          | 字符集，匹配方括号内的任意一个字符               | `[abc]` 可以匹配字符串中的 "a"、"b" 或 "c"                  |
| [^...]         | 否定字符集，匹配除方括号内字符之外的任意一个字符 | `[^abc]` 可以匹配除了 "a"、"b" 和 "c" 以外的字符            |
| \*             | 匹配前面的元素零次或多次                         | `ab*c` 可以匹配 "ac"、"abc"、"abbc" 等                      |
| +              | 匹配前面的元素一次或多次                         | `ab+c` 可以匹配 "abc"、"abbc"、"abbbc" 等                   |
| ?              | 匹配前面的元素零次或一次                         | `ab?c` 可以匹配 "ac" 或 "abc"                               |
| {n}            | 匹配前面的元素恰好 n 次                          | `a{3}` 可以匹配 "aaa"                                       |
| {n,}           | 匹配前面的元素至少 n 次                          | `a{2,}` 可以匹配 "aa"、"aaa"、"aaaa" 等                     |
| {n,m}          | 匹配前面的元素至少 n 次、最多 m 次               | `a{2,4}` 可以匹配 "aa"、"aaa" 或 "aaaa"                     |
| (…)            | 分组，捕获匹配的文本                             | `(ab)+` 可以匹配 "ab"、"abab"、"ababab" 等                  |
| \|             | 逻辑或，匹配两侧任意一个表达式                   | `a\|b` 可以匹配 "a" 或 "b"                                  |
| `\.`           | 转义字符，匹配点号字符                           | `\.` 可以匹配字符串中的 "."                                 |
| `\d{4}`        | 预定义匹配字符集，匹配四位数字                   | `\d{4}` 可以匹配字符串中的四位数字                          |
| `.*`           | 重复匹配，匹配任意字符零次或多次                 | `.*` 可以匹配任意长度的字符串                               |
| `(?i)abc`      | 忽略大小写匹配，匹配 "abc" 不区分大小写          | `(?i)abc` 可以匹配 "abc"、"AbC"、"ABC" 等                   |
| `(?m)^abc$`    | 多行模式匹配，匹配以 "abc" 开头和结尾的字符串    | `(?m)^abc$` 可以匹配 "abc" 以及多行文本中的每一行都是 "abc" |
| `.*?`          | 非贪婪模式匹配，匹配尽量少的字符                 | `.*?` 可以匹配任意长度的字符串，但尽量匹配最少的字符        |

常用的特殊字符。

| 特殊字符 |                   描述                    |
| :------: | :---------------------------------------: |
|    /d    |     匹配任何十进制数字，与【0-9】一致     |
|    /D    |               匹配任意数字                |
|    /w    | 匹配任何字母数字下划线以及 unicode 字符集 |
|    /W    |       匹配任何非字母数字以及下划线        |
|    /s    |  匹配任何空格字符，与【\n\t\r\v\f】相同   |
|    /S    |               匹配任意字符                |
|    \A    |             匹配字符串的起始              |
|    \Z    |             匹配字符串的结束              |
|    .     |              匹配任何字符串               |

代码演示：

```python
import re

# 准备需要被匹配的字符串
data = 'hello jie you are 22 age old'

# 匹配任何十进制数字，与【0-9】一致
print(re.findall('\d', data))
# 匹配任何空格字符
print(re.findall('\s', data))
# 匹配任何字母数字下划线以及unicode字符集
print(re.findall('\w', data))
# 匹配字符串的起始
print(re.findall('\Ahello', data))
```

量词符号。

|   符号    |                                      描述                                       |
| :-------: | :-----------------------------------------------------------------------------: |
| re1\|re2  |                           匹配正则表达式 re1 或者 re2                           |
|     ^     |                               匹配字符串起始部分                                |
|     $     |                               匹配字符串终止部分                                |
|    \*     |                      匹配 0 次或者多次前面出现的正则表达式                      |
|     +     |                      匹配一次或者多次前面出现的正则表达式                       |
|    {N}    |                          匹配 N 次前面出现的正则表达式                          |
|   {M,N}   |                              给出匹配到的数据范围                               |
|   [...]   |                          匹配来自字符集的任意单一字符                           |
| [..x-y..] |                          匹配 x~y 范围中的任意单一字符                          |
|  [^...]   | 不匹配此字符集中出现的任何一个字符， 包括某一范围的字符（如果在此字符集中出现） |
|    \      |                                将特殊字符无效化                                 |

代码演示

```python
 import re

# 准备需要被匹配的字符串
data = 'hello jie you are 22 age old'

# 匹配正则表达式 re1 或者  re2 注意 ： 匹配的数据只按字符串数据返回，而不是按照匹配规则返回
print(re.findall('hello|jie|21', data))
# 匹配字符串起始部分
print(re.findall('^hello', data))
# 匹配字符串终止部分
print(re.findall('old$', data))
# W* 匹配0次或多次数字或字母
print(re.findall('\w*', data))
# W+ 匹配一次或者多次数字或字母 空属于0次范围不会配匹配出来
print(re.findall('\w+', data))
# 对于匹配到的数据只获取3个
print(re.findall('\w{3}', data))
# 匹配a~z范围中的任意单一字符 [a-zA-Z0-9]等同于\w
print(re.findall('[a-z]{3}', data))
# 匹配1或者5次 {N,M}中间的逗号左右不要出现空格
print(re.findall('\w{1,5}', data))
# 不匹配此字符集中出现的任何一个字符 字符集中的^号不代表开始的意思而是过滤掉
print(re.findall('[^jie]', data))
```

组

| 符号 |            描述            |
| :--: | :------------------------: |
| （） | 在匹配规则中获取指定的数据 |

代码演示：

```shell
In [1]: import re

In [2]: data = 'hello jie you are 22 age old'

In [3]: result = re.search('hello (.*)jie (.*)', data)

In [4]: print(result.groups())
('', 'you are 22 age old')

In [5]: print("1:" + result.group(1))
1:

In [6]: print("2:" + result.group(2))
2:you are 22 age old
```

### 2.2 利用 re 库处理正则表达式

| 方法                                         | 描述                                      | 返回值                            |
| -------------------------------------------- | ----------------------------------------- | --------------------------------- |
| `compile(pattern[, flags])`                  | 根据包含正则表达式的字符串创建模式对象    | re 对象                           |
| `search(pattern, string[, flags])`           | 在字符串中查找                            | 第一个匹配到的对象或者 None       |
| `match(pattern, string[, flags])`            | 在字符串的开始处匹配模式                  | 在字符串开头匹配到的对象或者 None |
| `split(pattern, string[, maxsplit=0,flags])` | 根据模式的匹配项来分割字符串              | 分割后的字符串列表                |
| `findall(pattern, string,flags)`             | 列出字符串中模式的所有匹配项              | 所有匹配到的字符串列表            |
| `sub(pat,repl, string[,count=0,flags])`      | 将字符串中所有的 pat 的匹配项用 repl 替换 | 完成替换后的新字符串              |
| `finditer(pattern, string,flags)`            | 将所有匹配到的项生成一个迭代器            | 所有匹配到的字符串组合成的迭代器  |
| `subn(pat,repl, string[,count=0,flags])`     | 在替换字符串后，同时报告替换的次数        | 完成替换后的新字符串及替换次数    |
| `escape(string)`                             | 将字符串中所有特殊正则表达式字符串转义    | 转义后的字符串                    |
| `purge(pattern)`                             | 清空正则表达式                            |                                   |
| `template(pattern[,flags])`                  | 编译一个匹配模板                          | 模式对象                          |
| `fullmatch(pattern, string[, flags])`        | match 方法的全字符串匹配版本              | 类似 match 的返回值               |

re 的额外匹配要求

re 模块的额外匹配要求,其实这些匹配要求都是一些属性，一般情况下使用率不高，了解即可。

|          属性          |                                            描述                                            |
| :--------------------: | :----------------------------------------------------------------------------------------: |
| `re.I 、re.IGNORECASE` |                                     不区分大小写的匹配                                     |
|   `re.L、re.LOCALE`    |                    根据所使用的本地语言环境通过\w、\W、\s、\S 实现匹配                     |
|  `re.M、re.MULTILINE`  |     ^和$分别匹配目标字符串中行的起始和结尾，而不是严格匹配整个字符串本身的起始和结尾。     |
|   `re.S、rer.DOTALL`   | "."(点号)通常匹配除了\n（换行符）之外的所有单个字符；该标记表示"."（点号）能够匹配全部字符 |
|   `re.X、re.VERBOSE`   |                                忽略规则表达式中的空白和注释                                |

例如，最常用的是 re 模块下的 findall 函数，用来输出所有符合模式匹配的子串，如下所示：

```shell
In [1]: import re

In [2]: data = "What is the difference between python 2.7.13 and Python 3.6.0 ?"

In [3]: re.findall('python [0-9]\.[0-9]\.[0-9]', data)
Out[3]: ['python 2.7.1']
```

re 模块在模式匹配的时候忽略字符的大小写，可以通过传递标志的形式告诉 re 模块忽略大小写这个需求，如下所示：

```shell
In [4]: re.findall('python [0-9]\.[0-9]\.[0-9]', data, flags=re.IGNORECASE)
Out[4]: ['python 2.7.1', 'Python 3.6.0']
```

Python 中有两种使用正则表达式的方式。

1. 第一种是直接使用 re 模块中的函数，正如前面的例子中演示的一样。
2. 第二种是创建一个特定模式编译的正则表达式对象，然后使用这个对象中的方法。

编译的正则表达式使用方法如下：

```shell
In [1]: import re

In [2]: data = "What is the difference between python 2.7.13 and Python 3.6.0 ?"

In [3]: re_obj = re.compile('python [0-9]\.[0-9]\.[0-9]', flags=re.IGNORECASE)

In [4]: re_obj.findall(data)
Out[4]: ['python 2.7.1', 'Python 3.6.0']
```

两种方式进行比较

例如，我们使用 Linux 下的 seq 命令产生 1000 万个整数保存到文件中。
该数据文件大约有 76M，并不算很大，但是足以用来比较编译版本的正则表达式和非编译版本的正则表达式之间的性能。
接下来，对文件的每一行应用模式“`[0-9]+`”，并使用 Linux 下的 time 工具统计程序的运行时间。

```shell
hujianli@hujianli-OptiPlex-7010:~$ seq 1 10000000 > data.txt
hujianli@hujianli-OptiPlex-7010:~$ du -sh data.txt
76M	data.txt
```

非编译的正则表达式版本源码如下：

```python
# $ cat re_nocompile.py
#!/usr/bin/python
#-*- coding: UTF-8 -*-
import re

def main():
    pattern = "[0-9]+"
    with open('data.txt') as f:
        for line in f:
            re.findall(pattern, line)

if __name__ == '__main__':
    main()
```

编译的正则表达式版本源码如下：

```python
# $ cat re_compile.py
#!/usr/bin/python
#-*- coding: UTF-8 -*-
import re

def main():
    pattern = "[0-9]+"
    re_obj = re.compile(pattern)
    with open('data.txt') as f:
        for line in f:
            re_obj.findall(line)

if __name__ == '__main__':
    main()
```

```shell
hujianli@hujianli-OptiPlex-7010:~$ time python re_nocompile.py

real	0m10.055s
user	0m9.968s
sys	0m0.040s
hujianli@hujianli-OptiPlex-7010:~$ time python re_compile.py

real	0m4.182s
user	0m4.160s
sys	0m0.021s
```

在数据量大的情况下，建议使用编译版本的正则表达式。

!!! info "强烈推荐工具！"

    [正则表达式生成代码网站](https://regex101.com/)

### 2.3 常用的 re 方法

#### 1."匹配"类的函数

##### findall 函数

该函数在字符串中查找模式匹配，将所有的匹配字符串以列表的形式返回

```shell
In [1]: import re

In [2]: data = "What is the difference between python 2.7.13 and Python 3.6.0 ?"

In [3]: re.findall('[0-9]\.[0-9]\.[0-9]', data)
Out[3]: ['2.7.1', '3.6.0']

In [4]: re.findall('Pytho [0-9]\.[0-9]\.[0-9]', data)
Out[4]: []

In [5]: re.findall('Python [0-9]\.[0-9]\.[0-9]', data)
Out[5]: ['Python 3.6.0']

In [6]: re.findall('[0-9]\.[0-9]\.[0-9]', data)
Out[6]: ['2.7.1', '3.6.0']
```

```python
import re

pattern = 'Red'
colors = 'Red, Blue, Black, Red, Green'
p = re.findall(pattern, colors)
print(p)

str_line = 'Peter Piper picked a peck of pickled peppers. How many pickled peppers did Peter Piper pick?'
pt = re.findall('pe\w+', str_line)
pt1 = re.findall('pic\w+', str_line)
print(pt)
print(pt1)

line = 'Hello hello HELLO bye'
p = re.findall('he\w+', line, re.IGNORECASE)
print(p)
```

##### match 函数

该函数用以匹配字符串的开始部分，如果模式匹配成功，返回一个 SRE_Match 类型的对象，如果模式匹配失败，返回一个 None。

```shell
In [7]: data.startswith('What')
Out[7]: True

In [8]: data.startswith('Not What')
Out[8]: False

In [9]: re.match('What', data)
Out[9]: <_sre.SRE_Match object; span=(0, 4), match='What'>

In [10]: if re.match('What', data):
    ...:     print(True)
    ...: else:
    ...:     print(False)
    ...:
True

In [11]: if re.match('Not What', data):
    ...:     print(True)
    ...: else:
    ...:     print(False)
    ...:
False
```

虽然简单使用时 match 函数和 startswith 函数比较类似，但是，对于复杂的情况，match 函数能够轻易解决，starswith 则无能为力。

例如，我们需要判断一个文本字符串是否以一个数字开头。由于我们不知道具体是哪个数字，只知道要求是数字，因此，无法使用 startswith 函数。

这个时候，可以使用 re 模块的 match 函数轻松解决，如下所示：

```shell
In [12]: re.match('\d+', "123 is one hundred and twenty-three")
Out[12]: <_sre.SRE_Match object; span=(0, 3), match='123'>
```

match 匹配成功时返回 SRE_Match 类型的对象。该对象包含了相关的模式和原始字符串，模式匹配成功的子串起始位置和结束位置，也可以通过该对象获取匹配的字符串。

```shell
In [13]: r = re.match('\d+', "123 is one hundred and twenty-three")

In [14]: r.start()
Out[14]: 0

In [15]: r.end()
Out[15]: 3

In [16]: r.re
Out[16]: re.compile(r'\d+', re.UNICODE)

In [17]: r.string
Out[17]: '123 is one hundred and twenty-three'

In [18]: r.group()
Out[18]: '123'
```

```python
import re

str_line = "This is python tutorial. Do you enjoy learning python ?"

obj = re.match(r'(.*) enjoy (.*?) .*', str_line)

if obj:
	print(obj.groups())
```

##### search 函数

该函数模式匹配成功时，也会返回一个 SRE_Match 对象。

search 函数与 match 函数用法几乎一样，区别在于前者在字符串的任意位置进行匹配，后者仅对字符串的开始部分进行匹配。
它们的共同点是，如果匹配成功，返回 SRE_Match 对象，如果匹配失败，返回一个 None。

```python
import re

pattern = ['programming', 'hello']
str_line = 'Python programming is fun'

for p in pattern:
	print("Searching for %s in %s" % (p, str_line))

	if re.search(p, str_line):
		print("Match found")
	else:
		print("No match found")
```

##### finditer 函数

该函数返回一个迭代器，遍历迭代器可以得到一个 SRE_Match 对象，如下所示：

```shell
In [19]: data = "What is the difference between python 2.7.13 and Python 3.6.0 ?"

In [20]: r = re.finditer('[0-9]\.[0-9]\.[0-9]', data)

In [21]: for it in r:
    ...:     print(it.group(0))
    ...:
2.7.1
3.6.0
```

#### 2."修改类"函数

##### sub 函数

该函数类似于字符串的 replace 函数，只是 sub 函数支持使用正则表达式。

所以，re 模块中的 sub 函数使用场景更加广泛，使用方式也更加灵活。

例如，下面的正则表达式模式，可以同时匹配"2.7.13"和"3.6.0"，并将它们都替换为"x.x.x"。

这个需求看似简单，如果使用 Python 字符串的 replace 函数，需要进行两次替换。

使用正则表达式的 sub 函数，只需要一次替换即可完成。如下所示：

```shell
In [22]: re.sub('[0-9]+\.[0-9]+\.[0-9]+', 'x.x.x', data)
Out[22]: 'What is the difference between python x.x.x and Python x.x.x ?'
```

也可以结合 sub 函数和正则表达式的功能实现更加复杂的替换。例如，将下面的日期进行格式化，如下所示：

```shell
In [23]: text = 'Today is 3/2/2017. PyCon starts 5/25/2017.'

In [24]: re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text)
Out[25]: 'Today is 2017-3-2. PyCon starts 2017-5-25.'
```

```python
import re

str_line = 'Peter Piper picked a peck of pickled peppers. How many pickled peppers did Peter Piper pick?'
print("Original: ", str_line)

p = re.sub('Peter', 'Mary', str_line)
print("Replaced: ", p)

p = re.sub('Peter', 'Mary', str_line, count=1)
print("Replacing only one occurrence of Peter... ")
print("Replaced: ", p)
```

##### subn 函数

在 Python 的 re 模块中，sub()和 subn()函数都是用来替换字符串中的匹配项。它们的区别在于返回值和行为。

sub()函数返回替换后的新字符串，而 subn()函数返回一个元组，其中第一个元素是替换后的新字符串，第二个元素是替换次数。

例如：

```python
import re
s = "hello world"
new_s = re.sub(r"world", "python", s)
print(new_s)  # 输出：hello python
```

subn()函数的语法与 sub()函数类似，只是返回值是一个元组，其中第一个元素是替换后的新字符串，第二个元素是替换次数。例如：

```python
import re
s = "hello world"
new_s, n = re.subn(r"o", "a", s)
print(new_s)  # 输出：hella warld
print(n)  # 输出：2
```

##### split 函数

split 函数与 Python 字符串的 split 函数功能一样，都是将一个字符串拆分成子串的列表。

区别在于 re 模块的 split 函数能够使用正则表达式。例如，对于下面这一段包含冒号，逗号，单引号和若干空格的文本，我们希望拆分出每一个单词。

面对这个需求，Python 内置的 split 函数无法进行处理，因此，可以直接使用 re 模块的 split 函数。re 模块的 split 函数能够指定多个分隔符，如下所示：

```shell
In [26]: text = "MySQL slave binlog position: master host '10.173.33.35', filename 'mysql-bin.000002', position '524993060'"

In [27]: re.split(r"[':,\s]+", text.strip("'"))
Out[27]:
['MySQL',
 'slave',
 'binlog',
 'position',
 'master',
 'host',
 '10.173.33.35',
 'filename',
 'mysql-bin.000002',
 'position',
 '524993060']
```

#### 3.大小写不敏感

我们使用 Python 的 re 模块，并不一定总是为了使用正则表达式进行复杂的匹配。
有时候一些很小的需求，使用 re 模块也会比较方便。例如，我们在字符串查找或替换的时候需要忽略字符的大小写。如下所示：

```shell
In [28]: text = 'UPPER PYTHON, lower python, Mixed Python'
In [29]: re.findall('python', text, flags=re.IGNORECASE)
Out[29]: ['PYTHON', 'python', 'Python']
In [30]: re.sub('python', 'snake', text, flags=re.IGNORECASE)
Out[30]: 'UPPER snake, lower snake, Mixed snake'
```

#### 4.非贪婪匹配

在正则表达式的字符串匹配中，有贪婪匹配和非贪婪匹配的区别。贪婪匹配总是匹配到最长的那个字符串，相应的，非贪婪匹配是指匹配到最小的那个字符串。

例如，在下面这个例子中，我们要匹配以“Beautiful”开头并且以点号结尾的字符串。

显然，存在两个符合条件的匹配，分别是“Beautiful is better than ugly.Explicit is better than implicit.”和“Beautiful is better than ugly.”。
默认情况下，正则表达式使用贪婪匹配，如果要使用非贪婪匹配，只需要在匹配字符串时加上一个“？”。

```shell
In [31]: text = "Beautiful is better than ugly. Explicit is better than implicit."

In [32]: re.findall('Beautiful.*\.', text)
Out[33]: ['Beautiful is better than ugly. Explicit is better than implicit.']

In [34]: re.findall('Beautiful.*?\.', text)
Out[35]: ['Beautiful is better than ugly.']
```

```python
import re

# 准备需要被匹配的字符串
data = 'hello jie you are 22 age old'
# ? 可将贪婪模式转为非贪婪模式 就是匹配多次转为匹配一次
re_obj = re.compile('hello (.*?) you')

result = re_obj.findall(data)

print(result)
```

### 2.4 案例：获取 HTML 页面中的所有超链接

在这个例子中，我们使用开源的 requests 库获取 Hack News 的内容，然后使用正则表达式解析出所有的 http 或 https 链接。如下所示：

```shell
In [1]: import re

In [2]: import requests

In [3]: r = requests.get('https://news.ycombinator.com/')

In [4]: re.findall('"(https?://.*?)"', r.content)
Out[4]:
['http://www.ycombinator.com',

 'https://pages.nist.gov/800-63-3/',
 'http://chaosinmotion.com/blog/?p=1184',
  ......
 'https://iohk.io/blog/proof-refinement-basics/',
 'https://www.youtube.com/watch?v=xkdPjbaLngE',
 'https://github.com/HackerNews/API',
 'http://www.ycombinator.com/apply/']
```

**requests 补充：**

requests 是用来发送 HTTP 请求的库，也是 Python 生态中最知名的开源项目之一，在 Python 爬虫中广泛使用。

requests 的功能与标准库的 urllib2 类似，只是前者的接口设计对工程师更加友好。实现相同的功能，使用 requests 比使用 urllib2 能够节省更多的时间。由于 requests 是一个开源的项目，而不是标准库，所以，使用之前必须先进行安装。

[官方网站](https://requests.readthedocs.io/en/latest/)

如下所示：

```shell
pip install requests
python -m "import requests"
```

## 3 字符集编码

### ASCII

ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，其最多只能用 8 位来表示（一个字节），即：2\*\*8 = 256，所以，ASCII 码最多只能表示 256 个符号。

显然 ASCII 码无法将世界上的各种文字和符号全部表示，所以，就需要新出一种可以代表所有字符和符号的编码，即：Unicode

### Unicod

Unicod（统一码、万国码、单一码）是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，规定虽有的字符和符号最少由 16 位来表示（2 个字节），即：2 \*\*16 = 65536，

    注：此处说的的是最少2个字节，可能更多

### UTF-8

UTF-8，是对 Unicode 编码的压缩和优化，他不再使用最少使用 2 个字节，而是将所有的字符和符号进行分类：

ascii 码中的内容用 1 个字节保存、欧洲的字符用 2 个字节保存，东亚的字符用 3 个字节保存。

    Python2.x版本，默认支持的字符编码为ASCll

    Python3.x版本，默认支持的是Unicode，不用声明字符编码可以直接显示中文

简单来说：

```
#encode("utf-8")          # 编码为utf-8，解码必须一致
#decode("utf-8")          # 解码utf-8

Unicode 最纯，
utf-8 ————> Unicode -----> gbk
gbk -------> Unicode -----utf-8
```

代码演示：

```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
wd = "胡建力学python"
wd_encode = wd.encode()
print(wd_encode)
wd_decode = wd_encode.decode()
print(wd_decode)

wd_encode_gb2312 = wd.encode("gb2312")
print(wd_encode_gb2312)
wd_decode_gb2312 = wd_encode_gb2312.decode("gb2312")
print(wd_decode_gb2312)

wd_encode_utf8 = wd.encode("utf-8")
print(wd_encode_utf8)
wd_decode_utf8 = wd_encode_utf8.decode("utf-8")
print(wd_decode_utf8)
```

在 Python3 中，内置的 open 函数可以指定字符集编码：

```shell
>>> name = '赖明星'
>>> name
'赖明星'
>>> with open('/tmp/data.txt', 'w', encoding='utf-8') as f:
... f.write(name)
3
```

Python3 的字符集处理辅助函数：

```python
#!/usr/bin/env python
# -*- coding:utf8 -*-
# auther: 18793
# Date：2021/10/20 11:23
# filename: to_str_hu.py


def to_str(bytes_or_str):
    if isinstance(bytes_or_str, bytes):
        value = bytes_or_str.decode("utf-8")
    else:
        value = bytes_or_str
    return value


def to_bytes(bytes_or_str):
    if isinstance(bytes_or_str, str):
        value = bytes_or_str.encode("utf-8")
    else:
        value = bytes_or_str
    return value


print(repr(to_str(b"hujianli1")))
print(repr(to_str("hujianli1")))


print(repr(to_bytes(b"hujianli2")))
print(repr(to_bytes("hujianli2")))
```

“字符串”和“字节串”的转换，字节串在字符串声明时前面新增 b

```python
def upper_s(s):
    """把输入字符串里的所有 "s" 都转为大写"""
    return s.replace('s', 'S')


bin_obj = b'super sunflowers.'
print(bin_obj)
str_obj = bin_obj.decode('utf-8')
print(upper_s(str_obj))
```

## 4 Jinja2 模板

### 4.1 模板介绍

模板在 Python 的 web 开发中广泛使用，它能够有效地将业务逻辑和页面逻辑分离，使得工程师编写出可读性更好、更加容易理解和维护的代码。

试想一下，要为一个大型的表格构建 HTML 代码，表格中的数据由数据库中读取的数据以及必要的 HTML 字符串连接在一起。

这个时候，最简单也最直接的方式就是在 Python 代码中使用字符串拼接的方式生成 HTML 代码。如果真的这么做了，对工程师来说将是个噩梦，而且代码无法维护。

Python 的标准库自带了一个简单的模板，下面的代码便是一个模板使用的例子。

```shell
In [1]: from string import Template

In [2]: s = Template('$who is a $role')

In [3]: s.substitute(who='bob', role='teacher')
Out[3]: 'bob is a teacher'

In [4]: s.substitute(who='lily', role='student')
Out[4]: 'lily is a student'
```

Python 自带的模板功能非常有限，例如无法在模板中使用控制语句和表达式，不支持继承和重用等操作。

这对于 web 开发来说远远不够，因此，出现了第三方的模板系统。目前市面上有非常多的模板系统，其中最知名的是 Jinja2 和 Mako。

### 4.2 Jinja2 语法入门

补充资料：Flask 是一个使用 Python 编写的轻量级 Web 应用框架，本来只是作者的一个愚人节玩笑，不过发布以后大受欢迎，进而成为一个正式的项目。

Flask 是 Python 生态中最流行的 Web 框架之一，本身的代码也写得非常优雅，所以有不少 Python 工程师学习 Flask 的源码。

Jinja2 模板引擎之所以使用广泛，是因为它具有以下优点：

- 相对于 Template，Jinja2 更加灵活，它提供了控制结构、表达式和继承等，工程师可以在模板中做更多的事情；

- 相对于 Mako，Jinja2 提供了仅有的控制结构，不允许在模板中编写太多的业务逻辑，避免了工程师乱用行为；

- 相对于 Django 模板，Jinja2 的性能更好；

- Jinja2 模板的可读性很好。

Jinja2 是 Flask 的一个依赖，如果已经安装了 Flask，Jinja2 也会随之安装。当然，也可以单独安装 Jinja2：

```shell
pip install jinja2
python -c "import jinja2"
```

接下来将详细介绍 Jinja2 的语法。

#### 1.语法块

在 Jinja2 中，存在三种语法：

- 控制结构{%%}

- 变量取值{{}}

- 注释{##}

下面是使用 Jinja 控制结构和注释的一个例子：

```html
{# note: disabled template because we no longer use this {% for user in users %}
... {% endfor%} #}
```

可以看到，for 循环的使用与 Python 比较类似，但是，没有了复合语句末尾的冒号。
此外需要使用 endfor 作为结束标志。

Jinja2 中的 if 语句也一样，没有复合语句末尾的冒号，需要使用 endif 作为结束标志。如下所示：

```html
{% if users %}
<ul>
  {% for user in users %}
  <li>{{ user.username }}</li>
  {% endfor%}
</ul>
{% endif %}
```

#### 2.变量

Jinja2 模板中使用的{{}}语法表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值在渲染模板时获取。

Jinja2 识别所有的 Python 数据类型，甚至是一些复杂的类型，如列表、字典和对象等，如下所示：

```html
<p>A value from a dictionary: {{ mydict['key'] }}.</p>
<p>A value from a list: {{ mylist[3] }}.</p>
<p>A value from a list, with a variable index: {{ mylist[myintvar] }}.</p>
<p>A value from an object's method: {{ myobj.somemethod() }}.</p>
```

#### 3.Jinja2 中的过滤器

变量可以通过“过滤器”进行修改，过滤器可以理解为是 Jinja2 里面的内置函数和字符串处理函数。例如，存在一个名为 lower 的过滤器，它的作用与字符串对象的 lower 方法一模一样。

在 Jinja2 中，变量可以通过“过滤器”修改，过滤器与变量用管道（|）分割。多个过滤器可以链式调用，前一个过滤器的输出会作为后一个过滤器的输入。如下所示：

```html
{{ "Hello World" | replace("Hello", "Goodbye") }} -> Goodbye World {{ "Hello
World" | replace("Hello", "Goodbye") | upper }} -> GOODBYE WORLD { 42.55 | round
}} -> 43.0 {{ 42.55 | round | int }} -> 43
```

Jinja2 变量过滤器

| 过滤器名称 | 说明                                       |
| ---------- | ------------------------------------------ |
| safe       | 渲染值时不转义                             |
| capitalize | 把值的首字母转换成大写，其他字母转换成小写 |
| lower      | 把值转换成小写形式                         |
| upper      | 把值转换成大写形式                         |
| title      | 把值中每个单词的首字母都转换成大写         |
| trim       | 把值的首尾空格删掉                         |
| striptags  | 渲染之前把值中所有的 HTML 标签都删掉       |

#### 4.Jinja2 的控制结构

Jinja2 中的 if 语句类似于 Python 中的 if 语句，但是，需要使用 endif 语句作为条件判断的结束。我们可以使用 if 语句判断一个变量是否定义，是否为空，是否为真值。与 Python 中的 if 语句一样，也可以使用 elif 和 else 构建多个分支，如下所示：

```html
{% if kenny.sick %} Kenny is sick. {% elif kenny.dead %} You killed Kenny! You
bastard!!! {% else %} Kenny looks okay ---so far {% endif %}
```

#### 5.Jinja2 的 for 循环

Jinja2 中的 for 语句可用于迭代 Python 的数据类型，包括列表、元组和字典。
在 Jinja 中不存在 while 循环，这也符合了 Jinja2 的“提供仅有的控制结构，不允许在模板中编写太多的业务逻辑，避免了工程师乱用行为”设计原则。

在 Jinja2 中迭代列表：

```html
<h1>Members</h1>
<ul>
  {% for user in users %}
  <li>{{ user.username }}</li>
  {% endfor%}
</ul>
```

在 Jinja2 中也可以遍历字典：

```html
<dl>
  {% for key, value in d.iteritems() %}
  <dt>{{ key }}</dt>
  <dd>{{ value }}</dd>
  {% endfor%}
</dl>
```

除了基本的 for 循环使用以外，Jinja2 还提供了一些特殊的变量，我们不用定义就可以直接使用这些变量。

假设你有一个保存了联系人信息的字典，字典的 key 是联系人的名字，字典的 value 是联系人的电话。你现在想把联系人的信息以表格的形式显示在 HTML 页面上。此时，除了姓名和电话以外，你还希望表格的第一列是序号。这个需求如果在 Python 代码中实现，将会像下面这样

```python
data = dict(bob=13000000001, lily=130000000002, robin=130000000003)
index = 0
for key, value in data.viewitems():
    index += 1
    print(index, key, value, sep=",")
```

Jinja2 为了让工程师尽可能在模板中少写 Python 代码处理业务逻辑，仅在模板中处理显示工作问题，提供了一些特殊变量。对于前面的这个例子，在 Jinja2 中的正确做法如下所示：

```html
{% for key, value in data.iteritems() %}
<tr class="info">
  <td>{{ loop.index}}</td>
  <td>{{ key }}</td>
  <td>{{ value }}</td>
</tr>
{% endfor%}
```

#### 6.Jinja2 的宏

宏类似于编程语言中的函数，它用于将行为抽象成可重复调用的代码块。与函数一样，宏分为定义和调用，下面是一个声明宏的例子：

```html
{% macro input(name, type='text', value='') %}
<input type="{{ type }}" name="{{ name }}" value="{{ value }}" />
{% endmacro %}
```

在宏的定义中，使用 macro 关键字定义一个宏，input 是宏的名称。
它有三个参数，分别是 name，type 和 value，其中 type 和 value 参数有默认值。

可以看到宏的定义与 Python 的函数定义非常相似，此外，它与 Jinja2 中的 for 循环和 if 语句一样，不需要使用复合语句的冒号，使用 endmacro 结束宏的定义。

下面是宏的调用，与函数调用类似：

```html
<p>{{ input('username', value='user') }}</p>
<p>{{ input('password', 'password') }}</p>
<p>{{ input('submit', 'submit', 'Submit') }}</p>
```

#### 7.Jinja2 的继承和 Super 函数

如果只是使用 Jinja2 进行配置文件管理，将基本用不到 Jinja2 继承功能。如果是使用 Jinja2 进行 web 开发，那么，继承是 Jinja2 最吸引人的功能。

Jinja2 中最强大的部分就是模板继承。模板继承允许你构建一个包含站点共同元素的基本模板“骨架”，并定义子模板可以覆盖的块。

假设我们有一个名为 base.html 的 HTML 文档，里面的内容如下：

```html
<html lang="en">
  <head>
    {% block head %}
    <link rel="stylesheet" href="style.css" />
    <title>{% block title %}{% endblock %}-My Webpage</title>
    {% endblock %}
  </head>
  <body>
    <div id="content">{% block content %}{% endblock %}</div>
  </body>
</html>
```

在 base.html 中，我们使用{%block name%}的方式定义了三个块，这些块可以在子模板中进行替换或调用。

下面是一个名为 index.html 的 HTML 文档，文档的内容如下：

```html
{% extends "base.html" %} {% block title %}Index{% endblock%} {% block head %}
{{ super() }}
<style type="text/css">
  .important {
    color: #336699;
  }
</style>
{% endblock%} {% block content %}
<h1>Index</h1>
<p class="important">Welcome on my awesome homepage.</p>
{% endblock%}
```

在 index.html 中，我们使用`{%extends"base.html"%}`继承 base.html，继承以后，base.html 中的所有内容都会在 index.html 中展现。

在 index.html 中，我们重新定义了 title 和 content 这两个块的内容。

#### 8.Jinja2 的其他运算

Jinja2 中可以定义变量，为了对变量进行操作，Jinja2 提供了算数操作、比较操作和逻辑操作。使用 Jinja2 模板时，应该尽可能在 Python 代码中进行逻辑处理，在 Jinja2 中仅处理显示问题。

因此，一般很少用到 Jinja2 的变量和变量的运算操作。

部分 Jinja2 中的运算操作：

- 算数运算`+-*///%***`

- 比较操作`==！=>>=<<=`

- 逻辑运算`not and or`

### 4.3 Jinja2 实战

下面来看两个例子以巩固前面的知识。
如果读者在 Flask 中使用 Jinja2，则几乎不需要关心 Jinja2 的使用。

因为 Jinja2 的开发者和 Flask 的开发者是同一个人，为了便于工程师在 Flask 中使用 Jinja2，作者在 Flask 中很好地集成了 Jinja2。

集成以后，想要在 Flask 中使用 Jinja2，只需使用 Flask 包下的`render_template`函数访问模板即可。

#### 1.基本功能演示

创建一个最简单的 flask-demo 程序

安装虚拟环境

```shell
$ sudo apt-get install python3-venv
$ mkdir flask-sample1/
$ cd flask-sample1/
$ mkdir static
$ mkdir templates

#目录结构如下
+ flask-sample1
    - static
    - templates

#创建虚拟环境
# 使用Python 3自带的 venv 创建虚拟环境
$ python3 -m venv venv
$ source venv/bin/activate
(venv) $ pip install flask
(venv) $ pip freeze
(venv) $ python -c "import flask"
```

vim app.py

app.py 代码如下：

```python
from flask import Flask

app = Flask(__name__)


@app.route('/')
def hello_world():
    return 'Hello World!'


if __name__ == '__main__':
    app.run(port=9011, host="0.0.0.0")  # 如果不是本地访问需要加IP
```

```shell
flask run --host=0.0.0.0 --port=9011
```

flask-sample1/templates/simple.html 如下

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- 使用过滤器处理表达式的结果 -->
    <title>{{ title | trim }}</title>
  </head>
  <body>
    <!-- 注释 -->
    {# This is a Comment #}
    <ul id="navigation">
      <!-- for语句，以endfor结束 -->
      {% for item in items %}
      <!-- 访问变量的属性 -->
      <li><a href="{{ item.href }}">{{ item['caption'] }}</a></li>
      {% endfor %}
    </ul>
    <p>{{ content }}</p>
  </body>
</html>
```

在这个 HTML 模板中，我们使用 for 循环遍历一个列表，列表中的每一项是一个字典。
字典中包含了文字和连接，我们将使用字典中的数据渲染成 HTML 的超链接。此外，我们还会使用 Jinja2 提供的过滤器 trim 删除 title 中的空格。

修改 app.py 文件

```python
from flask import Flask, render_template

app = Flask(__name__)


@app.route('/')
def hello_world():
    title = "Title  H   "
    items = [{'href': 'a.com', 'caption': 'ACaption'}, {'href': 'b.com', 'caption': 'Bcaption'}]
    content = "This is content"
    return render_template('simple.html', **locals())


if __name__ == '__main__':
    app.run()
```

执行上面的代码，渲染模板的结果如下：

```shell
$ curl http://127.0.0.1:5000/
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- 使用过滤器处理表达式的结果 -->
    <title>Title H</title>
  </head>
  <body>
    <!-- 注释 -->

    <ul id="navigation">
      <!-- for语句，以endfor结束 -->

      <!-- 访问变量的属性 -->
      <li><a href="a.com">ACaption</a></li>

      <!-- 访问变量的属性 -->
      <li><a href="b.com">Bcaption</a></li>
    </ul>
    <p>This is content</p>
  </body>
</html>
```

可以看到，使用 Jinja2 渲染模板以后 title 中的空格已经被删除，for 循环也正确渲染了多个超链接标签。

#### 2.继承功能演示

为了演示继承的功能，我们需要使用两个 HTML 文件，分别是 base.html 和 index.html。

base.html 的内容如下：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- 定义代码块，可以在子模块中重载 -->
    {% block head %}
    <link rel="stylesheet" href="style.css" />
    <title>{% block title %}{% endblock %} - My Webpage</title>
    {% endblock %}
  </head>
  <body>
    <div id="content">
      <!-- 定义代码块，没有提供默认内容 -->
      {% block content %} {% endblock %}
    </div>
    <div id="footer">
      <!-- 定义代码块，没有提供默认内容 -->
      {% block footer %} {% endblock %}
    </div>
  </body>
</html>
```

index.html 的内容如下：

```html
<!-- 写在开头，用以继承 -->
{% extends "base.html" %}

<!-- 标题模块被重载 -->
{% block title %}Index{% endblock %}

<!-- head模块被重载，并且，使用super继承了base.html中head的内容 -->
{% block head %} {{ super() }}
<style type="text/css">
  .important {
    color: #336699;
  }
</style>
{% endblock %}

<!-- 覆盖了content模块 -->
{% block content %}
<h1>This is h1 content</h1>
<p class="important">Welcome on my awesome homepage.</p>
{% endblock %}
```

我们使用下面的 Python 代码渲染 Jinja2 模板：

```python
from flask import Flask, render_template

app = Flask(__name__)


@app.route('/')
def hello_world():
    return render_template('index.html')


if __name__ == '__main__':
    app.run()
```

渲染以后生成的结果如下：

```html
<!-- 写在开头，用以继承 -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- 定义代码块，可以在子模块中重载 -->

    <link rel="stylesheet" href="style.css" />
    <title>Index - My Webpage</title>

    <style type="text/css">
      .important {
        color: #336699;
      }
    </style>
  </head>
  <body>
    <div id="content">
      <!-- 定义代码块，没有提供默认内容 -->

      <h1>This is h1 content</h1>
      <p class="important">Welcome on my awesome homepage.</p>
    </div>
    <div id="footer">
      <!-- 定义代码块，没有提供默认内容 -->
    </div>
  </body>
</html>
```

从这个例子中可以看到：

1）我们渲染的是 index.html，并没有直接渲染 base.html，但是最后生成的模板中包含了完整的 HTML 框架，这也是继承广泛的使用场景；

2）我们虽然在 index.html 中定义了 title 块，但是，因为我们使用{{super（）}}引用了 base.html 中的 HEAD 块，因此，最后渲染的结果中包含了 base.html 中的 head 块和 index.html 中的 head 块。
例如，最后渲染的结果中 title 标签的内容是“Index-My Webpage”，这个字符串就来自 index.html 和 base.html；

3）我们在 index.html 中重新定义了 content 块的内容，因此，最后生成的文档中在正确位置显示了 content 块的内容。

### 4.4 案例：使用 Jinja2 生成 HTML 表格

#### 1.使用 Jinja2 生成 HTML 表格

如果不使用模板，只能在 Python 代码中拼接 HTML 代码，如下所示：

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
from __future__ import print_function
from __future__ import unicode_literals

links = [{'title': u'杭州地铁三期规划正式获批 3号线即将上马',
          'href': 'http://zzhz.zjol.com.cn/system/2016/12/21/021404496.shtml'},
         {'title': u'涉及房地产的四个关键点',
          'href': 'http://zzhz.zjol.com.cn/system/2016/12/19/021402558.shtml'},
         {'title': u'潮鸣项目定名“凤起潮鸣”，绿城说的“杭州生活样本”将如何呈现',
          'href': 'http://zzhz.zjol.com.cn/system/2016/12/19/021402558.shtml'}]

content = """
<html>
    <body>
        <table>
"""

for index, link in enumerate(links, 1):
    item = "<tr><td>{0}</td><td><a href = '{1}'>{2}</a></td></tr>\n".format(
        index, link['href'], link['title'])
    content += item

content += """
        </table>
    </body>
</html>
"""
print(content)

```

可以看到，上面的代码将业务逻辑和表现逻辑混合在一起，显得比较混乱。这个时候，我们完全可以使用 Jinja2 模板解决这个问题。

使用 Jinja2 以后，我们需要一个模板。在这个例子中，模板的名称为 hzfc.html，内容如下：

```html
<html>
  <body>
    <table>
      {% for item in items %}
      <tr>
        <td>{{ loop.index }}</td>
        <td><a href="{{ item['href'] }}">{{ item['title'] }}</a></td>
      </tr>
      {% endfor %}
    </table>
  </body>
</html>
```

使用模板以后，我们只需要在 Python 代码中调用渲染函数即可，在本例中，我们将使用 4.4.3 节中的辅助函数 render。渲染模板的 Python 代码如下所示：

```python
# -*- coding: UTF-8 -*-

import jinja2

links = [
    {'title': u'杭州地铁三期规划正式获批 3号线即将上马', 'href': 'http://zzhz.zjol.com.cn/system/2016/12/21/021404496.shtml'},
    {'title': u'涉及房地产的四个关键点', 'href': 'http://zzhz.zjol.com.cn/system/2016 /12/19/021402558.shtml'},
    {'title': u'潮鸣项目定名“凤起潮鸣”，绿城说的“杭州生活样本”将如何呈现', 'href': 'http://zzhz.zjol.com.cn/system/2016/12/19/021402558.shtml'}
]

env = jinja2.Environment(loader=jinja2.FileSystemLoader('.'))
template = env.get_template('hzfc.html')
content = template.render(items=links)

print(content)
```

可以看到，当我们将业务逻辑与表现逻辑分离以后，代码自然就变得清晰易懂、易于维护了。
