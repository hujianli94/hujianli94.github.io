# 5.文档与报告


## 1.使用csv读写CSV文件

### 1.1 写入CSV数据

- 写入元祖序列的数据

```python
#!/usr/bin/env python
# -*- coding:utf8 -*-

import csv

headers = ['ID', 'UserName', 'Password', 'Age', 'Country']
rows = [(1001, "qiye", "qiye_pass", 24, "China"),
        (1002, "Mary", "Mary_pass", 20, "USA"),
        (1003, "Jack", "Jack_pass", 20, "USA"),
        ]

with open('qiye.csv', 'w', newline="") as f:
    f_csv = csv.writer(f)
    f_csv.writerow(headers)
    f_csv.writerows(rows)
```



- 写入字典序列的数据

```python
import csv

headers = ['ID', 'UserName', 'Password', 'Age', 'Country']
rows = [{'ID': 1001, 'UserName': "qiye", 'Password': "qiye_pass", 'Age': 24, 'Country': " China"},
        {'ID': 1002, 'UserName': "Mary", 'Password': "Mary_pass", 'Age': 20, 'Country': "USA"},
        {'ID': 1003, 'UserName': "Jack", 'Password': "Jack_pass", 'Age': 20, 'Country': "USA"},
        ]

with open('qiye2.csv', 'w') as f:
    f_csv = csv.DictWriter(f, headers)
    f_csv.writeheader()
    f_csv.writerows(rows)
```


- 写入普通数据

```python
import csv

with open("sr.csv", "w") as f:
    w = csv.writer(f, delimiter=",")
    w.writerow(["one", "two", "three"])
    w.writerow(["four", "five", "six"])
```






### 1.2 读取CSV数据


```python
#!/usr/bin/env python
# -*- coding:utf8 -*-
# auther; 18793
# Date：2020/5/6 13:11
# filename: sample03.py

import csv

with open('qiye.csv') as f:
    f_csv = csv.reader(f)
    headers = next(f_csv)
    print(headers)
    for row in f_csv:
        print(row)
```


- 以列表形式输出

```python
import csv
csvfile = open('csv_test.csv', 'r')
# 
reader = csv.reader(csvfile)
for row in reader:
    if '小P' in row:
        print(row)
```


- 以字典形式输出

```python
# 以字典形式输出，第一行作为字典的键
reader = csv.DictReader(csvfile)
for row in reader:
    if row['姓名']== '小P':
        print(row)
```



### 1.3 读写CSV文件

```python


import csv

with open('pingan.csv', 'r') as rf:
    reader = csv.reader(rf)
    with open('pingan2.csv', 'w') as wf:
        writer = csv.writer(wf)
        headers = next(reader)
        writer.writerow(headers)
        for row in reader:
            if row[0] < '2016-01-01':
                break
            if int(row[5]) >= int(50000000):
                writer.writerow(row)
```


读取-写入-读取

```python
# writer()函数
# 先读取csv文件，再将读取的数据处理后写入新的csv中
import csv

headers = ['编号', '书名', '作者', '出版社', '出版时间', '级别']
rows = [
    "10,软件工程1,胡建力,机械工业出版社,199407226517,2",
    "11,汇编语言1,胡建力2,北京工业大学出版社,199407126517,2",
    "12,计算机语言1,胡建力3,经济科学出版社,199417126517,1",
    "13,FLASH精选1,胡建力4,中国纺织出版社,199417126511,3",
    "14,JAVA基础1,胡建力5,电子工业出版社,199117126511,3",
    "15,JAVA程序设计1,胡建力6,世界出版社,199117126512,2",
    "16,新东方英语1,胡建力7,外语出版社,192117126512,1"
]

with open("test.csv", "r", encoding="utf-8") as rf:
    reader = csv.reader(rf)
    print("开始读取test.csv文件内容......................")
    with open("test_bak.csv", "w", newline="", encoding="utf-8") as wf:
        writer = csv.writer(wf, delimiter=",")
        header = ["|".join(headers)]
        print("开始写入标题header 到test_bak.csv文件......................")
        writer.writerow(header)
        print("开始写入文件旧数据 到test_bak.csv文件......................")
        for row in reader:
            # print(row)
            writer.writerow(row)
        rows_list = [str(row).split(",") for row in rows]
        print("开始写入新的数据 到test_bak.csv文件......................")
        for row_new in rows_list:
            writer.writerow(row_new)
    print("读写完毕，查看写入后的内容................")

with open("test_bak.csv", "r", encoding="utf-8") as rf:
    reader = csv.reader(rf)
    for info in reader:
        print("|".join(info))
```



python3写入csv文件中文乱码的解决

```python

# 加入encoding='utf-8-sig'就不会乱码了
with open("haha.csv",'w',newline='',encoding='utf-8-sig') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(["飞机转场记录号", "登机口"])

```


csv操作函数

```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
import csv

# 将数据写入csv文件
def write_csv_file(path, head, data):
    '''
    :param path: CSV文件的路径和文件名
    :param head: 生成的CSV文件的文件头
    :param data: data为需要写入CSV文件的数据，也需要传入一个列表
    :return:
    '''
    try:
        with open(path, "w", newline='') as csv_file:
            writer = csv.writer(csv_file, dialect='excel')
            if head is not None:
                writer.writerow(head)
            for row in data:
                writer.writerow(row)
            print("Write a CSV file to path %s Successful." % path)

    except Exception as e:
        print("Write an CSV file to path: %s, Case: %s" % (path, e))
```



[Python3读写CSV文件](https://www.cnblogs.com/superhin/p/python-csv.html)



## 2.使用Python处理Excel文档


Python操作的Excel包有`xlrd、xlwt、pyExcelerator和openpyxl`。

其中，pyExcelerator只支持2003版本，openpyxl只支持2007版本，xlrd支持Excel任何版本的读取，xlwt支持Excel任何版本的写入。


Python自带的模块中有针对xls格式的xlrd和xlwt模块，但这两个库仅仅是针对xls的操作，要操作xlsx格式文件时，则需要使用到openpyxl第三方库。

|模块|来源|读|写|支持格式|
|----|-----|----|----|------|
|xlrd|标准库|√|×|xls|
|xlwt|标准库|×|√|xls|
|openpyxl|三方库|√|√|xlsx|



**整体思路**


虽然这几个库已经把Excel的文件、表、行、列的概念完全转换为Python中的对象，但每次操作都需要遍历每一个单元格，
甚至很多时候要花费大量的时间在思考循环单元格的边界上，这本身就是在重复造轮子，因此花了半天时间整理了以下六个函数。



### 2.1 使用xlrd和xlwt读写Excel

为了版本的兼容性，大多数开发人员选择使用xlrd和xlwt操作Excel。xlrd和xlwt的安装如下：

```shell
pip install xlrd
pip install xlwt
```


完成安装后，在Python交互式命令行查看xlrd和xlwt模块的版本信息：

```shell
>>> import xlwt
>>> import xlrd
>>> xlrd.__VERSION__
'2.0.1'
>>> xlwt.__VERSION__
'1.3.0'
```

Excel的写入相对比CVS复杂，但Excel可以实现设置数据格式、合并单元格、设置公式和插入图片等功能。使用xlwt实现上述功能的代码如下：

#### 2.1.1 使用xlwt写入文件数据

数据样本

`car.txt`

```
车辆概况       车龄    全款价    原价
三菱1          2      50001   60001
三菱2          2      50002   60002
三菱3          2      50003   60003
```

```python
import xlwt

# 标题列表
columns = []
# 数据列表
datas = []

with open('car.txt', encoding='utf-8') as f:
    # 首行判断
    is_first_line = True
    for line in f:
        line = line[:-1]
        if is_first_line:
            is_first_line = False
            columns = line.split('\t')
            continue
        datas.append(line.split('\t'))


# print(columns)
#
# for data in datas:
#     print(data)


def Using_xlwt():
    """
    使用xlwt生成xls的excel文件
    :return:
    """
    workbook = xlwt.Workbook(encoding='utf-8')
    sheet = workbook.add_sheet('瓜子二手车')

    for col, column in enumerate(columns):
        sheet.write(0, col, column)

    for row, data in enumerate(datas):
        for col, column_data in enumerate(data):
            sheet.write(row + 1, col, column_data)
    workbook.save('瓜子二手车1.xls')


if __name__ == '__main__':
    Using_xlwt()
```


或者如下方式

```python
def write_xls_excel(url,sheet_name,two_dimensional_data):
  """
    写入xls格式文件
    参数：
        url:文件路径
        sheet_name:表名
        two_dimensional_data：将要写入表格的数据（二维列表）
    """
    # 创建工作簿对象
    workbook = xlwt.Workbook()
    # 创建工作表对象
    sheet = workbook.add_sheet(sheet_name)
    # 遍历每一行数据
    for i in range(0,len(two_dimensional_data)):
        # 遍历每一列数据
        for j in range(0,len(two_dimensional_data[i])):
            # 写入数据
            sheet.write(i,j,two_dimensional_data[i][j])
    # 保存
    workbook.save(url)
    print("写入成功")
```




使用xlwt模块把数据写入Excel文件的整体思路如下：

1. xlwt创建生成临时Excel对象。
2. 添加WorkSheets对象。
3. 单元格的位置由行列索引决定，索引从0开始。
4. 数据写入主要由write_merge()和write()实现，两者分别是合并单元格再写入和单元格写入。
5. 设置数据格式是在写入（write_merge()和write()）的数据中传入参数style。

除此之外，xlwt还可以设置单元格背景颜色、添加单元格边框、设置单元格高宽度、设置字体颜色和数据类型等，由于篇幅较大，本书就不详细讲解了。



#### 2.1.2 xls文件追加写入数据

```python
def write_xls_excel_add(url, two_dimensional_data, index):
    """
    追加写入xls格式文件
    参数：
        url:文件路径
        two_dimensional_data：将要写入表格的数据（二维列表）
        index：指定要追加的表的序号（第几个工作表，传入参数从1开始数）
    """
    # 打开指定的工作簿
    workbook = xlrd.open_workbook(url)
    # 获取工作簿中的所有表格
    sheets = workbook.sheet_names()
    # 获取指定的表
    worksheet = workbook.sheet_by_name(sheets[index-1])
    # 获取表格中已存在的数据的行数
    rows_old = worksheet.nrows
    # 将xlrd对象拷贝转化为xlwt对象
    new_workbook = copy(workbook)
    # 获取转化后工作簿中的第index个表格
    new_worksheet = new_workbook.get_sheet(index-1)
    # 遍历每一行数据
    for i in range(0, len(two_dimensional_data)):
        # 遍历每一列数据
        for j in range(0, len(two_dimensional_data[i])):
            # 追加写入数据，注意是从i+rows_old行开始写入
            new_worksheet.write(i+rows_old, j, two_dimensional_data[i][j])
    # 保存工作簿
    new_workbook.save(url)
    print("追加写入成功")
```


#### 2.1.3 使用xlrd读取文件数据


```python
def Using_xlrd():
    """
    使用xlrd读取xls的excel文件
    :return:
    """
    df = xlrd.open_workbook('./瓜子二手车1.xls')
    table = df.sheet_by_name('瓜子二手车')
    for i in range(table.nrows):
        print(table.row_values(i))
```


或者如下方式

```python

def read_xls_excel(url,index):
    """
    读取xls格式文件
    参数：
        url:文件路径
        index：工作表序号（第几个工作表，传入参数从1开始数）
    返回：
        data:表格中的数据
    """
    # 打开指定的工作簿
    workbook = xlrd.open_workbook(url)
    # 获取工作簿中的所有表格
    sheets = workbook.sheet_names()
    # 获取工作簿中所有表格中的的第 index 个表格
    worksheet = workbook.sheet_by_name(sheets[index-1])
    # 定义列表存储表格数据
    data = []
    # 遍历每一行数据
    for i in range(0, worksheet.nrows):
        # 定义表格存储每一行数据
        da = []
        # 遍历每一列数据
        for j in range(0, worksheet.ncols):
            # 将行数据存储到da列表
            da.append(worksheet.cell_value(i, j))
        # 存储每一行数据
        data.append(da)
    # 返回数据
    return data
```


读取Excel文件的数据思路大致如下：

1. xlrd生成Workbook对象，并指向Excel文件。
2. 选择Workbook里面某个WorkSheets对象。
3. 获取WorkSheets里面的数据已占用的总行数和总列数(某个单元格的数据)。
4. 循环总行数和总列数，读取每一个单元格的数据。





### 2.2 使用openpyxl读写Excel

#### 2.2.1 读取Excel文件

```python
import openpyxl


def read_xlsx_excel(url, sheet_name):
    """
    读取xlsx格式文件
    参数：
        url:文件路径
        sheet_name:表名
    返回：
        data:表格中的数据
    """
    # 使用openpyxl加载指定路径的Excel文件并得到对应的workbook对象
    workbook = openpyxl.load_workbook(url)
    # 根据指定表名获取表格并得到对应的sheet对象
    sheet = workbook[sheet_name]
    # 定义列表存储表格数据
    data = []
    # 遍历表格的每一行
    for row in sheet.rows:
        # 定义表格存储每一行数据
        da = []
        # 从每一行中遍历每一个单元格
        for cell in row:
            # 将行数据存储到da列表
            da.append(cell.value)
        # 存储每一行数据
        data.append(da)
    # 返回数据
    return data


if __name__ == '__main__':
    fn = '瓜子二手车2.xlsx'
    sheet_name = "默认title"
    for i in read_xlsx_excel(fn, sheet_name):
        print(i)
```




#### 2.2.2 写入Excel文件


```python
import openpyxl

def write_xlsx_excel(url, sheet_name, two_dimensional_data, header=None):
    """
    写入xlsx格式文件
    参数：
        url:文件路径
        sheet_name:表名
        two_dimensional_data：将要写入表格的数据（二维列表）
        header:表头数据（可选）
    """
    # 创建工作簿对象
    workbook = openpyxl.Workbook()
    # 创建工作表对象
    sheet = workbook.active
    # 设置该工作表的名字
    sheet.title = sheet_name

    # 写入表头
    if header:
        for j in range(0, len(header)):
            sheet.cell(row=1, column=j + 1, value=str(header[j]))

    # 遍历表格的每一行
    for i in range(len(two_dimensional_data)):
        # 遍历表格的每一列
        for j in range(len(two_dimensional_data[i])):
            # 写入数据（注意openpyxl的行和列是从1开始的）
            sheet.cell(row=i + 2, column=j + 1, value=str(two_dimensional_data[i][j]))
    
    # 保存到指定位置
    workbook.save(url)
    print("写入成功")
```

调用方式如下：

```python
data = [
    ["姓名", "年龄", "性别"],
    ["张三", 20, "男"],
    ["李四", 25, "女"],
    ["王五", 30, "男"]
]

write_xlsx_excel("example.xlsx", "Sheet1", data, header=["Name", "Age", "Gender"])
```




#### 2.2.3 xlsx文件追加写入数据

```python
def write_xlsx_excel_add(url, sheet_name, two_dimensional_data):
    """
    追加写入xlsx格式文件
    参数：
        url:文件路径
        sheet_name:表名
        two_dimensional_data：将要写入表格的数据（二维列表）
    """
    # 使用openpyxl加载指定路径的Excel文件并得到对应的workbook对象
    workbook = openpyxl.load_workbook(url)
    # 根据指定表名获取表格并得到对应的sheet对象
    sheet = workbook[sheet_name]
    for tdd in two_dimensional_data:
        sheet.append(tdd)
    # 保存到指定位置
    workbook.save(url)
    print("追加写入成功")
```



### 2.3 案例-合并多个Excel到一个Excel中

```python
#!/usr/bin/python
import os
import glob

import openpyxl


def merge_xlsx_files(xlsx_files):
    wb = openpyxl.load_workbook(xlsx_files[0])
    ws = wb.active
    ws.title = "merged result"

    for filename in xlsx_files[1:]:
        workbook = openpyxl.load_workbook(filename)
        sheet = workbook.active
        for row in sheet.iter_rows(min_row=2):
            values = [cell.value for cell in row]
            ws.append(values)

    return wb


def get_all_xlsx_files(path):
    xlsx_files = glob.glob(os.path.join(path, '*.xlsx'))
    sorted(xlsx_files, key=str.lower)
    return xlsx_files


def main():
    xlsx_files = get_all_xlsx_files(os.path.expanduser('./'))
    wb = merge_xlsx_files(xlsx_files)
    wb.save('merged_form.xlsx')


if __name__ == '__main__':
    main()
```


在这个例子中，我们首先通过glob获取了指定目录下所有的Excel文档。然后，我们将这些文档按照文件名称进行了排序。
排序以后，在`merge_xlsx_files`函数中尝试合并多个Excel文档。我们合并Excel的思路也很简单：

1. 获取第一个文档中的表格(我们的Excel文档中只有一个表格)
2. 依次遍历其他文件中的报名表，并通过`iter_rows函数`忽略报名表中的首行内容；
3. 通过列表推导获取报名表中的数据，然后调用Worksheet的`append函数`将数据添加到汇总表的末尾。
4. 上述操作完成以后，返回Workbook对象。在main函数中，我们调用Workbook的save方法将汇总表保存到merged form.xlsx文件中。


我们只花费几分钟时间编写了不到30行的Python代码，就实现了将多个Excel文档合并成单个文件的功能。

因为是Python程序进行处理，所以无论有多少张表需要合并都能够快速处理，并且不会出错，也不会抱怨处理的表格太多。







!!!info "扩展阅读"



        [Python读写操作Excel数据](https://www.yuque.com/fcant/python/av5mti#NALtM)

        [Python 操作 Excel库对比](https://www.yuque.com/fcant/python/dgofgp#kE9F7)
        
        [Python 操作 Excel库对比总结整理](https://www.yuque.com/fcant/python/fpmbgy#4UX38)
        
        [用Python自动化操作Excel制作报表](https://www.yuque.com/fcant/python/kwuqai#KeCxK)
        
        [Python实现数据写入 Excel 的三种模块](https://www.yuque.com/fcant/python/ckep3q#EwRGy)




## 3.使用python-docx读写Word文件

如果将数据存储在Word文件中，一般以文章、新闻报道和小说这类文字内容较长的数据为主。Python读写Word文件需要第三方库扩展支持，使用pip安装：


```shell
pip install python-docx
```

模块安装后，验证模块是否安装成功，在Python交互式命令行查看python-docx模块的版本信息：

```shell
>>> import docx
>>> docx.__version__
```


### 3.1 写入Word文件


```python
# 数据写入
from docx import Document
from docx.shared import Inches

# 创建对象
document = Document()
# 添加标题，其中“0”代表标题类型，共有4种类型，具体可在Word的“开始”→“样式”中查看
document.add_heading('Python 爬虫', 0)
# 添加正文内容并设置部分内容格式
p = document.add_paragraph('Python 爬虫开发-')
# 设置内容加粗
p.runs[0].bold = True
# 添加内容并加粗
p.add_run('数据存储-').bold = True
# 添加内容
p.add_run('Word-')
# 添加内容并设置字体斜体
p.add_run('存储实例。').italic = True
# 添加正文，设置“样式”→“明显引用”
document.add_paragraph('样式'  '明显引用', style='IntenseQuote')
# 添加正文，设置“项目符号”
document.add_paragraph(
    '项目符号1', style='ListBullet'
)
document.add_paragraph(
    '项目符号2', style='ListNumber'
)
# 添加图片
document.add_picture('test.png', width=Inches(1.25))
# 添加表格
table = document.add_table(rows=1, cols=3)
hdr_cells = table.rows[0].cells
hdr_cells[0].text = 'Qty'
hdr_cells[1].text = 'Id'
hdr_cells[2].text = 'Desc'
for item in range(2):
    row_cells = table.add_row().cells
    row_cells[0].text = 'a'
    row_cells[1].text = 'b'
    row_cells[2].text = 'c'
# 保存文件
document.add_page_break()
document.save('test.docx')
```

分析上述代码，在Word文件中写入数据的整体思路如下：

1. 创建生成临时Word对象。
2. 分别使用`add_paragraph()`和`add_heading()`对Word对象添加标题和正文内容。
3. 如果想设置正文内容的字体加粗和斜体等，那么可以将正文内容p对象的属性`runs[0].bold`和`add_run('XX').italic`设置为True。
4. 如果要插入图片和添加表格，那么可以在Word对象中使用方法`add_picture()`和`add_table()`。
5. 完成数据写入，需要将Word对象保存成Word文件。



### 3.2 读取Word数据

读取Word数据比写入数据相对简单，因为不用设置内容格式，直接获取数据即可，实现代码如下：

```python
# 数据读取
import docx


def readDocx(docName):
    fullText = []
    doc = docx.Document(docName)
    # 读取全部内容
    paras = doc.paragraphs
    # 将每行数据存入列表
    for p in paras:
        fullText.append(p.text)
        # 将列表数据转换成字符串
    return '\n'.join(fullText)


print(readDocx('test.docx'))
```

分析上述代码，在Word文件中读取数据的整体思路如下：

1. 生成Word对象，并指向Word文件。
2. 使用`paragraphs()`获取Word对象全部内容。
3. 循环paragraphs对象，获取每行数据并写入列表。
4. 将列表转换为字符串，每个列表元素使用换行符连接，转换后数据的段落布局与Word文件相似。





!!!info "扩展阅读"


    [用Python自动化读写Word文档](https://www.yuque.com/fcant/python/wgabhn#r9lHm)





## 4.实践-多文件读写功能

样本文件

`test.txt`


```
[settings]
username = hujianli
password = 123123
```


main.py

```python
import csv
import configparser
import xlrd
import docx
import xlwt


class ReadWrite():
    def __init__(self, name):
        self.name = name
        self.fileStyle = name.split(".")[1]

    def reads(self):
        value = None
        if self.fileStyle == 'txt':
            f = open(self.name, 'r', encoding='utf-8')
            value = f.read()
            f.close()
        if self.fileStyle == 'csv':
            csvfile = open(self.name, 'r')
            value = csv.DictReader(csvfile)
        if self.fileStyle == 'ini':
            value = configparser.ConfigParser()
            value.read(self.name)
        if self.fileStyle in ['xls', 'xlsx']:
            value = xlrd.open_workbook(self.name)
        if self.fileStyle in ['doc', 'docx']:
            doc = docx.Document(self.name)
            value = doc.paragraphs
        return value

    def writes(self):
        target = None
        if self.fileStyle == 'txt':
            target = open(self.name, 'w', encoding='utf-8')
        if self.fileStyle == 'csv':
            csvfile = open(self.name, 'w', newline='')
            target = csv.writer(csvfile)
        if self.fileStyle == 'ini':
            target = configparser.ConfigParser()
            target.read(self.name)
        if self.fileStyle in ['xls', 'xlsx']:
            target = xlwt.Workbook()
        if self.fileStyle in ['doc', 'docx']:
            target = docx.Document()
        return target


if __name__ == '__main__':
    f = ReadWrite('test1.ini')
    # 读取数据
    value = f.reads()
    username = value.get("settings", "username")
    password = value.getint("settings", "password")
    print(f'用户名为：{username}，密码为：{password}')
    # 写入数据
    target = f.writes()
    target.set("settings", "address", "GZ")
    with open("test1.ini", "w+") as f:
        target.write(f)
```


我们定义了ReadWrite类，并重写了类的初始化方法__init__()，定义了实例方法reads()和writes()，每个方法的说明如下：


1. 初始化方法__init__()设置类实例化的参数，在类的实例化过程中必须传入参数name，该参数代表文件的路径信息。
2. 实例方法reads()通过判断文件后缀名的方式选择相应的文件读取操作，由于每个文件的读取方式各不相同，只有TXT、CSV和Docx文件是读取文件内容，INI和Excel文件是返回文件对象。
3. 实例方法writes()也是通过判断文件后缀名的方式选择相应的文件写入操作，每个文件的数据写入方式不同，所以该方法返回相应的文件对象，具体的写入过程不在方法内实现。





## 5.使用Python操作PDF文档

PDF（Portable Document Format）是一种便携式文档格式，这种文档格式与操作系统平台无关。

PDF文件无论是在Windows，Unix还是在苹果公司的Mac OS操作系统中都是通用的，这一特点使它成为在Internet上进行电子文档发行和数字化信息传播的理想文档格式。

虽然PDF便于传输和阅读，但是，编辑PDF却很不容易。PyPDF2对编辑PDF提供了有限的支持，我们可以使用PyPDF2模块读取、合并和写入PDF文档。


### 5.1 PyPDF2安装与介绍


PyPDF2是一个纯Python的开源库，能够分割或合并PDF文件，也可以裁剪或转换PDF文件中的页面。

我们还可以使用PyPDF2查看PDF文件的元信息，对PDF文件进行加密，破解PDF文件的密码等。

PyPDF2是一个开源的库，因此，在使用之前需要先安装。如下所示：


```shell
pip install PyPDF2
```

PyPDF2的官方文档: https://pythonhosted.org/PyPDF2/index.html  中找到PyPDF2的使用文档。


从官方文档中我们知道，PyPDF2提供了4个主要的类，分别是`PdfFileWriter`、`PdfFileReader`、`PdfFileMerger`和`PageObject`。


前三个类分别用以读取PDF文件、写入PDF文件与合并PDF文件。


PageObject类代表了一个PDF页面，可以使用PdfFileReader类的getPage方法得到一个PageObject对象。



### 5.2 使用PdfFileReader读取PDF文件

为了测试PyPDF2，我们使用数据库领域的红宝书进行测试。读者可以在http://www.redbook.io/下载红宝书，也可以在本书的附件下载名为redbooks.pdf的文件。

下载完成以后，打开该PDF文件。这是一份54页的PDF文档


```python
import PyPDF2

reader = PyPDF2.PdfReader(open('redbooks.pdf', 'rb'))

# 获取PDF文件页数
print(len(reader.pages))

# is_encrypted属性会返回一个布尔值，表示PDF是否经过了加密。
print(reader.is_encrypted)

# 我们通过PageObject类的extract_text方法提取页面中的文本。
page = reader.pages[4]
print(page.extract_text())

# 通过PdfReader类的metadata属性获取PDF文件的元信息。
print(reader.metadata)
```






### 5.3 使用PdfFileWriter创建PDF文件


有时候，我们需要编辑PDF页面。例如，去除PDF文件中的第一页，从一个PDF文件中提取几个页面保存到另一个文件。

PyPDF2并不能直接编辑PDF文件，但是，我们可以利用PyPDF2从一个PDF文档拷贝需要的页面到另一个PDF文档，通过这种迂回的方式实现编辑PDF的功能。


pdf加密创建


```python
import PyPDF2

# 创建了一个PdfWriter对象和一个PdfReader对象
reader = PyPDF2.PdfReader(open('redbooks.pdf', 'rb'))
output = PyPDF2.PdfWriter()

# 通过PdfWriter对象的add_page方法增加页面
output.add_page(reader.pages[1])
output.add_page(reader.pages[4])
output.add_page(reader.pages[5])

# 使用了len(output.pages)获取PdfFileWriter拥有的PDF页面数
print(len(output.pages))

# 使用encrypt方法对PDF文件进行加密
output.encrypt('123456', use_128bit=True)

outputStream = open("PyPDF2-output.pdf", "wb")

# 调用PdfWriter对象的write方法,生成一个新的PDF文件
output.write(outputStream)
outputStream.close()
```



pdf解密

解密是在读取文件时用的，用到`derypt()`函数。


```python
from PyPDF2 import PdfWriter, PdfReader

input_pdf = 'PyPDF2-output.pdf'
output_pdf = 'reportlab.pdf'
password = '123456'
pdf_writer = PdfWriter()
reader = PdfReader(open(input_pdf, 'rb'))
pdf_reader = reader.decrypt(password)

for page in range(len(reader.pages)):
    pdf_writer.add_page(reader.pages[page])

with open(output_pdf, 'wb') as fh:
    pdf_writer.write(fh)
```


### 5.4 修改PDF页面

如果需要修改PDF的页面，PyPDF2也提供了部分支持，如旋转页面、添加水印。



PageObject类中有部分方法可以修改PDF页面，其中，`rotateClockwise`和`rotateCounter-Clockwise`方法用来旋转页面。

这两个方法只接受一个参数，且参数取值必须是90的倍数，表示旋转多少度。

下面的代码将`redbooks.pdf`文件的首页旋转180度，并保存到一个新的文件中。

如下所示：


```python
import PyPDF2

# 创建PdfReader对象和PdfWriter对象，并通过pages方法获取redbooks.pdf文件的首页。
reader = PyPDF2.PdfReader(open('redbooks.pdf', 'rb'))
output = PyPDF2.PdfWriter()

page = reader.pages[0]

# rotate方法用来旋转页面。
page.rotate(180)
output.add_page(page)

# 将旋转后的页面写入rotate-page-test.pdf文件中
outputStream = open("PyPDF2-page-test.pdf", "wb")

output.write(outputStream)
outputStream.close()
```



### 5.5 为PDF添加水印

PageObject还有一个名为mergePage的方法，该方法用来将两个页面进行合并，合并以后组成一个新的页面。我们可以使用该方法为PDF添加水印。


例如，实验过程中使用Micsoft Word创建一个新的Word文档，在Word文档中插入“加密文件”这几个艺术字，然后将Word文档保存为PDF文件。


```python
# 为PDF增加水印

import PyPDF2

# 创建了两个PdfReader对象和一个PdfWriter对象
reader = PyPDF2.PdfReader(open('redbooks.pdf', 'rb'))
watermark = PyPDF2.PdfReader(open('watermark.pdf', 'rb'))

writer = PyPDF2.PdfWriter()

# 过for循环遍历redbooks.pdf文件，对该PDF文件中的每一个页面都合并我们创建的水印文件。
for i in range(len(reader.pages)):
    page = reader.pages[i]
    page.merge_page(watermark.pages[0])

    # 使用add_page方法将合并后的页面添加到PdfWriter对象中
    writer.add_page(page)

# 将PdfWriter对象保存到watermark-test.pdf文件中
outputStream = open("watermark-test.pdf", "wb")

writer.write(outputStream)

outputStream.close()
```


打开文档，发现redbooks.pdf文件每一页pdf内容都已经添加了水印。



### 5.6 使用PdfFileMerger合并多个PDF文件

假定现在有一个很无聊的任务，需要将多个PDF文件合并成一个PDF文件。并且，每个PDF文件都有相同的封面，合并成一个PDF文件以后只有一个封面。



有了PdfMerger对象以后，要将目录下的多个PDF文件合并成一个PDF文件就非常容易了，基本步骤如下：

1. 找到工作目录下所有PDF文件；
2. 为了有序添加PDF文件，将所有PDF文件按文件名进行排序；
3. 除了第一页外，将每个PDF的所有页面添加到PdfMerger对象中；
4. 将PdfMerger对象保存到磁盘中。

完整的程序如下：

```python
import os
import glob
import PyPDF2


def get_all_pdf_files(path):
    """
    首先通过glob模块获取path目录下所有PDF文件，并根据文件名对文件进行了排序。
    :param path: 路径
    :return:
    """
    all_pdfs = glob.glob("{0}/*.pdf".format(path))
    all_pdfs.sort(key=str.lower)
    return all_pdfs


def main():
    all_pdfs = get_all_pdf_files(os.path.expanduser('./'))
    if not all_pdfs:
        raise SystemExit('No pdf file found!')

    # 创建了一个PdfMerger对象，并使用append方法将第一个PDF文件完整保存，接着将其他PDF文件依次添加到PdfFileMerger对象中。
    merger = PyPDF2.PdfMerger()

    with open(all_pdfs[0], 'rb') as first_obj:
        merger.append(first_obj)

    # 其他PDF文件，我们需要去除第一页，保留其他页面，因此，我们先构建了PdfReader对象。
    # 构造PdfReader对象是为了获取PDF总页数，知道PDF有多少页面以后才能够给pages参数传递正确的参数。
    for pdf in all_pdfs[1:]:
        with open(pdf, 'rb') as obj:
            reader = PyPDF2.PdfReader(obj)
            merger.append(fileobj=obj, pages=(1, len(reader.pages)))
    # 将这些内容写入硬盘上的一个文件中
    with open('merge-pdfs.pdf', 'wb') as f:
        merger.write(f)


if __name__ == '__main__':
    main()
```


## 6.使用Python归档图片

在Linux下，我们可以通过一个名为exiftool的命令行工具查看照片的元信息。

exiftool可以显示非常全面的信息，如果将所有信息都显示出来，几张纸都打印不下。

使用exiftool之前需要安装，可以从 http://www.sno.phy.queensu.ca/~phil/exiftool/ 下载以后根据说明文档进行安装。

exiftool显示的信息非常全面，这里仅仅给出了部分信息。

可以看到，exiftool显示的信息非常专业，有一些信息需要有摄影知识才能看懂。
但是，即便是对摄影一点都不了解的读者也能看到，exiftool暴露了不少隐私信息，如照片拍摄的详细时间和具体位置。



### 6.1 在Python中使用PIL查看图片元信息

安装PIL

```sh
pip install Pillow
```


下面来看一个例子，假设我们要为当前目录下所有图片文件创建缩略图。

虽然有一些工具对编辑图片提供了支持，但是，大批量图片创建缩略图依然是一项很琐碎的工作。

此时，我们可以使用PL来创建缩略图。创建缩略图的思路也很简单, 首先获取所有的照片，然后使用Image.open方法创建Image对象。创建完Image对象以后，通过该对象的thumbnail方法创建缩略图。

最后，将创建的缩略图保存到磁盘中。如下所示：

```python
import glob
import os

from PIL import Image

size = 128, 128

for infile in glob.glob("*.jpg"):
    file, ext = os.path.splitext(infile)
    im = Image.open(infile)
    im.thumbnail(size)
    im.save(file + "-thumbnail.jpg", "JPEG")
```

有了Exif的信息以及TAGS与GPSTAGS字典以后，我们可以使用Python程序编写一个类似于exiftool的工具。



如下所示：

```python
from __future__ import print_function
import sys
import os

from PIL import Image
from PIL.ExifTags import TAGS
from PIL.ExifTags import GPSTAGS


def get_iamge_meta_info(filename):
    exif_data = {}
    with Image.open(filename) as img:
        data = img._getexif()
        for tag, value in data.iteritems():
            decoded = TAGS.get(tag)
            exif_data[decoded] = value

        if exif_data['GPSInfo']:
            gps_data = {}
            for tag, value in exif_data['GPSInfo'].iteritems():
                decoded = GPSTAGS.get(tag)
                gps_data[decoded] = value
            exif_data['GPSInfo'] = gps_data

    return exif_data


def main():
    sys.argv.append("")
    filename = sys.argv[1]
    if not os.path.exists(filename):
        raise SystemExit("{0} is not exists".format(filename))

    exif_data = get_iamge_meta_info(filename)

    for key, value in exif_data.iteritems():
        print(key, value, sep=':')


if __name__ == '__main__':
    main()
```

- 首先通过`sys.argv`获取用户在命令行传递的文件名，为了处理用户没有传递任何图片的异常情况，我们先向`sys.argv`列表中增加一个空的元素，然后再去获取命令行传递的文件名。
- 获取到文件名以后，通过`os.path.exists`函数判断文件是否存在，如果文件不存在，抛出异常并退出程序。
- 随后，我们将文件名传递给`get_iamge_meta_info`函数，该函数使用Image类的open方法得到一个Image对象，并使用该对象的getexif方法得到照片的Exif信息。
- getexif方法以字典形式返回Exf信息，而字典的键是相应的编码，可读性较差。因此，我们需要使用TAGS和GPSTAGS字典将编码转换成可读性更强的描述字符串。转换成可读性更强的描述字符串以
后，将结果保存到`exif_data`字典中。最后，`get_iamge_meta_info`函数将图片的Exif信息以字典的形式返回给调用者。


利用Python生态中的Pillow库，我们仅用40行代码就实现了一个类似于exiftool的命令行工具。更重要的是，我们在Python程序中获取Exif信息以后，可以继续在Python程序中对图片进行后续处理，如根据图片的拍摄时间、拍摄地点、使用设备等进行图片归档。


## 7.发送报告


### 7.1 使用标准的smtplib与mime发送邮件

了解SMTP协议，得到邮箱的授权码以后就可以使用Python代码发送电子邮件了。

Python标准库有多个与邮件相关的模块，其中，smtplib模块负责发送邮件。smtplib发送邮件大概分为以下几个步骤：


1)连接到SMTP服务器；

2)发送SMTP的“Hello”消息；

3)登录到SMTP服务器；

4)发送电子邮件；

5)关闭SMTP服务器的连接。


下面的代码是一个发送纯文本邮件的例子。

这个例子中，我们在`send_mail`函数中构建了一个MIMEText对象，并通过这个MIMEText对象设置收件人、发件人和邮件主题。

设置完成以后，根据前面介绍的步骤一步一步发送电子邮件。如下所示：

```python
from __future__ import print_function
import smtplib
from email.mime.text import MIMEText

SMTP_SERVER = "smtp.qq.com"
SMTP_PORT = 25


def send_mail(user, pwd, to, subject, text):
    msg = MIMEText(text)
    msg['From'] = user
    msg['To'] = to
    msg['Subject'] = subject

    smtp_server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
    print('Connecting To Mail Server.')
    try:
        smtp_server.ehlo()
        print('Starting Encrypted Seccion.')

        smtp_server.starttls()
        smtp_server.ehlo()
        print('Logging Into Mail Server')

        smtp_server.login(user, pwd)
        print('Sending Mail.')
        smtp_server.sendmail(user, to, msg.as_string())
    except Exception as err:
        print('Sending Mail Failed: {0}'.format(err))
    finally:
        smtp_server.quit()


def main():
    send_mail('403720692@qq.com', 'ezawhklhlphzcbae',
              'joy_lmx@163.com', 'Important', 'Test Message')


if __name__ == '__main__':
    main()

```


前面这个例子仅仅发送纯文本的电子邮件，如果需要发送带有附件的邮件，需要构建一个MIMEMultipart对象，并通过MIMEMultipart的attach方法添加附件。

例如，下面这段程序是Python官方给出的例子，在这个例子中，我们将多个png文件作为附件一起发送。
为了发送附件，首先构造一个MIMEMultipart对象，并通过该对象设置发件人、收件人和邮件主题。
对于图片附件，为每张图片构造一个MIMEImage对象，并使用MIMEMultipart的attach方法添加图片附件。


如下所示：

```python
# Import smtplib for the actual sending function
import smtplib

# Here are the email package modules we'll need
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart

COMMASPACE = ', '

# Create the container (outer) email message.
msg = MIMEMultipart()
msg['Subject'] = 'Our family reunion'
# me == the sender's email address
# family = the list of all recipients' email addresses
msg['From'] = me
msg['To'] = COMMASPACE.join(family)
msg.preamble = 'Our family reunion'

# Assume we know that the image files are all in PNG format
for file in pngfiles:
    # Open the files in binary mode.  Let the MIMEImage class automatically
    # guess the specific image type.
    fp = open(file, 'rb')
    img = MIMEImage(fp.read())
    fp.close()
    msg.attach(img)

# Send the email via our own SMTP server.
s = smtplib.SMTP('localhost')
s.sendmail(me, family, msg.as_string())
s.quit()
```



### 7.2 使用开源yagmail发送邮件

如果你想使用开源的 yagmail 发送邮件，你可以按照下面的步骤进行配置：

1. 安装 yagmail

```bash
pip install yagmail
```

2. 导入 yagmail 并配置发件人信息

```python
import yagmail

yag = yagmail.SMTP("发件人邮箱", "发件人授权码")
```

其中，发件人邮箱 需要替换为你实际的发件人邮箱，发件人授权码 需要替换为你在邮件服务商处设置的授权码。需要注意的是，不同的邮件服务商提供的授权码设置方式可能不同，请根据你的具体情况进行设置。

使用 yagmail 发送邮件
```python
import yagmail

yag = yagmail.SMTP("发件人邮箱", "发件人授权码")
receiver = "收件人邮箱"
subject = "邮件主题"
contents = ["邮件正文"]

yag.send(to=receiver, subject=subject, contents=contents)
```

以上代码中，收件人邮箱 需要替换为你实际的收件人邮箱，邮件主题 和 邮件正文 也需要根据实际情况进行设置。

如果你想发送带附件的邮件，可以参考 yagmail 的官方文档（https://github.com/kootenpv/yagmail）进行设置。


需要注意的是，使用 yagmail 发送邮件时，如果你的邮件服务商使用的是非标准端口（一般为 25、465 或 587），你需要在 SMTP() 方法中显式指定端口号，例如：

```python
import yagmail

yag = yagmail.SMTP(user="发件人邮箱", password="发件人授权码", port="465")
```

通过上述步骤，你就可以使用开源的 yagmail 发送邮件了。



使用yagmail发送一封带有附件的电子邮件

- demo

```python
import yagmail

# 配置发件人信息
sender_email = "your_sender_email@example.com"
sender_password = "your_sender_password"

# 配置收件人信息
receiver_email = "recipient@example.com"

# 配置邮件内容
subject = "这是一封带附件的测试邮件"
content = "这是一封使用 yagmail 发送的带附件的测试邮件，请忽略。"

# 配置附件路径
attachment = "path_to_your_attachment_file"

# 发送邮件
try:
    yag = yagmail.SMTP(sender_email, sender_password)
    yag.send(
        to=receiver_email,
        subject=subject,
        contents=content,
        attachments=attachment
    )
    print("邮件发送成功！")
except Exception as e:
    print("邮件发送失败:", str(e))
```

## 8.接收邮件


### 8.1 接收邮件协议IMAP与POP3

SMTP是发送电子邮件的协议，相应的，也有接收电子邮件的协议。


接收电子邮件有两种协议，分别是POP3和IMAP。

POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等）不会反馈到服务器上。

例如，通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时移动的。

IMAP提供了webmail与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。

与此同时，IMAP跟POP3一样提供了方便的邮件下载服务，让用户能进行离线阅读。

IMAP提供的摘要浏览功能可以让你在阅读完所有的邮件到达时间、主题、发件人、大小等信息后再作出是否下载的决定。

此外，IMAP更好地支持了从多个不同设备中随时访问新邮件。

总之，IMAP为用户带来更为便捷和可靠的体验。POP3更易丢失邮件或多次下载相同的邮件，IMAP通过邮件客户端与webmail之间的双向同步功能能更好地避免这些问题。

因此，仅介绍如何在Python程序中通过IMAP协议接收电子邮件。




### 8.2 使用开源从imapclient接收邮件

imapclient 是一个 Python 第三方库，用于连接到 IMAP 服务器并检索邮件数据。在使用 imapclient 接收邮件前，请确保你已经具备以下条件：

1. 你已经拥有了待连接的 IMAP 邮箱的主机名和端口号；
2. 你已经知道了待连接的邮箱地址和对应的密码。


```sh
pip install imapclient
```


接下来是一个使用 imapclient 接收邮件并打印邮件摘要信息的示例程序：

```python
import imaplib
from imapclient import IMAPClient

# 邮箱账户信息
email = "your_email@example.com"
password = "your_password"

# 邮箱服务器信息
imap_host = "imap.example.com"
imap_port = 993

# 连接到邮箱服务器
with IMAPClient(imap_host) as client:
    # 登录邮箱
    client.login(email, password)

    # 选择收件箱
    client.select_folder("INBOX")

    # 搜索邮件
    messages = client.search(["ALL"])

    # 打印邮件摘要信息
    for uid, message_data in client.fetch(messages, "RFC822").items():
        print("邮件UID:", uid)
        print("邮件信息:", message_data[b"RFC822"].decode("utf-8"))

    # 退出邮箱
    client.logout()
```

### 8.3 使用pyzmail解析邮件


pyzmail 是 Python 第三方库，用于解析 MIME 格式邮件。在使用 pyzmail 解析邮件之前，请确保你已经安装了该库。

```sh
pip install pyzmail
```

接下来是一个使用 pyzmail 解析邮件并打印邮件信息的示例程序：

```python
import imaplib
import pyzmail

# 邮箱账户信息
email = "your_email@example.com"
password = "your_password"

# 邮箱服务器信息
imap_host = "imap.example.com"
imap_port = 993

# 连接到邮箱服务器
with imaplib.IMAP4_SSL(imap_host, imap_port) as client:
    # 登录邮箱
    client.login(email, password)

    # 选择收件箱
    client.select("INBOX")

    # 搜索邮件
    typ, messages = client.search(None, "ALL")

    for num in messages[0].split():
        # 下载邮件正文
        typ, data = client.fetch(num, "(BODY[])")
        message_data = data[0][1]

        # 解析 MIME 格式邮件
        mail = pyzmail.PyzMessage.factory(message_data)

        # 打印邮件主题、发件人、收件人和正文
        print("主题：", mail.get_subject())
        print("发件人：", mail.get_address("from"))
        print("收件人：", mail.get_addresses("to"))
        print("正文：", mail.text_part.get_payload().decode(mail.text_part.charset))

    # 退出邮箱
    client.logout()
```

### 8.4 使用imapclient删除邮件

要使用 imapclient 库删除邮件，你需要按照以下步骤进行操作：


1. 连接到 IMAP 服务器并登录邮箱；
2. 选择要删除邮件的文件夹（例如收件箱）；
3. 搜索要删除的邮件；
4. 使用 imap_client.delete_messages() 方法删除邮件；
5. 退出邮箱。


下面是一个示例程序，演示如何使用 imapclient 删除邮件：

```python
from imapclient import IMAPClient

# 邮箱账户信息
email = "your_email@example.com"
password = "your_password"

# 邮箱服务器信息
imap_host = "imap.example.com"
imap_port = 993

# 连接到邮箱服务器
with IMAPClient(imap_host) as client:
    # 登录邮箱
    client.login(email, password)

    # 选择收件箱
    client.select_folder("INBOX")

    # 搜索要删除的邮件
    messages = client.search(["FROM", "sender@example.com"])

    # 删除邮件
    client.delete_messages(messages)

    # 将删除操作同步到服务器
    client.expunge()

    # 退出邮箱
    client.logout()
```

在上述示例中，你需要将 your_email@example.com 替换为实际的邮箱地址，将 your_password 替换为对应邮箱的登录密码，并将 imap.example.com 和 993 替换为实际的 IMAP 服务器主机名和端口号。可以根据自己的需求修改搜索条件，例如可以根据发件人过滤要删除的邮件。

运行以上代码，它将登录到指定的邮箱账户，选择收件箱文件夹，并删除满足搜索条件的邮件。请注意，`delete_messages()` 方法只是将邮件标记为删除状态，要将更改同步到服务器并永久删除邮件，需要调用 `expunge()` 方法。

确保在使用 imapclient 删除邮件时小心操作，以免意外删除了重要的邮件。建议先在测试环境下验证程序的正确性，然后再应用到生产环境中。



## 9. 综合案例：使用Python打造一个geek的邮件客户端



命令行项目客户端为emcli，项目地址(https://github.com/lalor/emcli)



### 9.1 emcli的功能设计

emcli的需求非常简单，仅仅是发送电子邮件，这也符合Linux中一条命令只做一件事情的原则。

发送邮件需要用到很多的输入信息，包括：

- [x] SMTP服务器的域名；
- [x] SMTP服务器的端口号；
- [x] 登录SMTP服务器的用户名；
- [x] 登录SMTP服务器的密码；
- [x] 邮件的主题；
- [x] 邮件的内容；
- [x] 邮件的附件；
- [x] 邮件的收件人。

发送一封带附件的邮件至少需要用到这里的8种信息，否则就没有办法正确发送邮件。

对于这里的8种信息，如果所有信息都通过命令行指定，然后使用argparse库解析这些命令行参数，那么emcli将没有任何易用性可言。


为了提高emcli的易用性，我们应该尽可能减少需要命令行指定的参数。

可以看到，对于前面的8种信息，前4种信息是与邮件内容无关的信息，后4种信息是与邮件内容相关的信息。

为了减少命令行参数，我们可以将邮件内容无关的信息保存到配置文件中，将邮件内容相关的信息通过命令行参数来指定。

因此，我们增加一个`~/.emcli.cnf`文件，该文件保存了SMTP服务器的域名、端口号以及登录SMTP服务器的用户名和密码。如下所示：


```sh
$ cat ~/.emcli.cnf
[DEFAULT]
smtp_server = smtp.qq.com
smtp_port = 25
username = 403720692@qq.com
password = abc123
```

当我们调用emcli程序时，程序会自动读取`~/.emcli.cnf`文件中的内容，使用`~/.emcli.cnf`文件中的配置来发送邮件。

```python
def get_config_file(config_file):
    if config_file is None:
        config_file = os.path.expanduser('~/.emcli.cnf')
    return config_file

# .....
def main():
    parser = get_argparse()

    config_file = get_config_file(parser.conf)

    if not os.path.exists(config_file):
        logger.error('{0} is not exists'.format(config_file))
        raise SystemExit()
    else:
        meta = get_meta_from_config(config_file)
    #....
```



邮件客户端的使用方式如下

```sh
# send email to multiple recipents:
echo "This email come from terminal" | emcli -s "This is subject" -r joy_lmx@163.com me@mingxinglai.com


# send email with attaches:
emcli -s "This is subject" -a *.py -r joy_lmx@163.com < /etc/passwd
```


在第一条命令中，我们通过管道来获取邮件内容，通过“-s”选项指定邮件的主题，通过“r”选项指定收件人。

收件人是一个必传的参数，并且，收件人可以有多个。

在第二条命令中，我们使用输入重定向的方式读取/etc/passwd文件的内容作为邮件体。并且，通过“-a”选项指定邮件的附件。

### 9.2 emcli功能实现

解析命令行参数

```python
def get_argparse():
    parser = argparse.ArgumentParser(description='A email client in terminal')
    parser.add_argument('-s', action='store', dest='subject', required=True, help='specify a subject (must be in quotes if it has spaces)')
    parser.add_argument('-a', action='store', nargs='*', dest='attaches', required=False, help='attach file(s) to the message')
    parser.add_argument('-f', action='store', dest='conf', required=False, help='specify an alternate .emcli.cnf file')
    parser.add_argument('-r', action='store', nargs='*', dest='recipients', required=True, help='recipient who you are sending the email to')
    parser.add_argument('-v', action='version', version='%(prog)s 0.2')
    return parser.parse_args()
```


emcli除了使用argparse解析命令行参数以外，还需要使用ConfigParser解析配置文件的内容，以此获取SMTP服务器的地址和端口。如下所示：

```python
def get_meta_from_config(config_file):
    config = ConfigParser.SafeConfigParser()

    with open(config_file) as fp:
        config.readfp(fp)

    meta = Storage()
    for key in ['smtp_server', 'smtp_port', 'username', 'password']:
        try:
            val = config.get('DEFAULT', key)
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError) as err:
            logger.error(err)
            raise SystemExit(err)
        else:
            meta[key] = val

    return meta
```

我们通过命令行参数获取了与邮件相关的内容，通过配置文件获取了与SMTP服务器相关的信息。


接下来就可以使用yagmail发送电子邮件了。如下所示：


```python
def send_email(meta):
    content = get_email_content()
    body = [content]
    if meta.attaches:
        body.extend(meta.attaches)

    with yagmail.SMTP(user=meta.username, password=meta.password,
                      host=meta.smtp_server, port=int(meta.smtp_port)) as yag:
        logger.info('ready to send email "{0}" to {1}'.format(meta.subject, meta.recipients))
        ret = yag.send(meta.recipients, meta.subject, body)

def main():
    parser = get_argparse()

    config_file = get_config_file(parser.conf)

    if not os.path.exists(config_file):
        logger.error('{0} is not exists'.format(config_file))
        raise SystemExit()
    else:
        meta = get_meta_from_config(config_file)

    # 命令行参数绑定邮件相关的内容
    meta.subject = parser.subject
    meta.recipients = parser.recipients
    meta.attaches = parser.attaches

    for attach in meta.attaches:
        if not os.path.exists(attach):
            logger.error('{0} is not exists'.format(attach))
            raise SystemExit()

    send_email(meta)
```


### 9.3 使用setuptools打包源码

当我们开发完一个功能以后，接下来要做的就是分发软件包。


Pytho中有多个库可以帮助我们分发软件包，现在使用最广泛的是setuptools。

setuptools是distutils增强版的集合，也是由PEAK(Python Enterprise Application Kit)开发的工具。

它可以帮助我们更简单地创建和分发Pythor包，尤其是拥有依赖关系的复杂情况。

使用setuptools打包源码主要是编写setup.py文件并在文件中调用setup函数。emcli项目的setup.py文件内容如下：

```python
#!/usr/bin/env python
# coding: utf-8
from setuptools import setup

setup(
    name='emcli',
    version='0.3',
    author='Mingxing LAI',
    author_email='me@mingxinglai.com',
    url='https://github.com/lalor/emcli',
    description='A email client in terminal',
    packages=['emcli'],
    install_requires=['yagmail'],
    tests_require=['nose', 'tox'],
    entry_points={
        'console_scripts': [
            'emcli=emcli:main',
        ]
    }
)
```

setup函数有很多参数，在emcli项目中仅用到了很少一部分。各个参数的含义如下：

- name:项目的名称
- version:项目的版本
- author:作者的名字
- author_email:作者的联系方式
- url:项目的主页
- description:简短介绍
- packages:项目的代码
- install_requires:项目依赖
- tests_requires:测试依赖
- entry_points:命令行程序的入口


有了合适的 setup.py 文件就可以方便地安装emcli项目了。如下所示：
```sh
python setup.py install
```

如果需要将软件包安装到其他机器上，可以使用下面的命令生成一个tar包，如下所示：

```sh
python setup.py sdist
```

执行完上面的命令会在当前目录下创建一个dist目录。dist目录下保存了emcli的安装包

```sh
$ tree dist/
dist/
  - emcli-0.3.tar.gz
```



### 9.4 使用twine上传到PyPi

在Python生态中，工程师已经习惯了使用pip命令安装软件包。

为了让最终用户可以使用pip命令安装emcli项目，我们需要将emcli发布到PyPI（http:l/pypi.python.org)上。


因此，我们需要在PyPI上注册一个账号。账号注册完成以后，在HOME目录下创建一个pypirc文件，并在文件中填入PyPI的用户名和密码：

```sh
[pypi]
username:<your username>
password:<your password>
```

配置好用户名和密码以后，还需要安装一个名为twine的小工具。twine是一个将软件包上传到PyPI上的工具。如下所示：

```sh
pip install twine
```

使用twine将emcli上传到PyPI:

```sh
twine dist/*
```


上传完成以后，任何人都可以在自己的电脑上使用pp命令安装我们的命令行邮件客户端。





- [Python3读写JSON文件](https://www.cnblogs.com/superhin/p/11502830.html)
- [Python3读写YAML文件](https://www.cnblogs.com/superhin/p/11503756.html)
- [Python3读写TOML文件](https://www.cnblogs.com/superhin/p/python-toml.html)
