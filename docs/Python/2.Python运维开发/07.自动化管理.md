# 07.自动化管理

## 7.1 SSH

SSH(Secure Shell)是一种由 IETF 的网络工作小组制定、创建在应用层和传输层基础上的安全协议，为计算机上的 Shell 提供安全的传输和使用环境。

### 1.SSH 协议

在互联网早期，通信都是明文的，如 rsh、FTP、POP 和 Telnet。

一旦通信报文被截获内容就泄漏无疑。

1995 年，芬兰学者 Tatu Ylonen 设计了 SSH 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案。

这个方案迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置。

SSH 只是一种协议，存在多种实现，既有商业实现，也有开源实现。目前，在 Liux 下广泛使用的是 OpenSSH,它是一款应用广泛的开源软件。

即将介绍的 paramiko 是 SSH 协议的一种 Python 实现。

S$H 除了提供安全的传输和登录以外，还可以进行批量命令执行，使用非常方便。

正是由于 SSH 简单好用的特点，常见的 Ansible 工具,都依赖 SSH 进行远程服务器的管理。

使用 SSH 的好处非常明显，既充分利用了现成的机制，又省去了在远程服务器安装代理（Agent)程序。因此，诸多自动化工具都依赖于 SSH。

### 2.OpenSSH 实现

OpenSSH 客户端是一个名为 ssh 可执行程序，ssh 命令连接远程服务器，示例如下

```sh
ssh username@remote_host
```

非 22 端口号

```sh
ssh username@remote_host -p port
```

不进入交互式的 shell

```sh
ssh username@remote_host 'COMMANDS'
```

### 3.使用秘钥登录远程服务器

1. 生成密钥对：

在本地计算机上打开终端或命令提示符窗口，并运行以下命令来生成密钥对：

```sh
ssh-keygen -t rsa
```

这将生成一对公钥（id_rsa.pub）和私钥（id_rsa）文件。

2. 将公钥复制到远程服务器：

使用以下命令将公钥复制到远程服务器上：

```sh
ssh-copy-id username@remote_host
# 其中 username 是您在远程服务器上的用户名，remote_host 是远程服务器的 IP 地址或主机名。您将被要求输入远程服务器的密码。
```

如果 ssh-copy-id 命令不可用，您可以手动将公钥内容复制到远程服务器的 ~/.ssh/authorized_keys 文件中。

配置 SSH 服务：在远程服务器上，确保 SSH 服务已启用并配置为允许使用密钥进行身份验证。打开远程服务器上的 SSH 配置文件 /etc/ssh/sshd_config，找到以下行并确保其处于以下状态：

```
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys
```

3. 重启 SSH 服务：

保存并关闭 SSH 配置文件后，重新启动 SSH 服务以使更改生效。在远程服务器上运行以下命令：

```sh
sudo service ssh restart
```

尝试使用密钥登录：现在，您应该能够使用密钥进行远程登录，而无需输入密码。在本地计算机上，使用以下命令登录到远程服务器：

```sh
ssh username@remote_host

# 这将使用私钥进行身份验证。
```

使用私钥登录时需要注意，**私钥文件与远程服务器中 authorized keys 文件的权限都必须为 600**，否则登录会出错。 这也是工程师使用私钥登录时最容易遇到的错误。

### 4.使用 ssh-agent 管理私钥

使用 ssh-agent 可以更方便地管理私钥，避免每次使用私钥时都需要手动输入密码。

以下是使用 ssh-agent 管理私钥的简单步骤：

1. 启动 ssh-agent：

在终端或命令提示符窗口中运行以下命令来启动 ssh-agent：

```sh
eval $(ssh-agent)
```

2. 添加私钥到 ssh-agent：

运行以下命令将私钥添加到 ssh-agent：

```sh
ssh-add /path/to/private_key
# 将 /path/to/private_key 替换为您的私钥文件的路径。
```

如果私钥受密码保护，您将被要求输入密码以解锁私钥。

私钥添加完成以后，可以执行 ssh add-L 命令查看哪些私钥已经被添加到 ssh-agent 中。

如下所示：

```sh
ssh-add -L
ssh-rsa AAAAB3NzaCxxxxx......xxxx2dNKzx/qjAYIdaVuuhMesQ5n8=mac_air
ssh-rsa AAAAB3Nzxxxxxxx......xxxxnmT431XKh51Z8c7ZFXZ id_rsa
```

启动 ssh-agent 以后，当我们尝试与远程服务器建立连接时，ssh 客户端将会尝试使用存储在 ssh-agent 中的私钥与远程服务器进行认证。

配置 SSH 客户端：打开 SSH 客户端配置文件 ~/.ssh/config（如果不存在则创建），并添加以下内容：

```
Host *
  AddKeysToAgent yes
  UseKeychain yes
  IdentityFile /path/to/private_key
```

将 /path/to/private_key 替换为您的私钥文件的路径。

这样配置后，每次使用 SSH 连接时，客户端将自动将私钥添加到 ssh-agent 中。

3. 尝试使用私钥进行远程登录
   现在，您可以尝试使用私钥进行远程登录，而无需手动输入密码。在终端或命令提示符窗口中运行以下命令：

```sh
ssh username@remote_host
# 这将使用 ssh-agent 中的私钥进行身份验证。
```

### 5.轻量级自动化运维工具 pssh

[Centos7 部署轻量级自动化运维工具 pssh](https://semaik.gitee.io/2021/01/21/Centos7%E9%83%A8%E7%BD%B2%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7pssh/)

[轻量级自动化运维工具 ---pssh&pscp.pssh](https://www.cnblogs.com/alexlv/p/13597113.html)

## 7.2 Polysh 库

Polysh 是一个用于批量管理服务器的工具，它可以帮助管理员同时在多台服务器上执行命令、上传文件等操作。下面是一个使用 Polysh 批量管理服务器的代码示例：

### 1.安装 Polysh

```sh
pip install polysh
```

### 2.创建一个配置文件

在你的本地机器上创建一个名为 `polysh_config.yaml` 的配置文件，并按照以下格式填写服务器信息：

```yaml
servers:
  - name: server1
    host: 192.168.0.1
    user: username
    password: password
  - name: server2
    host: 192.168.0.2
    user: username
    password: password
  # 添加更多服务器...
```

### 3.编写 Python 脚本

创建一个名为 polysh_script.py 的 Python 脚本，并使用以下代码示例来批量管理服务器：

```python
from polysh import Polysh

# 加载服务器配置文件
polysh = Polysh('polysh_config.yaml')

# 在所有服务器上执行命令
polysh.run('ls -l')

# 在指定服务器上执行命令
polysh.run('uname -a', servers=['server1'])

# 上传文件到所有服务器
polysh.put('local_file.txt', 'remote_path/')

# 下载文件从指定服务器
polysh.get('remote_path/remote_file.txt', 'local_path/')
```

在终端中运行以下命令来执行脚本：

```sh
python polysh_script.py
```

### 4.Polysh 实现修改密码、上传文件和安装压缩包

```python
from polysh import Polysh

# 加载服务器配置文件
polysh = Polysh('polysh_config.yaml')

# 修改密码
def change_password(username, new_password):
    command = f'echo "{username}:{new_password}" | chpasswd'
    polysh.run(command)

# 上传文件
def upload_file(local_path, remote_path):
    polysh.put(local_path, remote_path)

# 安装压缩包
def install_package(package_name):
    command = f'apt-get install {package_name} -y'
    polysh.run(command)

# 示例用法
if __name__ == '__main__':
    # 修改密码
    change_password('username', 'new_password')

    # 上传文件
    upload_file('local_file.txt', 'remote_path/')

    # 安装压缩包
    install_package('zip')
```

## 7.3 pexpect 库

### 1.远程登录 ssh 并执行命令

simple1.py

```python
from pexpect import pxssh
import getpass

try:
    s = pxssh.pxssh() #创建pxssh对象
    hostname = input('hostname: ')
    username = input('username: ')
    password = getpass.getpass('password: ')  #接收密码输入
    s.login(hostname, username, password) #建立ssh连接
    s.sendline('uptime')  # run a command #运行uptime命令
    s.prompt()  # match the prompt #匹配系统提示符
    print(s.before)  # print everything before the prompt.  #打印出现系统提示符前的命令输出
    s.sendline('ls -l') #运行命令
    s.prompt()#匹配系统提示符
    print(s.before) #打印出现系统提示符前的命令输出
    s.sendline('df')#运行命令
    s.prompt()#匹配系统提示符
    print(s.before)#打印出现系统提示符前的命令输出
    s.logout() #断开ssh连接
except pxssh.ExceptionPxssh as e:
    print("pxssh failed on login.")
    print(str(e))
```

### 2.远程登录 ftp

simple2.py

```python
from __future__ import unicode_literals	#使用unicode编码

import pexpect
import sys

child = pexpect.spawnu('ftp ftp.openbsd.org')
child.expect('(?i)name .*: ') #(?i)忽略大小写
child.sendline('anonymous')
child.expect('(?i)password')
child.sendline('pexpect@sourceforge.net')
child.expect('ftp> ')
child.sendline('bin') #开启二进制传输
child.expect('ftp> ')
child.sendline('get robots.txt')
child.expect('ftp> ')
sys.stdout.write (child.before)
print("Escape character is '^]'.\n")
sys.stdout.write (child.after)
sys.stdout.flush()
child.interact() # Escape character defaults to ^]
child.sendline('bye')
child.close()
```

### 3.远程登录 ssh 并上传文件

```python
import pexpect
import sys

ip = "192.168.1.21"
user = "root"
passwd = "xxxx"
target_file = "/data/logs/nginx_access.log"

child = pexpect.spawn('/usr/bin/ssh', [user + '@' + ip])
fout = open('mylog.txt', 'w')
child.logfile = fout

try:
    child.expect('(?i)password')
    child.sendline(passwd)
    child.expect('#')
    child.sendline('tar -czf /data/nginx_access.tar.gz ' + target_file)
    child.expect('#')
    print(child.before)
    child.sendline('exit')
    fout.close()
except pexpect.EOF:
    print("expect EOF")
except pexpect.TIMEOUT:
    print("expect TIMEOUT")

child = pexpect.spawn('/usr/bin/scp', [user + '@' + ip + ':/data/nginx_access.tar.gz', '/home'])
fout = open('mylog.txt', 'a')
child.logfile = fout
try:
    child.expect('(?i)password')
    child.sendline(passwd)
    child.expect(pexpect.EOF)
except pexpect.EOF:
    print("expect EOF")
except pexpect.TIMEOUT:
    print("expect TIMEOUT")
```

## 7.4 paramiko 库

使用 paramiko 库：https://github.com/paramiko/paramiko

### 1.账号密码登录执行命令

```python
#!/usr/bin/python
#ssh
import paramiko
import sys,os

host = '10.152.15.200'
user = 'peterli
password = '123456'

s = paramiko.SSHClient()                                 # 绑定实例
s.load_system_host_keys()                                # 加载本地HOST主机文件
s.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 允许连接不在know_hosts文件中的主机
s.connect(host,22,user,password,timeout=5)               # 连接远程主机
while True:
        cmd=raw_input('cmd:')
        stdin,stdout,stderr = s.exec_command(cmd)        # 执行命令
        cmd_result = stdout.read(),stderr.read()         # 读取命令结果
        for line in cmd_result:
                print line,
s.close()
```

```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
import paramiko
import time

ip = "172.16.10.10"
port= 22
username="root"
passwd="superadmin"


def ssh2(ip,port,username,passwd,cmd):
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(ip,port,username,passwd,timeout=5)
        chan=ssh.invoke_shell()
        print(chan.recv(1024))
        for m in cmd:
            res = chan.sendall(m+"\n")
            time.sleep(float(1))
        print(chan.recv(1024))
        ssh.close()
    except Exception as e:
        print(e)

cmd=['ls']
ssh2(ip,port,username,passwd,cmd)
```

### 2.上传下载文件

```python
import paramiko

transport = paramiko.Transport(('39.105.186.**', 22))
transport.connect(username='root', password='Situ')

sftp = paramiko.SFTPClient.from_transport(transport)
# 将location.py 上传至服务器 /tmp/test.py
sftp.put('wjx', '/tmp/wjx')

# 将remove_path 下载到本地 local_path
# sftp.get('/tmp/wjx', 'newjx')

transport.close()
```

### 3.使用 ssh 公钥私钥

```python
import paramiko

# 创建SSH对象
ssh = paramiko.SSHClient()

# 允许连接不在know_hosts文件中的主机
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

# 指定私钥路径
private_key = paramiko.RSAKey.from_private_key_file('c:\\Users\\boy\\.ssh\\id_rsa')

# 使用私钥连接服务器
ssh.connect(hostname='192.168.21.128', port=22, username='root', pkey=private_key)

# 执行命令
stdin, stdout, stderr = ssh.exec_command('df')

# 获取命令结果
result = stdout.read()

# 关闭连接
ssh.close()

print(result)
```

### 4.使用 ssh 公钥+密码认证封装

```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
import paramiko,sys
# 创建SSHClient对象
hostname = "172.16.10.10"
port=22
username="root"
password="superadmin"

#使用公钥登录ssh，进行连接
def ssh_connect_key(host,user,key_file,cmd):
    ssh=paramiko.SSHClient()
    ssh.load_system_host_keys()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    key=paramiko.RSAKey.from_private_key_file(key_file)
    ssh.connect(hostname=host,username=user,pkey=key,timeout=30)
    stdin,stdout,stderr=ssh.exec_command(cmd)
    result=stdout.read().decode()     #python3 bytes格式转换为sting,python2无需decode,result=str(stdout.read(),'utf8)
    ssh.close()
    return result

#使用用户名、密码来登录
def ssh_connect(host,user,password,cmd):
    ssh=paramiko.SSHClient()
    ssh.load_system_host_keys()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(hostname=host,username=user,password=password,timeout=30)
    stdin,stdout,stderr=ssh.exec_command(cmd)
    result=stdout.read()
    ssh.close()
    return result

if __name__ == '__main__':
    # a=len(sys.argv)
    # if a!=5:
    #     print ("参数个数不对，请输入四个参数!")
    # else:
    #     host=sys.argv[1]
    #     user=sys.argv[2]
    #     password=sys.argv[3]
    #     cmd=sys.argv[4]
    #     try:
    #         out=ssh_connect(host,user,password,cmd)
    #         print (out)
    #     except:
    #         print ("usages:python ssh2.py '192.168.10.129' 'root' '123456' 'ls /root'")

    ssh_connect(hostname,username,password,"df -Th")
```

### 5.简单封装 SSH 类

#### 示例 1

```python
import paramiko


class SSH:

    def __init__(self, host, port, user, ssh_key_path, timeout=1800):
        self.host = host
        self.port = port
        self.user = user
        self.ssh_key_path = ssh_key_path
        self.timeout = timeout
        self.connect()

    def connect(self):
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        pkey = paramiko.RSAKey.from_private_key_file(self.ssh_key_path)
        client.connect(hostname=self.host, username=self.user, port=self.port, pkey=pkey, timeout=self.timeout)
        self.client = client

    def exec(self, shell, timeout=1800):
        stdin, stdout, stderr = self.client.exec_command(command=shell, bufsize=1, timeout=timeout)
        while True:
            line = stdout.readline()
            if not line:
                break
            print(line)
        print(stderr.read())
        code = stdout.channel.recv_exit_status()
        return code

    def close(self):
        self.client.close()
```

#### 示例 2

```python
import paramiko
from io import StringIO  # py2 from StringIO import StringIO
import os

class SSH():
    def __init__(self, ip, port, username, password=None, key=None):
        self.ip = ip
        self.port = port
        self.username = username
        self.password = password
        self.key = key

    def command(self, shell):
        # 绑定实例
        ssh = paramiko.SSHClient()
        # 允许连接不在known_hosts文件上的主机
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            # 判断是密码登陆，还是密钥登陆
            if self.password:
                ssh.connect(hostname=self.ip, port=self.port, username=self.username, password=self.password, timeout=5)
            else:
                cache = StringIO(self.key)  # 将字符串通过StringIO转为file对象（self.key内容是从数据库查询的文本）
                key = paramiko.RSAKey.from_private_key(cache)  # 接收file对象
                # 使用key登录
                ssh.connect(hostname=self.ip, port=self.port, username=self.username, pkey=key)
            # 执行Shell命令，结果分别保存在标准输入，标准输出和标准错误
            stdin, stdout, stderr = ssh.exec_command(shell)
            stdout = stdout.read()
            error = stderr.read()
            # 判断stderr输出是否为空，为空则打印运行结果，不为空打印报错信息
            ssh.close()
            if not error:
                return {'code':200, 'msg':'执行命令成功', 'data': stdout}
            else:
                return {'code':500, 'msg':'执行命令失败', 'data': error}
        except Exception as e:
            return {'code':500, 'msg':'SSH连接失败! 错误信息： %s' % e}

    def scp(self, local_file, remote_file):
        # 绑定实例
        ts = paramiko.Transport((self.ip, self.port))
        try:
            if self.password:
                ts.connect(username=self.username, password=self.password)
            else:
                cache = StringIO(self.key)
                key = paramiko.RSAKey.from_private_key(cache)
                ts.connect(username=self.username, pkey=key)
            sftp = paramiko.SFTPClient.from_transport(ts)
            try:
                sftp.put(localpath=local_file, remotepath=remote_file)
                ts.close()
                return {'code':200, 'msg':'上传文件成功'}
            except Exception as e:
                return {'code':500, 'msg':'上传文件失败 %s' %e }
        except Exception as e:
            return {'code':500, 'msg':'SSH连接失败 %s' %e }

    # 新增一个ssh验证方法
    def test(self):
        result = self.command('ls')
        return result

if __name__ == '__main__':
    ssh = SSH('192.168.0.200', 22, 'root', '123456')
    ssh.test()
    local_file=os.path.join(os.getcwd(),'local_host_collect_linux.py')
    result = ssh.scp(local_file, '/tmp/local_host_collect_linux.py')
    result = ssh.command('chmod +x /tmp/local_host_collect_linux.py')
    result = ssh.command('python /tmp/local_host_collect_linux.py')

    print(result)
```

#### 示例 3

`logger.py`

```python
#!/usr/bin/env python
"""
logger.py: provides logging methods
"""

# from python lib
import logging
import sys
import os


class Log:
    """
    Singleton class to create log object
    """

    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super().__new__(cls)
        return cls.instance

    def initialise(self, logfile, level='DEBUG'):
        logger = logging.getLogger('qcs')
        logger.propagate = True
        logger.setLevel(level)

        # create stream handler
        fh = logging.StreamHandler(open(logfile, "w"))
        sh = logging.StreamHandler(sys.stdout)

        # create formatter
        formatter = logging.Formatter(
            '%(asctime)s %(levelname)s %(message)s')

        # add formatter to sh
        fh.setFormatter(formatter)
        sh.setFormatter(formatter)

        # add sh to logger
        logger.addHandler(sh)
        logger.addHandler(fh)
        self.logger = logger
        return self.logger

    def __repr__(self):
        return "{}()".format(self.__class__.__name__)

    def debug(self, *args, **kwargs):
        self.logger.debug(*args, **kwargs)

    def info(self, *args, **kwargs):
        self.logger.info(*args, **kwargs)

    def warn(self, *args, **kwargs):
        self.logger.warn(*args, **kwargs)

    def error(self, *args, **kwargs):
        self.logger.error(*args, **kwargs)

    def critical(self, *args, **kwargs):
        self.logger.critical(*args, **kwargs)


if __name__ == '__main__':
    print("Module loaded successfully")
    if os.environ.get('USE_ROBOT_LOGGER', None) == "True":
        from libs.log.logger import Log

        log = Log()
    else:
        log = Log()

    # some sample tests
    logfile = "test_log.log"
    log.initialise(logfile)
    print("I'm not using any logger")
    log.info("This is info line")
    log.debug("This is debug line")
    log.error("This is error line")
```

`ssh_lib.py`

```python
#!/usr/bin/env python
# -*- coding:utf8 -*-
# auther: 18793
# Date：2021/11/26 10:13
# filename: ssh_lib.py
# from python lib
import os
import sys

import paramiko
import pexpect
import time

# from external lib
from scp import SCPClient

# from qcs-automation libs
from libs.log import Log

# create log object
log = Log()


# username = sys.argv[1]


class SshConn(object):
    """ 一个ssh的类 """

    def __init__(self, ip, user, password):
        self.ip_address = ip
        self.user = user
        self.password = password
        self.conn = None

    def _init_connection(self):
        """
        Initiate ssh connection
        :return: None
        """
        try:
            self.conn = paramiko.SSHClient()
            self.conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.conn.connect(self.ip_address, username=self.user,
                              password=self.password)
            child = pexpect.spawn('ssh {}@{}'.format(self.user,
                                                     self.ip_address))
            res = child.expect([pexpect.TIMEOUT, ' (yes/no)?'])
            child.sendline('yes')
            # This sleep will help for pexpect to work
            time.sleep(5)
        except Exception as e:
            log.error("Unable to connect remote server")

    def execute_command(self, cmd):
        """
        Execute command
        :param cmd: Command to be executed
        :return: return tuple of (stdout, stderr)
        """
        try:
            if not isinstance(cmd, str):
                cmd = ' '.join(arg for arg in cmd)
            if not self.conn:
                self._init_connection()
            log.info("Executing command: {} on {}".format(cmd,
                                                          self.ip_address))
            stdin, stdout, stderr = self.conn.exec_command(cmd)
            try:
                stdoutbuffer = stdout.read()
            except Exception as e:
                stdout = str(e)

            try:
                stderrbuffer = stderr.read()
            except Exception as e:
                stderr = str(e)

            try:
                if not isinstance(stdout, str):
                    status = stdout.channel.recv_exit_status()
                else:
                    status = None
            except Exception as e:
                status = str(e)

            if not isinstance(stdout, str):
                stdout = stdoutbuffer.decode('utf8')
            if not isinstance(stderr, str):
                stderr = stderrbuffer.decode('utf8')
            log.info("Command status: {}".format(status))
            log.debug(stdout.splitlines())
            return (status, stdout.splitlines(), stderr.splitlines())
        except Exception as e:
            log.error("Unable to connect remote server {}" \
                      .format(self.ip_address))
            log.error(e)
            if 'SSH session not active' in str(e):
                log.info("Restablising connection on {}" \
                         .format(self.ip_address))
                # re-establish connection and execute the command
                self._init_connection()
                self.execute_command(cmd)
            return None, None, None

    def scp_get(self, remotepath, localpath, recursive=False):
        """
        Scp files/dir from SSH server
        """
        self._init_connection()
        scp = SCPClient(self.conn.get_transport(), buff_size=16384, socket_timeout=15.0)
        try:
            scp.get(remotepath, localpath, recursive, preserve_times=True)
        except Exception as e:
            log.info("Hit exception while scp_get from {} to {} on {}".format(
                remotepath, localpath, self.ip_address))
            log.info(e)
            raise
        return True

    def scp_put(self, localpath, remotepath, recursive=False):
        """
        Scp files/dir to SSH server
        """
        self._init_connection()
        scp = SCPClient(self.conn.get_transport())
        try:
            scp.put(localpath, remotepath, recursive)
        except Exception as e:
            log.info("Hit exception while scp_put from {} to {} on {}".format(
                localpath, remotepath, self.ip_address))
            log.info(e)
            raise
        return True

    def copy_command(self, localpath, remotepath):
        """
        copy file to remote server
        :param localpath: local path of the file
        :param remotepath: path where file should get copied
        """
        try:
            if not self.conn:
                self._init_connection()
            sftp = self.conn.open_sftp()
            try:
                log.info(sftp.stat(remotepath))
                log.info("File exists {}".format(remotepath))
            except IOError:
                log.info("Copying file {} to {}".format(localpath, remotepath))
                sftp.put(localpath, os.path.abspath(remotepath))
            sftp.close()
        except paramiko.SSHException as e:
            log.error("Connection Error: {}".format(e))


if __name__ == '__main__':
    print("Module loaded successfully.")
    logfile = "test_log.log"
    log.initialise(logfile)
    hu = SshConn("172.16.60.236", "root", "admin#123")
    # 复制文件到本地
    hu.copy_command("./test_log.log", "/home/tst_log.log")
    # 在远程环境执行命令
    print(hu.execute_command("hostname"))
    # 从远程拷贝文件到本地
    hu.scp_get("/home/go_muke", ".", recursive=True)
    # 从本地上传文件到远程
    hu.scp_put("/home/aaa", "/home/", recursive=True)
```

#### 示例 4

封装一个拉取数据到本地的 SSH 模块，这个模块命名为 MySSH.py 代码如下。

```python
import paramiko, math,json

class MySSH:
    def __init__(self, address, username, password, default_port):
        self.address = address
        self.default_port = default_port
        self.username = username
        self.password = password

    def Init(self):
        try:
            self.ssh_obj = paramiko.SSHClient()
            self.ssh_obj.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh_obj.connect(self.address, self.default_port, self.username, self.password, timeout=3,
                                 allow_agent=False, look_for_keys=False)
            self.sftp_obj = self.ssh_obj.open_sftp()
        except Exception:
            return False

    def BatchCMD(self, command):
        try:
            stdin, stdout, stderr = self.ssh_obj.exec_command(command, timeout=3)
            result = stdout.read()
            if len(result) != 0:
                result = str(result).replace("\\n", "\n")
                result = result.replace("b'", "").replace("'", "")
                return result
            else:
                return None
        except Exception:
            return None

    def CloseSSH(self):
        try:
            self.sftp_obj.close()
            self.ssh_obj.close()
        except Exception:
            pass

    def GetSystemVersion(self):
        return self.BatchCMD("uname")

    # 测试主机连通率
    def GetPing(self):
        try:
            if self.GetSystemVersion() != None:
                print("{} 已连通.".format(self.address))
                return True
            else:
                return False
        except Exception:
            return False

    # 拉取磁盘数据到本地，并返回字典
    def GetAllDiskSpace(self):
        ref_dict = {}
        cmd_dict = {"Linux\n": "df | grep -v 'Filesystem' | awk '{print $5 \":\" $6}'",
                    "AIX\n": "df | grep -v 'Filesystem' | awk '{print $4 \":\" $7}'"
                    }
        try:
            os_version = self.GetSystemVersion()
            for version, run_cmd in cmd_dict.items():
                if (version == os_version):
                    os_ref = self.BatchCMD(run_cmd)
                    ref_list = os_ref.split("\n")
                    for each in ref_list:
                        if each != "":
                            ref_dict[str(each.split(":")[1])] = str(each.split(":")[0])
            print("利用率字典: {}".format(ref_dict))
            return ref_dict
        except Exception:
            return False

    # 拉取内存数据到本地。
    def GetAllMemSpace(self):
        cmd_dict = {"Linux\n": "cat /proc/meminfo | head -n 2 | awk '{print $2}' | xargs | awk '{print $1 \":\" $2}'",
                    "AIX\n": "svmon -G | grep -v 'virtual' | head -n 1 | awk '{print $2 \":\" $4}'"
                    }
        try:
            os_version = self.GetSystemVersion()
            for version, run_cmd in cmd_dict.items():
                if (version == os_version):
                    os_ref = self.BatchCMD(run_cmd)
                    mem_total = math.ceil(int(os_ref.split(":")[0].replace("\n", "")) / 1024)
                    mem_free = math.ceil(int(os_ref.split(":")[1].replace("\n", "")) / 1024)
                    percentage = 100 - int(mem_free / int(mem_total / 100))
                    print("利用百分比: {}  \t 总内存: {}  \t 剩余内存: {}".format(percentage,mem_total,mem_free))
                    return str(percentage) + " %"
        except Exception:
            return False

    # 获取CPU利用率数据
    def GetCPUPercentage(self):
        ref_dict = {}
        cmd_dict = {"Linux\n": "vmstat | tail -n 1 | awk '{print $13 \":\" $14 \":\" $15}'",
                    "AIX\n": "vmstat | tail -n 1 | awk '{print $14 \":\" $15 \":\" $16}'"
                    }
        try:
            os_version = self.GetSystemVersion()
            for version, run_cmd in cmd_dict.items():
                if (version == os_version):
                    os_ref = self.BatchCMD(run_cmd)
                    ref_list = os_ref.split("\n")
                    for each in ref_list:
                        if each != "":
                            each = each.split(":")
                            ref_dict = {"us": each[0], "sys": each[1], "idea": each[2]}
            print("CPU利用率数据: {}".format(ref_dict))
            return ref_dict
        except Exception:
            return False

    # 获取到系统负载利用率 也就是一分钟负载五分钟负载十五分钟负载
    def GetLoadAVG(self):
        ref_dict = {}
        cmd_dict = {"Linux\n": "cat /proc/loadavg | awk '{print $1 \":\" $2 \":\" $3}'",
                    "AIX\n": "uptime | awk '{print $10 \":\" $11 \":\" $12}'"
                    }
        try:
            os_version = self.GetSystemVersion()
            for version, run_cmd in cmd_dict.items():
                if (version == os_version):
                    os_ref = self.BatchCMD(run_cmd)
                    ref_list = os_ref.split("\n")
                    for each in ref_list:
                        if each != "":
                            each = each.replace(",","").split(":")
                            ref_dict = {"1avg": each[0],"5avg": each[1],"15avg": each[2]}
                            print("负载利用率: {}".format(ref_dict))
                            return ref_dict
            return False
        except Exception:
            return False

    # 检测指定进程是否存活
    def CheckProcessStatus(self,processname):
        cmd_dict = {"Linux\n": "ps aux | grep '{0}' | grep -v 'grep' | awk {1} | wc -l".format(processname,"{'print $2'}"),
                    "AIX\n": "ps aux | grep '{0}' | grep -v 'grep' | awk {1} | wc -l".format(processname,"{'print $2'}")
                    }
        try:
            os_version = self.GetSystemVersion()
            for version, run_cmd in cmd_dict.items():
                if (version == os_version):
                    os_ref = self.BatchCMD(run_cmd)
                    ret_flag = str(os_ref.split("\n")[0].replace(" ","").strip())
                    if ret_flag != "0":
                        return True
            return False
        except Exception:
            return "None"

    # 检测指定端口是否存活
    def CheckPortStatus(self,port):
        cmd_dict = {"Linux\n": "netstat -antp | grep {0} | awk {1}".format(port,"{'print $6'}")
            ,       "AIX\n": "netstat -ant | grep {0} | head -n 1 | awk {1}".format(port,"{'print $6'}")
                    }
        try:
            os_version = self.GetSystemVersion()
            for version, run_cmd in cmd_dict.items():
                if (version == os_version):
                    os_ref = self.BatchCMD(run_cmd)
                    ret_flag = str(os_ref.split("\n")[0].replace(" ","").strip())
                    if ret_flag == "LISTEN" or ret_flag == "ESTABLISHED":
                        return True
            return False
        except Exception:
            return False
```

### 6.使用 paramiko 部署监控程序

下面是一个使用 paramiko 的完整例子。

在这个例子中，我们将远程服务器的 ip 地址保存在 hosts 文件中，并通过一个 for 循环遍历该文件中的 ip 地址。

每一个 ip 都会建立一个连接，然后将本地的 monitor.py 文件上传到远程服务器，上传到远程服务器以后，通过 SFTPClient 的 chmod 方法修改 monitor.py 文件的权限。

如下所示：

`depoly_monitor_with_paramiko.py`

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
from __future__ import print_function
import paramiko

def depoly_monitor(ip):

    with paramiko.SSHClient() as client:
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(ip, 2092, 'lmx')

        stdin, stdout, stderr = client.exec_command('ls -l')
        print(stdout.readlines())

        with client.open_sftp() as sftp:
            sftp.put('monitor.py', 'monitor.py')
            sftp.chmod('monitor.py', 0o755)


def main():
    with open('hosts') as f:
        for line in f:
            depoly_monitor(line.strip())


if __name__ == '__main__':
    main()
```

我们在介绍 SSHClient 和 SFTClient 类时仅仅介绍了如何建立连接。

在生产环境中，我们还应当调用 SSHClient 与 SFTPClient 对象的 close 方法及时关闭连接。

此外，也可以像这里的例子一样，使用 Python 的上下文管理器及时关闭连接。

### 7.使用 paramiko 部署 agent 程序

```python
import paramiko

def deploy_agent(ip, username, password, local_file, remote_dir):
    # 创建SSH客户端
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        # 与服务器建立连接
        client.connect(ip, username=username, password=password)

        # 创建SFTP客户端
        sftp = client.open_sftp()

        # 将本地的agent文件上传到远程服务器
        remote_file = f'{remote_dir}/agent.py'
        sftp.put(local_file, remote_file)

        # 在远程服务器上执行agent
        stdin, stdout, stderr = client.exec_command(f'python3 {remote_file}')

        # 打印执行的返回结果
        print(stdout.read().decode())
        print(stderr.read().decode())

        # 关闭SFTP连接
        sftp.close()

    except Exception as e:
        print(f'在部署过程中出现了错误：{e}')

    finally:
        # 关闭SSH连接
        client.close()

# 测试上述函数
deploy_agent('192.168.0.101', 'username', 'password', 'path/to/your/agent.py', '/remote/directory')
```

[Python paramiko 模块](https://www.yuque.com/fcant/python/lnie5i)

[Python Paramiko 实现 sftp 文件上传下载](https://www.yuque.com/fcant/python/lul9yw#wvnAX)

## 7.5 Fabric 自动化部署工具

### 1.简介

Fabric 是基于 Python2.5 以上版本实现的 SSH 命令行工具，简化了 SSH 的应用程序部署及系统管理任务。

提供了系统基础的操作组件，可以实现本地或远程 shell 命令，包括命令执行、文件上传、下载及完整执行日志输出等功能 Fabric 在 paramiko 的基础上做了更高一层的封装，操作起来会更加简单。

官方网站：http://www.fabfile.org

### 2.Fabric 安装

- pip 安装

```sh
pip install fabric==1.14.0
easy_install fabric
```

- 源码安装

```sh
yum -y install python-setuptools
wget https://pypi.python.org/packages/source/F/Fabric/Fabric-1.8.2.tar.gz --no-check-certificate
tar -zxvf Fabric-1.8.2.tar.gz
cd Fabric-1.8.2
python setup.py instal
```

eg:

```python
#!/usr/bin/env python
from fabric.api import run

def host_type():
    run('uname -s')
```

输出信息

```sh
[root@pxe-server 03.批量运维管理器Fabric]# fab -H 192.168.0.100 host_type
[192.168.0.100] Executing task 'host_type'
[192.168.0.100] run: uname -s
[192.168.0.100] Login password for 'root':
[192.168.0.100] out: Linux
[192.168.0.100] out:


Done.
Disconnecting from 192.168.0.100... done.
```

```sh
@runs_once  #主机遍历过程中，只有第一台触发此函数
```

### 3.查看本地与远程主机信息

`simple01.py`

```python
#!/usr/bin/env python
from fabric.api import *

env.user='root'
env.hosts=['192.168.1.21','192.168.1.22']
env.password='SKJh935yft#'

@runs_once
def local_task():
    local("uname -a")

def remote_task():
    with cd("/data/logs"):
        run("ls -l")
```

输出信息

```sh
[root@pxe-server 03.批量运维管理器Fabric]# fab -f simple01.py local_task
[192.168.0.100] Executing task 'local_task'
[localhost] local: uname -a
Linux pxe-server 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux

Done.
```

```sh
[root@pxe-server 03.批量运维管理器Fabric]# fab -f simple01.py remote_task
[192.168.0.100] Executing task 'remote_task'
[192.168.0.100] run: ls -l
[192.168.0.100] out: 总用量 221060
[192.168.0.100] out: -rw-r--r-- 1 root root 185540433 8月  17 21:57 jdk-linux-x64.tar.gz
[192.168.0.100] out: -rw-r--r-- 1 root root  40824607 8月  17 21:57 vagrant_2.2.4_x86_64.rpm
[192.168.0.100] out:

[192.168.0.103] Executing task 'remote_task'
[192.168.0.103] run: ls -l
[192.168.0.103] out: 总用量 221060
[192.168.0.103] out: -rw-r--r-- 1 root root 185540433 8月  17 21:58 jdk-linux-x64.tar.gz
[192.168.0.103] out: -rw-r--r-- 1 root root  40824607 8月  17 21:58 vagrant_2.2.4_x86_64.rpm
[192.168.0.103] out:


Done.
Disconnecting from 192.168.0.100... done.
Disconnecting from 192.168.0.103... done.
```

### 4.动态获取远程目录列表

```python
#!/usr/bin/env python
from fabric.api import *

env.user='root'
env.hosts=['192.168.1.21','192.168.1.22']
env.password="SKJh935yft#"

@runs_once      ##主机遍历过程中，只有第一台触发此函数
def input_raw():
    return prompt("please input directory name:",default="/home")

def worktask(dirname):
    run("ls -l "+dirname)

@task
def go():       #限定只有go函数对fab命令可见
    getdirname = input_raw()
    worktask(getdirname)
```

输出信息

```sh
[root@pxe-server 03.批量运维管理器Fabric]# fab -f simple02.py go
[192.168.0.100] Executing task 'go'
please input directory name: [/home] /root
[192.168.0.100] run: ls -l /root
[192.168.0.100] out: 总用量 4
[192.168.0.100] out: -rw-------.  1 root root 1863 2月  13 2019 anaconda-ks.cfg
[192.168.0.100] out: drwxr-xr-x  14 root root  184 6月   4 12:52 docbook
[192.168.0.100] out: drwxr-xr-x   3 root root   22 6月   4 13:13 linuxidc-vagrant-project
[192.168.0.100] out:

[192.168.0.103] Executing task 'go'
[192.168.0.103] run: ls -l /root
[192.168.0.103] out: 总用量 4
[192.168.0.103] out: -rw-------.  1 root root 1863 2月  13 2019 anaconda-ks.cfg
[192.168.0.103] out: drwxr-xr-x  14 root root  184 6月   4 12:52 docbook
[192.168.0.103] out: drwxr-xr-x   3 root root   22 6月   4 13:13 linuxidc-vagrant-project
[192.168.0.103] out:


Done.
Disconnecting from 192.168.0.100... done.
Disconnecting from 192.168.0.103... done.
```

通过 Fabric 的 env 对象定义网关模式，即俗称的中转、堡垒机环境。

定义格式为“env.gateway=‘192.168.1.23’”，其中 IP“192.168.1.23”为堡垒机 IP，

再结合任务函数 **实现目标主机文件上传与执行** 的操作

### 5.网关模式文件上传与执行

```python
#!/usr/bin/env python
from fabric.api import *
from fabric.context_managers import *
from fabric.contrib.console import confirm

env.user='root'
env.gateway='192.168.1.23'      #定义堡垒机IP，作为文件上传、执行的中转设备
env.hosts=['192.168.1.21','192.168.1.22']

#假如所有主机密码都不一样，可以通过env.passwords字典变量一一指定
env.passwords = {
    'root@192.168.1.21:22': 'SKJh935yft#',
    'root@192.168.1.22:22': 'SKJh935yft#',
    'root@192.168.1.23:22': 'KJSD9325hgs'   #堡垒机账号信息
}

#本地安装包路径
lpackpath="/home/install/lnmp0.9.tar.gz"
#远程安装包路径
rpackpath="/tmp/install"

@task
def put_task():
    run("mkdir -p /tmp/install")
    with settings(warn_only=True):
        #上传安装包
        result = put(lpackpath, rpackpath)
    if result.failed and not confirm("put file failed, Continue[Y/N]?"):
        abort("Aborting file put task!")

@task
def run_task():
    #执行远程命令，安装lnmp环境
    with cd("/tmp/install"):
        run("tar -zxvf lnmp0.9.tar.gz")
        #使用with继续继承/tmp/install目录位置状态
        with cd("lnmp0.9/"):
            run("./centos.sh")

@task
#上传、安装组合
def go():
    put_task()
    run_task()
```

### 6.使用 fabric 进行文件打包、上传与校验

```python
#!/usr/bin/env python
from fabric.api import *
from fabric.context_managers import *
from fabric.contrib.console import confirm

env.user='root'
env.hosts=['192.168.1.21','192.168.1.22','192.168.1.23']
env.password='SKJh935yft#'


@task
@runs_once
def tar_task():     #本地打包任务函数，只执行一次
    with lcd("/data/logs"):
        local("tar -czf access.tar.gz access.log")
@task
def put_task():     #上传文件任务函数
    run("mkdir -p /data/logs")
    with cd("/data/logs"):
        with settings(warn_only=True):
            ##put（上传）出现异常时继续执行，非终止
            result = put("/data/logs/access.tar.gz", "/data/logs/access.tar.gz")
        if result.failed and not confirm("put file failed, Continue[Y/N]?"):
            ##出现异常时，确认用户是否继续，（Y继续）
            abort("Aborting file put task!")

@task
def check_task():           ##校验文件任务函数
    with settings(warn_only=True):
        #本地local命令需要配置capture=True才能捕获返回值
        lmd5=local("md5sum /data/logs/access.tar.gz",capture=True).split(' ')[0]
        rmd5=run("md5sum /data/logs/access.tar.gz").split(' ')[0]
    if lmd5==rmd5:          ##对比本地及远程文件md5信息
        print "OK"
    else:
        print "ERROR"

@task
def go():
    tar_task()
    put_task()
    check_task()
```

三个功能互相独立，可以分开运行

```sh
fab -f simple4.py tar_task #文件打包
fab -f simple4.py put_task #文件上传
fab -f simple4.py check_task #文件校验
```

组合在一起运行

```python
@task
def go():
    tar_task()
    put_task()
    check_task()
```

```sh
fab -f simple4.py go
```

### 7.使用 fabric 源码安装 redis

完整的 fabfile 代码如下：

`fabfile.py`

```python
#!/usr/bin/python
from fabric.api import (local, put, abort, run, cd, task, execute, settings,
                        env, runs_once, lcd, sudo)
from fabric.contrib.console import confirm
from fabric.colors import green

env.user = 'lmx'
env.port = 2092
env.hosts = open('hosts').readlines()

@task
@runs_once
def test():
    with settings(warn_only=True), lcd("redis-3.2.8"):
        result = local("make test", capture=True)
        if result.failed and not confirm("Tests failed. Continue anyway?"):
            abort("Aborting at user request.")
        else:
            green("All tests passed without errors!")

    with lcd("redis-3.2.8"):
        local("make clean")
    local("tar -czf redis-3.2.8.tar.gz redis-3.2.8")

@task
def deploy():
    put("redis-3.2.8.tar.gz",  "/tmp/redis-3.2.8.tar.gz")
    with cd("/tmp"):
        run("tar xzf redis-3.2.8.tar.gz")
        with cd("redis-3.2.8"):
            sudo("make install")

@task
def clean_file():
    with cd("/tmp"):
        sudo("rm -rf redis-3.2.8.tar.gz")
        sudo("rm -rf redis-3.2.8")

@task
def clean_local_file():
    local("rm -rf redis-3.2.8.tar.gz")

@task
def install():
    execute(test)
    execute(deploy)
    execute(clean_file)
    execute(clean_local_file)
```

将这里的代码保存到当前目录下的 fabfile.py 文件中，然后执行下面的命令运行即可：

```sh
$ fab --list
Available commands:


clean_file
clean_local_file
deploy
install
test
```

```sh
$ fab install
```

### 8.部署 LNMP 业务服务环境

业务上线之前最关键的一项任务便是环境部署，往往一个业务涉及多种应用环境，比如 Web、DB、PROXY、CACHE 等，本示例通过 env.roledefs 定义不同主机角色，

再使用 “@roles（'webservers'）” 修饰符绑定到对应的任务函数，实现不同角色主机的部署差异，详细源码如下：

```python
#!/usr/bin/env python
from fabric.colors import *
from fabric.api import *

env.user='root'

#定义业务角色分组
env.roledefs = {
    'webservers': ['192.168.1.21', '192.168.1.22'],
    'dbservers': ['192.168.1.23']
}

env.passwords = {
    'root@192.168.1.21:22': 'SKJxxxxxx',
    'root@192.168.1.22:22': 'SKJxxxxxx',
    'root@192.168.1.23:22': 'KJSxxxxx'
}

#webtask任务函数引用'webservers'角色修饰符
@roles('webservers')
#部署nginx php php-fpm等环境
def webtask():
    print yellow("Install nginx php php-fpm...")
    with settings(warn_only=True):
        run("yum -y install nginx")
        run("yum -y install php-fpm php-mysql php-mbstring php-xml php-mcrypt php-gd")
        run("chkconfig --levels 235 php-fpm on")
        run("chkconfig --levels 235 nginx on")


# dbtask任务函数引用'dbservers'角色修饰符
@roles('dbservers')
#部署mysql环境
def dbtask():
    print yellow("Install Mysql...")
    with settings(warn_only=True):
        run("yum -y install mysql mysql-server")
        run("chkconfig --levels 235 mysqld on")


# publictask任务函数同时引用两个角色修饰符
@roles ('webservers', 'dbservers')
def publictask():
    print yellow("Install epel ntp...")
    with settings(warn_only=True):
        run("rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm")
        run("yum -y install ntp")

def deploy():
    execute(publictask)
    execute(webtask)
    execute(dbtask)
```

程序生产环境的发布是业务上线最后一个环节，要求具备源码打 包、发布、切换、回滚、版本管理等功能，本示例实现了这一整套流程 功能，其中版本切换与回滚使用了 Linux 下的软链接实现。

### 9.生产环境代码包发布管理

![1698375442101](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698375442101.6qq3ts2r3e80.webp){: .zoom}

本示例实现了一个通用性很强的代码发布管理功能，支持快速部署与回滚，无论发布还是回滚，都可以通过切换 current 的软链来实现，非常灵活。

在生产环境中 Nginx 的配置如下：

```conf
server_name domain.com
index index.html index.htm index.php；
root /data/www/Lwebadmin/current；
```

将站点根目录指向 `/data/www/Lwebadmin/current`，由于使用 Linux 软链接做切换，管理员的版本发布、回滚操作用户无感知，同时也规范了我们业务上线的流程。

```python
#!/usr/bin/env python
from fabric.api import *
from fabric.colors import *
from fabric.context_managers import *
from fabric.contrib.console import confirm
import time

env.user='root'
env.hosts=['192.168.1.21','192.168.1.22']
env.password='SKJh935yft#'

#开发机项目主目录
env.project_dev_source = '/data/dev/Lwebadmin/'
#开发机项目压缩包存储目录
env.project_tar_source = '/data/dev/releases/'
#项目压缩包名前缀，文件名为release.tar.gz
env.project_pack_name = 'release'

#项目生产环境主目录
env.deploy_project_root = '/data/www/Lwebadmin/'
#项目发布目录，位于主目录下面
env.deploy_release_dir = 'releases'
#对外服务的当前版本软链接
env.deploy_current_dir = 'current'

#版本号
env.deploy_version=time.strftime("%Y%m%d")+"v2"

#获得用户输入的版本号，以便做版本回滚操作
@runs_once
def input_versionid():
    return prompt("please input project rollback version ID:",default="")

#打包本地项目主目录，并将压缩包存储到本地压缩包目录
@task
@runs_once
def tar_source():
    print yellow("Creating source package...")
    with lcd(env.project_dev_source):
        local("tar -czf %s.tar.gz ." % (env.project_tar_source + env.project_pack_name))
    print green("Creating source package success!")


#上传任务函数
@task
def put_package():
    print yellow("Start put package...")
    with settings(warn_only=True):
        with cd(env.deploy_project_root+env.deploy_release_dir):
            run("mkdir %s" % (env.deploy_version))  #创建版本目录
    env.deploy_full_path=env.deploy_project_root + env.deploy_release_dir + "/"+env.deploy_version

    with settings(warn_only=True):  #上传项目压缩包至此目录
        result = put(env.project_tar_source + env.project_pack_name +".tar.gz",env.deploy_full_path)
    if result.failed and no("put file failed, Continue[Y/N]?"):
        abort("Aborting file put task!")

    with cd(env.deploy_full_path):  #成功解压后删除压缩包
        run("tar -zxvf %s.tar.gz" % (env.project_pack_name))
        run("rm -rf %s.tar.gz" % (env.project_pack_name))

    print green("Put & untar package success!")


#为当前版本目录做软链接
@task
def make_symlink():
    print yellow("update current symlink")
    env.deploy_full_path=env.deploy_project_root + env.deploy_release_dir + "/"+env.deploy_version
    with settings(warn_only=True):
        #删除软链接，重新创建并指定软链源目录，新版本生效
        run("rm -rf %s" % (env.deploy_project_root + env.deploy_current_dir))
        run("ln -s %s %s" % (env.deploy_full_path, env.deploy_project_root + env.deploy_current_dir))
    print green("make symlink success!")

#版本回滚任务函数
@task
def rollback():
   #获得用户输入的回滚版本号
    print yellow("rollback project version")
    versionid= input_versionid()
    if versionid=='':
        abort("Project version ID error,abort!")

    env.deploy_full_path=env.deploy_project_root + env.deploy_release_dir + "/"+versionid
    #删除软链接，重新创建并指定软链源目录，新版本生效
    run("rm -f %s" % env.deploy_project_root + env.deploy_current_dir)
    run("ln -s %s %s" % (env.deploy_full_path, env.deploy_project_root + env.deploy_current_dir))
    print green("rollback success!")

#自动化程序版本发布入口函数
@task
def go():
    tar_source()
    put_package()
    make_symlink()
```

### 10. 综合案例: 使用 fabric 部署 Flask 应用

- flask 应用示例

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-

import redis
from flask import Flask

app = Flask(__name__)

@app.route('/user/<int:identify>')
def get(identify):
    r = redis.StrictRedis(host='10.166.226.152', port=6379, db=0)
    username = r.get(identify)

    if username is None:
        return "not found", 404
    else:
        return username

if __name__ == '__main__':
    app.run()
```

- 完整的 fabfile 代码如下：

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
from __future__ import print_function

from fabric.api import (cd, run, task, env, roles, put, execute, hide, set_missing_host_key_policyings, sudo)
from fabric.colors import red, green, yellow
from fabric.contrib.files import exists

env.user = 'lmx'
env.port = 2092
env.roledefs = { 'web': ["10.166.224.14", "10.166.224.140"],
               'db': ["10.166.226.152"] }

def is_redis_installed():
    with settings(hide('everything'), warn_only=True):
        result = run("netstat -tl | grep -w 6379")
        return result.return_code == 0

def install_redis():
    sudo("apt-get install redis-server")

def change_redis_conf():
    sudo("sed -i 's/bind 127.0.0.1/bind 0.0.0.0/' /etc/redis/redis.conf")

def reboot_redis():
    sudo("/etc/init.d/redis-server restart", pty=False)

@task
@roles('db')
def depoly_db():

    if is_redis_installed():
        print(yellow('redis was successfully installed'))
    else:
        install_redis()

        change_redis_conf()

        reboot_redis()

        print(green('redis has successfully installed'))

def is_python_package_installed(package):
    with settings(hide('everything'), warn_only=True):
        result = run("python -c 'import {0}'".format(package))
        return result.return_code == 0

def install_python_package(package):
    sudo('pip install {0}'.format(package))

def pip_install_if_need(package):
    if not is_python_package_installed(package):
        install_python_package(package)
        print(green('{0} has installed'.format(package)))
    else:
        print(yellow('{0} was installed'.format(package)))

def install_package():
    for package in ['gunicorn', 'flask', 'redis']:
        pip_install_if_need(package)

def kill_web_app_if_exists():
    with cd('/tmp'):
        if exists('app.pid'):
            pid = run('cat app.pid')
            print(yellow('kill app which pid is {0}'.format(pid)))
            with settings(hide('everything'), warn_only=True):
                run('kill -9 {0}'.format(pid))
        else:
            print(red('pid file not exists'))

def upload_web_app():
    put('app.py', '/tmp/app.py')

def run_web_app():
    with cd('/tmp'):
        run('gunicorn -w 1 app:app -b 0.0.0.0:5000 -D -p /tmp/app.pid --log-file /tmp/app.log', pty=False)

def restart_web_app():
    kill_web_app_if_exists()
    run_web_app()

@task
@roles('web')
def depoly_web():

    install_package()

    upload_web_app()

    restart_web_app()

@task
def depoly_all():
    execute(depoly_db)
    execute(depoly_web)
```

在 fabfile 文件中，首先导入了 Fabric 的 API,然后，通过修改 env 字典的方式对 Fabric 进行了简单的配置。

这个例子在 env 字典中配置了访问远程服务器的用户名和端口号，并且，根据服务器的不用作用定义了 2 个 role。

服务器分类以后，部署服务只需要引用 role 的名称即可，非常方便。

通过 role 名称引用服务器的方式，在服务器数量较多时优势更为明显。

我们这里的 fabfile 文件定义了 3 个 task,分别是 depoly_db、depoly_web 和 depoly_all。

其中，depoly_all 是对 depoly_db 和 depoly_web 的封装。

封装以后，我们既可以分别部署数据库服务器和 Wb 服务器，也可以一次部署所有服务器。

在 depoly_db 部署任务中，首先通过 redis 的端口号是否存在判断 redis 数据库是否已经存在。

如果 redis 数据库已经存在并启动完成，什么都不做，否则，我们将会执行 apt-get 命令安装 redis 数据库。

redis 数据库安装完成以后只能本地访问，因此，使用 sed 命令修改 redis 数据库的配置文件，修改完成以后重启 redis 数据库。

在 depoly_web 部署任务中，首先安装相关的依赖包，包括 Flask 框架、gunicorn 服务器与访问 rdis 数据库的驱动。软件安装完成以后，将我们的应用程序上传到远程服务器中并重启 Web 服务器。

在重启 Web 服务器的过程中，我们首先读取 app.pid 文件中的进程 id,

如果该文件不存在，则认为应用没有运行，如果该文件存在，则读取文件中的进程 id 并通过 kill 命令关闭进程。关闭应用程序以后，再次使用 gunicorn 服务器启动应用程序，以达到重启应用的目的。

有了上面这个 fabfile 文件以后，我们只需要执行 `fab depoly_all`命令就能够一键完成数据服务和 Wb 服务的部署工作。

当我们有一个新的环境时，只需要简单配置服务器的地址就能够完成一键部署。

执行下面的命令完成数据服务和 Wb 服务的部署工作

```sh
$ fab depoly_all
```

### 11.Fabric 常用 API

```sh
local         # 执行本地命令，如local('uname -s')
lcd           # 切换本地目录，如lcd('/home')
cd            # 切换远程目录
run           # 执行远程命令
sudo          # sudo方式执行远程命令，如sudo('/etc/init.d/httpd start')
put           # 上次本地文件导远程主机，如put('/home/user.info','/data/user.info')
get           # 从远程主机下载文件到本地，如：get('/data/user.info','/home/user.info')
prompt        # 获得用户输入信息，如：prompt('please input user password:')
confirm       # 获得提示信息确认，如：confirm('Test failed,Continue[Y/N]?')
reboot        # 重启远程主机，如：reboot()

@task         # 函数修饰符，标识的函数为fab可调用的，非标记对fab不可见，纯业务逻辑
@runs_once    # 函数修饰符，标识的函数只会执行一次，不受多台主机影响
```

## 7.6 Python 实现定时任务的九种方案

https://www.yuque.com/fcant/python/oru0rr24l6q7628c
