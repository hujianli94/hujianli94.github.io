# 9.Python打造MySQL专家系统


## 9.1 Python语言高级特性

### 9.1.1 Python生成器


#### 1.迭代器协议


生成器自动实现了迭代器协议，而迭代器协议对很多人来说是一个较为抽象的概念。

所以，为了更好地理解生成器，需要简单回顾一下迭代器协议的概念。

迭代器协议是指：**对象需要提供next方法，它要么返回迭代中的下一项，要么就引起一个Stoplteration异常以终止迭代。**

可迭代对象就是实现了迭代器协议的对象。

所谓协议，只是一种约定，可迭代对象实现迭代器协议，Python的内置工具（如for循环、sum、min、max函数等）使用迭代器协议访问对象。

例如，在所有语言中都可以使用for循环遍历数组，而Python的list底层实现是一个保存对象引用的数组，因此，我们可以使用for循环来遍历1ist。如下所示：

```sh
In [1]: for n in [1,2,3,4]:
   ...:     print(n)
   ...:
1
2
3
4
```

for 不但可以遍历list，还可以遍历文件对象，如下所示：

```sh
In [2]: with open('/etc/passwd') as f:
   ...:     for line in f:
   ...:         print(line)
   ...:
```

为什么在Python中，文件还可以使用for循环进行遍历呢？

这是因为，文件对象在Python语言中实现了迭代器协议。

for循环并不知道它遍历的是一个文件对象，它只负责使用迭代器协议访问对象。

正是由于Pythor的文件对象实现了迭代器协议，我们才得以使用如此方便的方式访问文件。

如下所示：

```sh
In [3]: f = open("/etc/passwd")

In [4]: dir(f)
Out[4]:
['_CHUNK_SIZE',
 '__class__',
 '__del__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__enter__',
 '__eq__',
 '__exit__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__getstate__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__iter__',
 '__le__',
 '__lt__',
 '__ne__',
 '__new__',
 '__next__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
# .....
```
通过Python内置的dir函数可以看到，文件对象具有一个名为`__next__`的方法。

`__next__`方法就是迭代器协议的一部分，它要么返回迭代中的下一项，要么就抛出一个StopIteration异常。

for循环会自动调用`__next__`方法获取文件中的内容，与此同时，for循环也会通过结束循环的方式自动处理StopIteration异常。


#### 2.生成器

理解了迭代器协议和可迭代对象以后，再来看生成器会好理解很多。

Python使用生成器对延迟操作提供了支持。

所谓延迟操作是指在需要的时候才产生结果，而不是立即产生结果。

Python有两种不同的方式提供生成器：

1) 生成器函数：与普通函数定义类似，但是，使用yield语句而不是return语句返回结果。yild语句一次返回一个结果，在每个结果中间挂起函数的状态，以便下次从它离开
的地方继续执行；

2) 生成器表达式：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表。


下面是一个生成器的例子，使用生成器返回自然数的平方：

```python
def gensquares(N):
    for i in range(N):
        yield i ** 2


for item in gensquares(5):
    print(item)
```

相同的功能使用普通函数实现：

```python
def gensquares(N):
    res = []
    for i in range(N):
        res.append(i * i)
    return res


for item in gensquares(5):
    print(item)
```


可以看到，使用生成器以后，实现相同功能的代码行数更少了。

在我们的gensquares函数中，原来需要5行代码，现在需要3行代码即可。

我们再来看一个例子，以加深读者对生成器的理解。假设现在有一个列表，列表中包含若干整数。接下来，我们需要对列表进行过滤。在过滤以后的结果中只保留列表中偶数的数字。


```python
def get_even_num(l):
    res = []
    for item in l:
        if item % 2 == 0:
            res.append(item)
    return res


def main():
    l = range(5)
    for item in get_even_num(l):
        print(item)


if __name__ == '__main__':
    main()
```

使用生成器后，整体架构不变，但是代码更加清晰。如下所示：


```python
def get_even_num(l):
    for item in l:
        if item % 2 == 0:
            yield item


def main():
    l = range(5)
    for item in get_even_num(l):
        print(item)


if __name__ == '__main__':
    main()
```


生成器的表达式与列表推导式非常相似，使用列表推导式将一次产生所有结果。

而生成器不会一次产生所有结果，他会返回按需产生结果的一个对象，如下所示：

```sh
In [5]: squres = [x**2 for x in range(5)]

In [6]: squres
Out[6]: [0, 1, 4, 9, 16]
```

```sh
In [7]: squres = (x**2 for x in range(5))

In [8]: squres
Out[8]: <generator object <genexpr> at 0x7f06bb455a40>

In [9]: next(squres)
Out[9]: 0

In [10]: next(squres)
Out[10]: 1

In [11]: next(squres)
Out[11]: 4

In [12]: list(squres)
Out[12]: [9, 16]
```

在Python语言中，不但使用迭代器协议让for循环变得更加通用，而且，大部分内置函数也可以使用迭代器协议访问对象。

例如，sum函数是Python的内置函数，该函数使用迭代器协议访问对象，而生成器实现了迭代器协议，所以，我们可以直接这样计算一系列
值的和：

```sh
In [14]: sum((x ** 2 for x in range(4)))
Out[14]: 14
```

为了简单起见，我们也可以省略生成器中的圆括号。如下所示

```sh
In [15]: sum(x ** 2 for x in range(4))
Out[15]: 14
```

使用列表推导式的反面教材，加大内存消耗

```sh
In [15]: sum([x ** 2 for x in range(4)])
Out[15]: 14
```

#### 3.生成器与函数

Python的生成器语法上和函数类似，生成器函数和常规函数几乎是一样的，它们都是使用def语句进行定义。

差别在于：

1. 从语法上看，生成器使用yield语句返回一个值，而常规函数使用return语句返回一个值；

2. 从使用上看，Python的生成器自动实现了迭代器协议。由于生成器实现了迭代器协议，所以，我们可以在迭代环境中（如for循环、sum函
数、min函数等)使用生成器；

3. 从Python实现上看，生成器的yield语句挂起生成器函数的状态，保留足够的信息，以便之后从它离开的地方继续执行。


使用生成器的主要原因是，生成器支持延迟计算。

所谓延迟计算，就是一次返回一个结果，而不是一次返回所有结果。这对于大数据量处理将非常有用。


比较生成器和列表推导式的内存占用。
```python
import sys


def generator_test():
    gen = (x for x in range(100000))
    print(sys.getsizeof(gen))       # 200


def list_comprehension_test():
    lst = [x for x in range(100000)]
    print(sys.getsizeof(lst))       # 800984


generator_test()
list_comprehension_test()
```

从上面的输出结果中可以看出，在创建一个包含100000个元素的列表推导式时，内存占用800984字节。而在生成器表达式中，内存占用200字节。



除了延迟计算，生成器还能有效提高代码可读性。

例如，现在有一个需求，求一段文字中每个单词出现的位置。如果不使用生成器，程序大概是下面这样：

```python
def index_words(text):
    result = []
    if text:
        result.append(0)
    for index, letter in enumerate(text, 1):
        if letter == ' ':
            result.append(index)
    return result

text = """The Zen of Python, by Tim Peters"""
print(index_words(text))
```

使用生成器后，程序变得清晰。

```python
def index_words(text):
    if text:
        yield 0
    for index, letter in enumerate(text, 1):
        if letter == ' ':
            yield index

text = """The Zen of Python, by Tim Peters"""
print(list(index_words(text)))
```


yield语句和return语句一样返回一个值，生成器可以提高程序效率和代码的可读性。




### 9.1.2 Python装饰器

Python2.4开始提供了装饰器(decorator),装饰器作为修改函数的一种便捷方式，为工程师编写程序提供了便利性和灵活性。

适当使用装饰器能够有效提高代码的可读性和可维护性。装饰器本质上就是一个函数，这个函数接受其他函数作为参数，并将其以一个新的
修改后的函数进行替换。


#### 1.函数对象


```python
def say_hi():
    print("Hi")


hello = say_hi

hello()
```




#### 2.嵌套函数

```python
def outer(x, y):
    def inner():
        return x + y

    return inner


f = outer(1, 2)
print(f())
```

在这个例子中，我们定义了一个名为outer的函数，并在outer函数内部定义了inner函数。

outer函数以返回值的形式返回inner函数，我们将返回值保存在变量f中，f引用的是outer函数内部的inner函数。所以，当我们调用函数f时，实际是调用的inner函数。


#### 3.装饰器原型


```python
def greeting(f):
    f()


def say_hi():
    print("Hi")


def say_hello():
    print("Hello")


greeting(say_hi)
greeting(say_hello)
```


接下来看一个更加复杂的例子。在这个例子中，我们用到了前面介绍的所有知识。

首先，我们定义了一个名为say_hi的函数和一个名为bread的函数，bread函数接收say_hi函数作为参数。

在bread函数中，我们还定义了一个名为wrapper的嵌套函数。

在嵌套函数中，我们首先打印begin消息，然后再调用作为函数参数传递进来的say_hi函数，在say_hi函数调用完成以后，再打印end消息。

最后，我们将嵌套函数作为返回值，返回给了bread函数的调用者。bread函数的调用者得到返回值以后，执行函数调用。如下所示：


```python
def say_hi():
    print("Hi")


def bread(f):
    def wrapper(*args, **kwargs):
        print("begin call {0}".format(f.__name__))
        f()
        print("finish call {0}".format(f.__name__))

    return wrapper


say_hi_copy = bread(say_hi)
say_hi_copy()

```

上面的代码执行效果如下：

```sh
begin call say_hi
Hi
finish call say_hi
```


在上面这段程序中，bread函数接收say_hi函数作为参数，并将其以一个新的修改后的函数进行替换。

可以看到，bread函数实现的逻辑与前面提到的装饰器的逻辑是一样的。

这是因为bread本身就是一个合法的装饰器。

接下来，只需要使用Python的语法糖改造前面的程序，就完成了一个装饰器的定义和使用的完整例子。如下所示：

```python
def bread(f):
    def wrapper(*args, **kwargs):
        print("begin")
        f()
        print("end")

    return wrapper


@bread
def say_hi():
    print("Hi")


say_hi()
```


#### 4.装饰器的例子

假设我们有一个特殊的栈，这个栈不但实现了先进后出的数据结构，还会检查栈的用户是否具有相应的用户权限，只有管理员才能进行栈操作，如下


```python
def check_is_admin(username):
    if username != 'admin':
        raise Exception("This user is not allowed to put/get elem")

class Stack:
    def __init__(self):
        self.storage = []

    def put(self, username, elem):
        check_is_admin(username=username)
        self.storage.append(elem)

    def get(self, username):
        check_is_admin(username=username)
        if not self.storage:
            raise Exception("There is no elem in stack")
        return self.storage.pop()
```


使用装饰器之后，效果会更好，如下所示

```python
def check_is_admin(f):
    def wrapper(*args, **kwargs):
        if kwargs.get('username') != 'admin':
            raise Exception("This user is not allowed to put/get elem")
        return f(*args, **kwargs)
    return wrapper


class Stack:
    def __init__(self):
        self.storage = []

    @check_is_admin
    def put(self, username, elem):
        self.storage.append(elem)

    @check_is_admin
    def get(self, username):
        if not self.storage:
            raise Exception("There is no elem in stack")
        return self.storage.pop()
```

在这个例子中，我们使用装饰器进行参数检查。装饰器作为一种修改函数的方式，灵活应用，可以实现很多有意思的功能。例如：


1. 注入参数。为函数提供默认参数，生成新的参数等；
2. 记录函数的行为。可以统计函数的调用次数，缓存函数的结果，计算函数调用耗费的时间；
3. 预处理与后处理；
4. 修改调用时的上下文。


例如，下面的benchmark函数就是一个统计函数运行时间的装饰器。

```python
from __future__ import print_function
import time

def benchmark(func):
    def wrapper(*args, **kwargs):
        t = time.time()
        res = func(*args, **kwargs)
        print(func.__name__, time.time() - t)
        return res
    return wrapper

@benchmark
def add(a, b):
    time.sleep(1)
    return a + b

print(add(1, 2))
```


#### 5. 使用装饰器之后函数属性的变化


```python
from __future__ import print_function
import time


def benchmark(func):
    def wrapper(*args, **kwargs):
        t = time.time()
        res = func(*args, **kwargs)
        print(func.__name__, time.time() - t)
        return res

    return wrapper


def mul(a, b):
    """
    Calculate the product of two numbers
    """
    return a * b


@benchmark
def add(a, b):
    """
    Calculate the sum of two numbers
    """
    return a + b


print(mul.__name__)     # mul
print(mul.__doc__)      # Calculate the product of two numbers

print(add.__name__)     # wrapper
print(add.__doc__)      # None
```

可以看到，我们在没有使用装饰器装饰的函数中可以正确获取函数的名字和帮助信息。

而使用了benchmark装饰器装饰的函数将无法获取函数的属性。这种情况也很好理解，因为装饰器接受一个函数作为参数，并将其以一个新的修改后的函数进行替换。

因此，当我们获取add函数的属性时，由于它被benchmark装饰器装饰过，所以我们获取到的函数属性，实际上是装饰器返回给我们的这个函数的属性。

这个问题也很好解决，使用标准库的functools模块中的wraps装饰器即可。

wraps装饰器的作用是，复制函数属性至被装饰的函数。

如下所示：
```python
from __future__ import print_function
import time
import functools


def benchmark(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        t = time.time()
        res = func(*args, **kwargs)
        print(func.__name__, time.time() - t)
        return res

    return wrapper


def mul(a, b):
    """
    Calculate the product of two numbers
    """
    return a * b


@benchmark
def add(a, b):
    """
    Calculate the sum of two numbers
    """
    return a + b


print(mul.__name__)  # mul
print(mul.__doc__)  # Calculate the product of two numbers

print(add.__name__)  # add
print(add.__doc__)  # Calculate the sum of two numbers
```


#### 6.使用inspect获取函数参数


Python标准库的inspect模块。

inspect模块提供了许多有用的函数来获取活跃对象的信息。其中，getcallargs函数用来获取函数的参数信息。


getcallargs会返回一个字典，该字典保存了函数的所有参数，包括关键字参数和位置参数。

也就是说，getcallargs能够根据函数的定义和传递给函数的参数，推测出哪一个值传递给函数的哪一个参数。

getcallargs推测出这些信息以后，以一个字典的形式返回给我们所有的参数和取值。

因此，我们在检查username参数的取值是否为admin之前，可以先使用getcallargs函数获取函数的所有参数。

然后从getcallargs函数返回的字典中获取username的取值。通过这种方式，无论用户使用的是位置参数还是关键字参数都能进行正确处理。

如下所示：

```python
import functools
import inspect

def check_is_admin(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        func_args = inspect.getcallargs(func, *args, **kwargs)
        if func_args.get('username') != 'admin':
            raise Exception("This user is not allowed to put/get elem")
        return f(*args, **kwargs)
    return wrapper
```


#### 7.给装饰器传递参数

如果装饰器中有参数，那么就需要再嵌套一层函数。


```python
from __future__ import print_function

def times(length=1):
    def bread(func):
        def wrapper(*args, **kwargs):
            for i in range(length):
                func(*args, **kwargs)
        return wrapper
    return bread

@times(5)
def sandwich(name):
    print(name)

sandwich('Helo, World')
```





demo示例

```python
#!/usr/bin/env python
# -*- coding:utf8 -*-
import time


def abc(action):
    def mabc(func):
        def wrapper(*args, **kwargs):
            print("开始运行....", action)
            func(*args, **kwargs)
            print("运行结束！....", action)

        return wrapper
    return mabc


def timer(func):
    def deco(*args, **kwargs):
        start_time = time.time()
        func(*args, **kwargs)
        end_time = time.time()
        print(end_time - start_time)

    return deco


@timer
@abc("print_name")  # 带参数的装饰器
def deam_print_name(name):
    time.sleep(2)
    print("Hello {}!".format(name))


@timer
@abc("list_info")  # 带参数的装饰器
def deam_list_print(x):
    a = []
    time.sleep(2)
    for i in range(x):
        a.append(i)
    print(a)


if __name__ == '__main__':
    deam_list_print(8)
    print(''.center(100, "#"))
    print("".center(100, "#"))
    deam_print_name("hujianli")
```



利用装饰器实现失败重试

```python
#!/usr/bin/env python
# -*- coding:utf8 -*-
import subprocess
import requests


def Retry(second):
    def decorator(func):
        def warpper(*args, **kwargs):
            att = 0  # 计数器
            while att < second:  # 按照计数器条件来循环
                print(att)
                try:
                    return func(*args, **kwargs)  # 运行请求，或者命令
                except Exception as e:
                    att += 1  # 计数器累加

        return warpper

    return decorator


@Retry(3)
def cmd_01(cmd):
    subprocess.call(cmd)


# 简单的爬虫,重试3次爬取
@Retry(3)
def get_respone(url):
    r = requests.get(url)
    return r


cmd_01("dir1")
get_respone("http://www.baidu1.com")
```


#### 8.类装饰器


```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
#定义装饰类的装饰器，采用的方法是：定义内嵌类的函数，返回新类

#定义一个类装饰器及其使用的例子
def abc(myclss):
    class InnerClass:
        def __init__(self, z=0):
            self.z = 0
            self.wrapper = myclss()     #实例化被装饰的类

        def position(self):
            self.wrapper.position()
            print('z axis:',self.z)
    return InnerClass                   #返回新定义的类


'''
定义一个能够装饰类的装饰器abc，定义了一个内嵌类InnerClass用于代替被装饰的类，并返回新的内嵌类，实例化普通类
之后，得到的就是被装饰器装饰后的类
'''
@abc
class coordination:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def position(self):
        print("x axis:", self.x)
        print("y axis:", self.y)

if __name__ == '__main__':
    coor = coordination()
    coor.position()
```



#### 9.装饰器的缺点

虽然装饰器功能强大，但不能乱用。


一方面是因为装饰器的语法比较复杂，另一方面，装饰器具有速度慢和难以调试的缺点。

因此，装饰器的使用比较强调应用场景，需要使用得恰到好处才能够发挥它的优势。



### 9.1.3 Python上下文管理器


Python中有一种特殊的管理器，称为上下文管理器。

所谓上下文管理器就是实现了上下文管理协议的类（实现`__enter__`和`__exit__`方法）或函数(使用contextmanager装饰器)。

为了使用上下文管理器，Python2.6和Python3.0引入了一种特殊的语句，即 with 语句及其可选的 as 子语句。with 语句与上下文管理器一起协作，为Python工程师编程提供了些便利。


上下文管理器应用于某些特殊的情景之中，典型的应用场景是打开某种资源对资源进行处理，最后再关闭资源。

可以看到，上下文管理器的作用与常见的`try/finally`语句作用比较类似，都是用于确保打开的资源无论在何种情况下都能及时关闭。

在其他编程语言中，一般使用`try/finally`语句来完成。

在Python中应该优先使用上下文管理器，因为，上下文管理器可以使用更少的代码完成同样的功能。

与此同时，上下文管理器更加灵活。

例如，开发者也可以通过实现上下文管理器协议来编写自己的对象和函数，以便应用在 with 语句中简化资源的管理逻辑。接下来我们将深入讨论上下文管理器的应用场景和实现方式。



#### 1.with语句的形式化定义

```
with expression [as variable]:
  with-block
```
其中，expression返回了一个上下文管理器，with语句调用上下文管理器中的方法来管理资源。



#### 2.上下文管理器应用场景


```python
##不推荐
try:
    f = open("some_file.txt")
    data = f.read()
    # 其他文件操作..
finally:
    f.close()

##推荐
with open("some_file.txt") as f:
    data = f.read()
    # 其他文件操作..
```

当我们调用open函数时，open函数会返回一个文件对象，并赋值给相应的变量。


文件对象实现了上下文管理协议，因此，它是一个上下文管理器，Python利用with语句和上下文管理器管理资源。

在这个例子中，wh语句执行完成以后可以保证无论是否出现异常，这个文件对象都会关闭。

上下文管理器适用于所有打开资源，对资源进行处理，最后关闭资源的场景。

另一个典型的应用场景是确保加锁以后锁的释放。

使用`try/finally`语句的代码如下：


```python
lock = threading.Lock()
lock.acquire()

try:
    print ('Lock is held')
finally:
    lock.release()
```



与文件管理类似，使用上下文管理器能够有效减少代码行数，使得代码逻辑更加清晰。如下所示：

```python
lock = Lock()

withn lock:
    print ('Lock is held')
```


#### 3.上下文管理器协议


上下文管理器协议是Python中用于定义上下文管理器的协议，它包括`__enter__()`和`__exit__()`两个特殊方法。通过实现这两个方法，我们可以创建自己的上下文管理器。

- `__enter__()`方法在进入上下文管理器时被调用，并返回一个对象，该对象将在with语句中被赋值给一个变量。该方法可以执行一些初始化操作。

- `__exit__()`方法在离开上下文管理器时被调用，并接收三个参数：异常类型、异常值和追溯信息。该方法可以执行一些清理操作，例如关闭文件、释放资源等。如果在上下文块中产生了异常，异常会在`__exit__()`方法中被捕获。


```python
In [27]: f = open("/etc/passwd")

In [28]: dir(f)
Out[28]:
['_CHUNK_SIZE',
 '__class__',
 '__del__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__enter__',
 '__eq__',
 '__exit__',
#  ....


In [29]: import threading

In [30]: l = threading.Lock()

In [31]: dir(l)
Out[31]:
['__class__',
 '__delattr__',
 '__dir__',
 '__doc__',
 '__enter__',
 '__eq__',
 '__exit__',
#  .....
```


#### 4.自定义上下文管理器

我们也可以在自己的类中实现上下文管理协议，然后在wth语句中使用。

要实现上下文管理协议，按照Python的标准方式定义一个类，提供`__enter__`和`__exit__`方法即可。

下面给出一个非常有用的上下文管理器。

Python3中的open函数可以在打开文件时指定字符集编码，Python2中的open函数则没有这个功能。

因此，在Python2中只能使用标准库codecs来指定打开文件的字符集编码。

下面的例子中定义了一个Open类，并且实现了上下文管理器协议。

在Open类中，通过标准库的codecs模块模拟了Python3的open函数。如下所示：

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
import codecs

class Open(object):

    def __init__(self, filename, mode, encoding="utf-8"):
        self.fp = codecs.open(filename, mode, encoding)

    def __enter__(self):
        return self.fp

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.fp.close()


data = u"上下文管理器"
with Open('data.txt', 'w') as f:
    f.write(data)
```


#### 5.contextlib实现上下文管理器

在Python中，除了按照标准的协议定义一个可以在with语句中使用的上下文管理器以外。

开发者也可以使用标准库的contextlib模块简化实现上下文管理器的逻辑。该模块提供了名为contextmanager的装饰器，通过该装饰器装饰的函数变成了一个上下文管理器，可以用在wth语句之中。

这种写法比标准写法更加便捷，因此，受到了更多工程师的青睐。

如下所示：

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
import codecs
from contextlib import contextmanager

@contextmanager
def Open(filename, mode, encoding='utf-8'):
    fp = codecs.open(filename, mode, encoding)
    try:
        yield fp
    finally:
        fp.close()

data = u"上下文管理器"
with Open('data.txt', 'w') as f:
    f.write(data)
```


举个例子，我在前面实现的自动关闭连接的 create_conn_obj 上下文管理器，假如用函数来改写，可以简化成下面这样：

```python
from contextlib import contextmanager

@contextmanager
def create_conn_obj(host, port, timeout=None):
    """创建连接对象，并在退出上下文时自动关闭"""
    conn = create_conn(host, port, timeout=timeout)
    try:
        yield conn
    finally:
        conn.close()
```


#### 6.管理多个资源


从Python2.7和Python3.1开始，with语句也可以使用新的逗号语法，同时使用多个上下文管理器。

例如，我们要同时打开两个文件进行处理，很多工程师会写出下面这样的代码：

```python
with open('filel','r')as source:
    with open('file2','w')as target:
        target.write(source.read())
```



上面这段代码，也可以简化成下面这样：

```python
with open('filel','r') as source, open('file2','w') as target:
    target.write(source.read())
```


Python的with语句和上下文管理器是非常优秀的设计。


充分使用上下文管理器，不但可以减少代码中的错误，也能让代码看起来更加清晰整洁。

上下文管理器并不是必须的，它的所有功能都可以使用 `try/finally` 语句实现。

但是，使用上下文管理器以后代码行数更少，逻辑更加清晰。如果工程师在可以使用上下文管理器的情况下使用了 `try/finally` 语句，将被认为编写的代码不够Pythonic。