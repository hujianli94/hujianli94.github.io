# 7.自动化管理


## 7.1 使用SSH访问远程服务器

SSH(Secure Shell)是一种由IETF的网络工作小组制定、创建在应用层和传输层基础上的安全协议，为计算机上的Shell提供安全的传输和使用环境。


### 1.SSH 协议

在互联网早期，通信都是明文的，如rsh、FTP、POP和Telnet。

一旦通信报文被截获内容就泄漏无疑。

1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案。

这个方案迅速在全世界获得推广，目前已经成为Linux系统的标准配置。


SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。目前，在Liux下广泛使用的是OpenSSH,它是一款应用广泛的开源软件。

即将介绍的paramiko是SSH协议的一种Python实现。


S$H除了提供安全的传输和登录以外，还可以进行批量命令执行，使用非常方便。

正是由于SSH简单好用的特点，常见的Ansible工具,都依赖SSH进行远程服务器的管理。


使用SSH的好处非常明显，既充分利用了现成的机制，又省去了在远程服务器安装代理（Agent)程序。因此，诸多自动化工具都依赖于SSH。



### 2.OpenSSH实现

OpenSSH客户端是一个名为ssh可执行程序，ssh命令连接远程服务器，示例如下
```sh
ssh username@remote_host
```

非22端口号

```sh
ssh username@remote_host -p port
```


不进入交互式的shell

```sh
ssh username@remote_host 'COMMANDS'
```


### 3.使用秘钥登录远程服务器

1. 生成密钥对：

在本地计算机上打开终端或命令提示符窗口，并运行以下命令来生成密钥对：
```sh
ssh-keygen -t rsa
```
这将生成一对公钥（id_rsa.pub）和私钥（id_rsa）文件。



2. 将公钥复制到远程服务器：

使用以下命令将公钥复制到远程服务器上：

```sh
ssh-copy-id username@remote_host
# 其中 username 是您在远程服务器上的用户名，remote_host 是远程服务器的 IP 地址或主机名。您将被要求输入远程服务器的密码。
```

如果 ssh-copy-id 命令不可用，您可以手动将公钥内容复制到远程服务器的 ~/.ssh/authorized_keys 文件中。

配置 SSH 服务：在远程服务器上，确保 SSH 服务已启用并配置为允许使用密钥进行身份验证。打开远程服务器上的 SSH 配置文件 /etc/ssh/sshd_config，找到以下行并确保其处于以下状态：

```
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys
```

3. 重启 SSH 服务：

保存并关闭 SSH 配置文件后，重新启动 SSH 服务以使更改生效。在远程服务器上运行以下命令：
```sh
sudo service ssh restart
```
尝试使用密钥登录：现在，您应该能够使用密钥进行远程登录，而无需输入密码。在本地计算机上，使用以下命令登录到远程服务器：
```sh
ssh username@remote_host

# 这将使用私钥进行身份验证。
```

使用私钥登录时需要注意，**私钥文件与远程服务器中authorized keys文件的权限都必须为600**，否则登录会出错。 这也是工程师使用私钥登录时最容易遇到的错误。






### 4.使用ssh-agent管理私钥

使用 ssh-agent 可以更方便地管理私钥，避免每次使用私钥时都需要手动输入密码。

以下是使用 ssh-agent 管理私钥的简单步骤：

1. 启动 ssh-agent：

在终端或命令提示符窗口中运行以下命令来启动 ssh-agent：
```sh
eval $(ssh-agent)
```


2. 添加私钥到 ssh-agent：

运行以下命令将私钥添加到 ssh-agent：
```sh
ssh-add /path/to/private_key
# 将 /path/to/private_key 替换为您的私钥文件的路径。
```

如果私钥受密码保护，您将被要求输入密码以解锁私钥。


私钥添加完成以后，可以执行 ssh add-L 命令查看哪些私钥已经被添加到ssh-agent中。

如下所示：
```sh
ssh-add -L
ssh-rsa AAAAB3NzaCxxxxx......xxxx2dNKzx/qjAYIdaVuuhMesQ5n8=mac_air
ssh-rsa AAAAB3Nzxxxxxxx......xxxxnmT431XKh51Z8c7ZFXZ id_rsa
```
启动ssh-agent以后，当我们尝试与远程服务器建立连接时，ssh客户端将会尝试使用存储在ssh-agent中的私钥与远程服务器进行认证。


配置 SSH 客户端：打开 SSH 客户端配置文件 ~/.ssh/config（如果不存在则创建），并添加以下内容：
```
Host *
  AddKeysToAgent yes
  UseKeychain yes
  IdentityFile /path/to/private_key
```
将 /path/to/private_key 替换为您的私钥文件的路径。

这样配置后，每次使用 SSH 连接时，客户端将自动将私钥添加到 ssh-agent 中。





3. 尝试使用私钥进行远程登录
现在，您可以尝试使用私钥进行远程登录，而无需手动输入密码。在终端或命令提示符窗口中运行以下命令：

```sh
ssh username@remote_host
# 这将使用 ssh-agent 中的私钥进行身份验证。
```


### 5.轻量级自动化运维工具pssh

[Centos7部署轻量级自动化运维工具pssh](https://semaik.gitee.io/2021/01/21/Centos7%E9%83%A8%E7%BD%B2%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7pssh/)


[轻量级自动化运维工具 ---pssh&pscp.pssh](https://www.cnblogs.com/alexlv/p/13597113.html)




## 7.2 使用Polysh批量管理服务器


Polysh 是一个用于批量管理服务器的工具，它可以帮助管理员同时在多台服务器上执行命令、上传文件等操作。下面是一个使用 Polysh 批量管理服务器的代码示例：

### 1.安装 Polysh
```sh
pip install polysh
```


### 2.创建一个配置文件

在你的本地机器上创建一个名为 `polysh_config.yaml` 的配置文件，并按照以下格式填写服务器信息：

```yaml
servers:
  - name: server1
    host: 192.168.0.1
    user: username
    password: password
  - name: server2
    host: 192.168.0.2
    user: username
    password: password
  # 添加更多服务器...
```

### 3.编写 Python 脚本

创建一个名为 polysh_script.py 的 Python 脚本，并使用以下代码示例来批量管理服务器：

```python
from polysh import Polysh

# 加载服务器配置文件
polysh = Polysh('polysh_config.yaml')

# 在所有服务器上执行命令
polysh.run('ls -l')

# 在指定服务器上执行命令
polysh.run('uname -a', servers=['server1'])

# 上传文件到所有服务器
polysh.put('local_file.txt', 'remote_path/')

# 下载文件从指定服务器
polysh.get('remote_path/remote_file.txt', 'local_path/')
```

在终端中运行以下命令来执行脚本：
```sh
python polysh_script.py
```




### 4.Polysh 实现修改密码、上传文件和安装压缩包


```python
from polysh import Polysh

# 加载服务器配置文件
polysh = Polysh('polysh_config.yaml')

# 修改密码
def change_password(username, new_password):
    command = f'echo "{username}:{new_password}" | chpasswd'
    polysh.run(command)

# 上传文件
def upload_file(local_path, remote_path):
    polysh.put(local_path, remote_path)

# 安装压缩包
def install_package(package_name):
    command = f'apt-get install {package_name} -y'
    polysh.run(command)

# 示例用法
if __name__ == '__main__':
    # 修改密码
    change_password('username', 'new_password')

    # 上传文件
    upload_file('local_file.txt', 'remote_path/')

    # 安装压缩包
    install_package('zip')
```




## 7.3 使用paramiko免密远程执行shell

使用paramiko库：https://github.com/paramiko/paramiko


### 1.账号密码登录执行命令

```python
#!/usr/bin/python
#ssh
import paramiko
import sys,os

host = '10.152.15.200'
user = 'peterli
password = '123456'

s = paramiko.SSHClient()                                 # 绑定实例
s.load_system_host_keys()                                # 加载本地HOST主机文件
s.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 允许连接不在know_hosts文件中的主机
s.connect(host,22,user,password,timeout=5)               # 连接远程主机
while True:
        cmd=raw_input('cmd:')
        stdin,stdout,stderr = s.exec_command(cmd)        # 执行命令
        cmd_result = stdout.read(),stderr.read()         # 读取命令结果
        for line in cmd_result:
                print line,
s.close()
```


```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
import paramiko
import time

ip = "172.16.10.10"
port= 22
username="root"
passwd="superadmin"


def ssh2(ip,port,username,passwd,cmd):
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(ip,port,username,passwd,timeout=5)
        chan=ssh.invoke_shell()
        print(chan.recv(1024))
        for m in cmd:
            res = chan.sendall(m+"\n")
            time.sleep(float(1))
        print(chan.recv(1024))
        ssh.close()
    except Exception as e:
        print(e)

cmd=['ls']
ssh2(ip,port,username,passwd,cmd)
```


### 2.上传下载文件

```python
import paramiko

transport = paramiko.Transport(('39.105.186.**', 22))
transport.connect(username='root', password='Situ')

sftp = paramiko.SFTPClient.from_transport(transport)
# 将location.py 上传至服务器 /tmp/test.py
sftp.put('wjx', '/tmp/wjx')

# 将remove_path 下载到本地 local_path
# sftp.get('/tmp/wjx', 'newjx')

transport.close()
```


### 3.使用ssh公钥私钥

```python
import paramiko

# 创建SSH对象
ssh = paramiko.SSHClient()

# 允许连接不在know_hosts文件中的主机
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

# 指定私钥路径
private_key = paramiko.RSAKey.from_private_key_file('c:\\Users\\boy\\.ssh\\id_rsa')

# 使用私钥连接服务器
ssh.connect(hostname='192.168.21.128', port=22, username='root', pkey=private_key)

# 执行命令
stdin, stdout, stderr = ssh.exec_command('df')

# 获取命令结果
result = stdout.read()

# 关闭连接
ssh.close()

print(result)
```



### 4.使用ssh公钥+密码认证封装

```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
import paramiko,sys
# 创建SSHClient对象
hostname = "172.16.10.10"
port=22
username="root"
password="superadmin"

#使用公钥登录ssh，进行连接
def ssh_connect_key(host,user,key_file,cmd):
    ssh=paramiko.SSHClient()
    ssh.load_system_host_keys()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    key=paramiko.RSAKey.from_private_key_file(key_file)
    ssh.connect(hostname=host,username=user,pkey=key,timeout=30)
    stdin,stdout,stderr=ssh.exec_command(cmd)
    result=stdout.read().decode()     #python3 bytes格式转换为sting,python2无需decode,result=str(stdout.read(),'utf8)
    ssh.close()
    return result

#使用用户名、密码来登录
def ssh_connect(host,user,password,cmd):
    ssh=paramiko.SSHClient()
    ssh.load_system_host_keys()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(hostname=host,username=user,password=password,timeout=30)
    stdin,stdout,stderr=ssh.exec_command(cmd)
    result=stdout.read()
    ssh.close()
    return result

if __name__ == '__main__':
    # a=len(sys.argv)
    # if a!=5:
    #     print ("参数个数不对，请输入四个参数!")
    # else:
    #     host=sys.argv[1]
    #     user=sys.argv[2]
    #     password=sys.argv[3]
    #     cmd=sys.argv[4]
    #     try:
    #         out=ssh_connect(host,user,password,cmd)
    #         print (out)
    #     except:
    #         print ("usages:python ssh2.py '192.168.10.129' 'root' '123456' 'ls /root'")

    ssh_connect(hostname,username,password,"df -Th")
```



### 5.简单封装SSH类

```python
import paramiko


class SSH:

    def __init__(self, host, port, user, ssh_key_path, timeout=1800):
        self.host = host
        self.port = port
        self.user = user
        self.ssh_key_path = ssh_key_path
        self.timeout = timeout
        self.connect()

    def connect(self):
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        pkey = paramiko.RSAKey.from_private_key_file(self.ssh_key_path)
        client.connect(hostname=self.host, username=self.user, port=self.port, pkey=pkey, timeout=self.timeout)
        self.client = client

    def exec(self, shell, timeout=1800):
        stdin, stdout, stderr = self.client.exec_command(command=shell, bufsize=1, timeout=timeout)
        while True:
            line = stdout.readline()
            if not line:
                break
            print(line)
        print(stderr.read())
        code = stdout.channel.recv_exit_status()
        return code

    def close(self):
        self.client.close()
```


### 6.使用paramiko部署监控程序


下面是一个使用paramiko的完整例子。

在这个例子中，我们将远程服务器的ip地址保存在hosts文件中，并通过一个for循环遍历该文件中的ip地址。

每一个ip都会建立一个连接，然后将本地的 monitor.py 文件上传到远程服务器，上传到远程服务器以后，通过 SFTPClient 的 chmod 方法修改 monitor.py 文件的权限。

如下所示：

`depoly_monitor_with_paramiko.py`


```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
from __future__ import print_function
import paramiko

def depoly_monitor(ip):

    with paramiko.SSHClient() as client:
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(ip, 2092, 'lmx')

        stdin, stdout, stderr = client.exec_command('ls -l')
        print(stdout.readlines())

        with client.open_sftp() as sftp:
            sftp.put('monitor.py', 'monitor.py')
            sftp.chmod('monitor.py', 0o755)


def main():
    with open('hosts') as f:
        for line in f:
            depoly_monitor(line.strip())


if __name__ == '__main__':
    main()
```


我们在介绍SSHClient和SFTClient类时仅仅介绍了如何建立连接。

在生产环境中，我们还应当调用SSHClient与SFTPClient对象的close方法及时关闭连接。

此外，也可以像这里的例子一样，使用Python的上下文管理器及时关闭连接。


### 7.使用paramiko部署agent程序


```python
import paramiko

def deploy_agent(ip, username, password, local_file, remote_dir):
    # 创建SSH客户端
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        # 与服务器建立连接
        client.connect(ip, username=username, password=password)

        # 创建SFTP客户端
        sftp = client.open_sftp()

        # 将本地的agent文件上传到远程服务器
        remote_file = f'{remote_dir}/agent.py'
        sftp.put(local_file, remote_file)

        # 在远程服务器上执行agent
        stdin, stdout, stderr = client.exec_command(f'python3 {remote_file}')

        # 打印执行的返回结果
        print(stdout.read().decode())
        print(stderr.read().decode())

        # 关闭SFTP连接
        sftp.close()

    except Exception as e:
        print(f'在部署过程中出现了错误：{e}')

    finally:
        # 关闭SSH连接
        client.close()

# 测试上述函数
deploy_agent('192.168.0.101', 'username', 'password', 'path/to/your/agent.py', '/remote/directory')
```


[Python paramiko 模块](https://www.yuque.com/fcant/python/lnie5i)

[Python Paramiko 实现sftp文件上传下载](https://www.yuque.com/fcant/python/lul9yw#wvnAX)



## 7.4 自动化部署工具Fabric

### 1.简介

Fabric是基于Python2.5以上版本实现的SSH命令行工具，简化了SSH的应用程序部署及系统管理任务。

提供了系统基础的操作组件，可以实现本地或远程shell命令，包括命令执行、文件上传、下载及完整执行日志输出等功能Fabric在paramiko的基础上做了更高一层的封装，操作起来会更加简单。



官方网站：http://www.fabfile.org



### 2.Fabric安装


- pip 安装

```sh
pip install fabric==1.14.0
easy_install fabric
```


- 源码安装

```sh
yum -y install python-setuptools
wget https://pypi.python.org/packages/source/F/Fabric/Fabric-1.8.2.tar.gz --no-check-certificate
tar -zxvf Fabric-1.8.2.tar.gz
cd Fabric-1.8.2
python setup.py instal
```



eg:

```python
#!/usr/bin/env python
from fabric.api import run

def host_type():
    run('uname -s')
```


输出信息
```sh
[root@pxe-server 03.批量运维管理器Fabric]# fab -H 192.168.0.100 host_type
[192.168.0.100] Executing task 'host_type'
[192.168.0.100] run: uname -s
[192.168.0.100] Login password for 'root':
[192.168.0.100] out: Linux
[192.168.0.100] out:


Done.
Disconnecting from 192.168.0.100... done.
```

```sh
@runs_once  #主机遍历过程中，只有第一台触发此函数
```


### 3.查看本地与远程主机信息


`simple01.py`

```python
#!/usr/bin/env python
from fabric.api import *

env.user='root'
env.hosts=['192.168.1.21','192.168.1.22']
env.password='SKJh935yft#'

@runs_once
def local_task():
    local("uname -a")

def remote_task():
    with cd("/data/logs"):
        run("ls -l")
```


输出信息

```sh
[root@pxe-server 03.批量运维管理器Fabric]# fab -f simple01.py local_task
[192.168.0.100] Executing task 'local_task'
[localhost] local: uname -a
Linux pxe-server 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux

Done.
```

```sh
[root@pxe-server 03.批量运维管理器Fabric]# fab -f simple01.py remote_task
[192.168.0.100] Executing task 'remote_task'
[192.168.0.100] run: ls -l
[192.168.0.100] out: 总用量 221060
[192.168.0.100] out: -rw-r--r-- 1 root root 185540433 8月  17 21:57 jdk-linux-x64.tar.gz
[192.168.0.100] out: -rw-r--r-- 1 root root  40824607 8月  17 21:57 vagrant_2.2.4_x86_64.rpm
[192.168.0.100] out:

[192.168.0.103] Executing task 'remote_task'
[192.168.0.103] run: ls -l
[192.168.0.103] out: 总用量 221060
[192.168.0.103] out: -rw-r--r-- 1 root root 185540433 8月  17 21:58 jdk-linux-x64.tar.gz
[192.168.0.103] out: -rw-r--r-- 1 root root  40824607 8月  17 21:58 vagrant_2.2.4_x86_64.rpm
[192.168.0.103] out:


Done.
Disconnecting from 192.168.0.100... done.
Disconnecting from 192.168.0.103... done.
```


### 4.动态获取远程目录列表


```python
#!/usr/bin/env python
from fabric.api import *

env.user='root'
env.hosts=['192.168.1.21','192.168.1.22']
env.password="SKJh935yft#"

@runs_once      ##主机遍历过程中，只有第一台触发此函数
def input_raw():
    return prompt("please input directory name:",default="/home")

def worktask(dirname):
    run("ls -l "+dirname)

@task
def go():       #限定只有go函数对fab命令可见
    getdirname = input_raw()
    worktask(getdirname)
```

输出信息
```sh
[root@pxe-server 03.批量运维管理器Fabric]# fab -f simple02.py go
[192.168.0.100] Executing task 'go'
please input directory name: [/home] /root
[192.168.0.100] run: ls -l /root
[192.168.0.100] out: 总用量 4
[192.168.0.100] out: -rw-------.  1 root root 1863 2月  13 2019 anaconda-ks.cfg
[192.168.0.100] out: drwxr-xr-x  14 root root  184 6月   4 12:52 docbook
[192.168.0.100] out: drwxr-xr-x   3 root root   22 6月   4 13:13 linuxidc-vagrant-project
[192.168.0.100] out:

[192.168.0.103] Executing task 'go'
[192.168.0.103] run: ls -l /root
[192.168.0.103] out: 总用量 4
[192.168.0.103] out: -rw-------.  1 root root 1863 2月  13 2019 anaconda-ks.cfg
[192.168.0.103] out: drwxr-xr-x  14 root root  184 6月   4 12:52 docbook
[192.168.0.103] out: drwxr-xr-x   3 root root   22 6月   4 13:13 linuxidc-vagrant-project
[192.168.0.103] out:


Done.
Disconnecting from 192.168.0.100... done.
Disconnecting from 192.168.0.103... done.
```

通过Fabric的env对象定义网关模式，即俗称的中转、堡垒机环境。

定义格式为“env.gateway=‘192.168.1.23’”，其中IP“192.168.1.23”为堡垒机IP，

再结合任务函数 **实现目标主机文件上传与执行** 的操作




### 5.网关模式文件上传与执行


```python
#!/usr/bin/env python
from fabric.api import *
from fabric.context_managers import *
from fabric.contrib.console import confirm

env.user='root'
env.gateway='192.168.1.23'      #定义堡垒机IP，作为文件上传、执行的中转设备
env.hosts=['192.168.1.21','192.168.1.22']

#假如所有主机密码都不一样，可以通过env.passwords字典变量一一指定
env.passwords = {
    'root@192.168.1.21:22': 'SKJh935yft#',
    'root@192.168.1.22:22': 'SKJh935yft#',
    'root@192.168.1.23:22': 'KJSD9325hgs'   #堡垒机账号信息
}

#本地安装包路径
lpackpath="/home/install/lnmp0.9.tar.gz"
#远程安装包路径
rpackpath="/tmp/install"

@task
def put_task():
    run("mkdir -p /tmp/install")
    with settings(warn_only=True):
        #上传安装包
        result = put(lpackpath, rpackpath)
    if result.failed and not confirm("put file failed, Continue[Y/N]?"):
        abort("Aborting file put task!")

@task
def run_task():
    #执行远程命令，安装lnmp环境
    with cd("/tmp/install"):
        run("tar -zxvf lnmp0.9.tar.gz")
        #使用with继续继承/tmp/install目录位置状态
        with cd("lnmp0.9/"):
            run("./centos.sh")

@task
#上传、安装组合
def go():
    put_task()
    run_task()
```


### 6.使用fabric进行文件打包、上传与校验


```python
#!/usr/bin/env python
from fabric.api import *
from fabric.context_managers import *
from fabric.contrib.console import confirm

env.user='root'
env.hosts=['192.168.1.21','192.168.1.22','192.168.1.23']
env.password='SKJh935yft#'


@task
@runs_once
def tar_task():     #本地打包任务函数，只执行一次
    with lcd("/data/logs"):
        local("tar -czf access.tar.gz access.log")
@task
def put_task():     #上传文件任务函数
    run("mkdir -p /data/logs")
    with cd("/data/logs"):
        with settings(warn_only=True):
            ##put（上传）出现异常时继续执行，非终止
            result = put("/data/logs/access.tar.gz", "/data/logs/access.tar.gz")
        if result.failed and not confirm("put file failed, Continue[Y/N]?"):
            ##出现异常时，确认用户是否继续，（Y继续）
            abort("Aborting file put task!")

@task
def check_task():           ##校验文件任务函数
    with settings(warn_only=True):
        #本地local命令需要配置capture=True才能捕获返回值
        lmd5=local("md5sum /data/logs/access.tar.gz",capture=True).split(' ')[0]
        rmd5=run("md5sum /data/logs/access.tar.gz").split(' ')[0]
    if lmd5==rmd5:          ##对比本地及远程文件md5信息
        print "OK"
    else:
        print "ERROR"

@task
def go():
    tar_task()
    put_task()
    check_task()
```




三个功能互相独立，可以分开运行
```sh
fab -f simple4.py tar_task #文件打包
fab -f simple4.py put_task #文件上传
fab -f simple4.py check_task #文件校验
```

组合在一起运行
```python
@task
def go():
    tar_task()
    put_task()
    check_task()
```

```sh
fab -f simple4.py go
```



### 7.使用fabric源码安装redis

完整的fabfile代码如下：

`fabfile.py`

```python
#!/usr/bin/python
from fabric.api import (local, put, abort, run, cd, task, execute, settings,
                        env, runs_once, lcd, sudo)
from fabric.contrib.console import confirm
from fabric.colors import green

env.user = 'lmx'
env.port = 2092
env.hosts = open('hosts').readlines()

@task
@runs_once
def test():
    with settings(warn_only=True), lcd("redis-3.2.8"):
        result = local("make test", capture=True)
        if result.failed and not confirm("Tests failed. Continue anyway?"):
            abort("Aborting at user request.")
        else:
            green("All tests passed without errors!")

    with lcd("redis-3.2.8"):
        local("make clean")
    local("tar -czf redis-3.2.8.tar.gz redis-3.2.8")

@task
def deploy():
    put("redis-3.2.8.tar.gz",  "/tmp/redis-3.2.8.tar.gz")
    with cd("/tmp"):
        run("tar xzf redis-3.2.8.tar.gz")
        with cd("redis-3.2.8"):
            sudo("make install")

@task
def clean_file():
    with cd("/tmp"):
        sudo("rm -rf redis-3.2.8.tar.gz")
        sudo("rm -rf redis-3.2.8")

@task
def clean_local_file():
    local("rm -rf redis-3.2.8.tar.gz")

@task
def install():
    execute(test)
    execute(deploy)
    execute(clean_file)
    execute(clean_local_file)
```


将这里的代码保存到当前目录下的 fabfile.py 文件中，然后执行下面的命令运行即可：

```sh
$ fab --list
Available commands:


clean_file
clean_local_file
deploy
install
test
```


```sh
$ fab install
```


### 8.部署LNMP业务服务环境

业务上线之前最关键的一项任务便是环境部署，往往一个业务涉及多种应用环境，比如Web、DB、PROXY、CACHE等，本示例通过 env.roledefs 定义不同主机角色，

再使用 “@roles（'webservers'）” 修饰符绑定到对应的任务函数，实现不同角色主机的部署差异，详细源码如下：


```python
#!/usr/bin/env python
from fabric.colors import *
from fabric.api import *

env.user='root'

#定义业务角色分组
env.roledefs = {
    'webservers': ['192.168.1.21', '192.168.1.22'],
    'dbservers': ['192.168.1.23']
}

env.passwords = {
    'root@192.168.1.21:22': 'SKJh935yft#',
    'root@192.168.1.22:22': 'SKJh935yft#',
    'root@192.168.1.23:22': 'KJSD9325hgs'
}

#webtask任务函数引用'webservers'角色修饰符
@roles('webservers')
#部署nginx php php-fpm等环境
def webtask():
    print yellow("Install nginx php php-fpm...")
    with settings(warn_only=True):
        run("yum -y install nginx")
        run("yum -y install php-fpm php-mysql php-mbstring php-xml php-mcrypt php-gd")
        run("chkconfig --levels 235 php-fpm on")
        run("chkconfig --levels 235 nginx on")


# dbtask任务函数引用'dbservers'角色修饰符
@roles('dbservers')
#部署mysql环境
def dbtask():
    print yellow("Install Mysql...")
    with settings(warn_only=True):
        run("yum -y install mysql mysql-server")
        run("chkconfig --levels 235 mysqld on")


# publictask任务函数同时引用两个角色修饰符
@roles ('webservers', 'dbservers')
def publictask():
    print yellow("Install epel ntp...")
    with settings(warn_only=True):
        run("rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm")
        run("yum -y install ntp")

def deploy():
    execute(publictask)
    execute(webtask)
    execute(dbtask)
```

程序生产环境的发布是业务上线最后一个环节，要求具备源码打 包、发布、切换、回滚、版本管理等功能，本示例实现了这一整套流程 功能，其中版本切换与回滚使用了Linux下的软链接实现。




### 9.生产环境代码包发布管理


![1698375442101](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698375442101.6qq3ts2r3e80.webp){: .zoom}

本示例实现了一个通用性很强的代码发布管理功能，支持快速部署与回滚，无论发布还是回滚，都可以通过切换current的软链来实现，非常灵活。 



在生产环境中Nginx的配置如下：

```conf
server_name domain.com
index index.html index.htm index.php；
root /data/www/Lwebadmin/current；
```

将站点根目录指向 `/data/www/Lwebadmin/current`，由于使用Linux软链接做切换，管理员的版本发布、回滚操作用户无感知，同时也规范了我们业务上线的流程。


```python
#!/usr/bin/env python
from fabric.api import *
from fabric.colors import *
from fabric.context_managers import *
from fabric.contrib.console import confirm
import time

env.user='root'
env.hosts=['192.168.1.21','192.168.1.22']
env.password='SKJh935yft#'

#开发机项目主目录
env.project_dev_source = '/data/dev/Lwebadmin/'
#开发机项目压缩包存储目录
env.project_tar_source = '/data/dev/releases/'
#项目压缩包名前缀，文件名为release.tar.gz
env.project_pack_name = 'release'

#项目生产环境主目录
env.deploy_project_root = '/data/www/Lwebadmin/'
#项目发布目录，位于主目录下面
env.deploy_release_dir = 'releases'
#对外服务的当前版本软链接
env.deploy_current_dir = 'current'

#版本号
env.deploy_version=time.strftime("%Y%m%d")+"v2"

#获得用户输入的版本号，以便做版本回滚操作
@runs_once
def input_versionid():
    return prompt("please input project rollback version ID:",default="")

#打包本地项目主目录，并将压缩包存储到本地压缩包目录
@task
@runs_once
def tar_source():
    print yellow("Creating source package...")
    with lcd(env.project_dev_source):
        local("tar -czf %s.tar.gz ." % (env.project_tar_source + env.project_pack_name))
    print green("Creating source package success!")


#上传任务函数
@task
def put_package():
    print yellow("Start put package...")
    with settings(warn_only=True):
        with cd(env.deploy_project_root+env.deploy_release_dir):
            run("mkdir %s" % (env.deploy_version))  #创建版本目录
    env.deploy_full_path=env.deploy_project_root + env.deploy_release_dir + "/"+env.deploy_version

    with settings(warn_only=True):  #上传项目压缩包至此目录
        result = put(env.project_tar_source + env.project_pack_name +".tar.gz",env.deploy_full_path)
    if result.failed and no("put file failed, Continue[Y/N]?"):
        abort("Aborting file put task!")

    with cd(env.deploy_full_path):  #成功解压后删除压缩包
        run("tar -zxvf %s.tar.gz" % (env.project_pack_name))
        run("rm -rf %s.tar.gz" % (env.project_pack_name))

    print green("Put & untar package success!")


#为当前版本目录做软链接
@task
def make_symlink():
    print yellow("update current symlink")
    env.deploy_full_path=env.deploy_project_root + env.deploy_release_dir + "/"+env.deploy_version
    with settings(warn_only=True):
        #删除软链接，重新创建并指定软链源目录，新版本生效
        run("rm -rf %s" % (env.deploy_project_root + env.deploy_current_dir))
        run("ln -s %s %s" % (env.deploy_full_path, env.deploy_project_root + env.deploy_current_dir))
    print green("make symlink success!")

#版本回滚任务函数
@task
def rollback():
   #获得用户输入的回滚版本号
    print yellow("rollback project version")
    versionid= input_versionid()
    if versionid=='':
        abort("Project version ID error,abort!")

    env.deploy_full_path=env.deploy_project_root + env.deploy_release_dir + "/"+versionid
    #删除软链接，重新创建并指定软链源目录，新版本生效
    run("rm -f %s" % env.deploy_project_root + env.deploy_current_dir)
    run("ln -s %s %s" % (env.deploy_full_path, env.deploy_project_root + env.deploy_current_dir))
    print green("rollback success!")

#自动化程序版本发布入口函数
@task
def go():
    tar_source()
    put_package()
    make_symlink()
```


### 10. 综合案例: 使用fabric部署Flask应用


- flask应用示例

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-

import redis
from flask import Flask

app = Flask(__name__)

@app.route('/user/<int:identify>')
def get(identify):
    r = redis.StrictRedis(host='10.166.226.152', port=6379, db=0)
    username = r.get(identify)

    if username is None:
        return "not found", 404
    else:
        return username

if __name__ == '__main__':
    app.run()
```


- 完整的fabfile代码如下：

```python
#!/usr/bin/python
#-*- coding: UTF-8 -*-
from __future__ import print_function

from fabric.api import (cd, run, task, env, roles, put, execute, hide, set_missing_host_key_policyings, sudo)
from fabric.colors import red, green, yellow
from fabric.contrib.files import exists

env.user = 'lmx'
env.port = 2092
env.roledefs = { 'web': ["10.166.224.14", "10.166.224.140"],
               'db': ["10.166.226.152"] }

def is_redis_installed():
    with settings(hide('everything'), warn_only=True):
        result = run("netstat -tl | grep -w 6379")
        return result.return_code == 0

def install_redis():
    sudo("apt-get install redis-server")

def change_redis_conf():
    sudo("sed -i 's/bind 127.0.0.1/bind 0.0.0.0/' /etc/redis/redis.conf")

def reboot_redis():
    sudo("/etc/init.d/redis-server restart", pty=False)

@task
@roles('db')
def depoly_db():

    if is_redis_installed():
        print(yellow('redis was successfully installed'))
    else:
        install_redis()

        change_redis_conf()

        reboot_redis()

        print(green('redis has successfully installed'))

def is_python_package_installed(package):
    with settings(hide('everything'), warn_only=True):
        result = run("python -c 'import {0}'".format(package))
        return result.return_code == 0

def install_python_package(package):
    sudo('pip install {0}'.format(package))

def pip_install_if_need(package):
    if not is_python_package_installed(package):
        install_python_package(package)
        print(green('{0} has installed'.format(package)))
    else:
        print(yellow('{0} was installed'.format(package)))

def install_package():
    for package in ['gunicorn', 'flask', 'redis']:
        pip_install_if_need(package)

def kill_web_app_if_exists():
    with cd('/tmp'):
        if exists('app.pid'):
            pid = run('cat app.pid')
            print(yellow('kill app which pid is {0}'.format(pid)))
            with settings(hide('everything'), warn_only=True):
                run('kill -9 {0}'.format(pid))
        else:
            print(red('pid file not exists'))

def upload_web_app():
    put('app.py', '/tmp/app.py')

def run_web_app():
    with cd('/tmp'):
        run('gunicorn -w 1 app:app -b 0.0.0.0:5000 -D -p /tmp/app.pid --log-file /tmp/app.log', pty=False)

def restart_web_app():
    kill_web_app_if_exists()
    run_web_app()

@task
@roles('web')
def depoly_web():

    install_package()

    upload_web_app()

    restart_web_app()

@task
def depoly_all():
    execute(depoly_db)
    execute(depoly_web)
```



在fabfile文件中，首先导入了Fabric的API,然后，通过修改env字典的方式对Fabric进行了简单的配置。

这个例子在env字典中配置了访问远程服务器的用户名和端口号，并且，根据服务器的不用作用定义了2个role。

服务器分类以后，部署服务只需要引用role的名称即可，非常方便。

通过role名称引用服务器的方式，在服务器数量较多时优势更为明显。

我们这里的fabfile文件定义了3个task,分别是 depoly_db、depoly_web 和 depoly_all。


其中，depoly_all是对depoly_db和depoly_web的封装。

封装以后，我们既可以分别部署数据库服务器和Wb服务器，也可以一次部署所有服务器。

在depoly_db部署任务中，首先通过redis的端口号是否存在判断redis数据库是否已经存在。

如果redis数据库已经存在并启动完成，什么都不做，否则，我们将会执行apt-get命令安装redis数据库。

redis数据库安装完成以后只能本地访问，因此，使用sed命令修改redis数据库的配置文件，修改完成以后重启redis数据库。

在depoly_web部署任务中，首先安装相关的依赖包，包括Flask框架、gunicorn服务器与访问rdis数据库的驱动。软件安装完成以后，将我们的应用程序上传到远程服务器中并重启Web服务器。

在重启Web服务器的过程中，我们首先读取app.pid文件中的进程id,

如果该文件不存在，则认为应用没有运行，如果该文件存在，则读取文件中的进程id并通过kill命令关闭进程。关闭应用程序以后，再次使用gunicorn服务器启动应用程序，以达到重启应用的目的。

有了上面这个fabfile文件以后，我们只需要执行 `fab depoly_all`命令就能够一键完成数据服务和Wb服务的部署工作。

当我们有一个新的环境时，只需要简单配置服务器的地址就能够完成一键部署。


执行下面的命令完成数据服务和Wb服务的部署工作
```sh
$ fab depoly_all
```








### 11.Fabric常用API

```sh
local         # 执行本地命令，如local('uname -s')
lcd           # 切换本地目录，如lcd('/home')
cd            # 切换远程目录
run           # 执行远程命令
sudo          # sudo方式执行远程命令，如sudo('/etc/init.d/httpd start')
put           # 上次本地文件导远程主机，如put('/home/user.info','/data/user.info')
get           # 从远程主机下载文件到本地，如：get('/data/user.info','/home/user.info')
prompt        # 获得用户输入信息，如：prompt('please input user password:')
confirm       # 获得提示信息确认，如：confirm('Test failed,Continue[Y/N]?')
reboot        # 重启远程主机，如：reboot()

@task         # 函数修饰符，标识的函数为fab可调用的，非标记对fab不可见，纯业务逻辑
@runs_once    # 函数修饰符，标识的函数只会执行一次，不受多台主机影响
```





## 7.5 Python 实现定时任务的九种方案


https://www.yuque.com/fcant/python/oru0rr24l6q7628c