# 7.通用库 Oslo

Oslo 包含了众多不需要重复发明的“轮子”。olso-incubator 代码仓库中放置的是未“孵化”的项目。

已孵化的项目可直接 import，如果使用未孵化的则需要将代码同步到该项目代码 openstack/common 目录下，类似 “from ceilometer.openstack.common import log”。

| 通用项目名称          | 说明                                                                                                                                                               |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| oslo.config           | 用于解析命令行和配置文件中的配置选项。定义好的配置选项，必须在注册后才能使用。配置选项可以注册为命令行选项，这些配置选项可以从命令行中读取，并覆盖配置选项中的值。 |
| oslo.db               | 对 SQLAlchemy 访问的抽象。                                                                                                                                         |
| oslo.i18n             | 对 Python gettext 模块的封装，用于字符串的翻译和国际化。                                                                                                           |
| oslo.messaging        | 为 RPC 和事件通知提供了一套统一的接口。                                                                                                                            |
| stevedore             | 在 Setuptools 的 entry points 的基础上进行了一层封装，使得可以更容易地在运行时发现和载入插件。                                                                     |
| Taskflow              | 控制任务的执行。                                                                                                                                                   |
| cookiecutter          |  [项目模板](https://opendev.org/openstack/cookiecutter)                                                                                                            |
| oslo.policy           | 控制用户的权限，指定用户能够执行什么样的操作。                                                                                                                     |
| oslo.rootwrap         | 可以使 OpenStack 服务能够以 root 的身份执行 shell 命令。                                                                                                           |
| oslo.test             | 单元测试的基础框架。                                                                                                                                               |
| oslo.versionedobjects | 对数据库结构和 API 接口的改动添加版本控制，可以和 oslo.messaging 结合进行远程调用。                                                                                |

## 1.oslo.config

`oslo.config` 库用于解析命令行和配置文件中的配置选项，代码库位于`https:/github.com/openstack/oslo.config`,

项目主页为: `htps:/launchpad.net/oslo.config`,

参考文档在 `htp:/docs.openstack.org/developer//oslo.config/`。

oslo.config 的主要特性包括：

- 参数的类型限定
- 同时管理命令行与配置文件(ini)
- 自动生成示例配置文件
- 支持参数分组
- 运行时重新载入配置

下面我将通过一个简单的示例来展示如何使用 oslo.config 模块。

运行以下命令来安装 `oslo.config` 模块：

```sh
# 安装 oslo.config
pip install oslo.config
```

示例 1-读取命令行

```python
#!/usr/bin/env python3
# -*- coding:utf8 -*-

from oslo_config import cfg
from oslo_config import types

PortType = types.Integer(1, 65535)

# 定义参数
common_opts = [
    cfg.StrOpt('bind_host',
               default='0.0.0.0',
               help='IP address to listen on.'),
    cfg.Opt('bind_port',
            type=PortType,
            default=9292,
            help='Port number to listen on.')
]

# 注册参数
CONF = cfg.CONF

# 既注册为命令行参数又注册为配置文件
CONF.register_opts(common_opts)
CONF.register_cli_opts(common_opts)

# 使用参数
import sys

if __name__ == '__main__':
    # 将命令行参数传递给 CONF
    CONF(sys.argv[1:])
    print("bind_host: %s, bind_port: %s" % (CONF.bind_host, CONF.bind_port))
```

运行一下 test_oslo_config.py

```sh
$ python ./test_oslo_config.py --bind_host localhost --bind_port 8080
bind_host: localhost, bind_port: 8080

$ python test_oslo_config.py --bind_host 127.0.0.1
bind_host: 127.0.0.1, bind_port: 9292


$ python test_oslo_config.py -h
usage: test_oslo_config.py [-h] [--bind_host BIND_HOST]
                        [--bind_port BIND_PORT] [--config-dir DIR]
                        [--config-file PATH]

$ python test_oslo_config.py --bind_host 127.0.0.1 --bind_port abc
argument --bind_port: Invalid Integer(min=1, max=65535) value: abc


optional arguments:
-h, --help            show this help message and exit
--bind_host BIND_HOST
                        IP address to listen on.
--bind_port BIND_PORT
                        Port number to listen on.
--config-dir DIR      Path to a config directory to pull *.conf files from.
                        This file set is sorted, so as to provide a
                        predictable parse order if individual options are
                        over-ridden. The set is parsed after the file(s)
                        specified via previous --config-file, arguments hence
                        over-ridden options in the directory take precedence.
--config-file PATH    Path to a config file to use. Multiple config files
                        can be specified, with values in later files taking
                        precedence. Defaults to None.

# --config-dir 与 --config-file 是 oslo.config 默认保留的参数，分别用于指定配置文件目录与名称。
```

示例 2-读取配置文件

假设我们有一个应用程序，需要从配置文件中读取一些选项，比如数据库连接信息。首先，我们需要创建一个配置文件，比如 `app.conf`，并在其中定义相关的选项，例如：

```ini
[database]
connection = mysql://user:password@localhost/dbname
```

接下来，我们可以使用 oslo.config 模块来读取这些选项。

下面是一个简单的 Python 脚本示例：

sample1.py

```python
from oslo_config import cfg

# 定义配置选项
opts = [
    cfg.StrOpt('connection', default='sqlite://', help='Database connection string'),
]

# 注册配置选项
conf = cfg.ConfigOpts()
conf.register_opts(opts, 'database')

# 读取配置文件
conf(default_config_files=['app.conf'])

# 使用配置选项
print("Database Connection:", conf.database.connection)
```

示例 3-同时管理命令行与配置文件(ini)

test_oslo_config.py 中，我们把相同的参数既注册为命令行参数又注册为配置文件

```python
# 注册参数
CONF = cfg.CONF

# 既注册为命令行参数又注册为配置文件
CONF.register_opts(common_opts)
CONF.register_cli_opts(common_opts)
```

如果，在配置文件与命令行中同时指定一个参数，那么后注册的会覆盖掉先注册掉的参数。本例中，配置文件参数先注册，所以命令行中的参数会覆盖掉配置文件中的参数：

```sh
# test.conf
[DEFAULT]
bind_host=127.0.0.1
bind_port=8888
```

```sh
# 使用配置文件
$ python test_oslo_config.py --config-dir=. --config-file=test.conf
bind_host: 127.0.0.1, bind_port: 8080


# 使用配置文件和命令行，命令行覆盖配置文件
$ python test_oslo_config.py --config-dir=. --config-file=test.conf --bind_host=localhost --bind_port=9999
bind_host: localhost, bind_port: 9999
```

示例 4-支持参数分组

`test_oslo_config2.py`

```python
#!/usr/bin/env python3
# -*- coding:utf8 -*-
from oslo_config import cfg
from oslo_config import types

# 创建参数组
logger_group = cfg.OptGroup(name='logger',
                            title='logger options')

logger_opts = [
    cfg.BoolOpt('debug',
                default=False,
                help='Enable debug log or not.'),
    cfg.BoolOpt('verbose',
                default=True,
                help='Enable verbose log or not.')
]

# 注册参数
CONF = cfg.CONF
# 注册参数组
CONF.register_group(logger_group)
# 注册参数时指定参数组
CONF.register_opts(logger_opts, logger_group)
CONF.register_cli_opts(logger_opts, logger_group)

# 使用参数
import sys

if __name__ == '__main__':
    # 解析命令行参数
    CONF(sys.argv[1:])
    # 使用参数组中的参数
    print('debug: %s, verbose: %s' % (CONF.logger.debug,
                                      CONF.logger.verbose))
```

```sh
$ python test_oslo_config2.py -h
usage: test_oslo_config2 [-h] [--config-dir DIR] [--config-file PATH] [--logger-debug] [--logger-nodebug] [--logger-noverbose] [--logger-verbose]

optional arguments:
# ....

logger options:
  --logger-debug      Enable debug log or not.
  --logger-nodebug    The inverse of --debug
  --logger-noverbose  The inverse of --verbose
  --logger-verbose    Enable verbose log or not.
```

由此可以看出，对于参数组中的参数，需要使用 `--[参数组]-[参数]` 来指定。

另外，由于 debug 和 verbose 两个参数都是 Bool 类型的，所以对应会有一对`--[参数组]-[参数]` 和 `--[参数组]-no[参数]` 存在，分别用于指定 True 和 False。

在配置文件中指定参数组的话，只需要像下面这样指定即可：

```sh
# test.conf
[logger]
debug=true
verbose=true
```

```sh
$ python test_oslo_config2.py
debug: False, verbose: True

$ python test_oslo_config2.py --config-file=test.conf
debug: True, verbose: True
```

### 实践: 配置文件

my.conf

```ini
#-*-coding:utf-8-*-
# my.conf

[DEFAULT]
#[DEFAULT]不可省略
enabled_apis = ec2, osapi_keystone, osapi_compute
bind_host = 196.168.1.111
bind_port = 9999

[rabbit]
host = 127.0.0.1
port = 12345
use_ssl=true
user_id = guest
password = guest
```

接着写一个脚本文件`config.py`，该脚本的功能非常简单，直接执行时打印该脚本使用到的配置项的值。

```python
# -*-coding:utf-8-*-
# config.py

from oslo_config import cfg

# 声明配置项模式
# 单个配置项模式
enabled_apis_opt = cfg.ListOpt('enabled_apis',
                               default=['ec2', 'osapi_compute'],
                               help='List of APIs to enable by default.')
# 多个配置项组成一个模式
common_opts = [
    cfg.StrOpt('bind_host',
               default='0.0.0.0',
               help='IP address to listen on.'),

    cfg.IntOpt('bind_port',
               default=9292,
               help='Port number to listen on.')
]
# 配置组
rabbit_group = cfg.OptGroup(
    name='rabbit',
    title='RabbitMQ options'
)
# 配置组中的模式，通常以配置组的名称为前缀（非必须）
rabbit_ssl_opt = cfg.BoolOpt('use_ssl',
                             default=False,
                             help='use ssl for connection')
# 配置组中的多配置项模式
rabbit_Opts = [
    cfg.StrOpt('host',
               default='localhost',
               help='IP/hostname to listen on.'),
    cfg.IntOpt('port',
               default=5672,
               help='Port number to listen on.')
]

# 创建对象CONF，用来充当容器
CONF = cfg.CONF
# 注册单个配置项模式
CONF.register_opt(enabled_apis_opt)

# 注册含有多个配置项的模式
CONF.register_opts(common_opts)

# 配置组必须在其组件被注册前注册！
CONF.register_group(rabbit_group)

# 注册配置组中含有多个配置项的模式，必须指明配置组
CONF.register_opts(rabbit_Opts, rabbit_group)

# 注册配置组中的单配置项模式，指明配置组
CONF.register_opt(rabbit_ssl_opt, rabbit_group)

# 接下来打印使用配置项的值
if __name__ == "__main__":
    # 调用容器对象，传入要解析的文件（可以多个）
    CONF(default_config_files=['my.conf'])

    for i in CONF.enabled_apis:
        print("DEFAULT.enabled_apis: " + i)

    print("DEFAULT.bind_host: " + CONF.bind_host)
    print("DEFAULT.bind_port: " + str(CONF.bind_port))
    print("rabbit.use_ssl: " + str(CONF.rabbit.use_ssl))
    print("rabbit.host: " + CONF.rabbit.host)
    print("rabbit.port: " + str(CONF.rabbit.port))
```

执行 config.py，结果如下：

```sh
DEFAULT.enabled_apis: ec2
DEFAULT.enabled_apis: osapi_keystone
DEFAULT.enabled_apis: osapi_compute
DEFAULT.bind_host: 196.168.1.111
DEFAULT.bind_port: 9999
rabbit.use_ssl: True
rabbit.host: 127.0.0.1
rabbit.port: 12345
```

下面的 config_test.py 不指定配置文件

```python
if __name__ == "__main__":
    # 调用容器对象，传入要解析的文件（可以多个）
    # CONF(default_config_files=['my.conf'])
    CONF()

    for i in CONF.enabled_apis:
        print("DEFAULT.enabled_apis: " + i)

    print("DEFAULT.bind_host: " + CONF.bind_host)
    print("DEFAULT.bind_port: " + str(CONF.bind_port))
    print("rabbit.use_ssl: " + str(CONF.rabbit.use_ssl))
    print("rabbit.host: " + CONF.rabbit.host)
    print("rabbit.port: " + str(CONF.rabbit.port))
```

执行 config_test.py 比较结果差别：

```sh
DEFAULT.enabled_apis: ec2
DEFAULT.enabled_apis: osapi_compute
DEFAULT.bind_host: 0.0.0.0
DEFAULT.bind_port: 9292
rabbit.use_ssl: False
rabbit.host: localhost
rabbit.port: 5672
```

### 实践: 命令行和配置文件重复指定配置项

脚本文件`config.py`

```python
# -*-coding:utf-8-*-
# config.py
import argparse
import sys
from oslo_config import cfg

from oslo_config import types

PortType = types.Integer(1, 65535)
# 声明配置项模式
# 单个配置项模式
enabled_apis_opt = cfg.ListOpt('enabled_apis',
                               default=['ec2', 'osapi_compute'],
                               help='List of APIs to enable by default.')
# 多个配置项组成一个模式
common_opts = [
    cfg.StrOpt('bind_host',
               default='0.0.0.0',
               help='IP/hostname to listen on.'),
    cfg.Opt('bind_port',
            type=PortType,
            default=9292,
            help='Port number to listen on.')
]
# 配置组
rabbit_group = cfg.OptGroup(
    name='rabbit',
    title='RabbitMQ options'
)
# 配置组中的模式，通常以配置组的名称为前缀（非必须）
rabbit_ssl_opt = cfg.BoolOpt('use_ssl',
                             default=False,
                             help='use ssl for connection')
# 配置组中的多配置项模式
rabbit_Opts = [
    cfg.StrOpt('host',
               default='localhost',
               help='IP/hostname to listen on.'),
    cfg.Opt('port',
            type=PortType,
            default=5672,
            help='Port number to listen on.')
]

# 创建对象CONF，用来充当容器
CONF = cfg.CONF

# 注册单个配置项模式
CONF.register_opt(enabled_apis_opt)
# 注册含有多个配置项的模式
CONF.register_opts(common_opts)
# 配置组必须在其组件被注册前注册！
CONF.register_group(rabbit_group)
# 注册配置组中含有多个配置项的模式，必须指明配置组
CONF.register_opts(rabbit_Opts, rabbit_group)
# 注册配置组中的单配置项模式，指明配置组
CONF.register_opt(rabbit_ssl_opt, rabbit_group)

# 注册单个配置项模式
CONF.register_cli_opt(enabled_apis_opt)
# 注册含有多个配置项的模式
CONF.register_cli_opts(common_opts)
# 注册配置组中含有多个配置项的模式，必须指明配置组
CONF.register_cli_opts(rabbit_Opts, rabbit_group)
# 注册配置组中的单配置项模式，指明配置组
CONF.register_cli_opt(rabbit_ssl_opt, rabbit_group)

# 接下来打印使用配置项的值
if __name__ == "__main__":
    # 调用容器对象，传入要解析的文件（可以多个）
    # CONF(default_config_files=['my.conf'])
    CONF(sys.argv[1:], project='my', version='1.0')
    # CONF(sys.argv[1:], project='my', version='1.0', default_config_files=["./my.conf"])

    for i in CONF.enabled_apis:
        print("DEFAULT.enabled_apis: " + i)

    print("DEFAULT.bind_host: " + CONF.bind_host)
    print("DEFAULT.bind_port: " + str(CONF.bind_port))
    print("rabbit.use_ssl: " + str(CONF.rabbit.use_ssl))
    print("rabbit.host: " + CONF.rabbit.host)
    print("rabbit.port: " + str(CONF.rabbit.port))
```

```python
if __name__ == "__main__":
    # 调用容器对象，传入要解析的文件（可以多个）
    # CONF(default_config_files=['my.conf'])
    CONF(sys.argv[1:], project='my', version='1.0')
```

初始化后，才能正常解析配置文件和命令行选项。最终用户可以用默认的命令行选项`-config-file`或者`-config-dir`来指定配置文件名或者位置。

如果没有明确指定，默认按下面的顺序寻找配置文件：

```sh
/.my/my.conf ~/my.conf /etc/my/my.conf /etc/my.conf
```

可以使用以下命令行参数来传入配置文件或者直接在命令行中覆盖默认值：

1.传入配置文件：

```sh
python config.py --config-file ./my.conf
DEFAULT.enabled_apis: ec2
DEFAULT.enabled_apis: osapi_keystone
DEFAULT.enabled_apis: osapi_compute
DEFAULT.bind_host: 196.168.1.111
DEFAULT.bind_port: 9999
rabbit.use_ssl: True
rabbit.host: 127.0.0.1
rabbit.port: 12345
```

2.直接在命令行中覆盖默认值：

```sh
python config.py --enabled_apis ec2,osapi_compute --bind_host 127.0.0.1 --bind_port 8080 --rabbit-host localhost --rabbit-port 5671
DEFAULT.enabled_apis: ec2
DEFAULT.enabled_apis: osapi_compute
DEFAULT.bind_host: 127.0.0.1
DEFAULT.bind_port: 8080
rabbit.use_ssl: False
rabbit.host: localhost
rabbit.port: 5671
```

参考文献

oslo.config 用法总结

- https://gtcsq.readthedocs.io/en/latest/openstack/oslo_cfg.html

- https://blog.apporc.org/python--e9-85-8d-e7-bd-ae-e7-ae-a1-e7-90-86-ef-bc-9aoslo-config/

## 2.oslo.db

oslo.db 是针对 SQLAlchemy 访问的抽象。

代码库位于：https://github.com/openstack/oslo.db

项目主页为：https://bugs.launchpad.net/oslo

参考文档在：http://docs.openstack.org/developer/oslo.db

这个库主要用于 OpenStack 各个项目中的数据库操作，但它也可以被其他项目使用。

下面是一个简单的示例，展示了如何使用 `oslo.db` 来定义一个数据库模型，并进行基本的创建表、添加数据和查询数据操作。

首先，你需要安装 oslo.db 和其他依赖库：

```sh
pip install oslo.db sqlalchemy
```

`config.ini`

```ini
[database]
connection = sqlite:///example.db
;connection = mysql+pymysql://root:password123@localhost/database
```

然后，你可以编写一个 Python 脚本来使用 oslo.db：

`example.py`

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
from oslo_config import cfg
from oslo_db import options as db_options
from oslo_db.sqlalchemy import session
from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker

# 注册数据库配置选项
# db_options.set_defaults(cfg.CONF, connection='mysql+pymysql://root:123456@localhost:3306/test')
db_options.set_defaults(cfg.CONF)

# 定义配置文件路径
config_file = 'config.ini'
if os.path.exists(config_file):
    CONF = cfg.CONF
    # 加载配置文件
    CONF([], project='myapp', default_config_files=[config_file])
else:
    print(f"Config file '{config_file}' does not exist.")

# 创建数据库引擎
engine = create_engine(CONF.database.connection, echo=True)

# 定义模型基础类
Base = declarative_base()


# 定义一个简单的用户模型
class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)


# 创建表
Base.metadata.create_all(engine)

# 创建一个 Session 类
Session = sessionmaker(bind=engine)

# 创建一个数据库会话
with Session() as session:
    # 添加用户
    user = User(name='Alice', age=30)
    session.add(user)
    session.commit()

    # 查询用户
    users = session.query(User).all()
    for u in users:
        print(f'User ID: {u.id}, Name: {u.name}, Age: {u.age}')
```

确保 config.ini 文件和 Python 脚本位于同一目录中，或者提供正确的文件路径。这样，当脚本运行时，它会读取配置文件中的数据库连接信息，并使用这些信息来连接数据库。

## 3.oslo.i18n

oslo.i18n 是对 Python gettext 模块的封装，主要用于字符串的翻译和国际化。

参考文档在: http://docs.openstack.org/developer/oslo.i18n/

使用 oslo.i18n 前，需要首先创建一个如下的集成模块：

```python
#neutron/_i18n.py

import oslo_i18n
DOMAIN = "neutron"
_translators = oslo_i18n.TranslatorFactory(domain=DOMAIN)

# 主要的翻译函数，类似gettext中的"_"函数
_ = _translators.primary

#不同的log level对应的翻译函数
#对于debug level的log信息，不建议翻译

_LI = _translators.log_info
_LW = _translators.log_warning
_LE = _translators.log_error
_LC = _translators.log_critical

#之后，在程序中就可以比较容易的使用：

from neutron._i18n import _, _LW

LOG = logging.getLogger(name)
LOG.warning(_LW('No routers compatible with L3 agent '
                          'configuration on host %s'), host)
```

## 4.oslo.messaging

oslo.messaging 库为 OpenStack 各个项目使用 RPC 和事件通知（Event Notification）提供了一套统一的接口。

为了支持不同的 RPC 后端实现， oslo.messaging 对如下的对象进行了统一：

当使用 oslo.messaging 库时，可以通过配置文件指定所使用的 RPC 后端实现，例如 RabbitMQ、ZeroMQ 等。

oslo.messaging 提供了一套统一的接口，让不同的 RPC 后端实现可以在不修改应用代码的情况下进行切换。

一个服务端，golang 和 python 客户端的简单的代码示例

### 服务器端

```python
from oslo_config import cfg
from oslo_messaging import server as messaging_server
import oslo_messaging

CONF = cfg.CONF
transport = oslo_messaging.get_transport(CONF)

class RPCServerEndpoint(object):
    target = oslo_messaging.Target(namespace='demo', version='1.0')

    def echo(self, ctxt, arg):
        return "You said: %s" % arg

endpoints = [RPCServerEndpoint()]
target = oslo_messaging.Target(topic='test', server='server1')
server = messaging_server.MessageHandlingServer(transport, target, endpoints, executor='eventlet')
server.start()
server.wait()
```

### 客户端

#### golang

```go
package main

import (
	"fmt"
	"log"
	"github.com/streadway/amqp"
)

func main() {
	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		log.Fatalf("Failed to connect to RabbitMQ: %v", err)
	}
	defer conn.Close()

	ch, err := conn.Channel()
	if err != nil {
		log.Fatalf("Failed to open a channel: %v", err)
	}
	defer ch.Close()

	q, err := ch.QueueDeclare(
		"",    // name
		false, // durable
		true,  // delete when unused
		false, // exclusive
		false, // no-wait
		nil,   // arguments
	)
	if err != nil {
		log.Fatalf("Failed to declare a queue: %v", err)
	}

	msgs, err := ch.Consume(
		q.Name, // queue
		"",     // consumer
		true,   // auto-ack
		false,  // exclusive
		false,  // no-local
		false,  // no-wait
		nil,    // args
	)
	if err != nil {
		log.Fatalf("Failed to register a consumer: %v", err)
	}

	correlationID := generateUUID()

	err = ch.Publish(
		"test",         // exchange
		"server1",      // routing key
		false,          // mandatory
		false,          // immediate
		amqp.Publishing{
			ContentType:   "text/plain",
			CorrelationId: correlationID,
			ReplyTo:       q.Name,
			Body:          []byte("Hello from Golang"),
		})
	if err != nil {
		log.Fatalf("Failed to publish a message: %v", err)
	}

	for d := range msgs {
		if correlationID == d.CorrelationId {
			fmt.Printf("Response: %s\n", d.Body)
			break
		}
	}
}

func generateUUID() string {
	return "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" // Replace with your UUID generation logic
}
```

#### python

```python
from oslo_config import cfg
from oslo_messaging import messaging
import sys

CONF = cfg.CONF
TRANSPORT = messaging.get_transport(CONF)
TARGET = messaging.Target(topic='test', server='server1', namespace='demo', version='1.0')


def main():
    client = messaging.RPCClient(TRANSPORT, TARGET)

    arg = "Hello from Python"
    try:
        result = client.call({}, 'echo', arg=arg)
        print("Got response: %s" % result)
    except messaging.MessagingTimeout:
        print("Timeout while waiting for a response")
        sys.exit(1)


if __name__ == '__main__':
    main()
```

## 5.stevedore

利用 Python 语言的特性，运行时动态载入代码变得更加容易。

很多 Python 应用程序利用这样的特性在运行时发现和载入所谓的“插件”（plugin），使得自己更易于扩展。

Python 库 stevedore 就是在 Setuptools 的 entry points 基础上，构造了一层抽象层，使开发者可以更容易地在运行时发现和载入插件。

stevedore 参考文档在http://stevedore.readthedocs.org/。

## 6.cookiecutter

可以利用在 https://git.openstack.org/openstack-dev/cookiecutter 的模板，新建一个符合惯例的 OpenStack 项目。

```sh
sudo pip install cookiecutter
cd workspace
cookiecutter cookiecutter https://git.openstack.org/openstack-dev/cookiecutter
#（输入自己的模块名，例如 abc ）
#  cd abc
#  git init
#  git add .
#  git commit -a
```

可以看到利用 cookiecutter 模板建立起来的项目中，顶层目录下包含下表所示文件和目录

| 文件                  | 说明                                                 |
| --------------------- | ---------------------------------------------------- |
| abc                   | 代码目录                                             |
| babel.cfg             | babel 配置文件。babel 是一个用来帮助代码国家化的工具 |
| CONTRIBUTING.rst      | 开发者文件                                           |
| doc                   | 文档目录                                             |
| HACKING.rst           | 编码规范文件                                         |
| LICENSE               | 项目许可证信息                                       |
| MANIFEST.in           | MANIFEST 模板文件                                    |
| openstack-common.conf | 项目所用到的 oslo-incubator 库里的模块               |
| README.rst            | 项目说明文件                                         |
| requirements.txt      | 项目所依赖的第三方 python 库                         |
| setup.cfg             | setuptools 配置文件                                  |
| setup.py              | setuptools 主文件                                    |
| test-requirements.txt | 项目测试时所需要依赖的第三方 python 库               |
| tox.ini               | 项目测试的 tox 配置文件                              |
