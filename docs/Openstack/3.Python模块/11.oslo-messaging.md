# 11.oslo.messaging

oslo.messaging 库为 OpenStack 各个项目使用 RPC 和事件通知（Event Notification）提供了一套统一的接口。

为了支持不同的 RPC 后端实现， oslo.messaging 对如下的对象进行了统一：

当使用 oslo.messaging 库时，可以通过配置文件指定所使用的 RPC 后端实现，例如 RabbitMQ、ZeroMQ 等。

oslo.messaging 提供了一套统一的接口，让不同的 RPC 后端实现可以在不修改应用代码的情况下进行切换。

一个服务端，golang 和 python 客户端的简单的代码示例

## 服务器端

```python
from oslo_config import cfg
from oslo_messaging import server as messaging_server
import oslo_messaging

CONF = cfg.CONF
transport = oslo_messaging.get_transport(CONF)

class RPCServerEndpoint(object):
    target = oslo_messaging.Target(namespace='demo', version='1.0')

    def echo(self, ctxt, arg):
        return "You said: %s" % arg

endpoints = [RPCServerEndpoint()]
target = oslo_messaging.Target(topic='test', server='server1')
server = messaging_server.MessageHandlingServer(transport, target, endpoints, executor='eventlet')
server.start()
server.wait()
```

## 客户端

### golang

```go
package main

import (
	"fmt"
	"log"
	"github.com/streadway/amqp"
)

func main() {
	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		log.Fatalf("Failed to connect to RabbitMQ: %v", err)
	}
	defer conn.Close()

	ch, err := conn.Channel()
	if err != nil {
		log.Fatalf("Failed to open a channel: %v", err)
	}
	defer ch.Close()

	q, err := ch.QueueDeclare(
		"",    // name
		false, // durable
		true,  // delete when unused
		false, // exclusive
		false, // no-wait
		nil,   // arguments
	)
	if err != nil {
		log.Fatalf("Failed to declare a queue: %v", err)
	}

	msgs, err := ch.Consume(
		q.Name, // queue
		"",     // consumer
		true,   // auto-ack
		false,  // exclusive
		false,  // no-local
		false,  // no-wait
		nil,    // args
	)
	if err != nil {
		log.Fatalf("Failed to register a consumer: %v", err)
	}

	correlationID := generateUUID()

	err = ch.Publish(
		"test",         // exchange
		"server1",      // routing key
		false,          // mandatory
		false,          // immediate
		amqp.Publishing{
			ContentType:   "text/plain",
			CorrelationId: correlationID,
			ReplyTo:       q.Name,
			Body:          []byte("Hello from Golang"),
		})
	if err != nil {
		log.Fatalf("Failed to publish a message: %v", err)
	}

	for d := range msgs {
		if correlationID == d.CorrelationId {
			fmt.Printf("Response: %s\n", d.Body)
			break
		}
	}
}

func generateUUID() string {
	return "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" // Replace with your UUID generation logic
}
```

### python

```python
from oslo_config import cfg
from oslo_messaging import messaging
import sys

CONF = cfg.CONF
TRANSPORT = messaging.get_transport(CONF)
TARGET = messaging.Target(topic='test', server='server1', namespace='demo', version='1.0')


def main():
    client = messaging.RPCClient(TRANSPORT, TARGET)

    arg = "Hello from Python"
    try:
        result = client.call({}, 'echo', arg=arg)
        print("Got response: %s" % result)
    except messaging.MessagingTimeout:
        print("Timeout while waiting for a response")
        sys.exit(1)


if __name__ == '__main__':
    main()
```

- https://www.xiexianbin.cn/openstack/dev/openstack-rpc/index.html?to_index=1
