# Go By Example

## Go 经典hello world

我们的第一个例子是打印经典的“hello world”信息，我们先看下代码。
```go
package main
import "fmt"
func main() {
    fmt.Println("hello world")
}
```

输出结果为：
```sh
$ ls
el_01_hello_world.go
$ go build el_01_hello_world.go 
$ ls
el_01_hello_world    el_01_hello_world.go
$ ./el_01_hello_world 
hello world
```

为了使一个go文件能够编译为可执行文件，包名必须是main，然后我们导入提供格式化输出的fmt包，该程序的执行入口是func main()函数，在函数里面，我们使用fmt包提供的Println函数来输出”hello world”字符串。

为了运行这个程序，我们可以使用`go run el_01_hello_world.go`来运行这个例子，这样是直接输出运行结果而不会产生任何中间文件。

但是有的时候我们希望能够将程序编译为二进制文件保存起来，我们可以像上面一样使用`go build el_01_hello_world.go`来将源代码编译为二进制可执行文件。

然后我们可以直接运行这个二进制可执行文件。

好了，第一个例子就这样结束了。很简单。


## Go 数据类型

Go 拥有多种值类型，包括字符串，整型，浮点型，布尔型等。下面是一些基本的例子。

```go
package main

import "fmt"

func main() {

    // 字符串可以通过 `+` 连接。
    fmt.Println("go" + "lang")    //golang

    // 整数和浮点数
    fmt.Println("1+1 =", 1+1) //1+1 = 2
    fmt.Println("7.0/3.0 =", 7.0/3.0)//7.0/3.0 = 2.3333333333333335

    // 布尔型，以及常见的布尔操作。
    fmt.Println(true && false)  //false
    fmt.Println(true || false)  //true
    fmt.Println(!true)  //false
}
```





## Go 变量

Go是静态类型语言，变量是有明确类型的。编译器会检查函数调用中，变量类型的正确性。

使用var关键字来定义变量。

Go 的基本类型有：

```sh
bool
string
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
byte // uint8 的别名
rune // int32 的别名 代表一个Unicode码
float32 float64
complex64 complex128
```


看看下面的例子

```go
package main

import "fmt"

func main() {
	// `var` 关键字用来定义一个或者多个变量
	var a string = "initial"
	fmt.Println(a) //initial

	// 你一次可以定义多个变量
	var b, c int = 1, 2
	fmt.Println(b, c)	//1 2

	// Go会推断出具有初始值的变量的类型
	var d = true
	fmt.Println(d) //true

	//定义变量时，没有给出初始值的变量被默认初始化为零值
	//整型的零值就是0
	var e int
	fmt.Println(e) //0

	//":=" 语法是同时定义和初始化变量的快捷方式
	f := "short"
	fmt.Println(f)	//short
}
```




## Go 环境变量

环境变量是一种很普遍的将配置信息传递给Unix程序的机制。

```go
package main

import "os"
import "strings"
import "fmt"

func main() {
	// 为了设置一个key/value对，使用`os.Setenv`
	// 为了获取一个key的value，使用`os.Getenv`
	// 如果所提供的key在环境变量中没有对应的value，
	// 那么返回空字符串
	os.Setenv("FOO", "1")
	err := os.Setenv("FOO", "2")
	if err != nil {
		fmt.Println("设置环境变量出错:", err)
		return
	}
	fmt.Println("FOO:", os.Getenv("FOO")) //FOO: 2
	fmt.Println("BAR:", os.Getenv("BAR")) //BAR:

	// 删除环境变量
	err = os.Unsetenv("FOO")
	if err != nil {
		fmt.Println("删除环境变量出错:", err)
		return
	}

	// 验证是否删除成功
	value := os.Getenv("FOO")
	if value == "" {
		fmt.Println("环境变量已成功删除") //环境变量已成功删除
	} else {
		fmt.Println("环境变量删除失败")
	}

	// 使用`os.Environ`来列出环境变量中所有的key/value对
	// 你可以使用`strings.Split`方法来将key和value分开
	// 这里我们打印所有的key
	fmt.Println()
	for _, e := range os.Environ() {
		pair := strings.Split(e, "=")
		fmt.Println(pair[0])
	}
}
```

如果我们在运行前设置了 BAR 的值，那么运行程序将会获取到这个值。

```sh

$ BAR=2 go run environment-variables.go
FOO: 1
BAR: 2
...
```


## Go 常量

Go支持定义字符常量，字符串常量，布尔型常量和数值常量。

使用 `const` 关键字来定义常量。

```go
package main

import "fmt"
import "math"

// "const" 关键字用来定义常量
const s string = "constant"

func main() {
	fmt.Println(s) //constant

	// "const"关键字可以出现在任何"var"关键字出现的地方
	// 区别是常量必须有初始值
	const n = 500000000
	// 常量表达式可以执行任意精度数学计算
	const d = 3e20 / n
	fmt.Println(d) //6e+11

	// 数值型常量没有具体类型，除非指定一个类型
	// 比如显式类型转换
	fmt.Println(int64(d)) //600000000000

	// 数值型常量可以在程序的逻辑上下文中获取类型
	// 比如变量赋值或者函数调用。
	// 例如，对于math包中的Sin函数,它需要一个float64类型的变量
	fmt.Println(math.Sin(n)) //-0.28470407323754404
}
```



## Go for

for循环是Go语言唯一的循环结构。这里有三个基本的for循环类型。


```go
package main

import "fmt"

func main() {
	// 最基本的一种，单一条件循环
	// 这个可以代替其他语言的while循环
	i := 1
	for i <= 3 {
		fmt.Println(i)
		i = i + 1
	}
	// 经典的循环条件初始化/条件判断/循环后条件变化
	for j := 7; j <= 9; j++ {
		fmt.Println(j)
	}
	// 无条件的for循环是死循环，除非你使用break跳出循环或者
	// 使用return从函数返回
	for {
		fmt.Println("loop")
		break
	}
}

```

输出结果

```sh
1
2
3
7
8
9
loop
```

在后面的例子中，你将会看到其他的循环方式，比如使用range函数循环数组，切片和字典，或者用select函数循环channel通道。




## Go if..else条件判断


Go语言的条件判断结构也很简单。

```go

package main

import "fmt"

func main() {
	// 基本的例子
	if 7%2 == 0 {
		fmt.Println("7 is even")
	} else {
		fmt.Println("7 is odd")
	}
	// 只有if条件的情况
	if 8%4 == 0 {
		fmt.Println("8 is divisible by 4")
	}
	// if条件可以包含一个初始化表达式，这个表达式中的变量
	// 是这个条件判断结构的局部变量
	if num := 9; num < 0 {
		fmt.Println(num, "is negative")
	} else if num < 10 {
		fmt.Println(num, "has 1 digit")
	} else {
		fmt.Println(num, "has multiple digits")
	}
}
```

条件判断结构中，条件两边的小括号()是可以省略的，但是条件执行语句块两边的大括号{}不可以。

输出结果为
```sh
7 is odd
8 is divisible by 4
9 has 1 digit
```

在 Go 里面没有三元表达式 "?:" ，所以你只能使用条件判断语句。


## Go switch/case语句

当条件判断分支太多的时候，我们会使用switch语句来优化逻辑。

```go
package main

import "fmt"
import "time"

func main() {

	// 一个基本的 `switch`。
	i := 2
	fmt.Print("write ", i, " as ")
	switch i {
	case 1:
		fmt.Println("one")
	case 2:
		fmt.Println("two")
	case 3:
		fmt.Println("three")
	}

	// 在同一个 `case` 语句中，你可以使用逗号来分隔多个表达式。
	// 在这个例子中，我们还使用了可选的 `default` 分支。
	switch time.Now().Weekday() {
	case time.Saturday, time.Sunday:
		fmt.Println("It's the weekend")
	default:
		fmt.Println("It's a weekday")
	}

	// 不带表达式的 `switch` 是实现 if/else 逻辑的另一种方式。
	// 这里还展示了 `case` 表达式也可以不使用常量。
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("It's before noon")
	default:
		fmt.Println("It's after noon")
	}

	// 类型开关 (`type switch`) 比较类型而非值。可以用来发现一个接口值的类型。
	// 在这个例子中，变量 `t` 在每个分支中会有相应的类型。
	whatAmI := func(i interface{}) {
		switch t := i.(type) {
		case bool:
			fmt.Println("I'm a bool")
		case int:
			fmt.Println("I'm an int")
		default:
			fmt.Printf("Don't know type %T\n", t)
		}
	}
	whatAmI(true)
	whatAmI(1)
	whatAmI("hey")
}
```

运行输出结果：

```sh
$ go run switch.go
Write 2 as two
It's a weekday
It's after noon
I'm a bool
I'm an int
Don't know type string
```



## Go 切片

切片是Go语言的关键类型之一，它提供了比数组更多的功能。

### 示例1：

```go
package main

import "fmt"

func main() {
	// 和数组不同的是，切片的长度是可变的。
	// 我们可以使用内置函数make来创建一个长度不为零的切片
	// 这里我们创建了一个长度为3，存储字符串的切片，切片元素
	// 默认为零值，对于字符串就是""。
	s := make([]string, 3)
	fmt.Println("emp:", s) //emp: [  ]

	// 可以使用和数组一样的方法来设置元素值或获取元素值
	s[0] = "a"
	s[1] = "b"
	s[2] = "c"
	fmt.Println("set:", s)    //set: [a b c]
	fmt.Println("get:", s[2]) //get: c
	// 可以用内置函数len获取切片的长度
	fmt.Println("len:", len(s)) //len: 3

	// 切片还拥有一些数组所没有的功能。
	// 例如我们可以使用内置函数append给切片追加值，然后
	// 返回一个拥有新切片元素的切片。
	// 注意append函数不会改变原切片，而是生成了一个新切片，
	// 我们需要用原来的切片来接收这个新切片
	s = append(s, "d")
	s = append(s, "e", "f")
	fmt.Println("apd:", s) //apd: [a b c d e f]

	// 另外我们还可以从一个切片拷贝元素到另一个切片
	// 下面的例子就是创建了一个和切片s长度相同的新切片
	// 然后使用内置的copy函数来拷贝s的元素到c中。
	c := make([]string, len(s))
	copy(c, s)
	fmt.Println("cpy:", c) //cpy: [a b c d e f]

	// 切片还支持一个取切片的操作 "slice[low:high]"
	// 获取的新切片包含元素"slice[low]"，但是不包含"slice[high]"
	// 下面的例子就是取一个新切片，元素包括"s[2]"，"s[3]"，"s[4]"。
	l := s[2:5]
	fmt.Println("sl1:", l) //sl1: [c d e]

	// 如果省略low，默认从0开始，不包括"slice[high]"元素
	l = s[:5]
	fmt.Println("sl2:", l) //sl2: [a b c d e]

	// 如果省略high，默认为len(slice)，包括"slice[low]"元素
	l = s[2:]
	fmt.Println("sl3:", l) //sl3: [c d e f]

	// 我们可以同时声明和初始化一个切片
	t := []string{"g", "h", "i"}
	fmt.Println("dcl:", t) //dcl: [g h i]

	// 我们也可以创建多维切片，和数组不同的是，切片元素的长度也是可变的。
	twoD := make([][]int, 3)
	for i := 0; i < 3; i++ {
		innerLen := i + 1
		twoD[i] = make([]int, innerLen)
		for j := 0; j < innerLen; j++ {
			twoD[i][j] = i + j
		}
	}

	fmt.Println("2d: ", twoD) //2d:  [[0] [1 2] [2 3 4]]
}
```



数组和切片的定义方式的区别在于[]之中是否有固定长度或者推断长度标志符...。

### 示例2：

```go
package main

import "fmt"

func main() {
	s1 := make([]int, 0)
	test(s1)
	fmt.Println(s1)
}
func test(s []int) {
	s = append(s, 3)
	//因为原来分配的空间不够，所以在另外一个地址又重新分配了空间，所以原始地址的数据没有变
}
```

输出结果为：
```sh
[]
```

若改为：
```go
package main

import "fmt"

func main() {
	s1 := make([]int, 0)
	s1 = test(s1)
	fmt.Println(s1)
}
func test(s []int) []int {
	s = append(s, 3)
	return s
}

```

输出结果为：
```sh
[3]   //正确结果
```


### 示例3：

cap是slice的最大容量，append函数添加元素，如果超过原始slice的容量，会重新分配底层数组。


```go
package main

import "fmt"

func main() {
	s1 := make([]int, 3, 6)
	fmt.Println("s1= ", s1, len(s1), cap(s1)) //s1=  [0 0 0] 3 6

	s2 := append(s1, 1, 2, 3)
	fmt.Println("s1= ", s1, len(s1), cap(s1)) //s1=  [0 0 0] 3 6
	fmt.Println("s2= ", s2, len(s2), cap(s2)) //s2=  [0 0 0 1 2 3] 6 6

	s3 := append(s2, 4, 5, 6)
	fmt.Println("s1= ", s1, len(s1), cap(s1)) //s1=  [0 0 0] 3 6
	fmt.Println("s2= ", s2, len(s2), cap(s2)) //s2=  [0 0 0 1 2 3] 6 6
	fmt.Println("s3= ", s3, len(s3), cap(s3)) //s3=  [0 0 0 1 2 3 4 5 6] 9 12
}
```


### 示例4：

指向同一底层数组的slice之间copy时，允许存在重叠。

copy数组时，受限于src和dst数组的长度最小值。


```go
package main

import "fmt"

func main() {
	s1 := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s2 := make([]int, 3, 20)

	var n int
	n = copy(s2, s1)
	fmt.Println(n, s2, len(s2), cap(s2)) //3 [0 1 2] 3 20

	s3 := s1[4:6]
	fmt.Println(n, s3, len(s3), cap(s3)) //3 [4 5] 2 6

	n = copy(s3, s1[1:5])
	fmt.Println(n, s3, len(s3), cap(s3)) //2 [1 2] 2 6

}
```


## Go 数组

- 数组是一个具有`相同数据类型`的元素组成的`固定长度`的`有序集合`。

- 在Go语言中，数组是值类型，长度是类型的组成部分，也就是说 `”[10]int“` 和 `“[20]int”` 是完全不同的两种数组类型。

- 同类型的两个数组支持”==”和”!=”比较，但是不能比较大小。

- 数组作为参数时，函数内部不改变数组内部的值，除非是传入数组的指针。

- 数组的指针：*[3]int

- 指针数组：[2]*int

### 示例1:

```go
package main

import "fmt"

func main() {
	// 这里我们创建了一个具有5个元素的整型数组
	// 元素的数据类型和数组长度都是数组的一部分
	// 默认情况下，数组元素都是零值
	// 对于整数，零值就是0
	var a [5]int
	fmt.Println("emp:", a) //emp: [0 0 0 0 0]

	// 我们可以使用索引来设置数组元素的值，就像这样
	// "array[index] = value"  或者使用索引来获取元素值，
	// 就像这样"array[index]"
	a[4] = 100
	fmt.Println("set:", a) //set: [0 0 0 0 100]

	fmt.Println("get:", a[4]) //get: 100
	// 内置的len函数返回数组的长度
	fmt.Println("len:", len(a)) //len: 5

	// 这种方法可以同时定义和初始化一个数组
	b := [5]int{1, 2, 3, 4, 5}
	fmt.Println("dcl:", b) //dcl: [1 2 3 4 5]
	// 数组都是一维的，但是你可以把数组的元素定义为一个数组
	// 来获取多维数组结构
	var twoD [2][3]int
	for i := 0; i < 2; i++ {
		for j := 0; j < 3; j++ {
			twoD[i][j] = i + j
		}
	}
	fmt.Println("2d: ", twoD) //2d:  [[0 1 2] [1 2 3]]
}

```

拥有`固定长度`是数组的一个特点，但是这个特点有时候会带来很多不便，尤其在一个集合元素个数不固定的情况下。

这个时候我们更多地使用`切片`。


### 示例2:

可以用new创建数组，并返回数组的指针

```go
package main

import "fmt"

func main() {
	var a = new([5]int)
	test(a)
	fmt.Println(a, len(a)) //&[0 5 0 0 0] 5
}
func test(a *[5]int) {
	a[1] = 5
}
```

### 示例3:

```go
package main

import "fmt"

func main() {
	a := [...]User{
		{0, "User0"},
		{8, "User8"},
	}
	b := [...]*User{
		{0, "User0"},
		{8, "User8"},
	}
	fmt.Println(a, len(a)) //[{0 User0} {8 User8}] 2
	fmt.Println(b, len(b)) //[0xc000008078 0xc000008090] 2
}

type User struct {
	Id   int
	Name string
}
```


### 示例4：

遍历数组的方式

```go
package main

import "fmt"

var arrAge = [5]int{12, 13, 14, 15, 16}

//var arrLazy = [...]int{22, 23, 24, 25, 26}
//var arrKeyValue = [5]string{3: "hujian", 4: "xiaojian"}

func main() {
	// 遍历方法1
	for _, i2 := range arrAge {
		fmt.Println(i2)
	}
	fmt.Println("----------------------------")

	// 遍历方法2
	for i := 0; i < len(arrAge); i++ {
		fmt.Println(arrAge[i])
	}
}
```



## Go 字典

字典是Go语言内置的关联数据类型。因为数组是索引对应数组元素，而字典是键对应值。


### 示例1:
```go
package main

import "fmt"

func main() {
	// 创建一个字典可以使用内置函数make
	// "make(map[键类型]值类型)"
	m := make(map[string]int)
	// 使用经典的"name[key]=value"来为键设置值
	m["k1"] = 7
	m["k2"] = 13
	// 用Println输出字典，会输出所有的键值对
	fmt.Println("map:", m) //map: map[k1:7 k2:13]

	// 获取一个键的值 "name[key]".
	v1 := m["k1"]
	fmt.Println("v1: ", v1) //v1:  7

	// 内置函数返回字典的元素个数
	fmt.Println("len:", len(m)) //len: 2

	// 内置函数delete从字典删除一个键对应的值
	delete(m, "k2")
	fmt.Println("map:", m) //map: map[k1:7]

	// 根据键来获取值有一个可选的返回值，这个返回值表示字典中是否
	// 存在该键，如果存在为true，返回对应值，否则为false，返回零值
	// 有的时候需要根据这个返回值来区分返回结果到底是存在的值还是零值
	// 比如字典不存在键x对应的整型值，返回零值就是0，但是恰好字典中有
	// 键y对应的值为0，这个时候需要那个可选返回值来判断是否零值。
	_, ok := m["k2"]
	fmt.Println("ok:", ok) //ok: false

	// 你可以用 ":=" 同时定义和初始化一个字典
	n := map[string]int{"foo": 1, "bar": 2}
	fmt.Println("map:", n) //map: map[bar:2 foo:1]

	hu := map[string]string{
		"name":   "hujianli",
		"age":    "22",
		"sex":    "man",
		"school": "dianda",
	}
	// name:hujianli  age:22  sex:man  school:dianda
	fmt.Printf("name:%s  age:%s  sex:%s  school:%s\n", hu["name"], hu["age"], hu["sex"], hu["school"])

	//遍历map中的键值对–访问关联关系
	for i, i2 := range hu {
		fmt.Printf("key:%s value:%s\n", i, i2)
	}

	// 只遍历值
	for _, i2 := range hu {
		fmt.Printf("value -> %s\n", i2)
	}
	// 只遍历键
	for i := range hu {
		fmt.Printf("key -> %s\n", i)
	}

	// var mydicMap map[string]string
	mydicMaps := make(map[string]string)
	mydicMaps["hujianli1"] = "A1"
	mydicMaps["hujianli2"] = "A2"
	mydicMaps["hujianli3"] = "A3"

	for k, v := range mydicMaps {
		fmt.Printf("%s %s\n", k, v)
	}
	name1, ok := mydicMaps["hu1"]
	if !ok {
		fmt.Println("----------", name1)
	}

	// 或者
	if name2, ok := mydicMaps["hu2"]; !ok {
		fmt.Println("----------", name2)
	}
}
```

### 示例2:

排序遍历

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	scene := make(map[string]int)
	//准备map数据
	scene["route"] = 66
	scene["brazil"] = 4
	scene["china"] = 960
	// 声明一个切片保存map数据
	var sceneList []string
	// 将map数据遍历后复制到切片中
	for key := range scene {
		sceneList = append(sceneList, key)
	}
	// 对切片进行排序
	sort.Strings(sceneList)
	// 输出
	fmt.Println(sceneList) //[brazil china route]
}
```


清空map中的所有元素

Go 语言中没有清空map的方法和函数。

清空map的位于方法是重新make一个新的map。 

Go中的并行垃圾回收效率比写一个清空函数高效多了。



清空 map的一个解决方法

但在多次讨论中，Go 官方团队给出的解决方案是：

```go
for k := range m {
    delete(m, k)
}
```


```go
package main

import "fmt"

func main() {
	scene := make(map[string]int)
	//准备map数据
	scene["route"] = 66
	scene["brazil"] = 4
	scene["china"] = 960
	fmt.Println(scene) //map[brazil:4 china:960 route:66]

	//清空 map
	for k := range scene {
		delete(scene, k)
	}
	fmt.Println(scene) //map[]
}
```

### 示例3:

使用map查找重复的行

```go
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

func main() {
	counts := make(map[string]int)
	for _, filename := range os.Args[1:] {
		data, err := ioutil.ReadFile(filename)
		if err != nil {
			fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
			continue
		}
		for _, line := range strings.Split(string(data), "\n") {
			counts[line]++
		}
	}
	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}
```

执行结果
```sh
$ go run .\main.go .\test.txt
3       aaaaaaaaa
2       bbbb
```


## Go 列表

go 语言中的  

- 数组是类型相同的元素的集合

- 列表是双链表的容器, 可以添加不同类型的数据

- 切片是对现有数组的引用, 比数组更方便灵活, 还可以追加数据


列表与切片和map不同的是，列表并没有具体元素类型的限制。

因此，列表的元素可以是任意类型。

这既带来便利，也会引来一些问题。

给一个列表放入了非期望类型的值，在取出值后，将interface{}转换为期望类型时将会发生宕机。


### 示例1

```go
package main

import (
	"fmt"
)

func main() {
	// 定义包含不同类型值的列表
	list := []interface{}{"apple", 123, true}
	// 在遍历列表时,使用Switch语句根据元素的实际类型执行相应的操作。
	for _, item := range list {
		switch v := item.(type) {
		case string:
			fmt.Println("String:", v)
		case int:
			fmt.Println("Integer:", v)
		case bool:
			fmt.Println("Boolean:", v)
		default:
			fmt.Println("Unknown type")
		}
	}

	// 类型断言示例
	// 尝试将第一个元素转换为字符串类型，并使用ok变量来判断转换是否成功。
	str, ok := list[0].(string)
	if ok {
		fmt.Println("First element is a string:", str)
	} else {
		fmt.Println("First element is not a string")
	}
}
```


### 示例2

```go
package main

import (
	"container/list"
	"fmt"
)

func main() {
	// 创建一个列表实例
	l := list.New()
	// 将first字符串插入到列表的尾部，此时列表有一个元素
	l.PushBack("first")
	//67这个元素将被放在fist的前面
	l.PushFront(67)
	// 返回list最后一个元素
	fmt.Println(l.Back()) //&{0xc000122510 0xc000122570 0xc000122510 first}
	//返回list第一个元素
	fmt.Println(l.Front()) //&{0xc000122540 0xc000122510 0xc000122510 67}

	// 创建一个列表实例
	l1 := list.New()
	l1.PushBack("cancon") //尾部加          canon
	l1.PushFront(67)      // 头部加         67 canon

	// 尾部添加后保存元素句柄
	element := l1.PushBack("fist")   // 67 canon fist
	l1.InsertAfter("hight", element) // 在first后添加hight       67 canon fist hight
	l1.InsertBefore("None", element) // 在first之前添加None   67 canon None fist hight
	l1.Remove(element)               // 移除element变量对象的元素  67 canon None hight

	// 循环打印列表
	for i := l1.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
	}
}
```



## Go range函数

range函数是个神奇而有趣的内置函数，你可以使用它来遍历数组，切片和字典。

当用于遍历数组和切片的时候，range函数返回索引和元素；

当用于遍历字典的时候，range函数返回字典的键和值。


```go
package main

import "fmt"

func main() {
	// 这里我们使用range来计算一个切片的所有元素和
	// 这种方法对数组也适用
	nums := []int{2, 3, 4}
	sum := 0
	for _, num := range nums {
		sum += num
	}
	fmt.Println("sum:", sum)

	// range 用来遍历数组和切片的时候返回索引和元素值
	// 如果我们不要关心索引可以使用一个下划线(_)来忽略这个返回值
	// 当然我们有的时候也需要这个索引
	for i, num := range nums {
		if num == 3 {
			fmt.Println("index:", i)
		}
	}

	// 使用range来遍历字典的时候，返回键值对。
	kvs := map[string]string{"a": "apple", "b": "banana"}
	for k, v := range kvs {
		fmt.Printf("%s -> %s\n", k, v)
	}

	// range函数用来遍历字符串时，返回Unicode代码点。
	// 第一个返回值是每个字符的起始字节的索引，第二个是字符代码点，
	// 因为Go的字符串是由字节组成的，多个字节组成一个rune类型字符。
	for i, c := range "go" {
		fmt.Println(i, c)
	}
}
```

输出结果为
```sh
sum: 9
index: 1
a -> apple
b -> banana
0 103
1 111
```


## Go 字符串操作函数

strings 标准库提供了很多字符串操作相关的函数。这里提供的几个例子是让你先对这个包有个基本了解。

### 示例1

```go
package main

import s "strings"
import "fmt"

// 这里给fmt.Println起个别名，因为下面我们会多处使用。
var p = fmt.Println

func main() {
	// 下面是strings包里面提供的一些函数实例。注意这里的函数并不是
	// string对象所拥有的方法，这就是说使用这些字符串操作函数的时候
	// 你必须将字符串对象作为第一个参数传递进去。
	p("Contains:  ", s.Contains("test", "es"))        //Contains:   true
	p("Count:     ", s.Count("test", "t"))            //Count:      2
	p("HasPrefix: ", s.HasPrefix("test", "te"))       //HasPrefix:  true
	p("HasSuffix: ", s.HasSuffix("test", "st"))       //HasSuffix:  true
	p("Index:     ", s.Index("test", "e"))            //Index:      1
	p("Join:      ", s.Join([]string{"a", "b"}, "-")) //Join:       a-b
	p("Repeat:    ", s.Repeat("a", 5))                //Repeat:     aaaaa
	p("Replace:   ", s.Replace("foo", "o", "0", -1))  //Replace:    f00
	p("Replace:   ", s.Replace("foo", "o", "0", 1))   //Replace:    f0o
	p("Split:     ", s.Split("a-b-c-d-e", "-"))       //Split:      [a b c d e]
	p("ToLower:   ", s.ToLower("TEST"))               //ToLower:    test
	p("ToUpper:   ", s.ToUpper("test"))               //ToUpper:    TEST
	p()
	// 你可以在strings包里面找到更多的函数
	// 这里还有两个字符串操作方法，它们虽然不是strings包里面的函数，
	// 但是还是值得提一下。一个是获取字符串长度，另外一个是从字符串中
	// 获取指定索引的字符
	p("Len: ", len("hello")) //Len:  5
	p("Char:", "hello"[1])   //Char: 101
}
```





### 示例2

```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	str0 := "hujianli"
	str1 := `第一行
    第二行
    第三行
    `
	fmt.Println(len(str0), len(str1)) //求长度
	var str3 string = str0 + str1
	fmt.Println(str3)

	str4 := fmt.Sprintf("%s %s", str0, str1) //拼接字符串
	fmt.Println(str4)

	str5 := "hu,jian,li"
	fmt.Println(strings.Split(str5, ",")) //分割
	fmt.Println(strings.Split(str5, "i"))
	fmt.Printf("%q\n", strings.Split(" xyz ", ""))
	fmt.Printf("%q\n", strings.Split("", "Bernardo O'Higgins"))

	fmt.Printf("%t\n", strings.Contains("sssss", "ss")) //判断是否包含

	fmt.Printf("%t\n", strings.HasPrefix("hujianli", "hu")) //判断前缀
	fmt.Printf("%t\n", strings.HasSuffix("hujianli", "li")) //判断后缀
	fmt.Printf("%d\n", strings.Index("hujianli", "li"))     //判断子串出现的位置
	fmt.Printf("%d\n", strings.LastIndex("hujianli", "i"))  //判断子串最后出现的位置
	s := []string{"foo", "bar", "baz"}
	fmt.Println(strings.Join(s, ",")) //将一系列字符串连接为一个字符串，之间用sep来分隔。
}
```



## Go 字符串格式化

Go对字符串格式化提供了良好的支持。下面我们看些常用的字符串格式化的例子。


```go
package main

import "fmt"
import "os"

type point struct {
	x, y int
}

func main() {
	// Go提供了几种打印格式，用来格式化一般的Go值，例如
	// 下面的%v打印了一个point结构体的对象的值
	p := point{1, 2}
	fmt.Printf("%v\n", p) //{1 2}

	// 如果所格式化的值是一个结构体对象，那么`%+v`的格式化输出
	// 将包括结构体的成员名称和值
	fmt.Printf("%+v\n", p) //{x:1 y:2}

	// `%#v`格式化输出将输出一个值的Go语法表示方式。
	fmt.Printf("%#v\n", p) //main.point{x:1, y:2}

	// 使用`%T`来输出一个值的数据类型
	fmt.Printf("%T\n", p) //main.point

	// 格式化布尔型变量
	fmt.Printf("%t\n", true) //true

	// 有很多的方式可以格式化整型，使用`%d`是一种
	// 标准的以10进制来输出整型的方式
	fmt.Printf("%d\n", 123) //123

	// 这种方式输出整型的二进制表示方式
	fmt.Printf("%b\n", 14) //1110

	// 这里打印出该整型数值所对应的字符
	fmt.Printf("%c\n", 33) //!

	// 使用`%x`输出一个值的16进制表示方式
	fmt.Printf("%x\n", 456) //1c8

	// 浮点型数值也有几种格式化方法。最基本的一种是`%f`
	fmt.Printf("%f\n", 78.9) //78.900000

	// `%e`和`%E`使用科学计数法来输出整型
	fmt.Printf("%e\n", 123400000.0) //1.234000e+08
	fmt.Printf("%E\n", 123400000.0) //1.234000E+08

	// 使用`%s`输出基本的字符串
	fmt.Printf("%s\n", "\"string\"") //"string"

	// 输出像Go源码中那样带双引号的字符串，需使用`%q`
	fmt.Printf("%q\n", "\"string\"") //"\"string\""

	// `%x`以16进制输出字符串，每个字符串的字节用两个字符输出
	fmt.Printf("%x\n", "hex this") //6865782074686973

	// 使用`%p`输出一个指针的值
	fmt.Printf("%p\n", &p) //0xc0000180c0

	// 当输出数字的时候，经常需要去控制输出的宽度和精度。
	// 可以使用一个位于%后面的数字来控制输出的宽度，默认
	// 情况下输出是右对齐的，左边加上空格
	fmt.Printf("|%6d|%6d|\n", 12, 345) //|    12|   345|

	// 你也可以指定浮点数的输出宽度，同时你还可以指定浮点数
	// 的输出精度
	fmt.Printf("|%6.2f|%6.2f|\n", 1.2, 3.45) //|  1.20|  3.45|

	// To left-justify, use the `-` flag.
	fmt.Printf("|%-6.2f|%-6.2f|\n", 1.2, 3.45) //|1.20  |3.45  |

	// 你也可以指定输出字符串的宽度来保证它们输出对齐。默认
	// 情况下，输出是右对齐的
	fmt.Printf("|%6s|%6s|\n", "foo", "b") //|   foo|     b|

	// 为了使用左对齐你可以在宽度之前加上`-`号
	fmt.Printf("|%-6s|%-6s|\n", "foo", "b") //|foo   |b     |

	// `Printf`函数的输出是输出到命令行`os.Stdout`的，你
	// 可以用`Sprintf`来将格式化后的字符串赋值给一个变量
	s := fmt.Sprintf("a %s", "string")
	fmt.Println(s) //a string

	// 你也可以使用`Fprintf`来将格式化后的值输出到`io.Writers`
	fmt.Fprintf(os.Stderr, "an %s\n", "error") //an error
}
```



## Go 函数定义

函数是Go语言的重要内容。

```go
package main

import "fmt"

// 这个函数计算两个int型输入数据的和，并返回int型的和
func plus(a int, b int) int {
	// Go需要使用return语句显式地返回值
	return a + b
}
func main() {
	// 函数的调用方式很简单
	// "名称(参数列表)"
	res := plus(1, 2)
	fmt.Println("1+2 =", res) //1+2 = 3
}

```

Go的函数还有很多其他的特性，其中一个就是多返回值，我们下面会看到。

## Go 多返回值函数

```go
package main

import "fmt"

// `(int, int)` 在这个函数中标志着这个函数返回 2 个 `int`。
func vals() (int, int) {
    return 3, 7
}

func main() {

    // 这里我们通过_多赋值_操作来使用这两个不同的返回值。
    a, b := vals()
    fmt.Println(a)
    fmt.Println(b)

    // 如果你仅仅需要返回值的一部分的话，你可以使用空白标识符`_`。
    _, c := vals()
    fmt.Println(c)
}
```


## Go 函数命名返回值

函数接受参数。在 Go 中，函数可以返回多个“结果参数”，而不仅仅是一个值。它们可以像变量那样命名和使用。

如果命名了返回值参数，一个没有参数的return语句，会将当前的值作为返回值返回。

注意，如果遇到if等代码块和返回值同名，还需要显示写出返回值。

```go
package main

import "fmt"

// `(int, int)` 在这个函数中标志着这个函数返回 2 个 `int`。
func vals() (int, int) {
	return 3, 7
}

func main() {

	// 这里我们通过_多赋值_操作来使用这两个不同的返回值。
	a, b := vals()
	fmt.Println(a) //3
	fmt.Println(b) //7

	// 如果你仅仅需要返回值的一部分的话，你可以使用空白标识符`_`。
	_, c := vals()
	fmt.Println(c) //7
}
```



## Go 函数可变长参数

支持可变长参数列表的函数可以支持任意个传入参数，比如 fmt.Println 函数就是一个支持可变长参数列表的函数。


```go
package main

import "fmt"

// 这个函数可以传入任意数量的整型参数
func sum(nums ...int) {
	fmt.Print(nums, " ")
	total := 0
	for _, num := range nums {
		total += num
	}
	fmt.Println(total)
}

func main() {
	// 支持可变长参数的函数调用方法和普通函数一样
	// 也支持只有一个参数的情况
	sum(1, 2) //[1 2] 3

	sum(1, 2, 3) //[1 2 3] 6

	// 如果你需要传入的参数在一个切片中，像下面一样
	// "func(slice...)"把切片打散传入
	nums := []int{1, 2, 3, 4}
	sum(nums...) //[1 2 3 4] 10
}
```

需要注意的是，可变长参数应该是函数定义的最右边的参数，即最后一个参数。


## Go 函数回调


Go支持函数回调，你可以把函数名称作为参数传递给另外一个函数，然后在别的地方实现这个函数。

```go
package main

import "fmt"

type Callback func(x, y int) int

func main() {
	x, y := 1, 2
	fmt.Println(test(x, y, add)) //3

}

// 提供一个接口，让外部去实现
func test(x, y int, callback Callback) int {
	return callback(x, y)
}
func add(x, y int) int {
	return x + y
}
```


## Go 闭包 Closures

Go 支持匿名函数，并能用其构造 闭包。 匿名函数在你想定义一个不需要命名的内联函数时是很实用的。

```go
package main

import "fmt"

// 这个 `intSeq` 函数返回另一个在 `intSeq` 函数体内定义的匿名函数。
// 这个返回的函数使用闭包的方式 _隐藏_ 变量 `i`。
func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}

func main() {

	// 我们调用 `intSeq` 函数，将返回值（一个函数）赋给`nextInt`。
	// 这个函数的值包含了自己的值 `i`，
	// 这样在每次调用 `nextInt` 时都会更新 `i` 的值。
	nextInt := intSeq()

	// 通过多次调用 `nextInt` 来看看闭包的效果。
	fmt.Println(nextInt()) //1
	fmt.Println(nextInt()) //2
	fmt.Println(nextInt()) //3

	// 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。
	newInts := intSeq()
	fmt.Println(newInts()) //1
}
```


## Go 递归 Recursion

Go 支持 递归。 这里是一个经典的阶乘示例。

```go
package main

import "fmt"

// fact calculates the factorial of a number using recursion
func fact(n int) int {
	if n == 0 || n == 1 {
		return 1
	}
	return n * fact(n-1)
}

func main() {
	fmt.Println(fact(7)) //5040

}
```


## Go 指针 Pointers

Go 支持 * 指针 *， 允许在程序中通过引用传递值或者数据结构。


```go
package main

import "fmt"

// 我们将通过两个函数：`zeroval` 和 `zeroptr` 来比较指针和值类型的不同。
// `zeroval` 有一个 `int` 型参数，所以使用值传递。
// `zeroval` 将从调用它的那个函数中得到一个 `ival` 形参的拷贝。
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` 有一和上面不同的 `*int` 参数，意味着它用了一个 `int` 指针。
// 函数体内的 `*iptr` 接着_解引用_这个指针，从它内存地址得到这个地址对应的当前值。
// 对一个解引用的指针赋值将会改变这个指针引用的真实地址的值。
func zeroptr(iptr *int) {
	*iptr = 0
}

func main() {
	i := 1
	// 打印i的指针地址
	fmt.Printf("address: %p\n", &i) //address: 0xc0000180a8
	fmt.Println("initial:", i)      //initial: 1

	zeroval(i)
	fmt.Println("zeroval:", i) //zeroval: 1
	// 打印i的指针地址
	fmt.Printf("address: %p\n", &i) //address: 0xc0000180a8

	// 通过 `&i` 语法来取得 `i` 的内存地址，即指向 `i` 的指针。
	zeroptr(&i)
	fmt.Println("zeroptr:", i) //zeroptr: 0
	// 指针也是可以被打印的。
	fmt.Println("pointer:", &i) //0xc0000180a8
}
```

在对普通变量使用 "&" 操作符取地址获得这个变量的指针后，可以对指针使用 "*" 操作，进行指针的取值, “*“ 又被读作 ”处的值”。


这么记：

```go
ptr := &house       // 取址赋给ptr
value := *ptr       // 根据地址取值赋给value
```

```
&   取址              // 处的地址
*   根据地址取值       // 处的值
```


在函数间传递大数组数据时使用指针

```go
package main

func foo(array [1e6]int)  {
    println("mem chile .....")
}


func foo1(array *[1e6]int)  {
    println("mem chile .....")
}
func main() {
    // 声明一个需要8 MB的数组
    var array [1e6]int
    // 将数组传递给函数foo
    foo(array)

    // 节省了内存，但是会改变共享的内存
    // 将数组的地址传递给函数foo
    foo1(&array)

}
```


取地址操作符“&”和取值操作符“*”是一对互补操作符，“&”取出地址，“*” 根据地址取出地址指向的值。


变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：

- 对变量进行取地址（&）操作，可以获得这个变量的指针变量。

- 指针变量的值是指针地址。

- 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。



## Go 结构体

Go语言结构体数据类是将各个类型的变量定义的集合，通常用来表示记录。

```go
package main

import "fmt"

// 这个person结构体有name和age成员
type person struct {
	name string
	age  int
}

func main() {
	// 这个语法创建一个新结构体变量
	fmt.Println(person{"Bob", 20})

	// 可以使用"成员:值"的方式来初始化结构体变量
	fmt.Println(person{name: "Alice", age: 30})

	// 未显式赋值的成员初始值为零值
	fmt.Println(person{name: "Fred"})

	// 可以使用&来获取结构体变量的地址
	fmt.Println(&person{name: "Ann", age: 40})

	// 使用点号(.)来访问结构体成员
	s := person{name: "Sean", age: 50}
	fmt.Println(s.name)

	// 结构体指针也可以使用点号(.)来访问结构体成员
	// Go语言会自动识别出来
	sp := &s
	fmt.Println(sp.age)

	// 结构体成员变量的值是可以改变的
	sp.age = 51
	fmt.Println(sp.age)
}
```


运行结果：

```sh
$ go run structs.go
{Bob 20}
{Alice 30}
{Fred 0}
&{Ann 40}
Sean
50
51
```



## Go 方法

Go 支持在结构体类型中定义方法 (methods) 。

```go
package main

import "fmt"

type rect struct {
	width, height int
}

// 这里的 `area` 方法有一个_接收器(receiver)类型_ `rect`。
func (r *rect) area() int {
	return r.width * r.height
}

// 可以为值类型或者指针类型的接收器定义方法。
// 这里是一个值类型接收器的例子。
func (r rect) perim() int {
	return 2*r.width + 2*r.height
}

func main() {
	r := rect{width: 10, height: 5}

	// 这里我们调用上面为结构体定义的两个方法。
	fmt.Println("area: ", r.area())  //area:  50
	fmt.Println("perim:", r.perim()) //perim: 30

	// Go 自动处理方法调用时的值和指针之间的转化。
	// 你可以使用指针来调用方法来避免在方法调用时产生一个拷贝，
	// 或者让方法能够改变接受的结构体。
	rp := &r
	fmt.Println("area: ", rp.area())  //area:  50
	fmt.Println("perim:", rp.perim()) //perim: 30
}
```


## Go 接口 Interfaces


```go
package main

import "fmt"
import "math"

// 这里是一个几何体的基本接口。
type geometry interface {
	area() float64
	perim() float64
}

// 在我们的例子中，我们将在类型 `rect` 和 `circle` 上实现这个接口
type rect struct {
	width, height float64
}
type circle struct {
	radius float64
}

// 要在 Go 中实现一个接口，我们就需要实现接口中的所有方法。
// 这里我们在 `rect` 上实现了 `geometry` 接口。
func (r rect) area() float64 {
	return r.width * r.height
}
func (r rect) perim() float64 {
	return 2*r.width + 2*r.height
}

// `circle` 的实现。
func (c circle) area() float64 {
	return math.Pi * c.radius * c.radius
}
func (c circle) perim() float64 {
	return 2 * math.Pi * c.radius
}

// 如果一个变量具有接口类型，那么我们可以调用指定接口中的方法。
// 这里有一个通用的 `measure` 函数，利用它来在任何的 `geometry` 上工作。
func measure(g geometry) {
	fmt.Println(g)
	fmt.Println(g.area())
	fmt.Println(g.perim())
}

func main() {
	r := rect{width: 3, height: 4}
	c := circle{radius: 5}

	// 结构体类型 `circle` 和 `rect` 都实现了 `geometry` 接口，
	// 所以我们可以使用它们的实例作为 `measure` 的参数。
	measure(r)
	measure(c)
}
```

运行结果如下：
```sh
$ go run interfaces.go
{3 4}
12
14
{5}
78.53981633974483
31.41592653589793
```


## Go Errors

符合 Go 语言习惯的做法是使用一个独立、明确的返回值来传递错误信息。 

这与使用异常 (exception) 的 Java 和 Ruby 以及在 C 语言中有时用到的重载 (overloaded) 的单返回 / 错误值有着明显的不同。

Go 语言的处理方式能清楚的知道哪个函数 返回了错误，并能像调用那些没有出错的函数一样调用。

```go
package main

import "errors"
import "fmt"

// 按照惯例，错误通常是最后一个返回值并且是 `error` 类型，一个内建的接口。
func f1(arg int) (int, error) {
	if arg == 42 {
		// `errors.New` 构造一个使用给定的错误信息的基本 `error` 值。
		return -1, errors.New("can't work with 42")

	}
	// 返回错误值为 nil 代表没有错误。
	return arg + 3, nil
}

// 可以通过实现 `Error` 方法来自定义 `error` 类型。
// 这里使用自定义错误类型来表示上面例子中的参数错误。
type argError struct {
	arg  int
	prob string
}

func (e *argError) Error() string {
	return fmt.Sprintf("%d - %s", e.arg, e.prob)
}

func f2(arg int) (int, error) {
	if arg == 42 {
		// 在这个例子中，我们使用 `&argError` 语法来建立一个新的结构体，
		// 并提供了 `arg` 和 `prob` 这两个字段的值。
		return -1, &argError{arg, "can't work with it"}
	}
	return arg + 3, nil
}

func main() {

	// 下面的两个循环测试了各个返回错误的函数。
	// 注意在 `if` 行内的错误检查代码，在 Go 中是一个普遍的用法。
	for _, i := range []int{7, 42} {
		if r, e := f1(i); e != nil {
			fmt.Println("f1 failed:", e)
		} else {
			fmt.Println("f1 worked:", r)
		}
	}

	for _, i := range []int{7, 42} {
		if r, e := f2(i); e != nil {
			fmt.Println("f2 failed:", e)
		} else {
			fmt.Println("f2 worked:", r)
		}
	}

	// 你如果想在程序中使用一个自定义错误类型中的数据，
	// 你需要通过类型断言来得到这个错误类型的实例。
	_, e := f2(42)
	if ae, ok := e.(*argError); ok {
		fmt.Println(ae.arg)
		fmt.Println(ae.prob)
	}
}
```

运行输出内容：

```sh
$ go run errors.go
f1 worked: 10
f1 failed: can't work with 42
f2 worked: 10
f2 failed: 42 - can't work with it
42
can't work with it
```



## Go Panic

Panic表示的意思就是有些意想不到的错误发生了。

通常我们用来表示程序正常运行过程中不应该出现的，或者我们没有处理好的错误。


```go
package main

import "os"

func main() {
	// 我们使用panic来检查预期不到的错误
	panic("a problem")
	// Panic的通常使用方法就是如果一个函数
	// 返回一个我们不知道怎么处理的错误的
	// 时候，直接终止执行。
	_, err := os.Create("/tmp/file")
	if err != nil {
		panic(err)
	}
}

```

运行结果

```sh
panic: a problem
goroutine 1 [running]:
runtime.panic(0x44e060, 0xc0840031b0)
        C:/Users/ADMINI~1/AppData/Local/Temp/2/bindist667667715/go/src/pkg/runtime/panic.c:266 +0xc8
main.main()
        D:/GoDoc/go_panic.go:8 +0x58
exit status 2
```


和其他的编程语言不同的是，Go并不使用exception来处理错误，而是通过函数返回值返回错误代码。




## Go Exit

使用os.Exit可以给定一个状态，然后立刻退出程序运行。

```go
package main

import "fmt"
import "os"

func main() {
	// 当使用`os.Exit`的时候defer操作不会被运行，
	// 所以这里的``fmt.Println`将不会被调用
	defer fmt.Println("!")
	// 退出程序并设置退出状态值
	os.Exit(3)
}
```


注意，Go和C语言不同，main函数并不返回一个整数来表示程序的退出状态，而是将退出状态作为os.Exit函数的参数。

如果你使用go run来运行程序，将会有如下输出
```sh
exit status 3
```

如果你使用go build先编译程序，然后再运行可执行文件，程序将不会有输出。

如果你想查看程序的返回值，unix系列系统下面使用如下方法:
```sh
$ ./go_exit
$ echo $?
3
```


## Go Defer延迟调用

Defer 用来保证一个函数调用会在程序执行的最后被调用。通常用于资源清理工作。


```go
package main

import "fmt"
import "os"

// 假设我们想创建一个文件，然后写入数据，最后关闭文件
func main() {
	// 在使用createFile得到一个文件对象之后，我们使用defer
	// 来调用关闭文件的方法closeFile，这个方法将在main函数
	// 最后被执行，也就是writeFile完成之后
	//f := createFile("/tmp/defer.txt")
	// Windows下面使用这个语句
	f := createFile("D:\\Temp\\defer.txt")
	defer closeFile(f)
	writeFile(f)
}
func createFile(p string) *os.File {
	fmt.Println("creating")
	f, err := os.Create(p)
	if err != nil {
		panic(err)
	}
	return f
}
func writeFile(f *os.File) {
	fmt.Println("writing")
	fmt.Fprintln(f, "data")
}
func closeFile(f *os.File) {
	fmt.Println("closing")
	f.Close()
}

```

运行结果

```sh
creating
writing
closing
```

使用defer来调用closeFile函数可以保证在main函数结束之前，关闭文件的操作一定会被执行。






## Go JSON、YAML等格式解析
```go
package main

import (
	"encoding/json"
	"encoding/xml"
	"github.com/pelletier/go-toml"
	"gopkg.in/yaml.v2"
	"log"
)

type Student struct {
	Job  string `json:"job"`
	Name string `json:"name"`
	Sex  string `json:"sex"`
}

// parseJSON parses the given JSON data into a Student struct.
//
// It takes a byte array of JSON data as a parameter and returns a Student struct and an error.
func parseJSON(data []byte) (Student, error) {
	var student Student
	err := json.Unmarshal(data, &student)
	return student, err
}

func parseYAML(data []byte) (Student, error) {
	var student Student
	err := yaml.Unmarshal(data, &student)
	return student, err
}

// parseXML parses the XML data and returns a Student and an error.
//
// It takes a byte slice data as a parameter and returns a Student and an error.
func parseXML(data []byte) (Student, error) {
	var student Student
	err := xml.Unmarshal(data, &student)
	return student, err
}

// parseTOML parses the given data and returns a Student and an error.
//
// data []byte - the data to be parsed
// (Student, error) - the parsed Student and any parsing error
func parseTOML(data []byte) (Student, error) {
	var student Student
	tree, err := toml.Load(string(data))
	if err != nil {
		return student, err
	}
	err = tree.Unmarshal(&student)
	return student, err
}

func main() {
	// Example usage
	jsonData := []byte(`{"job": "Engineer", "name": "Alice", "sex": "female"}`)
	// YAML Example
	yamlData := []byte(`
job: Engineer
name: Alice
sex: female
`)
	// XML Example
	xmlData := []byte(`<Student><Job>Engineer</Job><Name>Alice</Name><Sex>female</Sex></Student>`)
	// TOML Example
	tomlData := []byte(`job = "Engineer"
name = "Alice"
sex = "female"`)

	// Parse JSON
	jsonStudent, err := parseJSON(jsonData)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("JSON Student:", jsonStudent) //2024/02/01 11:06:04 JSON Student: {Engineer Alice female}

	// Parse YAML
	yamlStudent, err := parseYAML(yamlData)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("YAML Student:", yamlStudent) //2024/02/01 11:15:47 YAML Student: {Engineer Alice female}

	// Parse XML
	xmlStudent, err := parseXML(xmlData)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("XML Student:", xmlStudent) //2024/02/01 11:06:04 XML Student: {Engineer Alice female}

	// Parse TOML
	tomlStudent, err := parseTOML(tomlData)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("TOML Student:", tomlStudent) //2024/02/01 11:16:41 TOML Student: {Engineer Alice female}
}
```


## Go JSON 解析


Go 提供内置的 JSON 编解码支持，包括内置或者自定义类 型与 JSON 数据之间的转化。


```go
package main

import "encoding/json"
import "fmt"
import "os"

// 我们使用两个结构体来演示自定义数据类型的JSON数据编码和解码。
type Response1 struct {
	Page   int
	Fruits []string
}
type Response2 struct {
	Page   int      `json:"page"`
	Fruits []string `json:"fruits"`
}

func main() {
	// 首先我们看一下将基础数据类型编码为JSON数据
	bolB, _ := json.Marshal(true)
	fmt.Println(string(bolB)) //true

	intB, _ := json.Marshal(1)
	fmt.Println(string(intB)) //1

	fltB, _ := json.Marshal(2.34)
	fmt.Println(string(fltB)) //2.34

	strB, _ := json.Marshal("gopher")
	fmt.Println(string(strB)) // "gopher"

	// 这里是将切片和字典编码为JSON数组或对象
	slcD := []string{"apple", "peach", "pear"}
	slcB, _ := json.Marshal(slcD)
	fmt.Println(string(slcB)) //["apple","peach","pear"]

	mapD := map[string]int{"apple": 5, "lettuce": 7}
	mapB, _ := json.Marshal(mapD)
	fmt.Println(string(mapB)) //{"apple":5,"lettuce":7}

	// JSON包可以自动地编码自定义数据类型。结果将只包括自定义
	// 类型中的可导出成员的值并且默认情况下，这些成员名称都作
	// 为JSON数据的键
	res1D := &Response1{
		Page:   1,
		Fruits: []string{"apple", "peach", "pear"}}
	res1B, _ := json.Marshal(res1D)
	fmt.Println(string(res1B)) //{"Page":1,"Fruits":["apple","peach","pear"]}

	// 你可以使用tag来自定义编码后JSON键的名称
	res2D := &Response2{
		Page:   1,
		Fruits: []string{"apple", "peach", "pear"}}
	res2B, _ := json.Marshal(res2D)
	fmt.Println(string(res2B)) //{"page":1,"fruits":["apple","peach","pear"]}

	// 现在我们看看解码JSON数据为Go数值
	byt := []byte(`{"num":6.13,"strs":["a","b"]}`)
	// 我们需要提供一个变量来存储解码后的JSON数据，这里
	// 的`map[string]interface{}`将以Key-Value的方式
	// 保存解码后的数据，Value可以为任意数据类型
	var dat map[string]interface{}
	// 解码过程，并检测相关可能存在的错误
	if err := json.Unmarshal(byt, &dat); err != nil {
		panic(err)
	}
	fmt.Println(dat) //map[num:6.13 strs:[a b]]

	// 为了使用解码后map里面的数据，我们需要将Value转换为
	// 它们合适的类型，例如我们将这里的num转换为期望的float64
	num := dat["num"].(float64)
	fmt.Println(num) //6.13

	// 访问嵌套的数据需要一些类型转换
	strs := dat["strs"].([]interface{})
	str1 := strs[0].(string)
	fmt.Println(str1) //a

	// 我们还可以将JSON解码为自定义数据类型，这有个好处是可以
	// 为我们的程序增加额外的类型安全并且不用再在访问数据的时候
	// 进行类型断言
	str := `{"page": 1, "fruits": ["apple", "peach"]}`
	res := &Response2{}
	json.Unmarshal([]byte(str), &res)
	fmt.Println(res)           //&{1 [apple peach]}
	fmt.Println(res.Fruits[0]) //apple

	// 上面的例子中，我们使用bytes和strings来进行原始数据和JSON数据
	// 之间的转换，我们也可以直接将JSON编码的数据流写入`os.Writer`
	// 或者是HTTP请求回复数据。
	enc := json.NewEncoder(os.Stdout)
	d := map[string]int{"apple": 5, "lettuce": 7}
	enc.Encode(d) //{"apple":5,"lettuce":7}
}
```


## Go XML 解析

Go 的 encoding.xml 包为 XML 和 类 - XML 格式提供了内建支持。

```go
package main

import (
	"encoding/xml"
	"fmt"
)

// 该类型将被映射为 XML。
// 与 JSON 例子类似，字段 tag 包含了编码和解码的指令。
// 这里我们使用了 XML 包的一些特性：
// `XMLName` 字段名规定了 struct 的 XML 元素的名称；
// `id,attr` 意思是 `Id` 字段是一个 XML _attribute_，而不是嵌套元素。
type Plant struct {
	XMLName xml.Name `xml:"plant"`
	Id      int      `xml:"id,attr"`
	Name    string   `xml:"name"`
	Origin  []string `xml:"origin"`
}

func (p Plant) String() string {
	return fmt.Sprintf("Plant id=%v, name=%v, origin=%v",
		p.Id, p.Name, p.Origin)
}

func main() {
	coffee := &Plant{Id: 27, Name: "Coffee"}
	coffee.Origin = []string{"Ethiopia", "Brazil"}

	// 传入我们声明了 XML 的 plant 类型。
	// 使用 `MarshalIndent` 生成可读性更好的输出结果。
	out, _ := xml.MarshalIndent(coffee, " ", "  ")
	fmt.Println(string(out))

	// 明确的为输出结果添加一个通用的 XML 头部信息
	fmt.Println(xml.Header + string(out))

	// 使用 `Unmarshal` 将 XML 格式的字节流解析到 struct 内。
	// 如果 XML 格式不正确，或无法映射到 struct，将会返回一个描述性错误。
	var p Plant
	if err := xml.Unmarshal(out, &p); err != nil {
		panic(err)
	}
	fmt.Println(p)

	tomato := &Plant{Id: 81, Name: "Tomato"}
	tomato.Origin = []string{"Mexico", "California"}

	// `parent>child>plant` 字段标签告诉编码器嵌套 `<parent><child>...` 下面的所有 plant。
	type Nesting struct {
		XMLName xml.Name `xml:"nesting"`
		Plants  []*Plant `xml:"parent>child>plant"`
	}

	nesting := &Nesting{}
	nesting.Plants = []*Plant{coffee, tomato}

	out, _ = xml.MarshalIndent(nesting, " ", "  ")
	fmt.Println(string(out))
}
```





## Go 读取文件

读写文件在很多程序中都是必须的基本任务。首先我们看看一 些读文件的例子。



```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
)

// check is a helper function to check for and handle errors.
func check(err error) {
	if err != nil {
		panic(err)
	}
}

// readFileAndPrint demonstrates various ways to read from a file and print its contents.
func readFileAndPrint() {
	// 也许大部分基本的文件读取任务是将文件内容读取到内存中
	dat, err := ioutil.ReadFile("dat")
	check(err)
	fmt.Print(string(dat))

	// 你经常会想对于一个文件是怎么读并且读取到哪一部分进行更多的控制。
	// 对于这个任务，从使用 `os.Open` 打开一个文件获取一个 `os.File` 值开始。
	f, err := os.Open("dat")
	check(err)

	// 从文件开始位置读取一些字节。
	// 这里最多读取 5 个字节，并且这也是我们实际读取的字节数。
	b1 := make([]byte, 5)
	n1, err := f.Read(b1)
	check(err)
	fmt.Printf("%d bytes: %s\n", n1, string(b1)) //5 bytes: hello

	// 你也可以 `Seek` 到一个文件中已知的位置并从这个位置开始进行读取。
	o2, err := f.Seek(6, 0)
	check(err)
	b2 := make([]byte, 2)
	n2, err := f.Read(b2)
	check(err)
	fmt.Printf("%d bytes @ %d: %s\n", n2, o2, string(b2)) //2 bytes @ 6: g

	// `io` 包提供了一些可以帮助我们进行文件读取的函数。 例如，上面的读取可以使用 `ReadAtLeast` 得到一个更健壮的实现。
	o3, err := f.Seek(6, 0)
	check(err)
	b3 := make([]byte, 2)
	n3, err := io.ReadAtLeast(f, b3, 2)
	check(err)
	fmt.Printf("%d bytes @ %d: %s\n", n3, o3, string(b3)) //2 bytes @ 6: g

	// Rewind to the beginning of the file.
	_, err = f.Seek(0, 0)
	check(err)

	// `bufio` 包实现了带缓冲的读取，这不仅对于很多小的读取操作能够提升性能，也提供了很多附加的读取函数。
	r4 := bufio.NewReader(f)
	b4, err := r4.Peek(5)
	check(err)
	fmt.Printf("5 bytes: %s\n", string(b4)) //5 bytes: hello

	// 任务结束后要关闭这个文件（通常这个操作应该在 `Open`
	// 操作后立即使用 `defer` 来完成）。
	f.Close()
}

func main() {
	// Get the current working directory.
	wd, err := os.Getwd()
	check(err)

	// Construct the file path relative to the current working directory.
	filePath := filepath.Join(wd, "internal\\Go-ReadFile")
	fmt.Println(filePath)

	// Set the file path as the current working directory.
	err = os.Chdir(filePath)
	check(err)

	readFileAndPrint()
}
```


运行结果如下：

```sh
$ echo "hello" > ./dat
$ echo "go" >>  ./dat

$ go run reading-files.go 
hello
go
5 bytes: hello
2 bytes @ 6: go
2 bytes @ 6: go
5 bytes: hello
```


Golang 超大文件读取的两个方案

https://learnku.com/articles/23559/two-schemes-for-reading-golang-super-large-files




## Go 写入文件

Go将数据写入文件的方法和上面介绍过的读取文件的方法很类似。

```go
package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}
func main() {
	// 首先看一下如何将一个字符串写入文件
	d1 := []byte("hello\ngo\n")
	err := ioutil.WriteFile("/tmp/dat1", d1, 0644)
	check(err)

	// 为了实现细颗粒度的写入，打开文件后再写入
	f, err := os.Create("/tmp/dat2")
	check(err)

	// 在打开文件后通常应该立刻使用defer来调用
	// 打开文件的Close方法，以保证main函数结束
	// 后，文件关闭
	defer f.Close()

	// 你可以写入字节切片
	d2 := []byte{115, 111, 109, 101, 10}
	n2, err := f.Write(d2)
	check(err)
	fmt.Printf("wrote %d bytes\n", n2) //wrote 5 bytes

	// 也可以使用`WriteString`直接写入字符串
	n3, err := f.WriteString("writes\n")
	fmt.Printf("wrote %d bytes\n", n3) //wrote 7 bytes

	// 调用Sync方法来将缓冲区数据写入磁盘
	f.Sync()
	// `bufio`除了提供上面的缓冲读取数据外，还
	// 提供了缓冲写入数据的方法
	w := bufio.NewWriter(f)
	n4, err := w.WriteString("buffered\n")
	fmt.Printf("wrote %d bytes\n", n4) //wrote 9 bytes

	// 使用Flush方法确保所有缓冲区的数据写入底层writer
	w.Flush()
}
```



## Go 行过滤器

Line Filters翻译一下大概是行数据过滤器。

简单一点就是一个程序从标准输入stdin读取数据，然后处理一下，将处理的结果输出到标准输出stdout。

grep和sed就是常见的行数据过滤器。

这里有一个行数据过滤器的例子，是把一个输入文本转换为大写的文本。

你可以使用这种方式来实现你自己的Go Line Filters。


```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func main() {
	// 使用缓冲scanner来包裹无缓冲的`os.Stdin`可以让我们
	// 方便地使用`Scan`方法，这个方法会将scanner定位到下
	// 一行的位置
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		// `Text`方法从输入中返回当前行
		ucl := strings.ToUpper(scanner.Text())
		// 输出转换为大写的行
		fmt.Println(ucl)
	}
	// 在`Scan`过程中，检查错误。文件结束不会被当作一个错误
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "error:", err)
		os.Exit(1)
	}
}

```

运行结果

```sh
hello world
HELLO WORLD
how are you
HOW ARE YOU
```


## Go 文件路径

filepath 包为 文件路径，提供了方便的跨操作系统的解析和构建函数； 比如：Linux 下的 dir/file 和 Windows 下的 dir.ile。


```go
package main

import (
	"fmt"
	"path/filepath"
	"strings"
)

func main() {

	// 应使用 `Join` 来构建可移植(跨操作系统)的路径。
	// 它接收任意数量的参数，并参照传入顺序构造一个对应层次结构的路径。
	p := filepath.Join("dir1", "dir2", "filename")
	fmt.Println("p:", p) //p: dir1\dir2\filename

	// 您应该总是使用 `Join` 代替手动拼接 `/` 和 `\`。
	// 除了可移植性，`Join` 还会删除多余的分隔符和目录，使得路径更加规范。
	fmt.Println(filepath.Join("dir1//", "filename"))       //dir1\filename
	fmt.Println(filepath.Join("dir1/../dir1", "filename")) //dir1\filename

	// `Dir` 和 `Base` 可以被用于分割路径中的目录和文件。
	// 此外，`Split` 可以一次调用返回上面两个函数的结果。
	fmt.Println("Dir(p):", filepath.Dir(p))   //Dir(p): dir1\dir2
	fmt.Println("Base(p):", filepath.Base(p)) //Base(p): filename

	// 判断路径是否为绝对路径。
	fmt.Println(filepath.IsAbs("dir/file"))  // false
	fmt.Println(filepath.IsAbs("/dir/file")) // false

	filename := "config.json"

	// 某些文件名包含了扩展名（文件类型）。
	// 我们可以用 `Ext` 将扩展名分割出来。
	ext := filepath.Ext(filename)
	fmt.Println(ext) //.json

	// 想获取文件名清除扩展名后的值，请使用 `strings.TrimSuffix`。
	fmt.Println(strings.TrimSuffix(filename, ext)) //config

	// `Rel` 寻找 `basepath` 与 `targpath` 之间的相对路径。
	// 如果相对路径不存在，则返回错误。
	rel, err := filepath.Rel("a/b", "a/b/t/file")
	if err != nil {
		panic(err)
	}
	fmt.Println(rel) //t\file

	rel, err = filepath.Rel("a/b", "a/c/t/file")
	if err != nil {
		panic(err)
	}
	fmt.Println(rel) //..\c\t\file
}
```


## Go 文件目录

对于操作文件系统中的 目录，Go 提供了几个非常有用的函数。

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
    "path/filepath"
)

func check(e error) {
    if e != nil {
        panic(e)
    }
}

func main() {

    // 在当前工作目录下，创建一个子目录。
    err := os.Mkdir("subdir", 0755)
    check(err)

    // 创建这个临时目录后，一个好习惯是：使用 `defer` 删除这个目录。
    // `os.RemoveAll` 会删除整个目录（类似于 `rm -rf`）。
    defer os.RemoveAll("subdir")

    // 创建一个用于创建临时文件的函数。
    createEmptyFile := func(name string) {
        d := []byte("")
        check(ioutil.WriteFile(name, d, 0644))
    }

    createEmptyFile("subdir/file1")

    // 我们还可以创建一个有层级的目录，使用 `MkdirAll` 函数，并包含其父目录。
    // 这个类似于命令 `mkdir -p`。
    err = os.MkdirAll("subdir/parent/child", 0755)
    check(err)

    createEmptyFile("subdir/parent/file2")
    createEmptyFile("subdir/parent/file3")
    createEmptyFile("subdir/parent/child/file4")

    // `ReadDir` 列出目录的内容，返回一个 `os.FileInfo` 类型的切片对象。
    c, err := ioutil.ReadDir("subdir/parent")
    check(err)

    fmt.Println("Listing subdir/parent")
    for _, entry := range c {
        fmt.Println(" ", entry.Name(), entry.IsDir())
    }

    // `Chdir` 可以修改当前工作目录，类似于 `cd`。
    err = os.Chdir("subdir/parent/child")
    check(err)

    // 当我们列出 *当前* 目录，就可以看到 `subdir/parent/child` 的内容了。
    c, err = ioutil.ReadDir(".")
    check(err)

    fmt.Println("Listing subdir/parent/child")
    for _, entry := range c {
        fmt.Println(" ", entry.Name(), entry.IsDir())
    }

    // `cd` 回到最开始的地方。
    err = os.Chdir("../../..")
    check(err)

    // 当然，我们也可以遍历一个目录及其所有子目录。
    // `Walk` 接受一个路径和回调函数，用于处理访问到的每个目录和文件。
    fmt.Println("Visiting subdir")
    err = filepath.Walk("subdir", visit)
}

// `filepath.Walk` 遍历访问到每一个目录和文件后，都会调用 `visit`。
func visit(p string, info os.FileInfo, err error) error {
    if err != nil {
        return err
    }
    fmt.Println(" ", p, info.IsDir())
    return nil
}
```

运行结果如下：

```sh
$ go run directories.go
Listing subdir/parent
  child true
  file2 false
  file3 false
Listing subdir/parent/child
  file4 false
Visiting subdir
  subdir true
  subdir/file1 false
  subdir/parent true
  subdir/parent/child true
  subdir/parent/child/file4 false
  subdir/parent/file2 false
  subdir/parent/file3 false
```


## Go 临时文件和目录

在程序运行时，我们经常创建一些运行时用到，程序结束后就不再使用的数据。

临时目录和文件 对于上面的情况很有用，因为它不会随着时间的推移而污染文件系统。

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func main() {

	// 创建临时文件最简单的方法是调用 `ioutil.TempFile` 函数。
	// 它会创建并打开文件，我们可以对文件进行读写。
	// 函数的第一个参数传 `""`，`ioutil.TempFile` 会在操作系统的默认位置下创建该文件。
	//f, err := ioutil.TempFile("", "sample") check(err)
	f, err := os.CreateTemp("", "sample")
	check(err)

	// 打印临时文件的名称。
	// 文件名以 `ioutil.TempFile` 函数的第二个参数作为前缀，
	// 剩余的部分会自动生成，以确保并发调用时，生成不重复的文件名。
	// 在类 Unix 操作系统下，临时目录一般是 `/tmp`。
	fmt.Println("Temp file name:", f.Name()) //Temp file name: C:\Users\18793\AppData\Local\Temp\sample1407861477

	// defer 删除该文件。
	// 尽管操作系统会自动在某个时间清理临时文件，但手动清理是一个好习惯。
	defer os.Remove(f.Name())

	// 我们可以向文件写入一些数据。
	_, err = f.Write([]byte{1, 2, 3, 4})
	check(err)

	// 如果需要写入多个临时文件，最好是为其创建一个临时 *目录*。
	// `ioutil.TempDir` 的参数与 `TempFile` 相同，
	// 但是它返回的是一个 *目录名*，而不是一个打开的文件。
	//dname, err := ioutil.TempDir("", "sampledir")
	dname, err := os.MkdirTemp("", "sampledir")
	fmt.Println("Temp dir name:", dname) //Temp dir name: C:\Users\18793\AppData\Local\Temp\sampledir3918010941

	defer os.RemoveAll(dname)

	// 现在，我们可以通过拼接临时目录和临时文件合成完整的临时文件路径，并写入数据。
	fname := filepath.Join(dname, "file1")
	// err = ioutil.WriteFile(fname, []byte{1, 2}, 0666)
	err = os.WriteFile(fname, []byte{1, 2}, 0666)
	check(err)
}
```



## Go 测试

想要写出好的 Go 程序，单元测试是很重要的一部分。 testing 包为提供了编写单元测试所需的工具，写好单元测试后，我们可以通过 go test 命令运行测试。

为方便演示，例子的代码位于 main 包，实际上，单元测试的代码可以位于任何包下。 

测试代码通常与需要被测试的代码位于同一个包下。

`demo1/demo1.go`

```go
package demo1

// 我们要测试下面这个简单的函数——返回最小值。
// 一般地，需要被测试的代码应该在类似于 `intutils.go` 的文件下，
// 其对应的测试文件应该被命名为 `intutils_test.go`。
func IntMin(a, b int) int {
	if a < b {
		return a
	} else {
		return b
	}
}
```

`demo1/demo1_test.go`

```go
package demo1

import (
	"fmt"
	"testing"
)

// 通常编写一个名称以 `Test` 开头的函数来创建测试。
func TestIntMinBasic(t *testing.T) {
	ans := IntMin(2, -2)
	if ans != -2 {
		// `t.Error*` 会报告测试失败的信息，然后继续运行测试。
		// `t.Fail*` 会报告测试失败的信息，然后立即终止测试。
		t.Errorf("IntMin(2, -2) = %d; want -2", ans)
	}
}

// 单元测试可以重复，所以会经常使用 *表驱动* 风格编写单元测试，
// 表中列出了输入数据，预期输出，使用循环，遍历并执行测试逻辑。
func TestIntMinTableDriven(t *testing.T) {
	var tests = []struct {
		a, b int
		want int
	}{
		{0, 1, 0},
		{1, 0, 0},
		{2, -2, -2},
		{0, -1, -1},
		{-1, 0, -1},
	}

	for _, tt := range tests {
		// t.Run 可以运行一个 "subtests" 子测试，一个子测试对应表中一行数据。
		// 运行 `go test -v` 时，他们会分开显示。
		testname := fmt.Sprintf("%d,%d", tt.a, tt.b)
		t.Run(testname, func(t *testing.T) {
			ans := IntMin(tt.a, tt.b)
			if ans != tt.want {
				t.Errorf("got %d, want %d", ans, tt.want)
			}
		})
	}
}
```


使用 -v 参数查看详细信息：

```sh
$ go test -v
== RUN   TestIntMinBasic
--- PASS: TestIntMinBasic (0.00s)
=== RUN   TestIntMinTableDriven
=== RUN   TestIntMinTableDriven/0,1
=== RUN   TestIntMinTableDriven/1,0
=== RUN   TestIntMinTableDriven/2,-2
=== RUN   TestIntMinTableDriven/0,-1
=== RUN   TestIntMinTableDriven/-1,0
--- PASS: TestIntMinTableDriven (0.00s)
    --- PASS: TestIntMinTableDriven/0,1 (0.00s)
    --- PASS: TestIntMinTableDriven/1,0 (0.00s)
    --- PASS: TestIntMinTableDriven/2,-2 (0.00s)
    --- PASS: TestIntMinTableDriven/0,-1 (0.00s)
    --- PASS: TestIntMinTableDriven/-1,0 (0.00s)
PASS
ok      examples/testing    0.023s
```




## Go Base64编码

Go提供了对base64编码和解码的内置支持

```go
package main

// 这种导入包的语法将默认的base64起了一个别名b64，这样
// 我们在下面就可以直接使用b64表示这个包，省点输入量
import b64 "encoding/base64"
import "fmt"

func main() {
	// 这里是我们用来演示编码和解码的字符串
	data := "abc123!?$*&()'-=@~"
	// Go支持标准的和兼容URL的base64编码。
	// 我们这里使用标准的base64编码，这个
	// 函数需要一个`[]byte`参数，所以将这
	// 个字符串转换为字节数组
	sEnc := b64.StdEncoding.EncodeToString([]byte(data))
	fmt.Println(sEnc)
	// 解码一个base64编码可能返回一个错误，
	// 如果你不知道输入是否是正确的base64
	// 编码，你需要检测一些解码错误
	sDec, _ := b64.StdEncoding.DecodeString(sEnc)
	fmt.Println(string(sDec))
	fmt.Println()
	// 使用兼容URL的base64编码和解码
	uEnc := b64.URLEncoding.EncodeToString([]byte(data))
	fmt.Println(uEnc)
	uDec, _ := b64.URLEncoding.DecodeString(uEnc)
	fmt.Println(string(uDec))
}

/*
类似于如下shell代码：
echo -n "your_data" | base64

要对Base64编码后的数据进行解码，可以使用以下命令：
echo -n "base64_encoded_data" | base64 -d
*/
```

运行结果

```sh
YWJjMTIzIT8kKiYoKSctPUB+
abc123!?$*&()'-=@~
YWJjMTIzIT8kKiYoKSctPUB-
abc123!?$*&()'-=@~
```

这两种方法都将原数据编码为base64编码，区别在于标准的编码后面是+，而兼容URL的编码方式后面是-。



## Go SHA1 散列

SHA1散列经常用来计算二进制或者大文本数据的短标识值。git版本控制系统用SHA1来标识受版本控制的文件和目录。

这里介绍Go中如何计算SHA1散列值。

Go 在 `crypto/*` 包里面实现了几个常用的散列函数。

```go
package main

import "crypto/sha1"
import "fmt"

func main() {
	s := "sha1 this string"
	// 生成一个hash的模式是`sha1.New()`，`sha1.Write(bytes)`
	// 然后是`sha1.Sum([]byte{})`，下面我们开始一个新的hash
	// 示例
	h := sha1.New()
	// 写入要hash的字节，如果你的参数是字符串，使用`[]byte(s)`
	// 把它强制转换为字节数组
	h.Write([]byte(s))
	// 这里计算最终的hash值，Sum的参数是用来追加而外的字节到要
	// 计算的hash字节里面，一般来讲，如果上面已经把需要hash的
	// 字节都写入了，这里就设为nil就可以了
	bs := h.Sum(nil)

	// SHA1散列值经常以16进制的方式输出，例如git commit就是
	// 这样，所以可以使用`%x`来将散列结果格式化为16进制的字符串
	fmt.Println(s)         //sha1 this string
	fmt.Printf("%x\n", bs) //cf23df2207d99a74fbe169e3eba035e633b65d94
}
```



## Go String与Byte切片之间的转换

String转换到Byte数组时，每个byte(byte类型其实就是uint8)保存字符串对应字节的数值。

注意Go的字符串是UTF-8编码的，每个字符长度是不确定的，一些字符可能是1、2、3或者4个字节结尾。

示例1：

```go
package main

import "fmt"

func main() {
	s1 := "abcd"
	b1 := []byte(s1)
	fmt.Println(b1) // [97 98 99 100]

	s2 := "中文"
	b2 := []byte(s2)
	fmt.Println(b2) // [228 184 173 230 150 135], unicode，每个中文字符会由三个byte组成

	r1 := []rune(s1)
	fmt.Println(r1) // [97 98 99 100], 每个字一个数值

	r2 := []rune(s2)
	fmt.Println(r2) // [20013 25991], 每个字一个数值
}

```





输出结果为

```sh
write 2 as two
it's a weekday
it's before noon
```


## Go URL解析

URL提供了一种统一访问资源的方式。我们来看一下Go里面如何解析URL。

```go
package main

import "fmt"
import "net/url"
import "strings"

func main() {
	// 我们将解析这个URL，它包含了模式，验证信息，
	// 主机，端口，路径，查询参数和查询片段
	s := "postgres://user:pass@host.com:5432/path?k=v#f"
	// 解析URL，并保证没有错误
	u, err := url.Parse(s)
	if err != nil {
		panic(err)
	}
	// 可以直接访问解析后的模式
	fmt.Println(u.Scheme) //postgres

	// User包含了所有的验证信息，使用
	// Username和Password来获取单独的信息
	fmt.Println(u.User)            //user:pass
	fmt.Println(u.User.Username()) //user
	p, _ := u.User.Password()
	fmt.Println(p) //pass
	// Host包含了主机名和端口，如果需要可以
	// 手动分解主机名和端口
	fmt.Println(u.Host) //host.com:5432

	h := strings.Split(u.Host, ":")
	fmt.Println(h[0]) //host.com
	fmt.Println(h[1]) //5432

	// 这里我们解析出路径和`#`后面的片段
	fmt.Println(u.Path)     ///path
	fmt.Println(u.Fragment) //f

	// 为了得到`k=v`格式的查询参数，使用RawQuery。你可以将
	// 查询参数解析到一个map里面。这个map为字符串作为key，
	// 字符串切片作为value。
	fmt.Println(u.RawQuery) //k=v

	m, _ := url.ParseQuery(u.RawQuery)

	fmt.Println(m)         //map[k:[v]]
	fmt.Println(m["k"][0]) //v
}
```




## Go 使用函数自定义排序


有时候我们想使用和集合的自然排序不同的方法对集合进行排序。 

例如，我们想按照字母的长度而不是首字母顺序对字符串排序。 这里是一个 Go 自定义排序的例子。


```go
package main

import "sort"
import "fmt"

// 为了在 Go 中使用自定义函数进行排序，我们需要一个对应的类型。
// 这里我们创建一个为内置 `[]string` 类型的别名的 `ByLength` 类型。
type ByLength []string

// 我们在类型中实现了 `sort.Interface` 的 `Len`，`Less` 和 `Swap` 方法，
// 这样我们就可以使用 `sort` 包的通用 `Sort` 方法了，
// `Len` 和 `Swap` 通常在各个类型中都差不多，`Less` 将控制实际的自定义排序逻辑。
// 在我们的例子中，我们想按字符串长度增加的顺序来排序，
// 所以这里使用了 `len(s[i])` 和 `len(s[j])`
func (s ByLength) Len() int {
	return len(s)
}
func (s ByLength) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}
func (s ByLength) Less(i, j int) bool {
	return len(s[i]) < len(s[j])
}

// 一切都准备好了，我们现在可以通过将原始的 `fruits` 切片转型成 `ByLength` 来实现我们的自定排序了。
// 然后对这个转型的切片使用 `sort.Sort` 方法。
func main() {
	fruits := []string{"peach", "banana", "kiwi"}
	sort.Sort(ByLength(fruits))
	fmt.Println(fruits) //[kiwi peach banana]
}
```

运行这个程序，和预期的一样，显示了一个按照字符串 长度排序的列表。

```sh
$ go run sorting-by-functions.go 
[kiwi peach banana]
```

类似的，参照这个创建一个自定义类型的方法，实现这个类型的 这三个接口方法，然后在一个这个自定义类型的集合上调用 `sort.Sort` 方法，我们就可以使用任意的函数来排序 Go 切片了。




## Go 命令行参数 Arguments


命令行参数 是指定程序运行参数的一个常见方式。

例如：`go run hello.go`， 程序 go 使用了 run 和 hello.go 两个参数。


```go
package main

import (
	"fmt"
	"os"
)

func main() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Fprintln(os.Stderr, "An error occurred:", r)
		}
	}()
	if len(os.Args) < 4 {
		fmt.Printf("Usage: %s <arg1> <arg2> <arg3> ...\n", os.Args[0])
		return
	}
	// `os.Args` 提供原始命令行参数访问功能。
	// 注意，切片中的第一个参数是该程序的路径，
	// 并且 `os.Args[1:]` 保存程序的所有参数。
	argsWithProg := os.Args
	argsWithoutProg := os.Args[1:]

	// 你可以使用标准的索引位置方式取得单个参数的值。
	arg := os.Args[3]

	// Print the program's arguments.
	fmt.Println(argsWithProg)
	fmt.Println(argsWithoutProg)
	fmt.Println(arg)
}
```


## Go 命令行标志 Flags

命令行标志 是命令行程序指定选项的常用方式。例如，在 wc -l 中， 这个 -l 就是一个命令行标志。

```go
package main

// Go 提供了一个 `flag` 包，支持基本的命令行标志解析。
// 我们将用这个包来实现我们的命令行程序示例。
import "flag"
import "fmt"

func main() {

	// 基本的标记声明仅支持字符串、整数和布尔值选项。
	// 这里我们声明一个默认值为 `"foo"` 的字符串标志 `word`
	// 并带有一个简短的描述。这里的 `flag.String` 函数返回一个字
	// 符串指针（不是一个字符串值），在下面我们会看到是如何
	// 使用这个指针的。
	wordPtr := flag.String("word", "foo", "a string")

	// 使用和声明 `word` 标志相同的方法来声明 `numb` 和 `fork` 标志。
	numbPtr := flag.Int("numb", 42, "an int")
	boolPtr := flag.Bool("fork", false, "a bool")

	// 用程序中已有的参数来声明一个标志也是可以的。注
	// 意在标志声明函数中需要使用该参数的指针。
	var svar string
	flag.StringVar(&svar, "svar", "bar", "a string var")

	// 所有标志都声明完成以后，调用 `flag.Parse()` 来执行
	// 命令行解析。
	flag.Parse()

	// 这里我们将仅输出解析的选项以及后面的位置参数。注意，
	// 我们需要使用类似 `*wordPtr` 这样的语法来对指针解引用，从而
	// 得到选项的实际值。
	fmt.Println("word:", *wordPtr)
	fmt.Println("numb:", *numbPtr)
	fmt.Println("fork:", *boolPtr)
	fmt.Println("svar:", svar)
	fmt.Println("tail:", flag.Args())
}
```


测试这个程序前，最好将这个程序编译成二进制文件，然后再运 行这个程序。
```sh
$ go build command-line-flags.go
$ .\command-line-flags
word: foo
numb: 42
fork: false
svar: bar
tail: []
```

注意到，如果你省略一个标志，那么这个标志的值自动的设 定为他的默认值。

```sh
$ ./command-line-flags -word=opt
word: opt
numb: 42
fork: false
svar: bar
tail: []
```

尾随的位置参数可以出现在任何标志后面。
```sh
$ ./command-line-flags -word=opt a1 a2 a3
word: opt
numb: 42
fork: false
svar: bar
tail: [a1 a2 a3]
```

注意，flag 包需要所有的标志出现位置参数之前（ 否则，这个标志将会被解析为位置参数）。

```sh
$ ./command-line-flags -word=opt a1 a2 a3 -numb=7
word: opt
numb: 42
fork: false
svar: bar
trailing: [a1 a2 a3 -numb=7]

$ ./command-line-flags -word=opt -numb=7 a1 a2 a3
word: opt
numb: 7
fork: false
svar: bar
tail: [a1 a2 a3]
```


使用 -h 或者 --help 标志来得到自动生成的这个命 令行程序的帮助文本。
```sh
$ ./command-line-flags -h
Usage of ./command-line-flags:
  -fork=false: a bool
  -numb=42: an int
  -svar="bar": a string var
  -word="foo": a string
```

如果你提供一个没有使用 flag 包指定的标志，程序会输出一 个错误信息，并再次显示帮助文本。
```sh
$ ./command-line-flags -wat
flag provided but not defined: -wat
Usage of ./command-line-flags:
# ...
```


我们可以使用环境变量，用于参数化程序的基本方式，如下。

```go
package main

// Go 提供了一个 `flag` 包，支持基本的命令行标志解析。
// 我们将用这个包来实现我们的命令行程序示例。
import (
	"flag"
	"os"
	"strconv"
)
import "fmt"

func main() {
	numbStr := os.Getenv("numb")
	if numbStr == "" {
		numbStr = "0" // 设置一个默认值
	}
	numb, err := strconv.Atoi(numbStr)
	if err != nil {
		// 处理转换失败的情况
		panic(err)
	}
	// 基本的标记声明仅支持字符串、整数和布尔值选项。
	// 这里我们声明一个默认值为 `"foo"` 的字符串标志 `word`
	// 并带有一个简短的描述。这里的 `flag.String` 函数返回一个字
	// 符串指针（不是一个字符串值），在下面我们会看到是如何
	// 使用这个指针的。
	wordPtr := flag.String("word", "foo", "a string")

	// 使用和声明 `word` 标志相同的方法来声明 `numb` 和 `fork` 标志。
	numbPtr := flag.Int("numb", numb, "an int")
  // ......
```

```sh
$ numb=1994 ./command-line-flags
word: foo
numb: 1994
fork: false
svar: bar
tail: []
```


## Go 命令行子命令 Subcommands
