# Go By Example

参考文献：

中文

- https://gobyexample-cn.github.io/
- https://learnku.com/docs/gobyexample/2020
- https://github.com/everyx/gobyexample



英文

- http://gobyexample.com


## Go hello world

我们的第一个例子是打印经典的“hello world”信息，我们先看下代码。

`hello-world.go`

```go
package main
import "fmt"
func main() {
    fmt.Println("hello world")
}
```

输出结果为：
```sh
$ ls
el_01_hello_world.go
$ go build el_01_hello_world.go 
$ ls
el_01_hello_world    el_01_hello_world.go
$ ./el_01_hello_world 
hello world
```

为了使一个go文件能够编译为可执行文件，包名必须是main，然后我们导入提供格式化输出的fmt包，该程序的执行入口是func main()函数，在函数里面，我们使用fmt包提供的Println函数来输出”hello world”字符串。

为了运行这个程序，我们可以使用`go run el_01_hello_world.go`来运行这个例子，这样是直接输出运行结果而不会产生任何中间文件。

但是有的时候我们希望能够将程序编译为二进制文件保存起来，我们可以像上面一样使用`go build el_01_hello_world.go`来将源代码编译为二进制可执行文件。

然后我们可以直接运行这个二进制可执行文件。

好了，第一个例子就这样结束了。很简单。


## Go 数据类型

Go 拥有多种值类型，包括字符串，整型，浮点型，布尔型等。下面是一些基本的例子。

`values.go`
```go
package main

import "fmt"

func main() {

    // 字符串可以通过 `+` 连接。
    fmt.Println("go" + "lang")    //golang

    // 整数和浮点数
    fmt.Println("1+1 =", 1+1) //1+1 = 2
    fmt.Println("7.0/3.0 =", 7.0/3.0)//7.0/3.0 = 2.3333333333333335

    // 布尔型，以及常见的布尔操作。
    fmt.Println(true && false)  //false
    fmt.Println(true || false)  //true
    fmt.Println(!true)  //false
}
```



## Go 变量

Go是静态类型语言，变量是有明确类型的。编译器会检查函数调用中，变量类型的正确性。

使用var关键字来定义变量。

Go 的基本类型有：

```sh
bool
string
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
byte // uint8 的别名
rune // int32 的别名 代表一个Unicode码
float32 float64
complex64 complex128
```


看看下面的例子

`variables.go`

```go
package main

import "fmt"

func main() {
	// `var` 关键字用来定义一个或者多个变量
	var a string = "initial"
	fmt.Println(a) //initial

	// 你一次可以定义多个变量
	var b, c int = 1, 2
	fmt.Println(b, c)	//1 2

	// Go会推断出具有初始值的变量的类型
	var d = true
	fmt.Println(d) //true

	//定义变量时，没有给出初始值的变量被默认初始化为零值
	//整型的零值就是0
	var e int
	fmt.Println(e) //0

	//":=" 语法是同时定义和初始化变量的快捷方式
	f := "short"
	fmt.Println(f)	//short
}
```






## Go 常量

Go支持定义字符常量，字符串常量，布尔型常量和数值常量。

使用 `const` 关键字来定义常量。

`constant.go`

```go
package main

import "fmt"
import "math"

// "const" 关键字用来定义常量
const s string = "constant"

func main() {
	fmt.Println(s) //constant

	// "const"关键字可以出现在任何"var"关键字出现的地方
	// 区别是常量必须有初始值
	const n = 500000000
	// 常量表达式可以执行任意精度数学计算
	const d = 3e20 / n
	fmt.Println(d) //6e+11

	// 数值型常量没有具体类型，除非指定一个类型
	// 比如显式类型转换
	fmt.Println(int64(d)) //600000000000

	// 数值型常量可以在程序的逻辑上下文中获取类型
	// 比如变量赋值或者函数调用。
	// 例如，对于math包中的Sin函数,它需要一个float64类型的变量
	fmt.Println(math.Sin(n)) //-0.28470407323754404
}
```



## Go for

for循环是Go语言唯一的循环结构。这里有三个基本的for循环类型。

`for.go`

```go
package main

import "fmt"

func main() {
	// 最基本的一种，单一条件循环
	// 这个可以代替其他语言的while循环
	i := 1
	for i <= 3 {
		fmt.Println(i)
		i = i + 1
	}
	// 经典的循环条件初始化/条件判断/循环后条件变化
	for j := 7; j <= 9; j++ {
		fmt.Println(j)
	}
	// 无条件的for循环是死循环，除非你使用break跳出循环或者
	// 使用return从函数返回
	for {
		fmt.Println("loop")
		break
	}
}

```

输出结果

```sh
1
2
3
7
8
9
loop
```

在后面的例子中，你将会看到其他的循环方式，比如使用range函数循环数组，切片和字典，或者用select函数循环channel通道。




## Go if..else条件判断


Go语言的条件判断结构也很简单。

`if-else.go`

```go

package main

import "fmt"

func main() {
	// 基本的例子
	if 7%2 == 0 {
		fmt.Println("7 is even")
	} else {
		fmt.Println("7 is odd")
	}
	// 只有if条件的情况
	if 8%4 == 0 {
		fmt.Println("8 is divisible by 4")
	}
	// if条件可以包含一个初始化表达式，这个表达式中的变量
	// 是这个条件判断结构的局部变量
	if num := 9; num < 0 {
		fmt.Println(num, "is negative")
	} else if num < 10 {
		fmt.Println(num, "has 1 digit")
	} else {
		fmt.Println(num, "has multiple digits")
	}
}
```

条件判断结构中，条件两边的小括号()是可以省略的，但是条件执行语句块两边的大括号{}不可以。

输出结果为
```sh
7 is odd
8 is divisible by 4
9 has 1 digit
```

在 Go 里面没有三元表达式 "?:" ，所以你只能使用条件判断语句。


## Go switch/case语句

当条件判断分支太多的时候，我们会使用switch语句来优化逻辑。

`switch.go`

```go
package main

import "fmt"
import "time"

func main() {

	// 一个基本的 `switch`。
	i := 2
	fmt.Print("write ", i, " as ")
	switch i {
	case 1:
		fmt.Println("one")
	case 2:
		fmt.Println("two")
	case 3:
		fmt.Println("three")
	}

	// 在同一个 `case` 语句中，你可以使用逗号来分隔多个表达式。
	// 在这个例子中，我们还使用了可选的 `default` 分支。
	switch time.Now().Weekday() {
	case time.Saturday, time.Sunday:
		fmt.Println("It's the weekend")
	default:
		fmt.Println("It's a weekday")
	}

	// 不带表达式的 `switch` 是实现 if/else 逻辑的另一种方式。
	// 这里还展示了 `case` 表达式也可以不使用常量。
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("It's before noon")
	default:
		fmt.Println("It's after noon")
	}

	// 类型开关 (`type switch`) 比较类型而非值。可以用来发现一个接口值的类型。
	// 在这个例子中，变量 `t` 在每个分支中会有相应的类型。
	whatAmI := func(i interface{}) {
		switch t := i.(type) {
		case bool:
			fmt.Println("I'm a bool")
		case int:
			fmt.Println("I'm an int")
		default:
			fmt.Printf("Don't know type %T\n", t)
		}
	}
	whatAmI(true)
	whatAmI(1)
	whatAmI("hey")
}
```

运行输出结果：

```sh
$ go run switch.go
Write 2 as two
It's a weekday
It's after noon
I'm a bool
I'm an int
Don't know type string
```



## Go 数组

- 数组是一个具有`相同数据类型`的元素组成的`固定长度`的`有序集合`。

- 在Go语言中，数组是值类型，长度是类型的组成部分，也就是说 `”[10]int“` 和 `“[20]int”` 是完全不同的两种数组类型。

- 同类型的两个数组支持”==”和”!=”比较，但是不能比较大小。

- 数组作为参数时，函数内部不改变数组内部的值，除非是传入数组的指针。

- 数组的指针：*[3]int

- 指针数组：[2]*int


### 示例1:

`arrays.go`

```go
package main

import "fmt"

func main() {
	// 这里我们创建了一个具有5个元素的整型数组
	// 元素的数据类型和数组长度都是数组的一部分
	// 默认情况下，数组元素都是零值
	// 对于整数，零值就是0
	var a [5]int
	fmt.Println("emp:", a) //emp: [0 0 0 0 0]

	// 我们可以使用索引来设置数组元素的值，就像这样
	// "array[index] = value"  或者使用索引来获取元素值，
	// 就像这样"array[index]"
	a[4] = 100
	fmt.Println("set:", a) //set: [0 0 0 0 100]

	fmt.Println("get:", a[4]) //get: 100
	// 内置的len函数返回数组的长度
	fmt.Println("len:", len(a)) //len: 5

	// 这种方法可以同时定义和初始化一个数组
	b := [5]int{1, 2, 3, 4, 5}
	fmt.Println("dcl:", b) //dcl: [1 2 3 4 5]
	// 数组都是一维的，但是你可以把数组的元素定义为一个数组
	// 来获取多维数组结构
	var twoD [2][3]int
	for i := 0; i < 2; i++ {
		for j := 0; j < 3; j++ {
			twoD[i][j] = i + j
		}
	}
	fmt.Println("2d: ", twoD) //2d:  [[0 1 2] [1 2 3]]
}

```

拥有`固定长度`是数组的一个特点，但是这个特点有时候会带来很多不便，尤其在一个集合元素个数不固定的情况下。

这个时候我们更多地使用`切片`。


### 示例2:

可以用new创建数组，并返回数组的指针

```go
package main

import "fmt"

func main() {
	var a = new([5]int)
	test(a)
	fmt.Println(a, len(a)) //&[0 5 0 0 0] 5
}
func test(a *[5]int) {
	a[1] = 5
}
```

### 示例3:

```go
package main

import "fmt"

func main() {
	a := [...]User{
		{0, "User0"},
		{8, "User8"},
	}
	b := [...]*User{
		{0, "User0"},
		{8, "User8"},
	}
	fmt.Println(a, len(a)) //[{0 User0} {8 User8}] 2
	fmt.Println(b, len(b)) //[0xc000008078 0xc000008090] 2
}

type User struct {
	Id   int
	Name string
}
```


### 示例4：

遍历数组的方式

```go
package main

import "fmt"

var arrAge = [5]int{12, 13, 14, 15, 16}

//var arrLazy = [...]int{22, 23, 24, 25, 26}
//var arrKeyValue = [5]string{3: "hujian", 4: "xiaojian"}

func main() {
	// 遍历方法1
	for _, i2 := range arrAge {
		fmt.Println(i2)
	}
	fmt.Println("----------------------------")

	// 遍历方法2
	for i := 0; i < len(arrAge); i++ {
		fmt.Println(arrAge[i])
	}
}
```



## Go 切片

切片是Go语言的关键类型之一，它提供了比数组更多的功能。

`slices.go`

### 示例1：

```go
package main

import "fmt"

func main() {
	// 和数组不同的是，切片的长度是可变的。
	// 我们可以使用内置函数make来创建一个长度不为零的切片
	// 这里我们创建了一个长度为3，存储字符串的切片，切片元素
	// 默认为零值，对于字符串就是""。
	s := make([]string, 3)
	fmt.Println("emp:", s) //emp: [  ]

	// 可以使用和数组一样的方法来设置元素值或获取元素值
	s[0] = "a"
	s[1] = "b"
	s[2] = "c"
	fmt.Println("set:", s)    //set: [a b c]
	fmt.Println("get:", s[2]) //get: c
	// 可以用内置函数len获取切片的长度
	fmt.Println("len:", len(s)) //len: 3

	// 切片还拥有一些数组所没有的功能。
	// 例如我们可以使用内置函数append给切片追加值，然后
	// 返回一个拥有新切片元素的切片。
	// 注意append函数不会改变原切片，而是生成了一个新切片，
	// 我们需要用原来的切片来接收这个新切片
	s = append(s, "d")
	s = append(s, "e", "f")
	fmt.Println("apd:", s) //apd: [a b c d e f]

	// 另外我们还可以从一个切片拷贝元素到另一个切片
	// 下面的例子就是创建了一个和切片s长度相同的新切片
	// 然后使用内置的copy函数来拷贝s的元素到c中。
	c := make([]string, len(s))
	copy(c, s)
	fmt.Println("cpy:", c) //cpy: [a b c d e f]

	// 切片还支持一个取切片的操作 "slice[low:high]"
	// 获取的新切片包含元素"slice[low]"，但是不包含"slice[high]"
	// 下面的例子就是取一个新切片，元素包括"s[2]"，"s[3]"，"s[4]"。
	l := s[2:5]
	fmt.Println("sl1:", l) //sl1: [c d e]

	// 如果省略low，默认从0开始，不包括"slice[high]"元素
	l = s[:5]
	fmt.Println("sl2:", l) //sl2: [a b c d e]

	// 如果省略high，默认为len(slice)，包括"slice[low]"元素
	l = s[2:]
	fmt.Println("sl3:", l) //sl3: [c d e f]

	// 我们可以同时声明和初始化一个切片
	t := []string{"g", "h", "i"}
	fmt.Println("dcl:", t) //dcl: [g h i]

	// 我们也可以创建多维切片，和数组不同的是，切片元素的长度也是可变的。
	twoD := make([][]int, 3)
	for i := 0; i < 3; i++ {
		innerLen := i + 1
		twoD[i] = make([]int, innerLen)
		for j := 0; j < innerLen; j++ {
			twoD[i][j] = i + j
		}
	}

	fmt.Println("2d: ", twoD) //2d:  [[0] [1 2] [2 3 4]]
}
```



数组和切片的定义方式的区别在于[]之中是否有固定长度或者推断长度标志符...。

### 示例2：

```go
package main

import "fmt"

func main() {
	s1 := make([]int, 0)
	test(s1)
	fmt.Println(s1)
}
func test(s []int) {
	s = append(s, 3)
	//因为原来分配的空间不够，所以在另外一个地址又重新分配了空间，所以原始地址的数据没有变
}
```

输出结果为：
```sh
[]
```

若改为：
```go
package main

import "fmt"

func main() {
	s1 := make([]int, 0)
	s1 = test(s1)
	fmt.Println(s1)
}
func test(s []int) []int {
	s = append(s, 3)
	return s
}

```

输出结果为：
```sh
[3]   //正确结果
```


### 示例3：

cap是slice的最大容量，append函数添加元素，如果超过原始slice的容量，会重新分配底层数组。


```go
package main

import "fmt"

func main() {
	s1 := make([]int, 3, 6)
	fmt.Println("s1= ", s1, len(s1), cap(s1)) //s1=  [0 0 0] 3 6

	s2 := append(s1, 1, 2, 3)
	fmt.Println("s1= ", s1, len(s1), cap(s1)) //s1=  [0 0 0] 3 6
	fmt.Println("s2= ", s2, len(s2), cap(s2)) //s2=  [0 0 0 1 2 3] 6 6

	s3 := append(s2, 4, 5, 6)
	fmt.Println("s1= ", s1, len(s1), cap(s1)) //s1=  [0 0 0] 3 6
	fmt.Println("s2= ", s2, len(s2), cap(s2)) //s2=  [0 0 0 1 2 3] 6 6
	fmt.Println("s3= ", s3, len(s3), cap(s3)) //s3=  [0 0 0 1 2 3 4 5 6] 9 12
}
```


### 示例4：

指向同一底层数组的slice之间copy时，允许存在重叠。

copy数组时，受限于src和dst数组的长度最小值。


```go
package main

import "fmt"

func main() {
	s1 := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s2 := make([]int, 3, 20)

	var n int
	n = copy(s2, s1)
	fmt.Println(n, s2, len(s2), cap(s2)) //3 [0 1 2] 3 20

	s3 := s1[4:6]
	fmt.Println(n, s3, len(s3), cap(s3)) //3 [4 5] 2 6

	n = copy(s3, s1[1:5])
	fmt.Println(n, s3, len(s3), cap(s3)) //2 [1 2] 2 6

}
```





## Go 字典

字典是Go语言内置的关联数据类型。因为数组是索引对应数组元素，而字典是键对应值。


### 示例1:

`maps.go`

```go
package main

import "fmt"

func main() {
	// 创建一个字典可以使用内置函数make
	// "make(map[键类型]值类型)"
	m := make(map[string]int)
	// 使用经典的"name[key]=value"来为键设置值
	m["k1"] = 7
	m["k2"] = 13
	// 用Println输出字典，会输出所有的键值对
	fmt.Println("map:", m) //map: map[k1:7 k2:13]

	// 获取一个键的值 "name[key]".
	v1 := m["k1"]
	fmt.Println("v1: ", v1) //v1:  7

	// 内置函数返回字典的元素个数
	fmt.Println("len:", len(m)) //len: 2

	// 内置函数delete从字典删除一个键对应的值
	delete(m, "k2")
	fmt.Println("map:", m) //map: map[k1:7]

	// 根据键来获取值有一个可选的返回值，这个返回值表示字典中是否
	// 存在该键，如果存在为true，返回对应值，否则为false，返回零值
	// 有的时候需要根据这个返回值来区分返回结果到底是存在的值还是零值
	// 比如字典不存在键x对应的整型值，返回零值就是0，但是恰好字典中有
	// 键y对应的值为0，这个时候需要那个可选返回值来判断是否零值。
	_, ok := m["k2"]
	fmt.Println("ok:", ok) //ok: false

	// 你可以用 ":=" 同时定义和初始化一个字典
	n := map[string]int{"foo": 1, "bar": 2}
	fmt.Println("map:", n) //map: map[bar:2 foo:1]

	hu := map[string]string{
		"name":   "hujianli",
		"age":    "22",
		"sex":    "man",
		"school": "dianda",
	}
	// name:hujianli  age:22  sex:man  school:dianda
	fmt.Printf("name:%s  age:%s  sex:%s  school:%s\n", hu["name"], hu["age"], hu["sex"], hu["school"])

	//遍历map中的键值对–访问关联关系
	for i, i2 := range hu {
		fmt.Printf("key:%s value:%s\n", i, i2)
	}

	// 只遍历值
	for _, i2 := range hu {
		fmt.Printf("value -> %s\n", i2)
	}
	// 只遍历键
	for i := range hu {
		fmt.Printf("key -> %s\n", i)
	}

	// var mydicMap map[string]string
	mydicMaps := make(map[string]string)
	mydicMaps["hujianli1"] = "A1"
	mydicMaps["hujianli2"] = "A2"
	mydicMaps["hujianli3"] = "A3"

	for k, v := range mydicMaps {
		fmt.Printf("%s %s\n", k, v)
	}
	name1, ok := mydicMaps["hu1"]
	if !ok {
		fmt.Println("----------", name1)
	}

	// 或者
	if name2, ok := mydicMaps["hu2"]; !ok {
		fmt.Println("----------", name2)
	}
}
```

### 示例2:

排序遍历

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	scene := make(map[string]int)
	//准备map数据
	scene["route"] = 66
	scene["brazil"] = 4
	scene["china"] = 960
	// 声明一个切片保存map数据
	var sceneList []string
	// 将map数据遍历后复制到切片中
	for key := range scene {
		sceneList = append(sceneList, key)
	}
	// 对切片进行排序
	sort.Strings(sceneList)
	// 输出
	fmt.Println(sceneList) //[brazil china route]
}
```


清空map中的所有元素

Go 语言中没有清空map的方法和函数。

清空map的位于方法是重新make一个新的map。 

Go中的并行垃圾回收效率比写一个清空函数高效多了。



清空 map的一个解决方法

但在多次讨论中，Go 官方团队给出的解决方案是：

```go
for k := range m {
    delete(m, k)
}
```


```go
package main

import "fmt"

func main() {
	scene := make(map[string]int)
	//准备map数据
	scene["route"] = 66
	scene["brazil"] = 4
	scene["china"] = 960
	fmt.Println(scene) //map[brazil:4 china:960 route:66]

	//清空 map
	for k := range scene {
		delete(scene, k)
	}
	fmt.Println(scene) //map[]
}
```

### 示例3:

使用map查找重复的行

```go
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

func main() {
	counts := make(map[string]int)
	for _, filename := range os.Args[1:] {
		data, err := ioutil.ReadFile(filename)
		if err != nil {
			fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
			continue
		}
		for _, line := range strings.Split(string(data), "\n") {
			counts[line]++
		}
	}
	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}
```

执行结果
```sh
$ go run .\main.go .\test.txt
3       aaaaaaaaa
2       bbbb
```


## Go 列表

go 语言中的  

- 数组是类型相同的元素的集合

- 列表是双链表的容器, 可以添加不同类型的数据

- 切片是对现有数组的引用, 比数组更方便灵活, 还可以追加数据


列表与切片和map不同的是，列表并没有具体元素类型的限制。

因此，列表的元素可以是任意类型。

这既带来便利，也会引来一些问题。

给一个列表放入了非期望类型的值，在取出值后，将interface{}转换为期望类型时将会发生宕机。


### 示例1

```go
package main

import (
	"fmt"
)

func main() {
	// 定义包含不同类型值的列表
	list := []interface{}{"apple", 123, true}
	// 在遍历列表时,使用Switch语句根据元素的实际类型执行相应的操作。
	for _, item := range list {
		switch v := item.(type) {
		case string:
			fmt.Println("String:", v)
		case int:
			fmt.Println("Integer:", v)
		case bool:
			fmt.Println("Boolean:", v)
		default:
			fmt.Println("Unknown type")
		}
	}

	// 类型断言示例
	// 尝试将第一个元素转换为字符串类型，并使用ok变量来判断转换是否成功。
	str, ok := list[0].(string)
	if ok {
		fmt.Println("First element is a string:", str)
	} else {
		fmt.Println("First element is not a string")
	}
}
```


### 示例2

```go
package main

import (
	"container/list"
	"fmt"
)

func main() {
	// 创建一个列表实例
	l := list.New()
	// 将first字符串插入到列表的尾部，此时列表有一个元素
	l.PushBack("first")
	//67这个元素将被放在fist的前面
	l.PushFront(67)
	// 返回list最后一个元素
	fmt.Println(l.Back()) //&{0xc000122510 0xc000122570 0xc000122510 first}
	//返回list第一个元素
	fmt.Println(l.Front()) //&{0xc000122540 0xc000122510 0xc000122510 67}

	// 创建一个列表实例
	l1 := list.New()
	l1.PushBack("cancon") //尾部加          canon
	l1.PushFront(67)      // 头部加         67 canon

	// 尾部添加后保存元素句柄
	element := l1.PushBack("fist")   // 67 canon fist
	l1.InsertAfter("hight", element) // 在first后添加hight       67 canon fist hight
	l1.InsertBefore("None", element) // 在first之前添加None   67 canon None fist hight
	l1.Remove(element)               // 移除element变量对象的元素  67 canon None hight

	// 循环打印列表
	for i := l1.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
	}
}
```



## Go range函数

range函数是个神奇而有趣的内置函数，你可以使用它来遍历数组，切片和字典。

当用于遍历数组和切片的时候，range函数返回索引和元素；

当用于遍历字典的时候，range函数返回字典的键和值。

`range.go`

```go
package main

import "fmt"

func main() {
	// 这里我们使用range来计算一个切片的所有元素和
	// 这种方法对数组也适用
	nums := []int{2, 3, 4}
	sum := 0
	for _, num := range nums {
		sum += num
	}
	fmt.Println("sum:", sum)

	// range 用来遍历数组和切片的时候返回索引和元素值
	// 如果我们不要关心索引可以使用一个下划线(_)来忽略这个返回值
	// 当然我们有的时候也需要这个索引
	for i, num := range nums {
		if num == 3 {
			fmt.Println("index:", i)
		}
	}

	// 使用range来遍历字典的时候，返回键值对。
	kvs := map[string]string{"a": "apple", "b": "banana"}
	for k, v := range kvs {
		fmt.Printf("%s -> %s\n", k, v)
	}

	// range函数用来遍历字符串时，返回Unicode代码点。
	// 第一个返回值是每个字符的起始字节的索引，第二个是字符代码点，
	// 因为Go的字符串是由字节组成的，多个字节组成一个rune类型字符。
	for i, c := range "go" {
		fmt.Println(i, c)
	}
}
```

输出结果为
```sh
sum: 9
index: 1
a -> apple
b -> banana
0 103
1 111
```


## Go 字符串操作函数

strings 标准库提供了很多字符串操作相关的函数。这里提供的几个例子是让你先对这个包有个基本了解。

`string-functions.go`

### 示例1

```go
package main

import s "strings"
import "fmt"

// 这里给fmt.Println起个别名，因为下面我们会多处使用。
var p = fmt.Println

func main() {
	// 下面是strings包里面提供的一些函数实例。注意这里的函数并不是
	// string对象所拥有的方法，这就是说使用这些字符串操作函数的时候
	// 你必须将字符串对象作为第一个参数传递进去。
	p("Contains:  ", s.Contains("test", "es"))        //Contains:   true
	p("Count:     ", s.Count("test", "t"))            //Count:      2
	p("HasPrefix: ", s.HasPrefix("test", "te"))       //HasPrefix:  true
	p("HasSuffix: ", s.HasSuffix("test", "st"))       //HasSuffix:  true
	p("Index:     ", s.Index("test", "e"))            //Index:      1
	p("Join:      ", s.Join([]string{"a", "b"}, "-")) //Join:       a-b
	p("Repeat:    ", s.Repeat("a", 5))                //Repeat:     aaaaa
	p("Replace:   ", s.Replace("foo", "o", "0", -1))  //Replace:    f00
	p("Replace:   ", s.Replace("foo", "o", "0", 1))   //Replace:    f0o
	p("Split:     ", s.Split("a-b-c-d-e", "-"))       //Split:      [a b c d e]
	p("ToLower:   ", s.ToLower("TEST"))               //ToLower:    test
	p("ToUpper:   ", s.ToUpper("test"))               //ToUpper:    TEST
	p()
	// 你可以在strings包里面找到更多的函数
	// 这里还有两个字符串操作方法，它们虽然不是strings包里面的函数，
	// 但是还是值得提一下。一个是获取字符串长度，另外一个是从字符串中
	// 获取指定索引的字符
	p("Len: ", len("hello")) //Len:  5
	p("Char:", "hello"[1])   //Char: 101
}
```





### 示例2

```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	str0 := "hujianli"
	str1 := `第一行
    第二行
    第三行
    `
	fmt.Println(len(str0), len(str1)) //求长度
	var str3 string = str0 + str1
	fmt.Println(str3)

	str4 := fmt.Sprintf("%s %s", str0, str1) //拼接字符串
	fmt.Println(str4)

	str5 := "hu,jian,li"
	fmt.Println(strings.Split(str5, ",")) //分割
	fmt.Println(strings.Split(str5, "i"))
	fmt.Printf("%q\n", strings.Split(" xyz ", ""))
	fmt.Printf("%q\n", strings.Split("", "Bernardo O'Higgins"))

	fmt.Printf("%t\n", strings.Contains("sssss", "ss")) //判断是否包含

	fmt.Printf("%t\n", strings.HasPrefix("hujianli", "hu")) //判断前缀
	fmt.Printf("%t\n", strings.HasSuffix("hujianli", "li")) //判断后缀
	fmt.Printf("%d\n", strings.Index("hujianli", "li"))     //判断子串出现的位置
	fmt.Printf("%d\n", strings.LastIndex("hujianli", "i"))  //判断子串最后出现的位置
	s := []string{"foo", "bar", "baz"}
	fmt.Println(strings.Join(s, ",")) //将一系列字符串连接为一个字符串，之间用sep来分隔。
}
```



## Go 字符串格式化

Go对字符串格式化提供了良好的支持。下面我们看些常用的字符串格式化的例子。

`string-formatting.go`

```go
package main

import "fmt"
import "os"

type point struct {
	x, y int
}

func main() {
	// Go提供了几种打印格式，用来格式化一般的Go值，例如
	// 下面的%v打印了一个point结构体的对象的值
	p := point{1, 2}
	fmt.Printf("%v\n", p) //{1 2}

	// 如果所格式化的值是一个结构体对象，那么`%+v`的格式化输出
	// 将包括结构体的成员名称和值
	fmt.Printf("%+v\n", p) //{x:1 y:2}

	// `%#v`格式化输出将输出一个值的Go语法表示方式。
	fmt.Printf("%#v\n", p) //main.point{x:1, y:2}

	// 使用`%T`来输出一个值的数据类型
	fmt.Printf("%T\n", p) //main.point

	// 格式化布尔型变量
	fmt.Printf("%t\n", true) //true

	// 有很多的方式可以格式化整型，使用`%d`是一种
	// 标准的以10进制来输出整型的方式
	fmt.Printf("%d\n", 123) //123

	// 这种方式输出整型的二进制表示方式
	fmt.Printf("%b\n", 14) //1110

	// 这里打印出该整型数值所对应的字符
	fmt.Printf("%c\n", 33) //!

	// 使用`%x`输出一个值的16进制表示方式
	fmt.Printf("%x\n", 456) //1c8

	// 浮点型数值也有几种格式化方法。最基本的一种是`%f`
	fmt.Printf("%f\n", 78.9) //78.900000

	// `%e`和`%E`使用科学计数法来输出整型
	fmt.Printf("%e\n", 123400000.0) //1.234000e+08
	fmt.Printf("%E\n", 123400000.0) //1.234000E+08

	// 使用`%s`输出基本的字符串
	fmt.Printf("%s\n", "\"string\"") //"string"

	// 输出像Go源码中那样带双引号的字符串，需使用`%q`
	fmt.Printf("%q\n", "\"string\"") //"\"string\""

	// `%x`以16进制输出字符串，每个字符串的字节用两个字符输出
	fmt.Printf("%x\n", "hex this") //6865782074686973

	// 使用`%p`输出一个指针的值
	fmt.Printf("%p\n", &p) //0xc0000180c0

	// 当输出数字的时候，经常需要去控制输出的宽度和精度。
	// 可以使用一个位于%后面的数字来控制输出的宽度，默认
	// 情况下输出是右对齐的，左边加上空格
	fmt.Printf("|%6d|%6d|\n", 12, 345) //|    12|   345|

	// 你也可以指定浮点数的输出宽度，同时你还可以指定浮点数
	// 的输出精度
	fmt.Printf("|%6.2f|%6.2f|\n", 1.2, 3.45) //|  1.20|  3.45|

	// To left-justify, use the `-` flag.
	fmt.Printf("|%-6.2f|%-6.2f|\n", 1.2, 3.45) //|1.20  |3.45  |

	// 你也可以指定输出字符串的宽度来保证它们输出对齐。默认
	// 情况下，输出是右对齐的
	fmt.Printf("|%6s|%6s|\n", "foo", "b") //|   foo|     b|

	// 为了使用左对齐你可以在宽度之前加上`-`号
	fmt.Printf("|%-6s|%-6s|\n", "foo", "b") //|foo   |b     |

	// `Printf`函数的输出是输出到命令行`os.Stdout`的，你
	// 可以用`Sprintf`来将格式化后的字符串赋值给一个变量
	s := fmt.Sprintf("a %s", "string")
	fmt.Println(s) //a string

	// 你也可以使用`Fprintf`来将格式化后的值输出到`io.Writers`
	fmt.Fprintf(os.Stderr, "an %s\n", "error") //an error
}
```



## Go 正则表达式

Go 提供内置的正则表达式。 这里是 Go 中基本的正则相关功能的例子。

`regular-expressions.go`

```go
package main

import "bytes"
import "fmt"
import "regexp"

func main() {

	// 这个测试一个字符串是否符合一个表达式。
	match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
	fmt.Println(match) //true

	// 上面我们是直接使用字符串，但是对于一些其他的正则任务，
	// 你需要 `Compile` 一个优化的 `Regexp` 结构体。
	r, _ := regexp.Compile("p([a-z]+)ch")

	// 这个结构体有很多方法。
	// 这里是类似我们前面看到的一个匹配测试。
	fmt.Println(r.MatchString("peach")) //true

	// 这是查找匹配字符串的。
	fmt.Println(r.FindString("peach punch")) //peach

	// 这个也是查找第一次匹配的字符串的，
	// 但是返回的匹配开始和结束位置索引，而不是匹配的内容。
	fmt.Println(r.FindStringIndex("peach punch")) //[0 5]

	// `Submatch` 返回完全匹配和局部匹配的字符串。
	// 例如，这里会返回 `p([a-z]+)ch` 和 `([a-z]+) 的信息。
	fmt.Println(r.FindStringSubmatch("peach punch")) //[peach ea]

	// 类似的，这个会返回完全匹配和局部匹配的索引位置。
	fmt.Println(r.FindStringSubmatchIndex("peach punch")) //[0 5 1 3]

	// 带 `All` 的这个函数返回所有的匹配项，而不仅仅是首次匹配项。
	// 例如查找匹配表达式的所有项。
	fmt.Println(r.FindAllString("peach punch pinch", -1)) //[peach punch pinch]

	// `All` 同样可以对应到上面的所有函数。
	fmt.Println(r.FindAllStringSubmatchIndex(
		"peach punch pinch", -1)) //[[0 5 1 3] [6 11 7 9] [12 17 13 15]]

	// 这个函数提供一个正整数来限制匹配次数。
	fmt.Println(r.FindAllString("peach punch pinch", 2)) //[peach punch]

	// 上面的例子中，我们使用了字符串作为参数，并使用了如 `MatchString` 这样的方法。
	// 我们也可以提供 `[]byte` 参数并将 `String` 从函数命中去掉。
	fmt.Println(r.Match([]byte("peach"))) //true

	// 创建正则表达式常量时，可以使用 `Compile` 的变体 `MustCompile` 。
	// 因为 `Compile` 返回两个值，不能用于常量。
	r = regexp.MustCompile("p([a-z]+)ch")
	fmt.Println(r) //p([a-z]+)ch

	// `regexp` 包也可以用来替换部分字符串为其他值。
	fmt.Println(r.ReplaceAllString("a peach", "<fruit>")) //a <fruit>

	// `Func` 变量允许传递匹配内容到一个给定的函数中，
	in := []byte("a peach")
	out := r.ReplaceAllFunc(in, bytes.ToUpper)
	fmt.Println(string(out)) //a PEACH
}
```



## Go 函数定义

函数是Go语言的重要内容。

`functions.go`

```go
package main

import "fmt"

// 这个函数计算两个int型输入数据的和，并返回int型的和
func plus(a int, b int) int {
	// Go需要使用return语句显式地返回值
	return a + b
}
func main() {
	// 函数的调用方式很简单
	// "名称(参数列表)"
	res := plus(1, 2)
	fmt.Println("1+2 =", res) //1+2 = 3
}

```

Go的函数还有很多其他的特性，其中一个就是多返回值，我们下面会看到。


## Go 多返回值函数

`multiple-return-values.go`

```go
package main

import "fmt"

// `(int, int)` 在这个函数中标志着这个函数返回 2 个 `int`。
func vals() (int, int) {
    return 3, 7
}

func main() {

    // 这里我们通过_多赋值_操作来使用这两个不同的返回值。
    a, b := vals()
    fmt.Println(a)
    fmt.Println(b)

    // 如果你仅仅需要返回值的一部分的话，你可以使用空白标识符`_`。
    _, c := vals()
    fmt.Println(c)
}
```


## Go 函数命名返回值

函数接受参数。在 Go 中，函数可以返回多个“结果参数”，而不仅仅是一个值。它们可以像变量那样命名和使用。

如果命名了返回值参数，一个没有参数的return语句，会将当前的值作为返回值返回。

注意，如果遇到if等代码块和返回值同名，还需要显示写出返回值。


```go
package main

import "fmt"

// `(int, int)` 在这个函数中标志着这个函数返回 2 个 `int`。
func vals() (int, int) {
	return 3, 7
}

func main() {

	// 这里我们通过_多赋值_操作来使用这两个不同的返回值。
	a, b := vals()
	fmt.Println(a) //3
	fmt.Println(b) //7

	// 如果你仅仅需要返回值的一部分的话，你可以使用空白标识符`_`。
	_, c := vals()
	fmt.Println(c) //7
}
```



## Go 变参函数

支持可变长参数列表的函数可以支持任意个传入参数，比如 fmt.Println 函数就是一个支持可变长参数列表的函数。

`variadic-functions.go`

```go
package main

import "fmt"

// 这个函数可以传入任意数量的整型参数
func sum(nums ...int) {
	fmt.Print(nums, " ")
	total := 0
	for _, num := range nums {
		total += num
	}
	fmt.Println(total)
}

func main() {
	// 支持可变长参数的函数调用方法和普通函数一样
	// 也支持只有一个参数的情况
	sum(1, 2) //[1 2] 3

	sum(1, 2, 3) //[1 2 3] 6

	// 如果你需要传入的参数在一个切片中，像下面一样
	// "func(slice...)"把切片打散传入
	nums := []int{1, 2, 3, 4}
	sum(nums...) //[1 2 3 4] 10
}
```

需要注意的是，可变长参数应该是函数定义的最右边的参数，即最后一个参数。


## Go 函数回调


Go支持函数回调，你可以把函数名称作为参数传递给另外一个函数，然后在别的地方实现这个函数。

```go
package main

import "fmt"

type Callback func(x, y int) int

func main() {
	x, y := 1, 2
	fmt.Println(test(x, y, add)) //3

}

// 提供一个接口，让外部去实现
func test(x, y int, callback Callback) int {
	return callback(x, y)
}
func add(x, y int) int {
	return x + y
}
```


## Go 闭包 Closures

Go 支持匿名函数，并能用其构造 闭包。 匿名函数在你想定义一个不需要命名的内联函数时是很实用的。

`closures.go`

```go
package main

import "fmt"

// 这个 `intSeq` 函数返回另一个在 `intSeq` 函数体内定义的匿名函数。
// 这个返回的函数使用闭包的方式 _隐藏_ 变量 `i`。
func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}

func main() {

	// 我们调用 `intSeq` 函数，将返回值（一个函数）赋给`nextInt`。
	// 这个函数的值包含了自己的值 `i`，
	// 这样在每次调用 `nextInt` 时都会更新 `i` 的值。
	nextInt := intSeq()

	// 通过多次调用 `nextInt` 来看看闭包的效果。
	fmt.Println(nextInt()) //1
	fmt.Println(nextInt()) //2
	fmt.Println(nextInt()) //3

	// 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。
	newInts := intSeq()
	fmt.Println(newInts()) //1
}
```


## Go 递归 Recursion

Go 支持 递归。 这里是一个经典的阶乘示例。

`recursion.go`

```go
package main

import "fmt"

// fact calculates the factorial of a number using recursion
func fact(n int) int {
	if n == 0 || n == 1 {
		return 1
	}
	return n * fact(n-1)
}

func main() {
	fmt.Println(fact(7)) //5040

}
```


## Go 指针 Pointers

Go 支持 * 指针 *， 允许在程序中通过引用传递值或者数据结构。

`pointers.go`

```go
package main

import "fmt"

// 我们将通过两个函数：`zeroval` 和 `zeroptr` 来比较指针和值类型的不同。
// `zeroval` 有一个 `int` 型参数，所以使用值传递。
// `zeroval` 将从调用它的那个函数中得到一个 `ival` 形参的拷贝。
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` 有一和上面不同的 `*int` 参数，意味着它用了一个 `int` 指针。
// 函数体内的 `*iptr` 接着_解引用_这个指针，从它内存地址得到这个地址对应的当前值。
// 对一个解引用的指针赋值将会改变这个指针引用的真实地址的值。
func zeroptr(iptr *int) {
	*iptr = 0
}

func main() {
	i := 1
	// 打印i的指针地址
	fmt.Printf("address: %p\n", &i) //address: 0xc0000180a8
	fmt.Println("initial:", i)      //initial: 1

	zeroval(i)
	fmt.Println("zeroval:", i) //zeroval: 1
	// 打印i的指针地址
	fmt.Printf("address: %p\n", &i) //address: 0xc0000180a8

	// 通过 `&i` 语法来取得 `i` 的内存地址，即指向 `i` 的指针。
	zeroptr(&i)
	fmt.Println("zeroptr:", i) //zeroptr: 0
	// 指针也是可以被打印的。
	fmt.Println("pointer:", &i) //0xc0000180a8
}
```

在对普通变量使用 "&" 操作符取地址获得这个变量的指针后，可以对指针使用 "*" 操作，进行指针的取值, “*“ 又被读作 ”处的值”。


这么记：

```go
ptr := &house       // 取址赋给ptr
value := *ptr       // 根据地址取值赋给value
```

```
&   取址              // 处的地址
*   根据地址取值       // 处的值
```


在函数间传递大数组数据时使用指针

```go
package main

func foo(array [1e6]int)  {
    println("mem chile .....")
}


func foo1(array *[1e6]int)  {
    println("mem chile .....")
}
func main() {
    // 声明一个需要8 MB的数组
    var array [1e6]int
    // 将数组传递给函数foo
    foo(array)

    // 节省了内存，但是会改变共享的内存
    // 将数组的地址传递给函数foo
    foo1(&array)

}
```


取地址操作符“&”和取值操作符“*”是一对互补操作符，“&”取出地址，“*” 根据地址取出地址指向的值。


变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：

- 对变量进行取地址（&）操作，可以获得这个变量的指针变量。

- 指针变量的值是指针地址。

- 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。



## Go 结构体

Go语言结构体数据类是将各个类型的变量定义的集合，通常用来表示记录。

`structs.go`

```go
package main

import "fmt"

// 这个person结构体有name和age成员
type person struct {
	name string
	age  int
}

func main() {
	// 这个语法创建一个新结构体变量
	fmt.Println(person{"Bob", 20})

	// 可以使用"成员:值"的方式来初始化结构体变量
	fmt.Println(person{name: "Alice", age: 30})

	// 未显式赋值的成员初始值为零值
	fmt.Println(person{name: "Fred"})

	// 可以使用&来获取结构体变量的地址
	fmt.Println(&person{name: "Ann", age: 40})

	// 使用点号(.)来访问结构体成员
	s := person{name: "Sean", age: 50}
	fmt.Println(s.name)

	// 结构体指针也可以使用点号(.)来访问结构体成员
	// Go语言会自动识别出来
	sp := &s
	fmt.Println(sp.age)

	// 结构体成员变量的值是可以改变的
	sp.age = 51
	fmt.Println(sp.age)
}
```


运行结果：

```sh
$ go run structs.go
{Bob 20}
{Alice 30}
{Fred 0}
&{Ann 40}
Sean
50
51
```



## Go 方法

Go 支持在结构体类型中定义方法 (methods) 。


`methods.go`

```go
package main

import "fmt"

type rect struct {
	width, height int
}

// 这里的 `area` 方法有一个_接收器(receiver)类型_ `rect`。
func (r *rect) area() int {
	return r.width * r.height
}

// 可以为值类型或者指针类型的接收器定义方法。
// 这里是一个值类型接收器的例子。
func (r rect) perim() int {
	return 2*r.width + 2*r.height
}

func main() {
	r := rect{width: 10, height: 5}

	// 这里我们调用上面为结构体定义的两个方法。
	fmt.Println("area: ", r.area())  //area:  50
	fmt.Println("perim:", r.perim()) //perim: 30

	// Go 自动处理方法调用时的值和指针之间的转化。
	// 你可以使用指针来调用方法来避免在方法调用时产生一个拷贝，
	// 或者让方法能够改变接受的结构体。
	rp := &r
	fmt.Println("area: ", rp.area())  //area:  50
	fmt.Println("perim:", rp.perim()) //perim: 30
}
```


## Go 接口 Interfaces


接口 (Interfaces) 是命名了的方法签名 (signatures) 的集合。


`interfaces.go`

```go
package main

import "fmt"
import "math"

// 这里是一个几何体的基本接口。
type geometry interface {
	area() float64
	perim() float64
}

// 在我们的例子中，我们将在类型 `rect` 和 `circle` 上实现这个接口
type rect struct {
	width, height float64
}
type circle struct {
	radius float64
}

// 要在 Go 中实现一个接口，我们就需要实现接口中的所有方法。
// 这里我们在 `rect` 上实现了 `geometry` 接口。
func (r rect) area() float64 {
	return r.width * r.height
}
func (r rect) perim() float64 {
	return 2*r.width + 2*r.height
}

// `circle` 的实现。
func (c circle) area() float64 {
	return math.Pi * c.radius * c.radius
}
func (c circle) perim() float64 {
	return 2 * math.Pi * c.radius
}

// 如果一个变量具有接口类型，那么我们可以调用指定接口中的方法。
// 这里有一个通用的 `measure` 函数，利用它来在任何的 `geometry` 上工作。
func measure(g geometry) {
	fmt.Println(g)
	fmt.Println(g.area())
	fmt.Println(g.perim())
}

func main() {
	r := rect{width: 3, height: 4}
	c := circle{radius: 5}

	// 结构体类型 `circle` 和 `rect` 都实现了 `geometry` 接口，
	// 所以我们可以使用它们的实例作为 `measure` 的参数。
	measure(r)
	measure(c)
}
```

运行结果如下：
```sh
$ go run interfaces.go
{3 4}
12
14
{5}
78.53981633974483
31.41592653589793
```


要学习更多关于 Go 的接口的知识，看看这篇 [很棒的博文](https://learnku.com/go/t/38843)。



## Go 错误处理 Errors

符合 Go 语言习惯的做法是使用一个独立、明确的返回值来传递错误信息。 

这与使用异常 (exception) 的 Java 和 Ruby 以及在 C 语言中有时用到的重载 (overloaded) 的单返回 / 错误值有着明显的不同。

Go 语言的处理方式能清楚的知道哪个函数 返回了错误，并能像调用那些没有出错的函数一样调用。

`errors.go`

```go
package main

import "errors"
import "fmt"

// 按照惯例，错误通常是最后一个返回值并且是 `error` 类型，一个内建的接口。
func f1(arg int) (int, error) {
	if arg == 42 {
		// `errors.New` 构造一个使用给定的错误信息的基本 `error` 值。
		return -1, errors.New("can't work with 42")

	}
	// 返回错误值为 nil 代表没有错误。
	return arg + 3, nil
}

// 可以通过实现 `Error` 方法来自定义 `error` 类型。
// 这里使用自定义错误类型来表示上面例子中的参数错误。
type argError struct {
	arg  int
	prob string
}

func (e *argError) Error() string {
	return fmt.Sprintf("%d - %s", e.arg, e.prob)
}

func f2(arg int) (int, error) {
	if arg == 42 {
		// 在这个例子中，我们使用 `&argError` 语法来建立一个新的结构体，
		// 并提供了 `arg` 和 `prob` 这两个字段的值。
		return -1, &argError{arg, "can't work with it"}
	}
	return arg + 3, nil
}

func main() {

	// 下面的两个循环测试了各个返回错误的函数。
	// 注意在 `if` 行内的错误检查代码，在 Go 中是一个普遍的用法。
	for _, i := range []int{7, 42} {
		if r, e := f1(i); e != nil {
			fmt.Println("f1 failed:", e)
		} else {
			fmt.Println("f1 worked:", r)
		}
	}

	for _, i := range []int{7, 42} {
		if r, e := f2(i); e != nil {
			fmt.Println("f2 failed:", e)
		} else {
			fmt.Println("f2 worked:", r)
		}
	}

	// 你如果想在程序中使用一个自定义错误类型中的数据，
	// 你需要通过类型断言来得到这个错误类型的实例。
	_, e := f2(42)
	if ae, ok := e.(*argError); ok {
		fmt.Println(ae.arg)
		fmt.Println(ae.prob)
	}
}
```

运行输出内容：

```sh
$ go run errors.go
f1 worked: 10
f1 failed: can't work with 42
f2 worked: 10
f2 failed: 42 - can't work with it
42
can't work with it
```



## Go Panic异常

Panic表示的意思就是有些意想不到的错误发生了。

通常我们用来表示程序正常运行过程中不应该出现的，或者我们没有处理好的错误。

`panic.go`

```go
package main

import "os"

func main() {
	// 我们使用panic来检查预期不到的错误
	panic("a problem")
	// Panic的通常使用方法就是如果一个函数
	// 返回一个我们不知道怎么处理的错误的
	// 时候，直接终止执行。
	_, err := os.Create("/tmp/file")
	if err != nil {
		panic(err)
	}
}
```


运行结果

```sh
panic: a problem
goroutine 1 [running]:
runtime.panic(0x44e060, 0xc0840031b0)
        C:/Users/ADMINI~1/AppData/Local/Temp/2/bindist667667715/go/src/pkg/runtime/panic.c:266 +0xc8
main.main()
        D:/GoDoc/go_panic.go:8 +0x58
exit status 2
```


和其他的编程语言不同的是，Go并不使用exception来处理错误，而是通过函数返回值返回错误代码。




## Go Exit

使用 os.Exit 可以给定一个状态，然后立刻退出程序运行。


```go
package main

import "fmt"
import "os"

func main() {
	// 当使用`os.Exit`的时候defer操作不会被运行，
	// 所以这里的``fmt.Println`将不会被调用
	defer fmt.Println("!")
	// 退出程序并设置退出状态值
	os.Exit(3)
}
```


注意，Go和C语言不同，main函数并不返回一个整数来表示程序的退出状态，而是将退出状态作为os.Exit函数的参数。

如果你使用go run来运行程序，将会有如下输出
```sh
exit status 3
```

如果你使用go build先编译程序，然后再运行可执行文件，程序将不会有输出。

如果你想查看程序的返回值，unix系列系统下面使用如下方法:
```sh
$ ./go_exit
$ echo $?
3
```


## Go Defer延迟调用

Defer 被用来确保一个函数调用在程序执行结束前执行。同 样用来执行一些清理工作。 `defer` 用在像其他语言中的 ensure 和 finally 用到的地方。


`defer.go`

```go
package main

import "fmt"
import "os"

// 假设我们想创建一个文件，然后写入数据，最后关闭文件
func main() {
	// 在使用createFile得到一个文件对象之后，我们使用defer
	// 来调用关闭文件的方法closeFile，这个方法将在main函数
	// 最后被执行，也就是writeFile完成之后
	//f := createFile("/tmp/defer.txt")
	// Windows下面使用这个语句
	f := createFile("D:\\Temp\\defer.txt")
	defer closeFile(f)
	writeFile(f)
}
func createFile(p string) *os.File {
	fmt.Println("creating")
	f, err := os.Create(p)
	if err != nil {
		panic(err)
	}
	return f
}
func writeFile(f *os.File) {
	fmt.Println("writing")
	fmt.Fprintln(f, "data")
}
func closeFile(f *os.File) {
	fmt.Println("closing")
	f.Close()
}

```

运行结果

```sh
creating
writing
closing
```

使用defer来调用closeFile函数可以保证在main函数结束之前，关闭文件的操作一定会被执行。


## Go 协程 Goroutines

Go 协程 (goroutine) 在执行上来说是轻量级的线程。

```go
package main

import "fmt"

func f(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
	}
}

func main() {

	// 假设我们有一个函数叫做 `f(s)`。一般会这样同步(synchronously)调用
	f("direct")

	// 使用 `go f(s)` 在一个 Go 协程中调用这个函数。
	// 这个新的 Go 协程将会并发(concurrently)执行这个函数。
	go f("goroutine")

	// 你也可以为匿名函数启动一个 Go 协程。
	go func(msg string) {
		fmt.Println(msg)
	}("going")

	// 现在这两个 Go 协程在独立的 Go 协程中异步(asynchronously)运行，所以
	// 程序直接运行到这一行。这里的 `Scanln` 代码需要我们
	// 在程序退出前按下任意键结束。
	fmt.Scanln()
	fmt.Println("done")
}
```

当我们运行这个程序时，将首先看到阻塞式调用的输出，然后是 两个 Go 协程的交替输出。这种交替的情况表示 Go 运行时是以 并发的方式运行协程的。

```sh
$ go run goroutines.go
direct : 0
direct : 1
direct : 2
goroutine : 0
going
goroutine : 1
goroutine : 2
<enter>
done
```


## Go 通道 Channels

通道 (Channels) 是连接多个 Go 协程的管道。你可以从一个 Go 协程 将值发送到通道，然后在别的 Go 协程中接收。

`channels.go`

```go
package main

import "fmt"

func main() {

	// 使用 `make(chan val-type)` 创建一个新的通道。
	// 通道类型就是他们需要传递值的类型。
	messages := make(chan string)

	// 使用 `channel <-` 语法 _发送(send)_ 一个新的值到通道中。这里 我们在一个新的 Go 协程中发送 `"ping"` 到上面创建的 `messages` 通道中。
	go func() { messages <- "ping" }()

	// 使用 `<-channel` 语法从通道中 _接收(receives)_ 一个值。这里 将接收我们在上面发送的 `"ping"` 消息并打印出来。
	msg := <-messages
	fmt.Println(msg)
}
```

我们运行程序时，通过通道，消息 "ping" 成功地从一个 Go 协程传到 另一个中。

```sh
$ go run channels.go
ping
```

默认发送和接收操作是阻塞的，直到发送方和接收方都准备完毕。

这个特性允许我们，不使用任何其它的同步操作，来在程序结尾等待 消息 "ping"。



## Go 通道缓冲 Buffering

默认情况下，通道是 无缓冲 的，这意味着只有对应的接收（<- chan） 通道准备好接收时，才允许进行发送（chan <-）。

可缓存通道 允许在没有对应接收方的情况下，缓存限定数量的值。

```go
package main

import "fmt"

func main() {

	// 这里我们创建了一个字符串通道，最多允许缓存 2 个值。
	messages := make(chan string, 2)

	// 由于此通道是缓冲的，因此我们可以将这些值发送到通道中
	// 而不需要相应的并发接收。
	messages <- "buffered"
	messages <- "channel"

	// 然后我们可以像前面一样接收这两个值。
	fmt.Println(<-messages)
	fmt.Println(<-messages)
}
```

运行：

```sh
$ go run channel-buffering.go 
buffered
channel
```

## GO 通道同步 Synchronization


我们可以使用通道来同步 Go 协程间的执行状态。这里是一个 使用阻塞的接受方式来等待一个 Go 协程的运行结束。

`channel-synchronization.go`

```go
package main

import "fmt"
import "time"

// 这是一个我们将要在 Go 协程中运行的函数。`done` 通道 将被用于通知其他 Go 协程这个函数已经工作完毕。
func worker(done chan bool) {
	fmt.Print("working...")
	time.Sleep(time.Second)
	fmt.Println("done")

	// 发送一个值来通知我们已经完工啦。
	done <- true
}

func main() {

	// 运行一个 worker Go协程，并给予用于通知的通道。
	done := make(chan bool, 1)
	go worker(done)

	// 程序将在接收到通道中 worker 发出的通知前一直阻塞。
	<-done
}
```



## Go JSON、YAML等格式解析

```go
package main

import (
	"encoding/json"
	"encoding/xml"
	"github.com/pelletier/go-toml"
	"gopkg.in/yaml.v2"
	"log"
)

type Student struct {
	Job  string `json:"job"`
	Name string `json:"name"`
	Sex  string `json:"sex"`
}

// parseJSON parses the given JSON data into a Student struct.
//
// It takes a byte array of JSON data as a parameter and returns a Student struct and an error.
func parseJSON(data []byte) (Student, error) {
	var student Student
	err := json.Unmarshal(data, &student)
	return student, err
}

func parseYAML(data []byte) (Student, error) {
	var student Student
	err := yaml.Unmarshal(data, &student)
	return student, err
}

// parseXML parses the XML data and returns a Student and an error.
//
// It takes a byte slice data as a parameter and returns a Student and an error.
func parseXML(data []byte) (Student, error) {
	var student Student
	err := xml.Unmarshal(data, &student)
	return student, err
}

// parseTOML parses the given data and returns a Student and an error.
//
// data []byte - the data to be parsed
// (Student, error) - the parsed Student and any parsing error
func parseTOML(data []byte) (Student, error) {
	var student Student
	tree, err := toml.Load(string(data))
	if err != nil {
		return student, err
	}
	err = tree.Unmarshal(&student)
	return student, err
}

func main() {
	// Example usage
	jsonData := []byte(`{"job": "Engineer", "name": "Alice", "sex": "female"}`)
	// YAML Example
	yamlData := []byte(`
job: Engineer
name: Alice
sex: female
`)
	// XML Example
	xmlData := []byte(`<Student><Job>Engineer</Job><Name>Alice</Name><Sex>female</Sex></Student>`)
	// TOML Example
	tomlData := []byte(`job = "Engineer"
name = "Alice"
sex = "female"`)

	// Parse JSON
	jsonStudent, err := parseJSON(jsonData)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("JSON Student:", jsonStudent) //2024/02/01 11:06:04 JSON Student: {Engineer Alice female}

	// Parse YAML
	yamlStudent, err := parseYAML(yamlData)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("YAML Student:", yamlStudent) //2024/02/01 11:15:47 YAML Student: {Engineer Alice female}

	// Parse XML
	xmlStudent, err := parseXML(xmlData)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("XML Student:", xmlStudent) //2024/02/01 11:06:04 XML Student: {Engineer Alice female}

	// Parse TOML
	tomlStudent, err := parseTOML(tomlData)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("TOML Student:", tomlStudent) //2024/02/01 11:16:41 TOML Student: {Engineer Alice female}
}
```


## Go JSON 解析


Go 提供内置的 JSON 编解码支持，包括内置或者自定义类 型与 JSON 数据之间的转化。

`json.go`

```go
package main

import "encoding/json"
import "fmt"
import "os"

// 我们使用两个结构体来演示自定义数据类型的JSON数据编码和解码。
type Response1 struct {
	Page   int
	Fruits []string
}
type Response2 struct {
	Page   int      `json:"page"`
	Fruits []string `json:"fruits"`
}

func main() {
	// 首先我们看一下将基础数据类型编码为JSON数据
	bolB, _ := json.Marshal(true)
	fmt.Println(string(bolB)) //true

	intB, _ := json.Marshal(1)
	fmt.Println(string(intB)) //1

	fltB, _ := json.Marshal(2.34)
	fmt.Println(string(fltB)) //2.34

	strB, _ := json.Marshal("gopher")
	fmt.Println(string(strB)) // "gopher"

	// 这里是将切片和字典编码为JSON数组或对象
	slcD := []string{"apple", "peach", "pear"}
	slcB, _ := json.Marshal(slcD)
	fmt.Println(string(slcB)) //["apple","peach","pear"]

	mapD := map[string]int{"apple": 5, "lettuce": 7}
	mapB, _ := json.Marshal(mapD)
	fmt.Println(string(mapB)) //{"apple":5,"lettuce":7}

	// JSON包可以自动地编码自定义数据类型。结果将只包括自定义
	// 类型中的可导出成员的值并且默认情况下，这些成员名称都作
	// 为JSON数据的键
	res1D := &Response1{
		Page:   1,
		Fruits: []string{"apple", "peach", "pear"}}
	res1B, _ := json.Marshal(res1D)
	fmt.Println(string(res1B)) //{"Page":1,"Fruits":["apple","peach","pear"]}

	// 你可以使用tag来自定义编码后JSON键的名称
	res2D := &Response2{
		Page:   1,
		Fruits: []string{"apple", "peach", "pear"}}
	res2B, _ := json.Marshal(res2D)
	fmt.Println(string(res2B)) //{"page":1,"fruits":["apple","peach","pear"]}

	// 现在我们看看解码JSON数据为Go数值
	byt := []byte(`{"num":6.13,"strs":["a","b"]}`)
	// 我们需要提供一个变量来存储解码后的JSON数据，这里
	// 的`map[string]interface{}`将以Key-Value的方式
	// 保存解码后的数据，Value可以为任意数据类型
	var dat map[string]interface{}
	// 解码过程，并检测相关可能存在的错误
	if err := json.Unmarshal(byt, &dat); err != nil {
		panic(err)
	}
	fmt.Println(dat) //map[num:6.13 strs:[a b]]

	// 为了使用解码后map里面的数据，我们需要将Value转换为
	// 它们合适的类型，例如我们将这里的num转换为期望的float64
	num := dat["num"].(float64)
	fmt.Println(num) //6.13

	// 访问嵌套的数据需要一些类型转换
	strs := dat["strs"].([]interface{})
	str1 := strs[0].(string)
	fmt.Println(str1) //a

	// 我们还可以将JSON解码为自定义数据类型，这有个好处是可以
	// 为我们的程序增加额外的类型安全并且不用再在访问数据的时候
	// 进行类型断言
	str := `{"page": 1, "fruits": ["apple", "peach"]}`
	res := &Response2{}
	json.Unmarshal([]byte(str), &res)
	fmt.Println(res)           //&{1 [apple peach]}
	fmt.Println(res.Fruits[0]) //apple

	// 上面的例子中，我们使用bytes和strings来进行原始数据和JSON数据
	// 之间的转换，我们也可以直接将JSON编码的数据流写入`os.Writer`
	// 或者是HTTP请求回复数据。
	enc := json.NewEncoder(os.Stdout)
	d := map[string]int{"apple": 5, "lettuce": 7}
	enc.Encode(d) //{"apple":5,"lettuce":7}
}
```


## Go XML 解析

Go 的 encoding.xml 包为 XML 和 类 - XML 格式提供了内建支持。

`xml.go`

```go
package main

import (
	"encoding/xml"
	"fmt"
)

// 该类型将被映射为 XML。
// 与 JSON 例子类似，字段 tag 包含了编码和解码的指令。
// 这里我们使用了 XML 包的一些特性：
// `XMLName` 字段名规定了 struct 的 XML 元素的名称；
// `id,attr` 意思是 `Id` 字段是一个 XML _attribute_，而不是嵌套元素。
type Plant struct {
	XMLName xml.Name `xml:"plant"`
	Id      int      `xml:"id,attr"`
	Name    string   `xml:"name"`
	Origin  []string `xml:"origin"`
}

func (p Plant) String() string {
	return fmt.Sprintf("Plant id=%v, name=%v, origin=%v",
		p.Id, p.Name, p.Origin)
}

func main() {
	coffee := &Plant{Id: 27, Name: "Coffee"}
	coffee.Origin = []string{"Ethiopia", "Brazil"}

	// 传入我们声明了 XML 的 plant 类型。
	// 使用 `MarshalIndent` 生成可读性更好的输出结果。
	out, _ := xml.MarshalIndent(coffee, " ", "  ")
	fmt.Println(string(out))

	// 明确的为输出结果添加一个通用的 XML 头部信息
	fmt.Println(xml.Header + string(out))

	// 使用 `Unmarshal` 将 XML 格式的字节流解析到 struct 内。
	// 如果 XML 格式不正确，或无法映射到 struct，将会返回一个描述性错误。
	var p Plant
	if err := xml.Unmarshal(out, &p); err != nil {
		panic(err)
	}
	fmt.Println(p)

	tomato := &Plant{Id: 81, Name: "Tomato"}
	tomato.Origin = []string{"Mexico", "California"}

	// `parent>child>plant` 字段标签告诉编码器嵌套 `<parent><child>...` 下面的所有 plant。
	type Nesting struct {
		XMLName xml.Name `xml:"nesting"`
		Plants  []*Plant `xml:"parent>child>plant"`
	}

	nesting := &Nesting{}
	nesting.Plants = []*Plant{coffee, tomato}

	out, _ = xml.MarshalIndent(nesting, " ", "  ")
	fmt.Println(string(out))
}
```


## Go 时间 Time

Go 对时间和时间段提供了大量的支持；这里是一些例子。

`time.go`

```go
package main

import "fmt"
import "time"

func main() {
	p := fmt.Println

	// 得到当前时间。
	now := time.Now()
	p(now) //2024-02-02 14:53:59.5996827 +0800 CST m=+0.002273101

	// 通过提供年月日等信息，你可以构建一个 `time`。
	// 时间总是关联着位置信息，例如时区。
	then := time.Date(
		2009, 11, 17, 20, 34, 58, 651387237, time.UTC)
	p(then) //2009-11-17 20:34:58.651387237 +0000 UTC

	// 你可以提取出时间的各个组成部分。
	p(then.Year())       //2009
	p(then.Month())      //November
	p(then.Day())        //17
	p(then.Hour())       //20
	p(then.Minute())     //34
	p(then.Second())     //58
	p(then.Nanosecond()) //651387237
	p(then.Location())   //UTC

	// 输出是星期一到日的 `Weekday` 也是支持的。
	p(then.Weekday()) //Tuesday

	// 这些方法来比较两个时间，分别测试一下是否是之前，之后或者是同一时刻，精确到秒。
	p(then.Before(now)) //true
	p(then.After(now))  //false
	p(then.Equal(now))  //false

	// 方法 `Sub` 返回一个 `Duration` 来表示两个时间点的间隔时间。
	diff := now.Sub(then)
	p(diff) //124546h19m0.948295463s

	// 我们计算出不同单位下的时间长度值。
	p(diff.Hours())       //124546.31693008207
	p(diff.Minutes())     //7.472779015804924e+06
	p(diff.Seconds())     //4.483667409482955e+08
	p(diff.Nanoseconds()) //448366740948295463

	// 你可以使用 `Add` 将时间后移一个时间间隔，
	// 或者使用一个 `-` 来将时间前移一个时间间隔。
	p(then.Add(diff)) //2024-02-02 06:53:59.5996827 +0000 UTC

	p(then.Add(-diff)) //1995-09-03 10:15:57.703091774 +0000 UTC
}
```

##  时间戳 Unix Epoch

一般程序会有获取 Unix 时间 的秒数、毫秒数、或者微秒数的需要。来看看如何用 Go 来实现。

`epoch.go`

```go
package main

import "fmt"
import "time"

func main() {

	// 分别使用带 `Unix` 或者 `UnixNano` 的 `time.Now`
	// 来获取从 Unix 纪元起到现在的秒数或者纳秒数。
	now := time.Now()
	secs := now.Unix()
	nanos := now.UnixNano()
	fmt.Println(now)

	// 注意 `UnixMillis` 是不存在的，所以要得到毫秒数的话，
	// 你要自己手动的从纳秒转化一下。
	millis := nanos / 1000000
	fmt.Println(secs)
	fmt.Println(millis)
	fmt.Println(nanos)

	// 你也可以将 Unix 纪元起的整数秒或者纳秒转化到相应的时间。
	fmt.Println(time.Unix(secs, 0))
	fmt.Println(time.Unix(0, nanos))
}

```

运行：
```sh
$ go run epoch.go 
2012-10-31 16:13:58.292387 +0000 UTC
1351700038
1351700038292
1351700038292387000
2012-10-31 16:13:58 +0000 UTC
2012-10-31 16:13:58.292387 +0000 UTC
```

## 时间的格式化和解析

Go 支持通过基于描述模板的时间格式化和解析。

`time-formatting-parsing.go`


```go
package main

import "fmt"
import "time"

func main() {
	p := fmt.Println

	// 这里是一个基本的按照 RFC3339 进行格式化的例子，使用对应模式常量。
	t := time.Now()
	p(t.Format(time.RFC3339)) //2024-02-02T15:00:58+08:00

	// 时间解析使用同 `Format` 相同的形式值。
	t1, e := time.Parse(
		time.RFC3339,
		"2012-11-01T22:08:41+00:00")
	p(t1) //2012-11-01 22:08:41 +0000 +0000

	// `Format` 和 `Parse` 使用基于例子的形式来决定日期格式，
	// 一般你只要使用 `time` 包中提供的模式常量就行了，但是你也可以实现自定义模式。
	// 模式必须使用时间 `Mon Jan 2 15:04:05 MST 2006` 来指定给定时间/字符串的格式化/解析方式。
	//时间一定要按照如下所示：2006为年，15 为小时，Monday 代表星期几，等等。
	p(t.Format("3:04PM"))                           //3:00PM
	p(t.Format("Mon Jan _2 15:04:05 2006"))         //Fri Feb  2 15:00:58 2024
	p(t.Format("2006-01-02T15:04:05.999999-07:00")) //2024-02-02T15:00:58.567745+08:00
	form := "3 04 PM"
	t2, e := time.Parse(form, "8 41 PM")
	p(t2) //0000-01-01 20:41:00 +0000 UTC

	// 对于纯数字表示的时间，你也可以使用标准的格式化字符串来提出时间值的组成。
	fmt.Printf("%d-%02d-%02dT%02d:%02d:%02d-00:00\n",
		t.Year(), t.Month(), t.Day(),
		t.Hour(), t.Minute(), t.Second()) //2024-02-02T15:00:58-00:00

	// `Parse` 函数在输入的时间格式不正确时会返回一个错误。
	ansic := "Mon Jan _2 15:04:05 2006"
	_, e = time.Parse(ansic, "8:41PM")
	p(e) //parsing time "8:41PM" as "Mon Jan _2 15:04:05 2006": cannot parse "8:41PM" as "Mon"
}
```


## Go 随机数 math/rand

Go 的 math/rand 包提供了伪随机数生成器（英）。

```go
package main

import "time"
import "fmt"
import "math/rand"

func main() {

	// 例如，`rand.Intn` 返回一个随机的整数 n，
	// `0 <= n <= 100`。
	fmt.Print(rand.Intn(100), ",")
	fmt.Print(rand.Intn(100))
	fmt.Println()

	// `rand.Float64` 返回一个64位浮点数 `f`，
	// `0.0 <= f <= 1.0`。
	fmt.Println(rand.Float64())

	// 这个技巧可以用来生成其他范围的随机浮点数，例如
	// `5.0 <= f <= 10.0`
	fmt.Print((rand.Float64()*5)+5, ",")
	fmt.Print((rand.Float64() * 5) + 5)
	fmt.Println()

	// 默认情况下，给定的种子是确定的，每次都会产生相同的随机数数字序列。
	// 要产生变化的序列，需要给定一个变化的种子。
	// 需要注意的是，如果你出于加密目的，需要使用随机数的话，请使用 `crypto/rand` 包，
	// 此方法不够安全。
	s1 := rand.NewSource(time.Now().UnixNano())
	r1 := rand.New(s1)

	// 调用上面返回的 `rand.Source` 的函数和调用 `rand` 包中函数是相同的。
	fmt.Print(r1.Intn(100), ",")
	fmt.Print(r1.Intn(100))
	fmt.Println()

	// 如果使用相同的种子生成的随机数生成器，将会产生相同的随机数序列。
	s2 := rand.NewSource(42)
	r2 := rand.New(s2)
	fmt.Print(r2.Intn(100), ",")
	fmt.Print(r2.Intn(100))
	fmt.Println()
	s3 := rand.NewSource(42)
	r3 := rand.New(s3)
	fmt.Print(r3.Intn(100), ",")
	fmt.Print(r3.Intn(100))
}
```

运行：

```sh
$ go run random-numbers.go
81,87
0.6645600532184904
7.123187485356329,8.434115364335547
0,28
5,87
5,87
```

参阅 math/rand 包 文档，提供了 Go 可以提供的其他随量的参考信息。



## 定时器 Timers

我们常常需要在后面一个时刻运行 Go 代码，或者在某段时间 间隔内重复运行。

Go 的内置 定时器 和 打点器 特性让这 些很容易实现。我们将先学习定时器，然后再学习打点器。

`timers.go`

```go
package main

import "time"
import "fmt"

func main() {

	// 定时器表示在未来某一时刻的独立事件。
	// 你告诉定时器需要等待的时间，然后它将提供一个用于通知的通道。
	// 这里的定时器将等待 2 秒。
	timer1 := time.NewTimer(time.Second * 2)

	// `<-timer1.C` 直到这个定时器的通道 `C` 明确的发送了
	// 定时器失效的值之前，将一直阻塞。
	<-timer1.C
	fmt.Println("Timer 1 expired")

	// 如果你需要的仅仅是单纯的等待，你需要使用 `time.Sleep`。
	// 定时器有用的原因之一就是你可以在定时器失效之前，取消这个定时器。
	timer2 := time.NewTimer(time.Second)
	go func() {
		<-timer2.C
		fmt.Println("Timer 2 expired")
	}()

	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}
}
```

第一个定时器将在程序开始后～2s 失效，但是第二个在它 没失效之前就停止了。

```sh
$ go run timers.go
Timer 1 expired
Timer 2 stopped
```


## 打点器 Tickers

定时器是当你想要在未来某一刻执行一次时 使用的 - 打点器 则是当你想要在固定的时间间隔重复执行 准备的。

这里是一个打点器的例子，它将定时的执行，直到我们将它停止。

`tickers.go`

```go
package main

import "time"
import "fmt"

func main() {

	// 打点器和定时器的机制有点相似：一个通道用来发送数据。
	// 这里我们在这个通道上使用内置的 `range` 来迭代值每隔
	// 500ms 发送一次的值。
	ticker := time.NewTicker(time.Millisecond * 500)
	go func() {
		for t := range ticker.C {
			fmt.Println("Tick at", t)
		}
	}()

	// 打点器可以和定时器一样被停止。
	// 一旦一个打点停止了，将不能再从它的通道中接收到值。
	// 我们将在运行后 1600ms 停止这个打点器。
	time.Sleep(time.Millisecond * 1600)
	ticker.Stop()
	fmt.Println("Ticker stopped")
}
```

当我们运行这个程序时，这个打点器会在我们停止它前打点 3 次。

```sh
$ go run tickers.go
Tick at 2012-09-23 11:29:56.487625 -0700 PDT
Tick at 2012-09-23 11:29:56.988063 -0700 PDT
Tick at 2012-09-23 11:29:57.488076 -0700 PDT
Ticker stopped
```




## Go 读文件

读写文件在很多程序中都是必须的基本任务。首先我们看看一 些读文件的例子。

`reading-files.go`

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
)

// check is a helper function to check for and handle errors.
func check(err error) {
	if err != nil {
		panic(err)
	}
}

// readFileAndPrint demonstrates various ways to read from a file and print its contents.
func readFileAndPrint() {
	// 也许大部分基本的文件读取任务是将文件内容读取到内存中
	dat, err := ioutil.ReadFile("dat")
	check(err)
	fmt.Print(string(dat))

	// 你经常会想对于一个文件是怎么读并且读取到哪一部分进行更多的控制。
	// 对于这个任务，从使用 `os.Open` 打开一个文件获取一个 `os.File` 值开始。
	f, err := os.Open("dat")
	check(err)

	// 从文件开始位置读取一些字节。
	// 这里最多读取 5 个字节，并且这也是我们实际读取的字节数。
	b1 := make([]byte, 5)
	n1, err := f.Read(b1)
	check(err)
	fmt.Printf("%d bytes: %s\n", n1, string(b1)) //5 bytes: hello

	// 你也可以 `Seek` 到一个文件中已知的位置并从这个位置开始进行读取。
	o2, err := f.Seek(6, 0)
	check(err)
	b2 := make([]byte, 2)
	n2, err := f.Read(b2)
	check(err)
	fmt.Printf("%d bytes @ %d: %s\n", n2, o2, string(b2)) //2 bytes @ 6: g

	// `io` 包提供了一些可以帮助我们进行文件读取的函数。 例如，上面的读取可以使用 `ReadAtLeast` 得到一个更健壮的实现。
	o3, err := f.Seek(6, 0)
	check(err)
	b3 := make([]byte, 2)
	n3, err := io.ReadAtLeast(f, b3, 2)
	check(err)
	fmt.Printf("%d bytes @ %d: %s\n", n3, o3, string(b3)) //2 bytes @ 6: g

	// Rewind to the beginning of the file.
	_, err = f.Seek(0, 0)
	check(err)

	// `bufio` 包实现了带缓冲的读取，这不仅对于很多小的读取操作能够提升性能，也提供了很多附加的读取函数。
	r4 := bufio.NewReader(f)
	b4, err := r4.Peek(5)
	check(err)
	fmt.Printf("5 bytes: %s\n", string(b4)) //5 bytes: hello

	// 任务结束后要关闭这个文件（通常这个操作应该在 `Open`
	// 操作后立即使用 `defer` 来完成）。
	f.Close()
}

func main() {
	// Get the current working directory.
	wd, err := os.Getwd()
	check(err)

	// Construct the file path relative to the current working directory.
	filePath := filepath.Join(wd, "internal\\Go-ReadFile")
	fmt.Println(filePath)

	// Set the file path as the current working directory.
	err = os.Chdir(filePath)
	check(err)

	readFileAndPrint()
}
```


运行结果如下：

```sh
$ echo "hello" > ./dat
$ echo "go" >>  ./dat

$ go run reading-files.go 
hello
go
5 bytes: hello
2 bytes @ 6: go
2 bytes @ 6: go
5 bytes: hello
```


Golang 超大文件读取的两个方案

https://learnku.com/articles/23559/two-schemes-for-reading-golang-super-large-files




## Go 写文件

Go将数据写入文件的方法和上面介绍过的读取文件的方法很类似。

`writing-files.go`

```go
package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}
func main() {
	// 首先看一下如何将一个字符串写入文件
	d1 := []byte("hello\ngo\n")
	err := ioutil.WriteFile("/tmp/dat1", d1, 0644)
	check(err)

	// 为了实现细颗粒度的写入，打开文件后再写入
	f, err := os.Create("/tmp/dat2")
	check(err)

	// 在打开文件后通常应该立刻使用defer来调用
	// 打开文件的Close方法，以保证main函数结束
	// 后，文件关闭
	defer f.Close()

	// 你可以写入字节切片
	d2 := []byte{115, 111, 109, 101, 10}
	n2, err := f.Write(d2)
	check(err)
	fmt.Printf("wrote %d bytes\n", n2) //wrote 5 bytes

	// 也可以使用`WriteString`直接写入字符串
	n3, err := f.WriteString("writes\n")
	fmt.Printf("wrote %d bytes\n", n3) //wrote 7 bytes

	// 调用Sync方法来将缓冲区数据写入磁盘
	f.Sync()
	// `bufio`除了提供上面的缓冲读取数据外，还
	// 提供了缓冲写入数据的方法
	w := bufio.NewWriter(f)
	n4, err := w.WriteString("buffered\n")
	fmt.Printf("wrote %d bytes\n", n4) //wrote 9 bytes

	// 使用Flush方法确保所有缓冲区的数据写入底层writer
	w.Flush()
}
```



## Go 行过滤器

Line Filters翻译一下大概是行数据过滤器。

简单一点就是一个程序从标准输入stdin读取数据，然后处理一下，将处理的结果输出到标准输出stdout。

grep和sed就是常见的行数据过滤器。

这里有一个行数据过滤器的例子，是把一个输入文本转换为大写的文本。

你可以使用这种方式来实现你自己的Go Line Filters。

`line-filters.go`

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func main() {
	// 使用缓冲scanner来包裹无缓冲的`os.Stdin`可以让我们
	// 方便地使用`Scan`方法，这个方法会将scanner定位到下
	// 一行的位置
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		// `Text`方法从输入中返回当前行
		ucl := strings.ToUpper(scanner.Text())
		// 输出转换为大写的行
		fmt.Println(ucl)
	}
	// 在`Scan`过程中，检查错误。文件结束不会被当作一个错误
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "error:", err)
		os.Exit(1)
	}
}

```

运行结果

```sh
hello world
HELLO WORLD
how are you
HOW ARE YOU
```


## Go 文件路径

filepath 包为 文件路径，提供了方便的跨操作系统的解析和构建函数； 比如：Linux 下的 dir/file 和 Windows 下的 dir.ile。

`file-paths.go`

```go
package main

import (
	"fmt"
	"path/filepath"
	"strings"
)

func main() {

	// 应使用 `Join` 来构建可移植(跨操作系统)的路径。
	// 它接收任意数量的参数，并参照传入顺序构造一个对应层次结构的路径。
	p := filepath.Join("dir1", "dir2", "filename")
	fmt.Println("p:", p) //p: dir1\dir2\filename

	// 您应该总是使用 `Join` 代替手动拼接 `/` 和 `\`。
	// 除了可移植性，`Join` 还会删除多余的分隔符和目录，使得路径更加规范。
	fmt.Println(filepath.Join("dir1//", "filename"))       //dir1\filename
	fmt.Println(filepath.Join("dir1/../dir1", "filename")) //dir1\filename

	// `Dir` 和 `Base` 可以被用于分割路径中的目录和文件。
	// 此外，`Split` 可以一次调用返回上面两个函数的结果。
	fmt.Println("Dir(p):", filepath.Dir(p))   //Dir(p): dir1\dir2
	fmt.Println("Base(p):", filepath.Base(p)) //Base(p): filename

	// 判断路径是否为绝对路径。
	fmt.Println(filepath.IsAbs("dir/file"))  // false
	fmt.Println(filepath.IsAbs("/dir/file")) // false

	filename := "config.json"

	// 某些文件名包含了扩展名（文件类型）。
	// 我们可以用 `Ext` 将扩展名分割出来。
	ext := filepath.Ext(filename)
	fmt.Println(ext) //.json

	// 想获取文件名清除扩展名后的值，请使用 `strings.TrimSuffix`。
	fmt.Println(strings.TrimSuffix(filename, ext)) //config

	// `Rel` 寻找 `basepath` 与 `targpath` 之间的相对路径。
	// 如果相对路径不存在，则返回错误。
	rel, err := filepath.Rel("a/b", "a/b/t/file")
	if err != nil {
		panic(err)
	}
	fmt.Println(rel) //t\file

	rel, err = filepath.Rel("a/b", "a/c/t/file")
	if err != nil {
		panic(err)
	}
	fmt.Println(rel) //..\c\t\file
}
```


## Go 文件目录

对于操作文件系统中的 目录，Go 提供了几个非常有用的函数。

`directories.go`

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
    "path/filepath"
)

func check(e error) {
    if e != nil {
        panic(e)
    }
}

func main() {

    // 在当前工作目录下，创建一个子目录。
    err := os.Mkdir("subdir", 0755)
    check(err)

    // 创建这个临时目录后，一个好习惯是：使用 `defer` 删除这个目录。
    // `os.RemoveAll` 会删除整个目录（类似于 `rm -rf`）。
    defer os.RemoveAll("subdir")

    // 创建一个用于创建临时文件的函数。
    createEmptyFile := func(name string) {
        d := []byte("")
        check(ioutil.WriteFile(name, d, 0644))
    }

    createEmptyFile("subdir/file1")

    // 我们还可以创建一个有层级的目录，使用 `MkdirAll` 函数，并包含其父目录。
    // 这个类似于命令 `mkdir -p`。
    err = os.MkdirAll("subdir/parent/child", 0755)
    check(err)

    createEmptyFile("subdir/parent/file2")
    createEmptyFile("subdir/parent/file3")
    createEmptyFile("subdir/parent/child/file4")

    // `ReadDir` 列出目录的内容，返回一个 `os.FileInfo` 类型的切片对象。
    c, err := ioutil.ReadDir("subdir/parent")
    check(err)

    fmt.Println("Listing subdir/parent")
    for _, entry := range c {
        fmt.Println(" ", entry.Name(), entry.IsDir())
    }

    // `Chdir` 可以修改当前工作目录，类似于 `cd`。
    err = os.Chdir("subdir/parent/child")
    check(err)

    // 当我们列出 *当前* 目录，就可以看到 `subdir/parent/child` 的内容了。
    c, err = ioutil.ReadDir(".")
    check(err)

    fmt.Println("Listing subdir/parent/child")
    for _, entry := range c {
        fmt.Println(" ", entry.Name(), entry.IsDir())
    }

    // `cd` 回到最开始的地方。
    err = os.Chdir("../../..")
    check(err)

    // 当然，我们也可以遍历一个目录及其所有子目录。
    // `Walk` 接受一个路径和回调函数，用于处理访问到的每个目录和文件。
    fmt.Println("Visiting subdir")
    err = filepath.Walk("subdir", visit)
}

// `filepath.Walk` 遍历访问到每一个目录和文件后，都会调用 `visit`。
func visit(p string, info os.FileInfo, err error) error {
    if err != nil {
        return err
    }
    fmt.Println(" ", p, info.IsDir())
    return nil
}
```

运行结果如下：

```sh
$ go run directories.go
Listing subdir/parent
  child true
  file2 false
  file3 false
Listing subdir/parent/child
  file4 false
Visiting subdir
  subdir true
  subdir/file1 false
  subdir/parent true
  subdir/parent/child true
  subdir/parent/child/file4 false
  subdir/parent/file2 false
  subdir/parent/file3 false
```


## Go 临时文件和目录

在程序运行时，我们经常创建一些运行时用到，程序结束后就不再使用的数据。

临时目录和文件 对于上面的情况很有用，因为它不会随着时间的推移而污染文件系统。

`temporary-files-and-directories.go`

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func main() {

	// 创建临时文件最简单的方法是调用 `ioutil.TempFile` 函数。
	// 它会创建并打开文件，我们可以对文件进行读写。
	// 函数的第一个参数传 `""`，`ioutil.TempFile` 会在操作系统的默认位置下创建该文件。
	//f, err := ioutil.TempFile("", "sample") check(err)
	f, err := os.CreateTemp("", "sample")
	check(err)

	// 打印临时文件的名称。
	// 文件名以 `ioutil.TempFile` 函数的第二个参数作为前缀，
	// 剩余的部分会自动生成，以确保并发调用时，生成不重复的文件名。
	// 在类 Unix 操作系统下，临时目录一般是 `/tmp`。
	fmt.Println("Temp file name:", f.Name()) //Temp file name: C:\Users\18793\AppData\Local\Temp\sample1407861477

	// defer 删除该文件。
	// 尽管操作系统会自动在某个时间清理临时文件，但手动清理是一个好习惯。
	defer os.Remove(f.Name())

	// 我们可以向文件写入一些数据。
	_, err = f.Write([]byte{1, 2, 3, 4})
	check(err)

	// 如果需要写入多个临时文件，最好是为其创建一个临时 *目录*。
	// `ioutil.TempDir` 的参数与 `TempFile` 相同，
	// 但是它返回的是一个 *目录名*，而不是一个打开的文件。
	//dname, err := ioutil.TempDir("", "sampledir")
	dname, err := os.MkdirTemp("", "sampledir")
	fmt.Println("Temp dir name:", dname) //Temp dir name: C:\Users\18793\AppData\Local\Temp\sampledir3918010941

	defer os.RemoveAll(dname)

	// 现在，我们可以通过拼接临时目录和临时文件合成完整的临时文件路径，并写入数据。
	fname := filepath.Join(dname, "file1")
	// err = ioutil.WriteFile(fname, []byte{1, 2}, 0666)
	err = os.WriteFile(fname, []byte{1, 2}, 0666)
	check(err)
}
```



## Go 测试

想要写出好的 Go 程序，单元测试是很重要的一部分。 testing 包为提供了编写单元测试所需的工具，写好单元测试后，我们可以通过 go test 命令运行测试。

为方便演示，例子的代码位于 main 包，实际上，单元测试的代码可以位于任何包下。 

测试代码通常与需要被测试的代码位于同一个包下。

`demo1/demo1.go`

```go
package demo1

// 我们要测试下面这个简单的函数——返回最小值。
// 一般地，需要被测试的代码应该在类似于 `intutils.go` 的文件下，
// 其对应的测试文件应该被命名为 `intutils_test.go`。
func IntMin(a, b int) int {
	if a < b {
		return a
	} else {
		return b
	}
}
```

`demo1/demo1_test.go`

```go
package demo1

import (
	"fmt"
	"testing"
)

// 通常编写一个名称以 `Test` 开头的函数来创建测试。
func TestIntMinBasic(t *testing.T) {
	ans := IntMin(2, -2)
	if ans != -2 {
		// `t.Error*` 会报告测试失败的信息，然后继续运行测试。
		// `t.Fail*` 会报告测试失败的信息，然后立即终止测试。
		t.Errorf("IntMin(2, -2) = %d; want -2", ans)
	}
}

// 单元测试可以重复，所以会经常使用 *表驱动* 风格编写单元测试，
// 表中列出了输入数据，预期输出，使用循环，遍历并执行测试逻辑。
func TestIntMinTableDriven(t *testing.T) {
	var tests = []struct {
		a, b int
		want int
	}{
		{0, 1, 0},
		{1, 0, 0},
		{2, -2, -2},
		{0, -1, -1},
		{-1, 0, -1},
	}

	for _, tt := range tests {
		// t.Run 可以运行一个 "subtests" 子测试，一个子测试对应表中一行数据。
		// 运行 `go test -v` 时，他们会分开显示。
		testname := fmt.Sprintf("%d,%d", tt.a, tt.b)
		t.Run(testname, func(t *testing.T) {
			ans := IntMin(tt.a, tt.b)
			if ans != tt.want {
				t.Errorf("got %d, want %d", ans, tt.want)
			}
		})
	}
}
```


使用 -v 参数查看详细信息：

```sh
$ go test -v
== RUN   TestIntMinBasic
--- PASS: TestIntMinBasic (0.00s)
=== RUN   TestIntMinTableDriven
=== RUN   TestIntMinTableDriven/0,1
=== RUN   TestIntMinTableDriven/1,0
=== RUN   TestIntMinTableDriven/2,-2
=== RUN   TestIntMinTableDriven/0,-1
=== RUN   TestIntMinTableDriven/-1,0
--- PASS: TestIntMinTableDriven (0.00s)
    --- PASS: TestIntMinTableDriven/0,1 (0.00s)
    --- PASS: TestIntMinTableDriven/1,0 (0.00s)
    --- PASS: TestIntMinTableDriven/2,-2 (0.00s)
    --- PASS: TestIntMinTableDriven/0,-1 (0.00s)
    --- PASS: TestIntMinTableDriven/-1,0 (0.00s)
PASS
ok      examples/testing    0.023s
```



## Go 数字解析

从字符串中解析数字在很多程序中是一个基础常见的任务，在 Go 中是这样处理的。

`number-parsing.go`

```go
package main

// 内置的 `strconv` 包提供了数字解析功能。
import "strconv"
import "fmt"

func main() {

	// 使用 `ParseFloat` 解析浮点数，这里的 `64` 表示解析的数的位数。
	f, _ := strconv.ParseFloat("1.234", 64)
	fmt.Println(f)

	// 在使用 `ParseInt` 解析整型数时，
	// 例子中的参数 `0` 表示自动推断字符串所表示的数字的进制。
	// `64` 表示返回的整型数是以 64 位存储的。
	i, _ := strconv.ParseInt("123", 0, 64)
	fmt.Println(i)

	// `ParseInt` 会自动识别出十六进制数。
	d, _ := strconv.ParseInt("0x1c8", 0, 64)
	fmt.Println(d)

	// `ParseUint` 也是可用的。
	u, _ := strconv.ParseUint("789", 0, 64)
	fmt.Println(u)

	// `Atoi` 是一个基础的 10 进制整型数转换函数。
	k, _ := strconv.Atoi("135")
	fmt.Println(k)

	// 在输入错误时，解析函数会返回一个错误。
	_, e := strconv.Atoi("wat")
	fmt.Println(e)
}

```


运行：

```sh
$ go run number-parsing.go 
1.234
123
456
789
135
strconv.ParseInt: parsing "wat": invalid syntax
```


## Go URL解析

URL提供了一种统一访问资源的方式。我们来看一下Go里面如何解析URL。

`url-parsing.go`

```go
package main

import "fmt"
import "net/url"
import "strings"

func main() {
	// 我们将解析这个URL，它包含了模式，验证信息，
	// 主机，端口，路径，查询参数和查询片段
	s := "postgres://user:pass@host.com:5432/path?k=v#f"
	// 解析URL，并保证没有错误
	u, err := url.Parse(s)
	if err != nil {
		panic(err)
	}
	// 可以直接访问解析后的模式
	fmt.Println(u.Scheme) //postgres

	// User包含了所有的验证信息，使用
	// Username和Password来获取单独的信息
	fmt.Println(u.User)            //user:pass
	fmt.Println(u.User.Username()) //user
	p, _ := u.User.Password()
	fmt.Println(p) //pass
	// Host包含了主机名和端口，如果需要可以
	// 手动分解主机名和端口
	fmt.Println(u.Host) //host.com:5432

	h := strings.Split(u.Host, ":")
	fmt.Println(h[0]) //host.com
	fmt.Println(h[1]) //5432

	// 这里我们解析出路径和`#`后面的片段
	fmt.Println(u.Path)     ///path
	fmt.Println(u.Fragment) //f

	// 为了得到`k=v`格式的查询参数，使用RawQuery。你可以将
	// 查询参数解析到一个map里面。这个map为字符串作为key，
	// 字符串切片作为value。
	fmt.Println(u.RawQuery) //k=v

	m, _ := url.ParseQuery(u.RawQuery)

	fmt.Println(m)         //map[k:[v]]
	fmt.Println(m["k"][0]) //v
}
```


## Go Base64编码

Go提供了对base64编码和解码的内置支持

`base64-encoding.go`

```go
package main

// 这种导入包的语法将默认的base64起了一个别名b64，这样
// 我们在下面就可以直接使用b64表示这个包，省点输入量
import b64 "encoding/base64"
import "fmt"

func main() {
	// 这里是我们用来演示编码和解码的字符串
	data := "abc123!?$*&()'-=@~"
	// Go支持标准的和兼容URL的base64编码。
	// 我们这里使用标准的base64编码，这个
	// 函数需要一个`[]byte`参数，所以将这
	// 个字符串转换为字节数组
	sEnc := b64.StdEncoding.EncodeToString([]byte(data))
	fmt.Println(sEnc)
	// 解码一个base64编码可能返回一个错误，
	// 如果你不知道输入是否是正确的base64
	// 编码，你需要检测一些解码错误
	sDec, _ := b64.StdEncoding.DecodeString(sEnc)
	fmt.Println(string(sDec))
	fmt.Println()
	// 使用兼容URL的base64编码和解码
	uEnc := b64.URLEncoding.EncodeToString([]byte(data))
	fmt.Println(uEnc)
	uDec, _ := b64.URLEncoding.DecodeString(uEnc)
	fmt.Println(string(uDec))
}

/*
类似于如下shell代码：
echo -n "your_data" | base64

要对Base64编码后的数据进行解码，可以使用以下命令：
echo -n "base64_encoded_data" | base64 -d
*/
```

运行结果

```sh
YWJjMTIzIT8kKiYoKSctPUB+
abc123!?$*&()'-=@~
YWJjMTIzIT8kKiYoKSctPUB-
abc123!?$*&()'-=@~
```

这两种方法都将原数据编码为base64编码，区别在于标准的编码后面是+，而兼容URL的编码方式后面是-。



## Go SHA1 散列

SHA1散列经常用来计算二进制或者大文本数据的短标识值。git版本控制系统用SHA1来标识受版本控制的文件和目录。

这里介绍Go中如何计算SHA1散列值。

`sha1-hashes.go`

Go 在 `crypto/*` 包里面实现了几个常用的散列函数。

```go
package main

import "crypto/sha1"
import "fmt"

func main() {
	s := "sha1 this string"
	// 生成一个hash的模式是`sha1.New()`，`sha1.Write(bytes)`
	// 然后是`sha1.Sum([]byte{})`，下面我们开始一个新的hash
	// 示例
	h := sha1.New()
	// 写入要hash的字节，如果你的参数是字符串，使用`[]byte(s)`
	// 把它强制转换为字节数组
	h.Write([]byte(s))
	// 这里计算最终的hash值，Sum的参数是用来追加而外的字节到要
	// 计算的hash字节里面，一般来讲，如果上面已经把需要hash的
	// 字节都写入了，这里就设为nil就可以了
	bs := h.Sum(nil)

	// SHA1散列值经常以16进制的方式输出，例如git commit就是
	// 这样，所以可以使用`%x`来将散列结果格式化为16进制的字符串
	fmt.Println(s)         //sha1 this string
	fmt.Printf("%x\n", bs) //cf23df2207d99a74fbe169e3eba035e633b65d94
}
```



## Go String与Byte切片之间的转换

String转换到Byte数组时，每个byte(byte类型其实就是uint8)保存字符串对应字节的数值。

注意Go的字符串是UTF-8编码的，每个字符长度是不确定的，一些字符可能是1、2、3或者4个字节结尾。

示例1：

```go
package main

import "fmt"

func main() {
	s1 := "abcd"
	b1 := []byte(s1)
	fmt.Println(b1) // [97 98 99 100]

	s2 := "中文"
	b2 := []byte(s2)
	fmt.Println(b2) // [228 184 173 230 150 135], unicode，每个中文字符会由三个byte组成

	r1 := []rune(s1)
	fmt.Println(r1) // [97 98 99 100], 每个字一个数值

	r2 := []rune(s2)
	fmt.Println(r2) // [20013 25991], 每个字一个数值
}

```





输出结果为

```sh
write 2 as two
it's a weekday
it's before noon
```



## Go 排序 Sorting

Go 的 sort 包实现了内置和用户自定义数据类型的排序 功能。我们首先关注内置数据类型的排序。


```go
package main

import "fmt"
import "sort"

func main() {

	// 排序方法是针对内置数据类型的；
	// 这里是一个字符串的例子。
	// 注意排序是原地更新的，所以他会改变给定的序列并且不返回一个新值。
	strs := []string{"c", "a", "b"}
	sort.Strings(strs)
	fmt.Println("Strings:", strs)

	// 一个 `int` 排序的例子。
	ints := []int{7, 2, 4}
	sort.Ints(ints)
	fmt.Println("Ints:   ", ints)

	// 我们也可以使用 `sort` 来检查一个序列是不是已经是排好序的。
	s := sort.IntsAreSorted(ints)
	fmt.Println("Sorted: ", s)
}

```

运行程序，打印排序好的字符串和整型序列以及我们 AreSorted 测试的结果 true。

```sh
$ go run sorting.go
Strings: [a b c]
Ints:    [2 4 7]
Sorted:  true
```


## Go 使用函数自定义排序


有时候我们想使用和集合的自然排序不同的方法对集合进行排序。 

例如，我们想按照字母的长度而不是首字母顺序对字符串排序。 这里是一个 Go 自定义排序的例子。

`sorting-by-functions.go`

```go
package main

import "sort"
import "fmt"

// 为了在 Go 中使用自定义函数进行排序，我们需要一个对应的类型。
// 这里我们创建一个为内置 `[]string` 类型的别名的 `ByLength` 类型。
type ByLength []string

// 我们在类型中实现了 `sort.Interface` 的 `Len`，`Less` 和 `Swap` 方法，
// 这样我们就可以使用 `sort` 包的通用 `Sort` 方法了，
// `Len` 和 `Swap` 通常在各个类型中都差不多，`Less` 将控制实际的自定义排序逻辑。
// 在我们的例子中，我们想按字符串长度增加的顺序来排序，
// 所以这里使用了 `len(s[i])` 和 `len(s[j])`
func (s ByLength) Len() int {
	return len(s)
}
func (s ByLength) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}
func (s ByLength) Less(i, j int) bool {
	return len(s[i]) < len(s[j])
}

// 一切都准备好了，我们现在可以通过将原始的 `fruits` 切片转型成 `ByLength` 来实现我们的自定排序了。
// 然后对这个转型的切片使用 `sort.Sort` 方法。
func main() {
	fruits := []string{"peach", "banana", "kiwi"}
	sort.Sort(ByLength(fruits))
	fmt.Println(fruits) //[kiwi peach banana]
}
```

运行这个程序，和预期的一样，显示了一个按照字符串 长度排序的列表。

```sh
$ go run sorting-by-functions.go 
[kiwi peach banana]
```

类似的，参照这个创建一个自定义类型的方法，实现这个类型的 这三个接口方法，然后在一个这个自定义类型的集合上调用 `sort.Sort` 方法，我们就可以使用任意的函数来排序 Go 切片了。




## Go 命令行参数 Arguments


命令行参数 是指定程序运行参数的一个常见方式。

例如：`go run hello.go`， 程序 go 使用了 run 和 hello.go 两个参数。


```go
package main

import (
	"fmt"
	"os"
)

func main() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Fprintln(os.Stderr, "An error occurred:", r)
		}
	}()
	if len(os.Args) < 4 {
		fmt.Printf("Usage: %s <arg1> <arg2> <arg3> ...\n", os.Args[0])
		return
	}
	// `os.Args` 提供原始命令行参数访问功能。
	// 注意，切片中的第一个参数是该程序的路径，
	// 并且 `os.Args[1:]` 保存程序的所有参数。
	argsWithProg := os.Args
	argsWithoutProg := os.Args[1:]

	// 你可以使用标准的索引位置方式取得单个参数的值。
	arg := os.Args[3]

	// Print the program's arguments.
	fmt.Println(argsWithProg)
	fmt.Println(argsWithoutProg)
	fmt.Println(arg)
}
```


## Go 命令行标志 Flags

命令行标志 是命令行程序指定选项的常用方式。例如，在 wc -l 中， 这个 -l 就是一个命令行标志。

```go
package main

// Go 提供了一个 `flag` 包，支持基本的命令行标志解析。
// 我们将用这个包来实现我们的命令行程序示例。
import "flag"
import "fmt"

func main() {

	// 基本的标记声明仅支持字符串、整数和布尔值选项。
	// 这里我们声明一个默认值为 `"foo"` 的字符串标志 `word`
	// 并带有一个简短的描述。这里的 `flag.String` 函数返回一个字
	// 符串指针（不是一个字符串值），在下面我们会看到是如何
	// 使用这个指针的。
	wordPtr := flag.String("word", "foo", "a string")

	// 使用和声明 `word` 标志相同的方法来声明 `numb` 和 `fork` 标志。
	numbPtr := flag.Int("numb", 42, "an int")
	boolPtr := flag.Bool("fork", false, "a bool")

	// 用程序中已有的参数来声明一个标志也是可以的。注
	// 意在标志声明函数中需要使用该参数的指针。
	var svar string
	flag.StringVar(&svar, "svar", "bar", "a string var")

	// 所有标志都声明完成以后，调用 `flag.Parse()` 来执行
	// 命令行解析。
	flag.Parse()

	// 这里我们将仅输出解析的选项以及后面的位置参数。注意，
	// 我们需要使用类似 `*wordPtr` 这样的语法来对指针解引用，从而
	// 得到选项的实际值。
	fmt.Println("word:", *wordPtr)
	fmt.Println("numb:", *numbPtr)
	fmt.Println("fork:", *boolPtr)
	fmt.Println("svar:", svar)
	fmt.Println("tail:", flag.Args())
}
```


测试这个程序前，最好将这个程序编译成二进制文件，然后再运 行这个程序。
```sh
$ go build command-line-flags.go
$ .\command-line-flags
word: foo
numb: 42
fork: false
svar: bar
tail: []
```

注意到，如果你省略一个标志，那么这个标志的值自动的设 定为他的默认值。

```sh
$ ./command-line-flags -word=opt
word: opt
numb: 42
fork: false
svar: bar
tail: []
```

尾随的位置参数可以出现在任何标志后面。
```sh
$ ./command-line-flags -word=opt a1 a2 a3
word: opt
numb: 42
fork: false
svar: bar
tail: [a1 a2 a3]
```

注意，flag 包需要所有的标志出现位置参数之前（ 否则，这个标志将会被解析为位置参数）。

```sh
$ ./command-line-flags -word=opt a1 a2 a3 -numb=7
word: opt
numb: 42
fork: false
svar: bar
trailing: [a1 a2 a3 -numb=7]

$ ./command-line-flags -word=opt -numb=7 a1 a2 a3
word: opt
numb: 7
fork: false
svar: bar
tail: [a1 a2 a3]
```


使用 -h 或者 --help 标志来得到自动生成的这个命 令行程序的帮助文本。
```sh
$ ./command-line-flags -h
Usage of ./command-line-flags:
  -fork=false: a bool
  -numb=42: an int
  -svar="bar": a string var
  -word="foo": a string
```

如果你提供一个没有使用 flag 包指定的标志，程序会输出一 个错误信息，并再次显示帮助文本。
```sh
$ ./command-line-flags -wat
flag provided but not defined: -wat
Usage of ./command-line-flags:
# ...
```


我们可以使用环境变量，用于参数化程序的基本方式，如下。

```go
package main

// Go 提供了一个 `flag` 包，支持基本的命令行标志解析。
// 我们将用这个包来实现我们的命令行程序示例。
import (
	"flag"
	"os"
	"strconv"
)
import "fmt"

func main() {
	numbStr := os.Getenv("numb")
	if numbStr == "" {
		numbStr = "0" // 设置一个默认值
	}
	numb, err := strconv.Atoi(numbStr)
	if err != nil {
		// 处理转换失败的情况
		panic(err)
	}
	// 基本的标记声明仅支持字符串、整数和布尔值选项。
	// 这里我们声明一个默认值为 `"foo"` 的字符串标志 `word`
	// 并带有一个简短的描述。这里的 `flag.String` 函数返回一个字
	// 符串指针（不是一个字符串值），在下面我们会看到是如何
	// 使用这个指针的。
	wordPtr := flag.String("word", "foo", "a string")

	// 使用和声明 `word` 标志相同的方法来声明 `numb` 和 `fork` 标志。
	numbPtr := flag.Int("numb", numb, "an int")
  // ......
```

```sh
$ numb=1994 ./command-line-flags
word: foo
numb: 1994
fork: false
svar: bar
tail: []
```


## Go 命令行子命令 Subcommands

go 和 git 这种命令行工具，都有很多的 子命令。 并且每个工具都有一套自己的 flag，比如： go build 和 go get 是 go 里面的两个不同的子命令。 


flag 包让我们可以轻松的为工具定义简单的子命令。


`command-line-subcommands.go`


```go
package main

import (
	"flag"
	"fmt"
	"os"
)

func main() {

	// 我们使用 `NewFlagSet` 函数声明一个子命令，
	// 然后为这个子命令定义一个专用的 flag。
	fooCmd := flag.NewFlagSet("foo", flag.ExitOnError)
	fooEnable := fooCmd.Bool("enable", false, "enable")
	fooName := fooCmd.String("name", "", "name")

	// 对于不同的子命令，我们可以定义不同的 flag。
	barCmd := flag.NewFlagSet("bar", flag.ExitOnError)
	barLevel := barCmd.Int("level", 0, "level")

	// 期望前面定义的子命令作为第一个参数传入。
	if len(os.Args) < 2 {
		fmt.Printf("usage: %s foo|bar\n", os.Args[0])
		os.Exit(1)
	}

	// 检查哪一个子命令被调用了。
	switch os.Args[1] {

	// 每个子命令，都会解析自己的 flag 并允许它访问后续的参数。
	case "foo":
		fooCmd.Parse(os.Args[2:])
		fmt.Println("subcommand 'foo'")
		fmt.Println("  enable:", *fooEnable)
		fmt.Println("  name:", *fooName)
		fmt.Println("  tail:", fooCmd.Args())
	case "bar":
		barCmd.Parse(os.Args[2:])
		fmt.Println("subcommand 'bar'")
		fmt.Println("  level:", *barLevel)
		fmt.Println("  tail:", barCmd.Args())
	default:
		fmt.Println("expected 'foo' or 'bar' subcommands")
		os.Exit(1)
	}
}
```


```sh
root@gdc-ci-base:/tmp# go build command-line-subcommands.go

root@gdc-ci-base:/tmp# ./command-line-subcommands foo -enable -name=joe a1 a2
subcommand 'foo'
  enable: true
  name: joe
  tail: [a1 a2]


root@gdc-ci-base:/tmp# ./command-line-subcommands bar -level 8 a1
subcommand 'bar'
  level: 8
  tail: [a1]


root@gdc-ci-base:/tmp# ./command-line-subcommands bar -enable a1
flag provided but not defined: -enable
Usage of bar:
  -level int
        level
```





## Go 环境变量

环境变量是一种很普遍的将配置信息传递给Unix程序的机制。

```go
package main

import "os"
import "strings"
import "fmt"

func main() {
	// 为了设置一个key/value对，使用`os.Setenv`
	// 为了获取一个key的value，使用`os.Getenv`
	// 如果所提供的key在环境变量中没有对应的value，
	// 那么返回空字符串
	os.Setenv("FOO", "1")
	err := os.Setenv("FOO", "2")
	if err != nil {
		fmt.Println("设置环境变量出错:", err)
		return
	}
	fmt.Println("FOO:", os.Getenv("FOO")) //FOO: 2
	fmt.Println("BAR:", os.Getenv("BAR")) //BAR:

	// 删除环境变量
	err = os.Unsetenv("FOO")
	if err != nil {
		fmt.Println("删除环境变量出错:", err)
		return
	}

	// 验证是否删除成功
	value := os.Getenv("FOO")
	if value == "" {
		fmt.Println("环境变量已成功删除") //环境变量已成功删除
	} else {
		fmt.Println("环境变量删除失败")
	}

	// 使用`os.Environ`来列出环境变量中所有的key/value对
	// 你可以使用`strings.Split`方法来将key和value分开
	// 这里我们打印所有的key
	fmt.Println()
	for _, e := range os.Environ() {
		pair := strings.Split(e, "=")
		fmt.Println(pair[0])
	}
}
```

如果我们在运行前设置了 BAR 的值，那么运行程序将会获取到这个值。

```sh
$ BAR=2 go run environment-variables.go
FOO: 1
BAR: 2
# ...
```


## HTTP 服务器

使用 net/http 包，我们可以轻松实现一个简单的 HTTP 服务器。

`http-servers.go`

```go
package main

import (
	"fmt"
	"net/http"
)

// *handlers* 是 `net/http` 服务器里面的一个基本概念。
// handler 对象实现了 `http.Handler` 接口。
// 编写 handler 的常见方法是，在具有适当签名的函数上使用 `http.HandlerFunc` 适配。
func hello(w http.ResponseWriter, req *http.Request) {

	// handler 函数有两个参数，`http.ResponseWriter` 和 `http.Request`。
	// response writer 被用于写入 HTTP 响应数据，这里我们简单的返回 "hello\n"。
	fmt.Fprintf(w, "hello\n")
}

func headers(w http.ResponseWriter, req *http.Request) {

	// 这个 handler 稍微复杂一点，
	// 我们需要读取的 HTTP 请求 header 中的所有内容，并将他们输出至 response body。
	for name, headers := range req.Header {
		for _, h := range headers {
			fmt.Fprintf(w, "%v: %v\n", name, h)
		}
	}
}

func main() {

	// 使用 `http.HandleFunc` 函数，可以方便的将我们的 handler 注册到服务器路由。
	// 它是 `net/http` 包中的默认路由，接受一个函数作为参数。
	http.HandleFunc("/hello", hello)
	http.HandleFunc("/headers", headers)

	// 最后，我们用端口和处理程序调用 `ListenAndServe`。`nil` 告诉它使用我们刚刚设置的默认路由器。
	http.ListenAndServe(":8090", nil)
}
```

后台运行服务器。

```sh
$ go run http-servers.go &
```

访问 /hello 路由。
```sh
$ curl localhost:8090/hello
hello
```


## HTTP 客户端

Go 标准库的 net/http 包为 HTTP 客户端和服务端提供了出色的支持。 在这个例子中，我们将使用它发送简单的 HTTP 请求。


```go
package main

import (
	"bufio"
	"fmt"
	"net/http"
)

func main() {

	// 向服务端发送一个 HTTP GET 请求。
	// `http.Get` 是创建 `http.Client` 对象并调用其 `Get` 方法的快捷方式。
	// 它使用了 `http.DefaultClient` 对象及其默认设置。
	resp, err := http.Get("http://gobyexample.com")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	// 打印 HTTP response 状态.
	fmt.Println("Response status:", resp.Status)

	// 打印 response body 前面 5 行的内容。
	scanner := bufio.NewScanner(resp.Body)
	for i := 0; scanner.Scan() && i < 5; i++ {
		fmt.Println(scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		panic(err)
	}
}
```

## Go 生成进程

有时，我们的 Go 程序需要生成其他的，非 Go 进程。例如，这个 网站的语法高亮是通过在 Go 程序中生成一个 pygmentize 来实现的。 让我们看一些关于 Go 生成进程的例子。

`spawning-processes.go`

```go
package main

import "fmt"
import "io/ioutil"
import "os/exec"

func main() {

	// 我们将从一个简单的命令开始，没有参数或者输入，仅打印
	// 一些信息到标准输出流。`exec.Command` 函数帮助我们创
	// 建一个表示这个外部进程的对象。
	dateCmd := exec.Command("date")

	// `.Output` 是另一个帮助我们处理运行一个命令的常见情况
	// 的函数，它等待命令运行完成，并收集命令的输出。如果没
	// 有出错，`dateOut` 将获取到日期信息的字节。
	dateOut, err := dateCmd.Output()
	if err != nil {
		panic(err)
	}
	fmt.Println("> date")
	fmt.Println(string(dateOut))

	// 下面我们将看看一个稍复杂的例子，我们将从外部进程的
	// `stdin` 输入数据并从 `stdout` 收集结果。
	grepCmd := exec.Command("grep", "hello")

	// 这里我们明确的获取输入/输出管道，运行这个进程，写入
	// 一些输入信息，读取输出的结果，最后等待程序运行结束。
	grepIn, _ := grepCmd.StdinPipe()
	grepOut, _ := grepCmd.StdoutPipe()
	grepCmd.Start()
	grepIn.Write([]byte("hello grep\ngoodbye grep"))
	grepIn.Close()
	grepBytes, _ := ioutil.ReadAll(grepOut)
	grepCmd.Wait()

	// 上面的例子中，我们忽略了错误检测，但是你可以使用
	// `if err != nil` 的方式来进行错误检查，我们也只收集
	// `StdoutPipe` 的结果，但是你可以使用相同的方法收集
	// `StderrPipe` 的结果。
	fmt.Println("> grep hello")
	fmt.Println(string(grepBytes))

	// 注意，在生成命令时，我们需要提供显式描述的命令和参数
	// 数组，而不能只传递一个命令行字符串。如果你想使用一个
	// 字符串生成一个完整的命令，那么你可以使用 `bash` 命令
	// 的 `-c` 选项：
	lsCmd := exec.Command("bash", "-c", "ls -a -l -h")
	lsOut, err := lsCmd.Output()
	if err != nil {
		panic(err)
	}
	fmt.Println("> ls -a -l -h")
	fmt.Println(string(lsOut))
}
```



## Go 执行进程

在前面的例子中，我们了解了生成外部进程的知识，当我们需要访问外部进程时需要这样做，但是有时候，我们只想用其他的（也许是非 Go 程序）来完全替代当前的 Go 进程。

这时候，我们 可以使用经典的 exec 方法的 Go 实现。

`execing-processes.go`

```go
package main

import "syscall"
import "os"
import "os/exec"

func main() {

	// 在我们的例子中，我们将执行 `ls` 命令。Go 需要提供我们需要执行的可执行文件的绝对路径，所以我们将使用 `exec.LookPath` 来得到它（大概是 `/bin/ls`）。
	binary, err := exec.LookPath("ls")
	if err != nil {
		panic(err)
	}

	// `Exec` 需要的参数是切片的形式的（不是放在一起的一个大字 符串）。我们给 `ls` 一些基本的参数。注意，第一个参数需要是程序名。
	args := []string{"ls", "-a", "-l", "-h"}

	env := os.Environ()

	// 这里是 `syscall.Exec` 调用。如果这个调用成功，那么我们的 进程将在这里被替换成 `/bin/ls -a -l -h` 进程。如果存 在错误，那么我们将会得到一个返回值。
	execErr := syscall.Exec(binary, args, env)
	if execErr != nil {
		panic(execErr)
	}
}
```

当我们运行程序时，它会替换为 ls。
```sh
$ go run execing-processes.go
total 16
drwxr-xr-x  4 mark 136B Oct 3 16:29 .
drwxr-xr-x 91 mark 3.0K Oct 3 12:50 ..
-rw-r--r--  1 mark 1.3K Oct 3 16:28 execing-processes.go
```

注意 Go 并不提供一个经典的 Unix fork 函数。通常这不 是个问题，因为运行 Go 协程，生成进程和执行进程覆盖了 fork 的大多数使用场景。







## Go 常用包

[Go 常用包](https://www.lynote.top/2022/10/24/golang/go_%E5%B8%B8%E7%94%A8%E5%8C%85/go_%E5%B8%B8%E7%94%A8%E5%8C%85)






## Go语言学习目录

[Go语言学习目录](https://blog.51cto.com/devwanghui/2508878)


