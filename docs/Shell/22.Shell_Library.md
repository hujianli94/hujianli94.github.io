# 22.Shell_Library

## 脚本编写注意事项

1）开头加解释器：`#!/bin/bash`

2）语法缩进，使用四个空格；多加注释说明。

3）命名建议规则：变量名大写、局部变量小写，函数名小写，名字体现出实际作用。

4）默认变量是全局的，在函数中变量 `local` 指定为局部变量，避免污染其他作用域。

5）有两个命令能帮助我调试脚本：`set -e` 遇到执行非 0 时退出脚本，`set -x` 和 `set +x` 打印执行过程。

```sh
# set -x 和 set +x 常用于调试函数。

set -x
function(){
  :
}
set +x
```

6）写脚本一定先测试再到生产上。

```sh
# set 的一些用法：
    shopt -s -o nounset     # 强调变量必须先声明才能使用

    set x y z               # 将x,y,z的值赋予位置参数1,2,3

    # 把 set -u 或 set -o nounset 插入到脚本中, 并运行它, 就会在每个试图使用未声明变量的地方给出一个unbound variable错误信息.
    # set -e     # 遇到执行非 0 时退出脚本，set -x 打印执行过程

    set -o pipefail #在这个设置执行后，其后面的代码，包括管道命令的返回值，为最后一个非零的命令的返回值，或者当管道内的所有命令都执行成功后返回零。

    set -o nounset      # 未声明变量就报错，强制退出
    set +o nounset      # set -/+u,简写

    set -o errexit      # 脚本只要发生错误，执行出现非0的结果,当脚本发生第一个错误时退出脚本
    set +o errexit      # set -/+e,简写

    set -o xtrace       # 表示跟踪脚本的执行过程，有利于调试,运行结果之前，先输出执行的那一行命令,比set -v更加完整详细
    set +o xtrace       # set -/+x,简写

    set -o noclobber    # 防止文件覆盖，文件存在就报错，不存在就正常创建
    set +o noclobber    # set -/+C,简写

    set -o allexport    # export 所有已定于的变量
    set +o allexport    # set -/+a,简写

    set -o noexec       # 读取脚本命令，不执行，进行语法检查
    set +o noexec       # set -/+n,简写

    set -o verbose      # 执行一个命令前打印出这个命令
    set +o verbose      # set -/+v,简写



    set -x
    # uname -a
    # ......
    set +x              #调试某一个区域  打印执行过程,用于调试函数居多
```

脚本开头执行时，执行如下命令， 在执行过程中若遇到使用了未定义的变量或命令返回值为非零，将直接报错退出：

```sh
# 任何命令执行失败即退出、未初始化变量时引发错误。
set -eu

# 管道中最弱的命令导致整个管道失败。这些设置增强脚本的健壮性。
set -euo pipefail
```

## shell 模板

```sh
#!/bin/env bash
###################################################################
#Script Name    :
#Description    :
#Args           :
#Update Date    :
#Author           : lework
#Email             : lework@yeah.net
###################################################################

set -o errexit          # Exit on most errors (see the manual)
set -o errtrace         # Make sure any error trap is inherited
set -o nounset          # Disallow expansion of unset variables
set -o pipefail         # Use last non-zero exit code in a pipeline


TAG="CMD"
LOG_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/logs"
LOG_FILE="$LOG_PATH/example_`date +"%Y%m%d"`.log"
HIDE_LOG=true

function log() {
    [ ! -d "$LOG_PATH" ] && mkdir -p $LOG_PATH
    if [ $HIDE_LOG ]; then
        echo -e "[`date +"%Y/%m/%d:%H:%M:%S %z"`] [`whoami`] [$TAG] $@" >> $LOG_FILE
    else
        echo "[`date +"%Y/%m/%d:%H:%M:%S %z"`] [`whoami`] [$TAG] $@" | tee -a $LOG_FILE
    fi
}

function script_trap_err() {
    local exit_code=1

    # Disable the error trap handler to prevent potential recursion
    trap - ERR

    # Consider any further errors non-fatal to ensure we run to completion
    set +o errexit
    set +o pipefail

    log "[E] ERROR"

    exit "$exit_code"
}

function script_trap_exit() {
    log "[I] shell exec done."
}

function main() {
    trap script_trap_err ERR
    trap script_trap_exit EXIT

    log "[I] shell start"

}

main "${@}"
```

## Docker

### Docker 容器

```sh
# $1: container name
func_docker_destroy_container(){
    local exist=`docker ps -a |awk '{print $NF}'|grep $1`
    if [[ $exist == "" ]];then
        return 0
    fi
    docker kill $1 >/dev/null 2>&1
    if [[ $(docker version --format '{{.Server.Version}}') = 17.06.0* ]]; then
        # Workaround https://github.com/moby/moby/issues/33948.
        # TODO: remove when 17.06.0 is not relevant anymore
        DOCKER_API_VERSION=v1.29 docker wait "$1" >/dev/null 2>&1 || true
    else
        docker wait "$1" >/dev/null 2>&1 || true
    fi
    docker rm -f -v "$1" >/dev/null 2>&1 || true
}

#$1: imagename:tag
#ret: 0 exist, 1 not exist
func_docker_image_exist(){
    local ret=`docker images $1  |wc |awk '{ print $1 }'`
    if [[ $ret == "2" ]];then
        return 0
    fi
    return 1
}

#$1: imagename:tag
func_docker_destroy_image(){
    func_docker_image_exist $1
    if [[ $? == "0" ]];then
        docker rmi $1
    fi
}
```

### 通过代理下载谷歌 Docker 容器

```sh
#!/bin/env bash
#
# lework
# Download Google container image from proxy point.


######################################################################################################
# environment configuration
######################################################################################################

RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
GREEN_PS3=$'\e[0;32m'
ORANGE_PS3=$'\e[0;33m'
WHITE='\033[0;37m'

proxy=(
  "gcr.azk8s.cn/google_containers"
  "registry.aliyuncs.com/google_containers"
  "gcrxio"
)
images=(
  "k8s.gcr.io/kube-apiserver:"
  "k8s.gcr.io/kube-controller-manager:"
  "k8s.gcr.io/kube-scheduler:"
  "k8s.gcr.io/kube-proxy:"
  "k8s.gcr.io/pause-amd64:3.1"
)

######################################################################################################
# function
######################################################################################################

function check() {
  docker info >/dev/null 2>1
  if [ "$?" != "0" ]; then
    echo -e "${RED}Please check if the docker service is started or installed."
    tput sgr0
    exit 1
  fi
}

function pull() {
  local image_url=$1
  local image=${image_url##*/}

  for proxy_url in ${proxy[*]}; do
    [ "${proxy_url:0-1}" != "/" ] && proxy_url=$proxy_url/
    echo -e "${ORANGE}[Proxy:] $proxy_url"
    echo -e "[Image:] $image_url"
    tput sgr0
    docker pull $proxy_url$image
    if [ "$?" == "0" ]; then
      docker tag $proxy_url$image $image_url
      docker images ${image_url}
      echo -e "${ORANGE}[Delete:] Delete Proxy image."
      tput sgr0
      docker rmi $proxy_url$image
      echo -e "${GREEN}[Result:] Pull image success."
      tput sgr0
      echo
      break
    else
      echo -e "${RED}[Result:] Pull image failed."
      tput sgr0
      echo
    fi
  done
}

function usage {
    echo "Download the Google docker image through the proxy node"
    echo
    echo "Usage: $0 [[[-p proxy] [-i image] | [-t tag] | [-f file]] | [-h]]"
    echo "  -p,--proxy      Specify proxy node url"
    echo "  -i,--image      Specify the image name"
    echo "  -t,--tag        Specify the image tag and download the k8s family bucket."
    echo "  -f,--file       Specify a file path containing the name"
    echo "  -h,--help       View help"
    echo
    echo
    echo "Example:"
    echo "  $0 gcr.io/google_containers/pause-amd64:3.1"
    echo "  $0 \"k8s.gcr.io/kube-{apiserver,controller-manager,proxy,scheduler}:v1.14.3\""
    echo "  $0 -i k8s.gcr.io/pause-amd64:3.1"
    echo "  $0 -p registry.aliyuncs.com/google_containers -i k8s.gcr.io/pause-amd64:3.1"
    echo "  $0 -t v1.14.3"
    echo "  $0 -f ./images.txt"
    echo
    exit 1
}


######################################################################################################
# main
######################################################################################################

check

[ "$#" == "0" ] && usage

while [ "$1" != "" ]; do
    case $1 in
        -p | --proxy )          shift
                                unset proxy
                                proxy=$1
                                ;;
        -i | --image )          shift
                image_url=$1
                                ;;
        -t | --tag )            shift
                tag=$1
                                ;;
        -f | --file )           shift
                file=$1
                                ;;
        -h | --help )           usage
                                exit
                                ;;
        *\.* | *\/*)            image_url=$1
                                ;;
        * )                     usage
                                exit 1
    esac
    shift
done

if echo "$image_url" | grep -q "{"; then
  prefix_image=$(echo $image_url | cut -d '{' -f 1)
  tag_image=$(echo $image_url | cut -d ':' -f 2)
  muti_image=$(echo $image_url | cut -d '{' -f 2 | cut -d '}' -f 1)
  for i in $(echo $muti_image | tr "," "\n")
  do
    pull $prefix_image$i:$tag_image
  done
  exit 0
fi

if [ "$tag" != "" ]; then
  for image in ${images[*]}
  do
    [ "${image:0-1}" == ":" ] && pull $image$tag || pull $image
  done
  exit 0
fi

if [ "$file" != "" ]; then
  while IFS= read line
  do
    pull $line
  done <"$file"
  exit 0
fi

pull $image_url
```

## Openssl

```sh
#$1: keyfile
#$2: cafile
#$3: valid_days
func_self_signed_ca_interactive(){
    local key=$1
    local ca=$2
    local days=$3
    if [ ! -d `dirname $key` ];then
        mkdir -p `dirname $key`
    fi
    if [ ! -d `dirname $ca` ];then
        mkdir -p `dirname $ca`
    fi
    openssl req  -nodes -new -x509 -days ${days} -keyout ${key} -out ${ca}
}

#$1: result config file
#$2: prompt, yes/no
#$3: bits
#$4: keyfile
#$5: email
#$6: commonName
#$7: subjectAltName
func_cert_sign_req_config(){
    local config_file=$1
    local dir=`dirname $config_file`
    if [ ! -d $dir ];then
        mkdir -p $dir
    fi

    local prompt=$2
    local bits=$3
    local keyfile=$4
    local email=$5
    local commonName=$6
    local subjectAltName=$7

    cat > $config_file <<EOF
[ req ]
prompt                 = ${prompt}
default_bits           = ${bits}
default_keyfile        = ${keyfile}
distinguished_name     = req_distinguished_name
attributes             = req_attributes
x509_extensions        = v3_ca

dirstring_type = nobmp

[ req_distinguished_name ]

countryName                    = Country Name (2 letter code)
countryName_default            = CN
countryName_min                = 2
countryName_max                = 2

localityName                   = Locality Name (eg, city)
localityName_default           = BeiJing

organizationalUnitName         = Organizational Unit Name (eg, section)
organizationalUnitName_default = no

commonName                     = Common Name (eg, YOUR name)
commonName_default             = ${commonName}
commonName_max                 = 64

emailAddress                   = Email Address
emailAddress_default           = ${email}
emailAddress_max               = 40

[ req_attributes ]
challengePassword              = A challenge password
challengePassword_min          = 4
challengePassword_max          = 20

[ v3_ca ]
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer:always
basicConstraints = CA:true
subjectAltName=${subjectAltName}
EOF
}
```

## k8s

```sh
#Generate config file from k8s style params
#$1: Saved Config file
#$2: command
#$3..:  command params
func_gen_config_k8s(){
    local file=$1
    local cmd=$2
    shift 2
    echo "declare -A CONFIGS" >$file
    $cmd 2>&1 $* |sed '1d' |sed  -E  's/.*(--[^:]*):(.*)/\#\2\n\1/' | sed -E 's/\[(.*)\]/\1/' | sed -E "s/--(.*)=(.*)/CONFIGS\[\1\]=\'--\1=\2\'/" >>$file
}
```

## Time

```sh
func_since_1970(){
    echo `date +"%s"`
}
func_cur_date(){
    echo `date +"%Y%m%d"`
}
func_yesterday_date(){
    echo `date -d yesterday +"%Y%m%d"`
}
func_before_yesterday_date(){
    echo `date -d "-2 day" +"%Y%m%d"`
}
func_cur_time(){
    echo `date +"%Y-%m-%d %H:%M:%S"`
}
func_yesterday_time(){
    echo `date -d yesterday +"%Y-%m-%d %H:%M:%S"`
}
```

## 编码转换

```sh
#convert 16base into 10base
#
func_16to10(){
    echo "ibase=16;obase=A; $1"|bc
}
```

## 日志

### 日志处理

```sh
#!/bin/env bash

LOGFILE=log.log
RETAIN_NUM_LINES=10

function logsetup {
    TMP=$(tail -n $RETAIN_NUM_LINES $LOGFILE 2>/dev/null) && echo "${TMP}" > $LOGFILE
    exec > >(tee -a $LOGFILE)
    exec 2>&1
}

function log {
    echo "[$(date --rfc-3339=seconds)]: $*"
}


function loginfo(){
    local level=$1
    local msg=$2
    local dateName=`date +%Y-%m-%d" "%H:%M:%S`
    [[ ! -d "${LOG_DIR}/" ]] && mkdir -p $LOG_DIR
    echo "[${dateName}] [${level}] ${msg}" >> $LOG_PATH
}

logsetup
log hello this is a log
```

```sh
LOG_WARN () {
  local time=$(date +'%F %T')
  printf "\033[1;31m$time WARN %-25s %-25s %-5s %s\n\033[0m" $0 ${FUNCNAME[1]} ${BASH_LINENO[0]} "$*"
  printf "$time WARN %-25s %-25s %-5s %s\n" $0 ${FUNCNAME[1]} ${BASH_LINENO[O]}"$*" > $LOGFILE
}


LOG_ERROR() {
  local time=$(date +'%F %T')
  printf "\033[1;31m$time ERROR %-25s %-25s %-5s %s\n\033[0m" $0 ${FUNCNAME[1} ${BASH_LINENO[0]} "$*"
  printf "$time ERROR %-25s %-25s %-5s %s\n" $0 ${FUNCNAME[1]} ${BASH_LINENO[O]} "$*" > $LOGFILE
}


LOG_INFO(){
  local time=$(date +'%F %T')
  printf "\033[1;32m$time INF0 %-25s %-25s %-5s %ss\n\033[0m" $0 ${FUNCNAME[1} ${BASH_LINENO[0]} "$*"
  printf "$time INFO %-25s %-25s %-5s %s\n" $0 ${FUNCNAME[1]} ${BASH_LINENO[0]} "$*" > $LOGFILE
}

LOG_DEBUG(){
  local time=$(date +'%F %T')
  [ "x"debug == 'xFalse' ] || printf "\033[1m$time INF0 %-25s %-25s %-5s %ss\n\033[0m" $0 ${FUNCNAME[1} ${BASH_LINENO[0]} "$*"
  printf "$time INFO %-25s %-25s %-5s %s\n" $0 ${FUNCNAME[1]} ${BASH_LINENO[0]} "$*" > $LOGFILE
}
```

```sh
INFO() {
	/bin/echo -e "\e[104m\e[97m[INFO]\e[49m\e[39m $@"
}

WARNING() {
	/bin/echo >&2 -e "\e[101m\e[97m[WARNING]\e[49m\e[39m $@"
}

ERROR() {
	/bin/echo >&2 -e "\e[101m\e[97m[ERROR]\e[49m\e[39m $@"
}
```

### 错误日志

```sh
#$1: message
func_fatal(){
    echo  -n -e "\033[31m"
    echo "Fatal Error: $1"
    echo -n -e "\033[0m"
    exit
}
```

```sh
ERROR_INFO="\n\033[31mERROR Summary: \033[0m\n  "
ACCESS_INFO="\n\033[32mACCESS Summary: \033[0m\n  "

TMP_DIR="$(rm -rf /tmp/kainstall* && mktemp -d -t kainstall.XXXXXXXXXX)"
LOG_FILE="${TMP_DIR}/kainstall.log"

function log::error() {
  # 错误日志

  local item
  item="[$(date +'%Y-%m-%dT%H:%M:%S.%N%z')]: \033[31mERROR:   \033[0m$*"
  ERROR_INFO="${ERROR_INFO}${item}\n  "
  echo -e "${item}" | tee -a "$LOG_FILE"
}

function log::info() {
  # 基础日志

  printf "[%s]: \033[32mINFO:    \033[0m%s\n" "$(date +'%Y-%m-%dT%H:%M:%S.%N%z')" "$*" | tee -a "$LOG_FILE"
}

function log::warning() {
  # 警告日志

  printf "[%s]: \033[33mWARNING: \033[0m%s\n" "$(date +'%Y-%m-%dT%H:%M:%S.%N%z')" "$*" | tee -a "$LOG_FILE"
}

function log::access() {
  # 访问信息

  ACCESS_INFO="${ACCESS_INFO}$*\n  "
  printf "[%s]: \033[32mINFO:    \033[0m%s\n" "$(date +'%Y-%m-%dT%H:%M:%S.%N%z')" "$*" | tee -a "$LOG_FILE"
}

function log::exec() {
  # 执行日志

  printf "[%s]: \033[34mEXEC:    \033[0m%s\n" "$(date +'%Y-%m-%dT%H:%M:%S.%N%z')" "$*" >>"$LOG_FILE"
}
```

## 字体颜色

### demo1

```sh
#Input is the command.
#The command's execute output will use red color
func_red_cmd(){
    echo  -n -e "\033[31m"
    $*
    echo  -n -e "\033[0m"
}

#Input is the command.
#The command's execute output will use yellow color
func_yellow_cmd(){
    echo  -n -e "\033[33m"
    $*
    echo  -n -e "\033[0m"
}

#Input is the command
#If command is error, display the error
func_error_cmd(){
    $*
    local ret=$?
    if [ ! $ret -eq 0 ];then
        echo  -n -e "\033[41;37m"
        echo "Error: [$ret] $*"
        echo  -n -e "\033[0m"
    fi
    return 0
}

#Input is the command
#If command is error, display the error and eixt
func_fatal_cmd(){
    $*
    local ret=$?
    if [ ! $ret -eq 0 ];then
        echo  -n -e "\033[41;37m"
        echo "Error: [$ret] $*"
        echo  -n -e "\033[0m"
        exit 1
    fi
    return 0
}

#Input is a string.
#The string  will be displayed with green color
func_green_str(){
    echo  -n -e "\033[32m"
    echo  -e "$*"
    echo  -n -e "\033[0m"
}

func_yellow_str(){
    echo  -n -e "\033[33m"
    echo  -e "$*"
    echo  -n -e "\033[0m"
}

#Input is a string.
#The string  will be displayed with red color
func_red_str(){
    echo  -n -e "\033[31m"
    echo  -e "$*"
    echo  -n -e "\033[0m"
}
```

### demo2

```sh
#!/bin/bash
#####################################
# Author: Sebastiaan Tammer
# Version: v1.0.0
# Date: 2018-11-17
# Description: Some printed text, now with colors!
# Usage: ./colorful.sh
#####################################

print_colored() {
  # Check if the function was called with the correct arguments.
  if [[ $# -ne 2 ]]; then
    echo "print_colored needs two arguments, exiting."
    exit 1
  fi

  # Grab both arguments.
  local string=$1
  local color=$2

  # Use a case-statement to determine the color code.
  case ${color} in
  red)
    local color_code="\e[31m";;
  blue)
    local color_code="\e[34m";;
  green)
    local color_code="\e[32m";;
  *)
    local color_code="\e[39m";; # Wrong color, use default.
  esac

  # Perform the echo, and reset color to default with [39m.
  echo -e ${color_code}${string}"\e[39m"
}

# Print the text in different colors.
print_colored "Hello world!" "red"
print_colored "Hello world!" "blue"
print_colored "Hello world!" "green"
print_colored "Hello world!" "magenta"
```

### demo3

```sh
# 方法1：
function echo_color() {
 if [ $1 == "green" ]; then
   echo -e "\033[32;40m$2\033[0m"
 elif [ $1 == "red" ]; then
   echo -e "\033[31;40m$2\033[0m"
 fi
}

# 方法2：
function echo_color() {
 case $1 in
   green)
     echo -e "\033[32;40m$2\033[0m"
     ;;
   red)
     echo -e "\033[31;40m$2\033[0m"
     ;;
   *)
     echo "Example: echo_color red string"
 esac
}

# 使用方法：echo_color green "test"
```

## 常见颜色

```sh
NOCOLOR='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
LIGHTGRAY='\033[0;37m'
DARKGRAY='\033[1;30m'
LIGHTRED='\033[1;31m'
LIGHTGREEN='\033[1;32m'
YELLOW='\033[1;33m'
LIGHTBLUE='\033[1;34m'
LIGHTPURPLE='\033[1;35m'
LIGHTCYAN='\033[1;36m'
WHITE='\033[1;37m'

echo -e "The first five colors of the rainbow are ${RED}red ${ORANGE}orange ${YELLOW}yellow ${GREEN}green ${NOCOLOR}and ${BLUE}blue${NOCOLOR}"
```

```sh
#定义一个颜色的函数
echo_color (){
    local color=$1
    local info=$2
    case "$color" in
    red)
        echo -e "\e[1;31m ${info} \e[0m"
       ;;
    green)
        echo -e "\e[1;32m ${info} \e[0m"
       ;;
    yellow)
        echo -e "\e[1;33m ${info} \e[0m"
       ;;
    blue)
        echo -e "\e[1;34m ${info} \e[0m"
       ;;
    Magenta)
        echo -e "\e[1;35m ${info} \e[0m"
    ;;
    cyan-blue)
        echo -e "\e[1;36m ${info} \e[0m"
    ;;
    esac

}


echo_color red "哈哈哈哈哈哈哈"
echo_color green "哈哈哈哈哈哈哈"
echo_color yellow "哈哈哈哈哈哈哈"
echo_color blue "哈哈哈哈哈哈"
echo_color Magenta "哈哈哈哈哈哈"
```

```sh
function echo_r (){
    # Color red: Error, Failed
    [ $# -ne 1 ] && return 1
    echo -e "\033[31m$1\033[0m"
}

function echo_g (){
    # Color green: Success
    [ $# -ne 1 ] && return 1
    echo -e "\033[32m$1\033[0m"
}
```

## 系统资源

### 获取系统资源

以 json 数据格式返回

```sh
#!/bin/bash
#
# author: lework
# date: 2019-10-11


######################################################################################################
# Environmental configuration
######################################################################################################

export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin


######################################################################################################
# Define globle variable
######################################################################################################

system_facts=''
cpu_facts=''
mem_facts=''
disk_facts=''
network_facts=''

bad=''
critical=''

bad_threshold=80
critical_threshold=90


######################################################################################################
# Define function
######################################################################################################

function check_used() {
  # 依据阀值设置,进行标记严重程度

  item=$1
  value=${2:-0}

  if [[ ${value%.*} -ge ${critical_threshold%.*} ]]; then
    critical=${critical}'"'${item}'",'
  elif [[ ${value%.*} -ge ${bad_threshold%.*} ]]; then
    bad=${bad}'"'${item}'",'
  fi

}


function get_system() {
  # 获取系统信息

  hostname=$(hostname 2>/dev/null)
  default_ipv4=$(ip -4 route get 8.8.8.8 2>/dev/null | head -1 | awk '{print $7}')
  distribution=$(awk '/^ID=/' /etc/*-release 2>/dev/null | awk -F'=' '{gsub("\"","");print $2}')
  distribution_version=$(python -c 'import platform; print platform.linux_distribution()[1]' 2>/dev/null)
  [ -z $distribution_version ] && distribution_version=$(awk '/^VERSION_ID=/' /etc/*-release 2>/dev/null | awk -F'=' '{gsub("\"","");print $2}')
  os_pretty_name=$(awk '/^PRETTY_NAME=/' /etc/*-release 2>/dev/null | awk -F'=' '{gsub("\"","");print $2 }')
  kernel=$(uname -r 2>/dev/null)
  os_time=$(date +"%F %T" 2>/dev/null)
  uptime=$(uptime 2>/dev/null |awk '{print $3}'|awk -F, '{print $1}')

  system_facts=$(cat << EOF
  {
    "hostname": "${hostname:-}",
    "default_ipv4": "${default_ipv4:-}",
    "distribution": "${distribution:-}",
    "distribution_version": "${distribution_version:-}",
    "os_pretty_name": "${os_pretty_name:-}",
    "kernel": "${kernel:-}",
    "os_time": "${os_time:-}",
    "uptime": "${uptime:-}"
  }
EOF
  )

}


function get_cpu() {
  # 获取cpu使用信息

  cpu_usedutilization=$(cat <(grep 'cpu ' /proc/stat) <(sleep 1 && grep 'cpu ' /proc/stat) | awk -v RS="" '{printf ("%.2f\n", ($13-$2+$15-$4)*100/($13-$2+$15-$4+$16-$5))}')
  cpu_loadavg1=$(awk '{print $1}' /proc/loadavg)
  cpu_loadavg5=$(awk '{print $2}' /proc/loadavg)
  cpu_loadavg15=$(awk '{print $3}' /proc/loadavg)

  cpu_facts=$(cat << EOF
  {
    "cpu_usedutilization": "${cpu_usedutilization:-0}",
    "cpu_loadavg1": "${cpu_loadavg1:-0}",
    "cpu_loadavg5": "${cpu_loadavg5:-0}",
    "cpu_loadavg15": "${cpu_loadavg15:-0}"
  }
EOF
  )

  check_used 'cpu_usedutilization' ${cpu_usedutilization}
  check_used 'cpu_loadavg1' ${cpu_loadavg1}
  check_used 'cpu_loadavg5' ${cpu_loadavg5}
  check_used 'cpu_loadavg15' ${cpu_loadavg15}

}


function get_mem() {
  # 获取内存使用信息

  memfree=$(awk -F":|kB" '$1~/^MemFree/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  memavailable=$(awk -F":|kB" '$1~/^MemAvailable/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  memtotal=$(awk -F":|kB" '$1~/^MemTotal/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  memcache=$(awk -F":|kB" '$1~/^Cached/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  membuffer=$(awk -F":|kB" '$1~/^Buffers/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  swaptotal=$(awk -F":|kB" '$1~/^SwapTotal/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)
  swapfree=$(awk -F":|kB" '$1~/^SwapFree/{gsub(/ +/,"",$0);print $2}' /proc/meminfo)

  [ "${memtotal:-0}" != "0" ] && mem_usedutilization=$(echo "${memtotal:-0} ${memfree:-0} ${memcache:-0} ${membuffer:-0}" | awk '{printf ("%.2f\n", ($1-$2-$3-$4)*100/$1)}')
  [ "${swaptotal:-0}" != "0" ] && swap_usedutilization=$(echo "${swaptotal:-0} ${swapfree:-0}"| awk '{printf ("%.2f\n", ($1-$2)*100/$1)}')

  mem_facts=$(cat << EOF
  {
    "memtotal": "${memtotal:-}",
    "memfree": "${memfree:-}",
    "memavailable": "${memavailable:-}",
    "memcache": "${memcache:-}",
    "membuffer": "${membuffer:-}",
    "mem_usedutilization": "${mem_usedutilization:-0}",
    "swaptotal": "${swaptotal:-}",
    "swapfree": "${swapfree:-}",
    "swap_usedutilization": "${swap_usedutilization:-0}"
  }
EOF
  )

  check_used 'mem' ${mem_usedutilization}
  check_used 'swap' ${swap_usedutilization}

}


function get_disk() {
  # 获取磁盘使用信息

  mount=$(grep '^/dev/' /proc/mounts | grep -v -E 'docker|containers|iso9660|kubelet' | awk '{print $2}')

  for m in ${mount:-}; do
    size_total=$(df -hP $m 2>/dev/null | awk 'END{print $2}')
    size_use=$(df -hP $m 2>/dev/null | awk 'END{print $3}')
    size_available=$(df -hP $m 2>/dev/null | awk 'END{print $4}')
    size_usedutilization=$(df -hP $m 2>/dev/null | awk 'END{sub(/'%'/,"");print $5}')
    block_total=$(df -hPBM $m 2>/dev/null | awk 'END{print $2}')
    block_use=$(df -hPBM $m 2>/dev/null | awk 'END{print $3}')
    block_available=$(df -hPBM $m 2>/dev/null | awk 'END{print $4}')
    block_usedutilization=$(df -hPBM $m 2>/dev/null | awk 'END{sub(/'%'/,"");print $5}')
    inode_total=$(df -hPi $m 2>/dev/null | awk 'END{print $2}')
    inode_use=$(df -hPi $m 2>/dev/null | awk 'END{print $3}')
    inode_available=$(df -hPi $m 2>/dev/null | awk 'END{print $4}')
    inode_usedutilization=$(df -hPi $m 2>/dev/null | awk 'END{sub(/'%'/,"");print $5}')

    mount_facts=${mount_facts:-''}$(cat <<EOF
    {
      "mount": "${m:-}",
      "size_total": "${size_total:-}",
      "size_use": "${size_use:-}",
      "size_available": "${size_available:-}",
      "size_usedutilization": "${size_usedutilization:-0}",
      "block_total": "${block_total:-}",
      "block_use": "${block_use:-}",
      "block_available": "${block_available:-}",
      "block_usedutilization": "${block_usedutilization:-0}",
      "inode_total": "${inode_total:-}",
      "inode_use": "${inode_use:-}",
      "inode_available": "${inode_available:-}",
      "inode_usedutilization": "${inode_usedutilization:-0}"
    },
EOF
    )

    check_used 'mount_size_'${m} ${size_usedutilization}
    check_used 'mount_block_'${m} ${block_usedutilization}
    check_used 'mount_inode_'${m} ${inode_usedutilization}
  done

  disk_facts="["${mount_facts%?}"]"

}


function get_network() {
  # 获取网络信息

  stat=$(netstat -nat 2>/dev/null | awk '/^tcp/{++S[$NF]}END{for(m in S) print "\"" m "\":",S[m] ","}')

  conn="None"
  curl -V >/dev/null 2>&1
  if [ $? -eq 0 ]; then
    curl -sI http://www.baidu.com 2>/dev/null | grep '200 OK' >/dev/null 2>&1
    [ $? -eq 0 ] && conn="True"
  fi
  network_facts=$(cat << EOF
  {
    "tcpconnection": {${stat%?}},
    "conn": "${conn}"
  }
EOF
  )

}


function main() {
  # 脚本主要流程

  get_system
  get_cpu
  get_mem
  get_disk
  get_network


  [ ! -z $bad ] && bad='['${bad%?}']'
  [ ! -z $critical ] && critical='['${critical%?}']'

  check_facts=$(cat << EOF
  {
    "system": ${system_facts:-[]},
    "cpu": ${cpu_facts:-[]},
    "mem": ${mem_facts:-[]},
    "disk": ${disk_facts:-[]},
    "network": ${network_facts:-[]},
    "bad": ${bad:-[]},
    "critical": ${critical:-[]}
  }
EOF
  )

  echo ${check_facts:-[]}

}


######################################################################################################
# main
######################################################################################################

main
```

### 网卡

```sh
#Get the net interfaces's name
func_nic_names(){
    local names=`ip addr |grep \<.*\>|awk '{print $2}'|sed -e "s/://"`
    echo $names
}
```

### 系统信息

```sh
#Get ipv4 address
func_ipv4_addr(){
    local ips=`ip addr |grep inet|grep -v inet6| awk '{print $2}'|sed "s/\/.*//"`
    echo $ips
}
```

### IP 地址处理

```sh
# converts IPv4 as "A.B.C.D" to integer
# 这个函数将 IPv4 地址的每一部分（A、B、C、D）提取出来，然后使用位移和加法将其转换为一个整数。
ip4_to_int() {
IFS=. read -r i j k l <<EOF
$1
EOF
  # 这一行将每个部分按照 IPv4 地址转换为整数的规则进行位移运算，并将结果相加得到最终的整数值。
  echo $(( i << 24 ) + ( j << 16 ) + ( k << 8 ) + l)
}

# converts interger to IPv4 as "A.B.C.D"
int_to_ip4() {
  echo "$(( ($1 >> 24) % 256 )).$(( ($1 >> 16) % 256 )).$(( ($1 >> 8) % 256 )).$(( $1 % 256 ))"
}

# returns the ip part of an CIDR
cidr_ip() {
  IFS=/ read -r ip _ <<EOF
$1
EOF
  echo $ip
}

# returns the prefix part of an CIDR
cidr_prefix() {
  IFS=/ read -r _ prefix <<EOF
$1
EOF
  echo $prefix
}

# returns net mask in numberic from prefix size
netmask_of_prefix() {
  echo $((4294967295 ^ (1 << (32 - $1)) - 1))
}

# returns default gateway address (network address + 1) from CIDR
cidr_default_gw() {
  ip=$(ip4_to_int $(cidr_ip $1))
  prefix=$(cidr_prefix $1)
  netmask=$(netmask_of_prefix $prefix)
  gw=$((ip & netmask + 1))
  int_to_ip4 $gw
}

# returns default gateway address (broadcast address - 1) from CIDR
cidr_default_gw_2() {
  ip=$(ip4_to_int $(cidr_ip $1))
  prefix=$(cidr_prefix $1)
  netmask=$(netmask_of_prefix $prefix)
  broadcast=$(((4294967295 - netmask) | ip))
  int_to_ip4 $((broadcast - 1))
}


ip4_to_int 192.168.0.1
# => 3232235521

int_to_ip4 3232235521
# => 192.168.0.1


# network address
ip=$(ip4_to_int 172.16.10.20)
netmask=$(ip4_to_int 255.255.252.0)
int_to_ip4 $((ip & netmask))
# => 172.16.8.0


# broadcast address
ip=$(ip4_to_int 172.16.10.20)
netmask=$(ip4_to_int 255.255.252.0)
int_to_ip4 $(((ip & netmask) + 1))
# => 172.16.8.1


cidr_ip "172.16.0.10/22"
# => 172.16.0.10

cidr_prefix "172.16.0.10/22"
# => 22

netmask_of_prefix 8
# => 4278190080


cidr_default_gw 192.168.10.1/24
# => 192.168.10.1
cidr_default_gw 192.168.10.1/16
# => 192.168.0.1
cidr_default_gw 172.17.18.19/20
# => 172.17.16.1


cidr_default_gw_2 192.168.10.1/24
# => 192.168.10.254
cidr_default_gw_2 192.168.10.1/16
# => 192.168.255.254
cidr_default_gw_2 172.17.18.19/20
# => 172.17.31.254


# 获取外网ip
get_ip(){
    local IP=$( ip addr | egrep -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | egrep -v "^192\.168|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-2]\.|^10\.|^127\.|^255\.|^0\." | head -n 1 )
    [ -z ${IP} ] && IP=$( wget -qO- -t1 -T2 ipv4.icanhazip.com )
    [ -z ${IP} ] && IP=$( wget -qO- -t1 -T2 ipinfo.io/ip )
    [ -z ${IP} ] && IP=$( wget -qO- -t1 -T2 api.ip.sb/ip )
    [ -z ${IP} ] && IP=$( wget -qO- -t1 -T2 members.3322.org/dyndns/getip )
    [ -z ${IP} ] && IP=$( ip -4 route get 8.8.8.8 2>/dev/null | head -1 | awk '{print $7}' )
    echo ${IP}
}

get_ipv6(){
    local ipv6=$(wget -qO- -t1 -T2 ipv6.icanhazip.com)
    [ -z ${ipv6} ] && return 1 || return 0
}
```

### 系统类型检查

```sh
release=''
check_sys(){
    if [[ -f /etc/redhat-release ]]; then
        release="centos"
    elif cat /etc/issue | grep -q -E -i "debian"; then
        release="debian"
    elif cat /etc/issue | grep -q -E -i "ubuntu"; then
        release="ubuntu"
    elif cat /etc/issue | grep -q -E -i "centos|red hat|redhat"; then
        release="centos"
    elif cat /proc/version | grep -q -E -i "debian"; then
        release="debian"
    elif cat /proc/version | grep -q -E -i "ubuntu"; then
        release="ubuntu"
    elif cat /proc/version | grep -q -E -i "centos|red hat|redhat"; then
        release="centos"
    fi
    bit=`uname -m`
}
```

```sh
OS=$(uname -s)

case "$OS" in
  FreeBSD) echo "This is FreeBSD" ;;
  Darwin) echo "This is Mac OSX" ;;
  AIX) echo "This is AIX" ;;
  Minix) echo "This is Minix" ;;
  Linux) echo "This is Linux" ;;
  *) echo "Failed to identify this OS" ;;
esac
```

### 检查软件包是否安装

```sh
#!/bin/bash
if rpm -q sysstat &>/dev/null; then
 echo "sysstat is already installed."
else
 echo "sysstat is not installed!"
fi
```

### 扫描主机端口状态

```sh
#!/bin/bash
HOST=$1
PORT="22 25 80 8080"
for PORT in $PORT; do
 if echo &>/dev/null > /dev/tcp/$HOST/$PORT; then
   echo "$PORT open"
 else
   echo "$PORT close"
 fi
done
```

## 系统服务

### 启动服务

```sh
# Start a systemd style Service
func_start_sd_service(){
    systemctl start $1
    sleep 1
    local sta=`systemctl status ${1} |grep "Active: failed"`
    if [ -n "$sta" ];then
        func_red_str   "Start[Fail] $1"
        func_red_str   "            $sta"
        ret=1
    else
        local x=`systemctl status ${1} | grep "Active:"`
        func_green_str "Start[OK]   $1"
        func_green_str "            $x"
    fi
    return $ret
}

# Start a systemd style Service
func_stop_sd_service(){
    systemctl stop $1
    ret=$?
    local sta=`systemctl status ${1} |grep "Active:"`
    func_yellow_str "Stopping $1"
    func_yellow_str "         $sta"
}
```

### Nginx 服务管理脚本

场景：使用源码包安装 Nginx 不含带服务管理脚本，也就是不能使用"service nginxstart"或"/etc/init.d/nginx start"，所以写了以下的服务管理脚本。

```sh
#!/bin/bash
# Description: Only support RedHat system
. /etc/init.d/functions
WORD_DIR=/usr/local/nginx
DAEMON=$WORD_DIR/sbin/nginx
CONF=$WORD_DIR/conf/nginx.conf
NAME=nginx
PID=$(awk -F'[; ]+' '/^[^#]/{if($0~/pid;/)print $2}' $CONF)

if [ -z "$PID" ]; then
  PID=$WORD_DIR/logs/nginx.pid
else
  PID=$WORD_DIR/$PID
fi

stop() {
  $DAEMON -s stop
  sleep 1
  [ ! -f $PID ] && action "* Stopping $NAME" /bin/true || action "* Stopping
  $NAME" /bin/false
}

start() {
  $DAEMON
  sleep 1
  [ -f $PID ] && action "* Starting $NAME" /bin/true || action "* Starting
  $NAME" /bin/false
}

reload() {
  $DAEMON -s reload
}

test_config() {
  $DAEMON -t
}

case "$1" in
 start)
   if [ ! -f $PID ]; then
     start
   else
     echo "$NAME is running..."
     exit 0
   fi
   ;;
 stop)
   if [ -f $PID ]; then
     stop
   else
     echo "$NAME not running!"
     exit 0
   fi
   ;;
 restart)
   if [ ! -f $PID ]; then
     echo "$NAME not running!"
     start
   else
     stop
     start
   fi
   ;;
 reload)
   reload
   ;;
 testconfig)
   test_config
   ;;
 status)
   [ -f $PID ] && echo "$NAME is running..." || echo "$NAME not running!"
   ;;
 *)
   echo "Usage: $0 {start|stop|restart|reload|testconfig|status}"
   exit 3
   ;;
esac
```

### 检查服务状态

```sh
#!/bin/bash
PORT_C=$(ss -anu |grep -c 123)
PS_C=$(ps -ef |grep ntpd |grep -vc grep)
if [ $PORT_C -eq 0 -o $PS_C -eq 0 ]; then
 echo "内容" | mail -s "主题" dst@example.com
fi
```

### 检查主机存活状态

```sh
# 方法1：将错误IP放到数组里面判断是否ping失败三次
#!/bin/bash
IP_LIST="192.168.18.1 192.168.1.1 192.168.18.2"
for IP in $IP_LIST; do
 NUM=1
 while [ $NUM -le 3 ]; do
   if ping -c 1 $IP > /dev/null; then
     echo "$IP Ping is successful."
     break
   else
     # echo "$IP Ping is failure $NUM"
     FAIL_COUNT[$NUM]=$IP
     let NUM++
   fi
 done
 if [ ${#FAIL_COUNT[*]} -eq 3 ];then
   echo "${FAIL_COUNT[1]} Ping is failure!"
   unset FAIL_COUNT[*]
 fi
done


# 方法2：将错误次数放到FAIL_COUNT变量里面判断是否ping失败三次
#!/bin/bash
IP_LIST="192.168.18.1 192.168.1.1 192.168.18.2"
for IP in $IP_LIST; do
 FAIL_COUNT=0
 for ((i=1;i<=3;i++)); do
   if ping -c 1 $IP >/dev/null; then
     echo "$IP Ping is successful."
     break
   else
     # echo "$IP Ping is failure $i"
     let FAIL_COUNT++
   fi
 done
 if [ $FAIL_COUNT -eq 3 ]; then
   echo "$IP Ping is failure!"
 fi
done


# 方法3：利用for循环将ping通就跳出循环继续，如果不跳出就会走到打印ping失败
#!/bin/bash
ping_success_status() {
 if ping -c 1 $IP >/dev/null; then
   echo "$IP Ping is successful."
   continue
 fi
}
IP_LIST="192.168.18.1 192.168.1.1 192.168.18.2"
for IP in $IP_LIST; do
 ping_success_status
 ping_success_status
 ping_success_status
 echo "$IP Ping is failure!"
done
```

### 检查网站可用性

1）检查 URL 可用性

```sh
# 方法1：
check_url() {
 HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w "%{http_code}" $1)
 if [ $HTTP_CODE -ne 200 ]; then
   echo "Warning: $1 Access failure!"
 fi
}

# 方法2：
check_url() {
if ! wget -T 10 --tries=1 --spider $1 >/dev/null 2>&1; then
#-T超时时间，--tries尝试1次，--spider爬虫模式
   echo "Warning: $1 Access failure!"
 fi
}

# 使用方法：check_url www.baidu.com
```

2）判断三次 URL 可用性

思路与上面检查主机存活状态一样。

```sh
# 方法1：利用循环技巧，如果成功就跳出当前循环，否则执行到最后一行
#!/bin/bash
check_url() {
 HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w "%{http_code}" $1)
 if [ $HTTP_CODE -eq 200 ]; then
   continue
 fi
}
URL_LIST="www.baidu.com www.agasgf.com"
for URL in $URL_LIST; do
 check_url $URL
 check_url $URL
 check_url $URL
 echo "Warning: $URL Access failure!"
done



# 方法2：错误次数保存到变量
#!/bin/bash
URL_LIST="www.baidu.com www.agasgf.com"
for URL in $URL_LIST; do
  FAIL_COUNT=0
  for ((i=1;i<=3;i++)); do
    HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w "%{http_code}" $URL)
    if [ $HTTP_CODE -ne 200 ]; then
      let FAIL_COUNT++
    else
      break
    fi
 done
 
 if [ $FAIL_COUNT -eq 3 ]; then
   echo "Warning: $URL Access failure!"
 fi
done



# 方法3：错误次数保存到数组
#!/bin/bash
URL_LIST="www.baidu.com www.agasgf.com"
for URL in $URL_LIST; do
 NUM=1
 while [ $NUM -le 3 ]; do
   HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w "%{http_code}"$URL)
   if [ $HTTP_CODE -ne 200 ]; then
     FAIL_COUNT[$NUM]=$IP #创建数组，以$NUM下标，$IP元素
     let NUM++
   else
     break
   fi
 done
 if [ ${#FAIL_COUNT[*]} -eq 3 ]; then
   echo "Warning: $URL Access failure!"
   unset FAIL_COUNT[*]  #清空数组
 fi
done
```

### http 心跳检测

```sh
URL="http://192.168.22.191/index.html"
THHP_CODE=`curl -o /dev/null -s -w "%{http_code}" "${URL}"`
if [ $HTTP_CODE != 200 ]
then
 echo -e "apache code:"$HTTP_CODE""
fi
```

### 检查 MySQL 主从同步状态

```sh
#!/bin/bash
USER=bak
PASSWD=123456
# gsub去除冒号后面的空格
IO_SQL_STATUS=$(mysql -u$USER -p$PASSWD -e 'show slave status\G' |awk -F:'/Slave_.*_Running/{gsub(": ",":");print $0}')



for i in $IO_SQL_STATUS; do
   THREAD_STATUS_NAME=${i%:*}
   THREAD_STATUS=${i#*:}
   if [ "$THREAD_STATUS" != "Yes" ]; then
     echo "Error: MySQL Master-Slave $THREAD_STATUS_NAME status is $THREAD_STATUS!"
   fi
done
```

### MySQL 数据库备份

#### 全库备份

```sh
#!/bin/bash
DATE=$(date +%F_%H-%M-%S)
HOST=192.168.1.120
DB=test
USER=bak
PASS=123456
MAIL="zhangsan@example.com lisi@example.com"
BACKUP_DIR=/data/db_backup
SQL_FILE=${DB}_full_$DATE.sql
BAK_FILE=${DB}_full_$DATE.zip
cd $BACKUP_DIR
if mysqldump -h$HOST -u$USER -p$PASS --single-transaction --routines --triggers -B $DB > $SQL_FILE; then
 zip $BAK_FILE $SQL_FILE && rm -f $SQL_FILE
 if [ ! -s $BAK_FILE ]; then
     echo "$DATE 内容" | mail -s "主题" $MAIL
 fi
else
 echo "$DATE 内容" | mail -s "主题" $MAIL
fi
find $BACKUP_DIR -name '*.zip' -ctime +14 -exec rm {} \;
```

#### 数据库目录备份

```sh
#!/bin/bash
DAY=`date +%Y%m%d`
SIZE=`du -sh /var/lib/mysql`
echo "Date: $DAY" >> /tmp/dbinfo.txt
echo "Data Size: $SIZE" >> /tmp/dbinfo.txt
cd /opt/dbbak &> /dev/null || mkdir /opt/dbbak
tar zcf /opt/dbbak/mysqlbak-${DAY}.tar.gz /var/lib/mysql /tmp/dbinfo.txt &> /dev/null

rm -f /tmp/dbinfo.txt
crontab-e
55 23 */3 * * /opt/dbbak/dbbak.sh
```

#### webdb 库做完整备份

- 每备份文件保存到系统的/mysqlbak 目录里
- 用系统日期做备份文件名 webdb-YYYY-mm-dd.sql
- 每次完整备份后都生成新的 binlog 日志
- 把当前所有的 binlog 日志备份到/mysqlbinlog 目录下

```sh
#mkdir /mysqlbak
#mkdir /mysqlbinlog
#service mysqld start
cd /shell

#vi webdb.sh
#!/bin/bash
day=`date +%F`
mysqldump -hlocalhost -uroot -p123 webdb > /mysqlbak/webdb-${day}.sql
mysql -hlocalhost -uroot -p -e "flush logs"
tar zcf /mysqlbinlog.tar.gz /var/lib/mysql/mysqld-bin.0*
#chmod +x webdb.sh
#crontab -e
30 23 * * 7 /shell/webdb.sh
```

### 轮询检测 Apache 状态并启用钉钉报警

```sh
#!/bin/bash
shell_user="root"
shell_domain="apache"
shell_list="/root/ip_list"
shell_row=`cat $shell_list |wc -l`
function trans_text(){
  text=$1
  curl 'https://oapi.dingtalk.com/robot/send?access_token=b4fcf5862088a1bc7f2bf66a' -H'Content-Type: application/json' \ -d'{   #指定钉钉机器人hook地址
       "msgtype": "text",
       "text": {
       "content": "'"$text"'"
     },
  }'
}
function apache_check_80(){
 ip=$1
 URL="http://$ip/index.html"
 HTTP_CODE=`curl -o /dev/null -s -w "%{http_code}" "${URL}"`
 if [ $HTTP_CODE != 200 ]
   then
     trans_text "
            
=================================================================
               \n $ip Apache 服务器状态异常，网页返回码:
'"$HTTP_CODE"' 请及时处理 ! \n
================================================================= \n"
 fi
}
while true
do
shell_list="/root/ip_list"
shell_row=`cat $shell_list |wc -l`
 for temp in `seq 1 $shell_row`
 do
     Ip_Addr=`cat $shell_list |head -n $temp |tail -n 1`
     apache_check_80 $Ip_Addr
 done
 sleep 10
done
```

## 监控 CPU、内存和硬盘利用率

### CPU

借助 vmstat 工具来分析 CPU 统计信息。

```sh
#!/bin/bash
DATE=$(date +%F" "%H:%M)
IP=$(ifconfig eth0 |awk -F '[ :]+' '/inet addr/{print $4}') # 只支持CentOS6
MAIL="example@mail.com"
if ! which vmstat &>/dev/null; then
 echo "vmstat command no found, Please install procps package."
 exit 1
fi
US=$(vmstat |awk 'NR==3{print $13}')
SY=$(vmstat |awk 'NR==3{print $14}')
IDLE=$(vmstat |awk 'NR==3{print $15}')
WAIT=$(vmstat |awk 'NR==3{print $16}')
USE=$(($US+$SY))
if [ $USE -ge 50 ]; then
 echo "
 Date: $DATE
 Host: $IP
 Problem: CPU utilization $USE
 " | mail -s "CPU Monitor" $MAIL
fi
```

### 检测 CPU 剩余百分比

```sh
#!/bin/bash
#Inspect CPU
#Sun Jul 31 17:25:41 CST 2016
PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/wl/bin
export PATH
TERM=linux
export TERM
CpuResult=$(top -bn 1 | grep "Cpu" | awk '{print $5}' | sed 's/\..*$//g')
if [[ $CpuResult < 20 ]];then
echo "CPU WARNING : $CpuResult" > /service/script/.cpu_in.txt
top -bn 1 >> /service/script./cpu_in.txt
mail -s "Inspcet CPU" wl < /service/script/.cpu_in.txt
fi
```

### 内存

```sh
#!/bin/bash
DATE=$(date +%F" "%H:%M)
IP=$(ifconfig eth0 |awk -F '[ :]+' '/inet addr/{print $4}')
MAIL="example@mail.com"
TOTAL=$(free -m |awk '/Mem/{print $2}')
USE=$(free -m |awk '/Mem/{print $3-$6-$7}')
FREE=$(($TOTAL-$USE))
# 内存小于1G发送报警邮件
if [ $FREE -lt 1024 ]; then
 echo "
 Date: $DATE
 Host: $IP
 Problem: Total=$TOTAL,Use=$USE,Free=$FREE
 " | mail -s "Memory Monitor" $MAIL
fi
```

### 内存检测

```sh
#!/bin/bash
#Inspect Memory : If the memory is less than 500 , then send mail to wl
#Tue Aug 2 09:13:43 CST 2016
PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/wl/bin
export PATH
MEM=$(free -m | grep "Mem" | awk '{print $4}')
if [[ MEM < 500 ]];then
  echo -e "Memory Warning : Memory free $MEM" > /service/script/.MemoryWarning
  mail -s "Memory Warning" wl < /service/script/.MemoryWarning
fi
```

### 硬盘

```sh
#!/bin/bash
DATE=$(date +%F" "%H:%M)
IP=$(ifconfig eth0 |awk -F '[ :]+' '/inet addr/{print $4}')
MAIL="example@mail.com"
TOTAL=$(fdisk -l |awk -F'[: ]+' 'BEGIN{OFS="="}/^Disk \/dev/{printf
"%s=%sG,",$2,$3}')
PART_USE=$(df -h |awk 'BEGIN{OFS="="}/^\/dev/{print $1,int($5),$6}')
for i in $PART_USE; do
 PART=$(echo $i |cut -d"=" -f1)
 USE=$(echo $i |cut -d"=" -f2)
 MOUNT=$(echo $i |cut -d"=" -f3)
 if [ $USE -gt 80 ]; then
   echo "
   Date: $DATE
   Host: $IP
   Total: $TOTAL
   Problem: $PART=$USE($MOUNT)
   " | mail -s "Disk Monitor" $MAIL
 fi
done
```

### 检测磁盘剩余空间

```sh
#!/bin/bash
#Insepct Harddisk , If the remaining space is more than 80%, the message is sent to the wl
#Tue Aug 2 09:45:56 CST 2016
PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/wl/bin
export PATH
for RemainingSpace in $(df -h | awk '{print $5}' | grep -v 'Use' | sed -e 's/[%]//g')
do
if [[ $RemainingSpace > 80 ]];then
 echo -e "$RemainingSpace"
 echo -e "$(df -h | grep $RemainingSpace)" > /service/script/.HarddiskWarning
 mail -s "disk Warning" wl < /service/script/.HarddiskWarning
fi
done
```

### 查看网卡实时流量

```sh
#!/bin/bash

# 定义流量单位转换函数
traffic_unit_conv() {
  local traffic=$1
  if [ $traffic -gt 1024000 ]; then
    printf "%.1f MB/s\n" "$(($traffic / 1024 / 1024))"
  elif [ $traffic -lt 1024000 ]; then
    printf "%.1f KB/s\n" "$(($traffic / 1024))"
  fi
}

# 获取命令行参数作为网卡名称
NIC=$1

# 打印表头
echo -e "In ------ Out"

# 进入无限循环
while true; do
  # 获取当前网卡的接收和发送字节数
  OLD_IN=$(awk -F'[: ]+' '$0 ~ "'$NIC'" { print $3 }' /proc/net/dev)
  OLD_OUT=$(awk -F'[: ]+' '$0 ~ "'$NIC'" { print $11 }' /proc/net/dev)

  # 等待一秒
  sleep 1

  # 再次获取网卡的接收和发送字节数
  NEW_IN=$(awk -F'[: ]+' '$0 ~ "'$NIC'" { print $3 }' /proc/net/dev)
  NEW_OUT=$(awk -F'[: ]+' '$0 ~ "'$NIC'" { print $11 }' /proc/net/dev)

  # 计算差值
  IN=$(($NEW_IN - $OLD_IN))
  OUT=$(($NEW_OUT - $OLD_OUT))

  # 输出流量信息
  echo "$(traffic_unit_conv $IN) $(traffic_unit_conv $OUT)"

  # 等待一秒
  sleep 1
done

# 使用示例：./traffic.sh eth0
```

### 监控服务器网卡流量

```sh
#!/bin/bash
#network
#Mike.Xu
while : ; do
speedtime='date +%m"-"%d" "%k":"%M'
speedday='date +%m"-"%d'
speedrx_before='ifconfig eth0|sed -n "8"p|awk '{print $2}'|cut -c7-'
speedtx_before='ifconfig eth0|sed -n "8"p|awk '{print $6}'|cut -c7-'
sleep 2
speedrx_after='ifconfig eth0|sed -n "8"p|awk '{print $2}'|cut -c7-'
speedtx_after='ifconfig eth0|sed -n "8"p|awk '{print $6}'|cut -c7-'
speedrx_result=$[(speedrx_after-speedrx_before)/256]
speedtx_result=$[(speedtx_after-speedtx_before)/256]
echo"$speedday$speedtime Now_In_Speed: "$speedrx_result"kbps Now_OUt_Speed:
"$speedtx_result"kbps"
sleep 2
done
```

### 给用户提供多个网卡选择

场景：服务器多个网卡时，获取指定网卡，例如网卡流量

```sh
#!/bin/bash
function local_nic() {
  local NUM=0
  local ARRAY_LENGTH=0
  local -a NIC_IP_ARRAY=()  # 明确初始化数组

  for NIC_NAME in $(ls /sys/class/net|grep -vE "lo|docker0"); do
    # NIC_IP=$(ifconfig $NIC_NAME |awk -F'[: ]+' '/inet addr/{print $4}')
    NIC_IP=$(ip -4 addr show $NIC_NAME | awk '/inet /{print \$2}' | cut -d'/' -f1)
    if [ -n "$NIC_IP" ]; then
      #将网卡名和对应IP放到数组
      NIC_IP_ARRAY[$NUM]="$NIC_NAME:$NIC_IP"
      ((NUM++))
    fi
  done


  RRAY_LENGTH=${#NIC_IP_ARRAY[@]}  # 使用 @ 避免展开为单个字符串
  #如果数组里面只有一条记录说明就一个网卡
  if [ $ARRAY_LENGTH -eq 1 ]; then
    NIC=${NIC_IP_ARRAY[0]%:*}
    return 0
  #如果没有记录说明没有网卡
  elif [ $ARRAY_LENGTH -eq 0 ]; then
    echo "No available network card!"
    exit 1
  else
    #如果有多条记录则提醒输入选择
    for NIC in ${NIC_IP_ARRAY[*]}; do
      echo $NIC
    done

    while true; do
      read -p "Please enter local use to network card name: " INPUT_NIC_NAME
      COUNT=0
      for NIC in ${NIC_IP_ARRAY[@]}; do
        NIC_NAME=${NIC%:*}
       if [[ $NIC_NAME == "$INPUT_NIC_NAME" ]]; then
          NIC=${NIC_IP_ARRAY[$COUNT]%:*}
          return 0
        else
          ((COUNT++))
        fi
      done
      echo "Invalid input, please try again."
    done
  fi
}
# local_nic
```

### 其他状态

list_sys_status.sh

显示系统使用的以下信息：
主机名、IP 地址、子网掩码、网关、DNS 服务器 IP 地址信息

```sh
#!/bin/bash
IP=`ifconfig eth0 | head -2 | tail -1 | awk '{print $2}' | awk -F":" '{print $2}'`
ZW=` ifconfig eth0 | head -2 | tail -1 | awk '{print $3}' | awk -F":" '{print $2}'`
GW=`route -n | tail -1 | awk '{print $2}'`
HN=`hostname`
DNS=`head -1 /etc/resolv.conf | awk '{print $2}'`
echo '此机IP地址是' $IP
echo '此机子网掩码是' $ZW
echo '此机网关是' $GW
echo '此机主机名是' $HN
echo '此机DNS是' $DNS
```

## 目录操作

### 创建多级目录

```sh
#Create Dirs: $1 $2 $3 ...
func_create_dirs(){
    for i in $*
    do
        if [ ! -d $i ];then
            mkdir -p $i
        fi
    done
}
```

### 强制复制文件

```sh
#Force Copy:
#$1: Destiation Directory
#$2,$3,$4,...: Source File or Directories
func_force_copy(){
    local dest=$1
    shift 1

    if [ ! -d $dest ];then
        func_red_str "Dest Dir doesn't exist: $dest"
        return 1
    fi

    for i in $*
    do
        if [ ! -e $i ];then
            func_red_str "Not Found: $i"
            return 1
        fi
    done

    for i in $*
    do
        cp -rf $i $dest/
    done
}
```

### 目录下找出包含关键字的文件

```sh
#!/bin/bash
DIR=$1
KEY=$2
for FILE in $(find $DIR -type f); do
 if grep $KEY $FILE &>/dev/null; then
   echo "--> $FILE"
 fi
done
```

### 监控目录

场景：记录目录下文件操作,将新创建的文件名追加到日志中。

需先安装 inotify-tools 软件包。

```sh
#!/bin/bash
MON_DIR=/opt
inotifywait -mq --format %f -e create $MON_DIR |\
while read files; do
  echo $files >> test.log
done
```

## 文件操作

### 批量修改文件名

方法 1

```sh
for file in $(ls *html); do
  mv $file bbs_${file#*_}
# mv $file $(echo $file |sed -r 's/.*(_.*)/bbs\1/')
# mv $file $(echo $file |echo bbs_$(cut -d_ -f2)
done
```

方法 2

```sh
for file in $(find . -maxdepth 1 -name "*html"); do
  mv $file bbs_${file#*_}
done
```

方法 3

```sh
rename article bbs *.html
```

### 统计当前目录中以.html 结尾的文件总大小

方法 1

```sh
find . -name "*.html" -exec du -k {} \; |awk '{sum+=$1}END{print sum}'
```

方法 2

```sh
for size in $(ls -l *.html |awk '{print $5}'); do
 sum=$(($sum+$size))
done
echo $sum
```

## 屏蔽网站访问频察的 IP

iptables 自动屏蔽访问网站频繁的 IP

场景：恶意访问,安全防范

### 屏蔽每分钟访问超过 200 的 IP

方法 1：根据访问日志（Nginx 为例）

```sh
#!/bin/bash
DATE=$(date +%d/%b/%Y:%H:%M)
ABNORMAL_IP=$(tail -n5000 access.log |grep $DATE |awk '{a[$1]++}END{for(i in
a)if(a[i]>100)print i}')

#先tail防止文件过大，读取慢，数字可调整每分钟最大的访问量。awk不能直接过滤日志，因为包含特殊字符。
for IP in $ABNORMAL_IP; do
 if [ $(iptables -vnL |grep -c "$IP") -eq 0 ]; then
   iptables -I INPUT -s $IP -j DROP
 fi
done
```

方法 2：通过 TCP 建立的连接

```sh
#!/bin/bash
# gsub是将第五列（客户端IP）的冒号和端口去掉
ABNORMAL_IP=$(netstat -an |awk '$4~/:80$/ && $6~/ESTABLISHED/{gsub(/:[0-9]+/,"",$5);{a[$5]++}}END{for(i in a)if(a[i]>100)print i}')

for IP in $ABNORMAL_IP; do
 if [ $(iptables -vnL |grep -c "$IP") -eq 0 ]; then
   iptables -I INPUT -s $IP -j DROP
 fi
done
```

### 屏蔽每分钟 SSH 尝试登录超过 10 次的 IP

方法 1：通过 lastb 获取登录状态:

```sh
#!/bin/bash

# 星期月天时分 %e单数字时显示7，而%d显示07
DATE=$(date +"%a %b %e %H:%M")
ABNORMAL_IP=$(lastb |grep "$DATE" |awk '{a[$3]++}END{for(i in a)if(a[i]>10)print
i}')
for IP in $ABNORMAL_IP; do
 if [ $(iptables -vnL |grep -c "$IP") -eq 0 ]; then
   iptables -I INPUT -s $IP -j DROP
 fi
done
```

方法 2：通过日志获取登录状态

```sh
#!/bin/bash
DATE=$(date +"%b %d %H")

ABNORMAL_IP="$(tail -n10000 /var/log/auth.log |grep "$DATE" |awk '/Failed/{a[$(NF-3)]++}END{for(i in a)if(a[i]>5)print i}')"

for IP in $ABNORMAL_IP; do
  if [ $(iptables -vnL |grep -c "$IP") -eq 0 ]; then
    iptables -A INPUT -s $IP -j DROP
    echo "$(date +"%F %T") - iptables -A INPUT -s $IP -j DROP" >> ~/ssh-login-limit.log
 fi
done
```

## Git

```sh
#$1: respositry url
#$2：branch
#$3: tag
#$4: local directory
func_git_check_tag(){
    local url=$1
    local branch=$2
    local tag=$3
    local dir=$4

    if [ ! -e $dir ];then
        func_error_cmd git clone $url $dir
        if [ ! $?  -eq 0 ];then
            func_red_str "Something is wrong in cloning"
            return 1
        fi
    fi

    if [ ! -d $dir ];then
        func_red_str "The local respositry is not a directory"
        return 1
    fi

    local cur=`pwd`
    cd $dir
        func_error_cmd git checkout master
        func_error_cmd git pull
        func_error_cmd git checkout $branch
        func_error_cmd git checkout $tag
        if [ ! $? -eq 0 ];then
            return 1
        fi
    cd $cur
}
```

## 守护进程

```sh
#$1: pidfile
#$2: log file
#$4: commands
func_daemon_cmd(){
    local pidfile=$1
    local stdout="$2.stdout"
    local stderr="$2.stderr"
    shift 2

    $* 1>>$stdout 2>>$stderr &
    local pid=$!
    echo $pid >$pidfile
}

#$1: pid
func_check_pid(){
    ps -p $1 1>/dev/null 2>&1
    if [ $? -eq 0 ];then
        return 0
    fi
    return 1
}

#$1: pid
#$2: pid desc
func_exit_no_pid(){
    func_check_pid  $1
    if [ ! $? -eq 0 ];then
        func_red_str "Pid($1:$2) doesn't exist"
        exit 1
    fi
    return 0
}

#$1: pid file
#$2: log file
#$3: executuable binary file name
#$4: command
func_start_cmd(){
    local pidf=$1
    local logf=$2
    local name=$3
    shift 3
    local cmd=$*

    if [ -e $pidf ];then
        func_red_str "The PID file has already existed, please check: $pidf"
        func_yellow_str "It may be running or hasn't delete the PID file when it was stopped last time"
        exit 1
    fi
    func_daemon_cmd $pidf $logf $cmd
    sleep 1
    func_exit_no_pid `cat $pidf` "[Fail]${name} is not running!"
    if [ $? -eq 0 ];then
        return 0
    fi
}

#$1: pid file
func_stop_cmd(){
    local pidf=$1

    if [ ! -e $pidf ];then
        func_red_str "The PID file doesn't exist': $pidf"
        func_yellow_str "It may be not running"
        exit 1
    fi

    local pid=`cat $pidf`
    if [ "$pid" == "1" ];then
        func_red_str "You are not allowed to stop PID 1 !"
        exit 1
    else
        kill -9 $pid
        rm -rf $pidf
    fi
    return 0
}

#$1: Target executable  file
#$2: Log path
#$3: An config Array's name, the Array must be global. Becareful, Just give Name, not value(no $)
#$4: Other parametes from the command line, [start|stop]
func_service_template_1(){
    local TARGET=$1
    local Logs=$2
    eval config_2334200776=\${$3[@]}
    local cmdline=$4
    CMD="${TARGET} ${config_2334200776[@]}"
    NAME=`basename ${TARGET}`
    PID_FILE="${Logs}/${NAME}.pid"
    LOG_FILE="${Logs}/${NAME}"
    OPERATE="${Logs}/${NAME}.operate"

    start(){
        echo -e "`func_cur_time`: [start] $CMD" >>$OPERATE
        func_start_cmd $PID_FILE $LOG_FILE $NAME $CMD
        if [ $? == 0 ];then
            func_green_str "$TARGET is running"
        fi
    }

    stop(){
        echo -e "`func_cur_time`: [stop]" >>$OPERATE
        func_stop_cmd $PID_FILE
        if [ $? == 0 ];then
            func_red_str "$TARGET is terminated"
        fi
    }

    case $cmdline in
        (start)
            start;;
        (stop)
            stop;;
        (restart)
            stop;start;;
        (*)
            echo "usage: $0 [stop|start|restart]"
    esac
}
```

## 数组

```sh
#$1: sep string
#$2: prefix
#$3: Array's name, the Array must be global. Becareful, Just give Name, not value(no $)
#$4: postfix
func_join_array(){
    local sep=$1
    local prefix=$2
    local postfix=$4
    eval array_doimgaeg3234553=(\${$3[@]})
    local len=${#array_doimgaeg3234553[@]}

    if [ $len -eq 1 ];then
        echo ${prefix}${array_doimgaeg3234553[@]}${postfix}
        return 0
    fi

    local i=0
    local str=${prefix}${array_doimgaeg3234553[$i]}${postfix}
    i=$(($i+1))

    while [ $i -lt $len ]
    do
        str=${str}${sep}${prefix}${array_doimgaeg3234553[$i]}${postfix}
        i=$(($i+1))
    done
    echo $str
    return 0
}

#if value is in array, return 0, else return 1
#$1: value
#$2: Array's name, the Array must be global. Becareful, Just give Name, not value(no $)
func_in_array(){
    eval array_adfadfadfgli3323455=(\${$2[@]})
    for i in ${array_adfadfadfgli3323455[@]}
    do
        if [ $i == $1 ];then
            return 0
        fi
    done
    return 1
}
```

## 更新

```sh
#return 0: the file is updated  1: nothing is changed 2:remote is wrong.
#must checksum by sha1sum
#$1: local version file
#$2: remote version url
#$3: local file path
#$4: remote file url
func_update_file(){
    if [ ! -e $1 ];then
        func_red_str "Can't found Local Version"
        exit 1
    fi

    local lver=`cat $1`
    if [ "$lver" == "" ];then
        func_red_str "Local Version is NULL!"
        exit 1
    fi

    local rver=`curl $2 2>/dev/null |grep -v \<`
    if [ "$rver" == "" ];then
        func_red_str "Can't get Remote Version"
        exit 1
    fi

    if [ "$lver" == "$rver" ];then
        func_green_str "Local Version matches the Remote Version."
        return 1
    fi

    local lfile=$3
    curl -o $lfile  $4 2>/dev/null

    local lsha1=`sha1sum $lfile|awk '{print $1}'`
    local rsha1=`echo $rver|awk '{print $1}'`

    if [ "$lsha1" == "$rsha1" ];then
        func_green_str "The Remote Version file lays: $lfile"
        return 0
    else
        func_red_str "The Remote File dosen't match the Remote Version: $lfile"
        return 2
    fi
}

#$1: local file path
#$2: remote file url
func_replace_lfile(){
    curl -o $1 $2 2>/dev/null
}

#get a file and check the sha1 code
#$1 local file
#$2 file url
#$3 sha1 code url
func_curl_file_sha1(){
    local rsha1=`curl $3 2>/dev/null|grep -v \<|awk '{print $1}'`
    if [ "$rsha1" == "" ];then
        func_red_str "Can't the file sha1 code!"
        return 1
    fi
    curl -o $1 $2
    local lsha1=`sha1sum $1|awk '{print $1}'`

    if [ "$lsha1" == "$rsha1" ];then
        func_green_str "The File lays: $lfile"
        return 0
    else
        func_red_str "The File dosen't match the sha1 code: $1"
        return 2
    fi
}
```

## 交互操作

```sh
#$1: password
#$2...: cmds
func_cmd_need_password(){
    local password=$1
    shift 1
    expect -c "
        spawn $*
        expect {
            \"*password:\" {set timeout 300; send \"${password}\r\";}
            \"*yes/no\" {send \"yes\r\"; exp_continue;}
        }
    expect eof"
}

#$1: VARNAME
#$2: prompt
func_secret_input(){
    echo -n "$2"
    stty -echo
    read $1
    stty echo
    echo ""
}
```

## 随机数

```sh
function TimestampRand()
{
    range=$1
    timestamp=`date +%s%N`
    let res=$timestamp%$range
    echo $res
}

function RandomRand()
{
    range=$1
    let res=$RANDOM%$range
    echo $res
}

function UrandomRand()
{
    range=$1
    rand=`head -200 /dev/urandom | cksum | cut -f1 -d" "`
    let res=$rand%$range
    echo $res
}

function UuidRand()
{
    range=$1
    rand=`cat /proc/sys/kernel/random/uuid| cksum | cut -f1 -d" "`
    let res=$rand%$range
    echo $res
}


function exp()
{
    echo "基于时间戳: `TimestampRand 10`"
    echo "基于\$RANDOM: `RandomRand 10`"
    echo "基于urandom: `UrandomRand 10`"
    echo "基于uuid: `UuidRand 10`"

    str=""
    for i in `seq 1 6`;do
        str="$str`RandomRand 9`"
    done

    echo $str
    echo "字符翻转:"
    echo $str | rev

    echo $str | awk '{for(i=1;i<=length;i++){line=substr($0,i,1)line}}END{print line}'
}

function random_str()
{
  num=8
  [ ! -z $1 ] && num=$1
  base64 /dev/urandom | tr -d '/+' | dd bs=$num count=1 2>/dev/null
}
```

获取随机 8 位字符串：

```sh
# 方法1：
echo $RANDOM |md5sum |cut -c 1-8
# 471b94f2

# 方法2：
openssl rand -base64 4
# vg3BEg==

# 方法3：
cat /proc/sys/kernel/random/uuid |cut -c 1-8
# ed9e032c
```

获取随机 8 位数字：

```sh
# 方法1：
echo $RANDOM |cksum |cut -c 1-8
# 23648321

# 方法2：
openssl rand -base64 4 |cksum |cut -c 1-8
# 38571131

# 方法3：
date +%N |cut -c 1-8
# 69024815
```

## 防火墙

```sh
# 设置 防火墙规则
add_iptables(){
    iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport $1 -j ACCEPT
    iptables -I INPUT -m state --state NEW -m udp -p udp --dport $1 -j ACCEPT
    ip6tables -I INPUT -m state --state NEW -m tcp -p tcp --dport $1 -j ACCEPT
    ip6tables -I INPUT -m state --state NEW -m udp -p udp --dport $1 -j ACCEPT
}
del_iptables(){
    iptables -D INPUT -m state --state NEW -m tcp -p tcp --dport $1 -j ACCEPT
    iptables -D INPUT -m state --state NEW -m udp -p udp --dport $1 -j ACCEPT
    ip6tables -D INPUT -m state --state NEW -m tcp -p tcp --dport $1 -j ACCEPT
    ip6tables -D INPUT -m state --state NEW -m udp -p udp --dport $1 -j ACCEPT
}
save_iptables(){
    if [[ ${release} == "centos" ]]; then
        service iptables save
        service ip6tables save
    else
        iptables-save > /etc/iptables.up.rules
        ip6tables-save > /etc/ip6tables.up.rules
    fi
}
```

## 批量传输文件及执行命令

```sh
#!/bin/bash

username="root"
password="123123"
port="22"

# 判断ip检查文件是否存在
if [ ! -f "./ip_check.txt" ]; then
  # 清空检查文件
  /usr/bin/true >./ip_check.txt
else
  # 创建检查文件
  /usr/bin/touch ./ip_check.txt
fi

# 传输文件
execut_ftp_file() {
  IFS=$'\n'
  for file in $(cat ./ftp_file.conf); do
    /opt/sshpass/bin/sshpass -p $password scp -o StrictHostKeyChecking=no ./$file $username@$1:/opt/
    echo "$1 ---- $file 文件传输完成"
  done
}

execut_commad_file() {
  IFS=$'\n'
  for com in $(cat ./execut_commad.conf); do
    /opt/sshpass/bin/sshpass -p $password ssh -o StrictHostKeyChecking=no $username@$1 $com
    echo "$1 ---------- $com 命令执行完成"
    sleep 3
  done
}

for line in $(cat ./ip.txt); do
  Ture_ip=$(/usr/bin/ping -c 2 $line)
  if [ $? != "0" ]; then
    echo "$line is blocked" >>./ip_check.txt
  else
    execut_ftp_file $line
    sleep 2
    execut_commad_file $line
  fi

done
```

## 下载文件

### 从互联网下载文件

```sh
# 下载文件
# 用于下载文件。如果文件已经存在，则直接返回；
# 如果文件不存在，则尝试下载。下面是详细的解释：
download(){
    local filename=$(basename $1)
    if [ -f ${1} ]; then
        echo "${filename} [found]"
    else
        echo "${filename} not found, download now..."
        wget --no-check-certificate -c -t3 -T60 -O ${1} ${2}
        if [ $? -ne 0 ]; then
            echo -e "[${red}Error${plain}] Download ${filename} failed."
            exit 1
        fi
    fi
}
# 使用示例
# download "/path/to/file.txt" "http://example.com/file.txt"
```

### 从 FTP 服务器下载文件

```sh
#!/bin/bash
if [ $# -ne 1 ]; then
 echo "Usage: $0 filename"
fi
dir=$(dirname $1)
file=$(basename $1)
ftp -n -v << EOF  # -n 自动登录
open 192.168.1.10 # ftp服务器
user admin password
binary  # 设置ftp传输模式为二进制，避免MD5值不同或.tar.gz压缩包格式错误
cd $dir
get "$file"
EOF
```

## 判断用户输入

### 是否是数字

demo1

```sh
# Checks if the argument is an integer.
check_integer() {
  # Input validation.
  if [[ $# -ne 1 ]]; then
    echo "Need exactly one argument, exiting."
    exit 1 # No validation done, exit script.
  fi

  # Check if the input is an integer.
  if [[ $1 =~ ^[[:digit:]]+$ ]]; then
    return 0 # Is an integer.
  else
    return 1 # Is not an integer.
  fi
}
```

demo2

```sh
#!/bin/bash
if [[ $1 =~ ^[0-9]+$ ]]; then
 echo "Is Number."
else
 echo "No Number."
fi
```

demo3

```sh
#!/bin/bash
echo $1 |awk '{print $0~/^[0-9]+$/?"Is Number.":"No Number."}' #三目运算符
```

### 是否 yes-no 检查

```sh
check_yes_no() {
  # Input validation.
  if [[ $# -ne 1 ]]; then
    echo "Need exactly one argument, exiting."
    exit 1 # No validation done, exit script.
  fi

  # Return 0 for yes, 1 for no, exit 2 for neither.
  if [[ ${1,,} = 'y' || ${1,,} = 'yes' ]]; then
    return 0
  elif [[ ${1,,} = 'n' || ${1,,} = 'no' ]]; then
    return 1
  else
    echo "Neither yes or no, exiting."
    exit 2
  fi
}
```

### 是否是 IP 地址

方法 1:

```sh
#!/bin/bash
function check_ip(){
 local IP=$1
 VALID_CHECK=$(echo $IP|awk -F. '$1<=255&&$2<=255&&$3<=255&&$4<=255{print "yes"}')
 if echo $IP|grep -E "^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$">/dev/null; then
   if [ $VALID_CHECK == "yes" ]; then
     echo "$IP available."
   else
     echo "$IP not available!"
   fi
 else
   echo "Format error!"
 fi
}
# check_ip 192.168.1.1
# check_ip 256.1.1.1
```

方法 2：

```sh
#!/bin/bash
function check_ip(){
 IP=$1
 if [[ $IP =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
   FIELD1=$(echo $IP|cut -d. -f1)
   FIELD2=$(echo $IP|cut -d. -f2)
   FIELD3=$(echo $IP|cut -d. -f3)
   FIELD4=$(echo $IP|cut -d. -f4)
   if [ $FIELD1 -le 255 -a $FIELD2 -le 255 -a $FIELD3 -le 255 -a $FIELD4 -le
255 ]; then
     echo "$IP available."
   else
     echo "$IP not available!"
   fi
 else
   echo "Format error!"
 fi
}
# check_ip 192.168.1.1
# check_ip 256.1.1.1
```

增加版：
加个死循环，如果 IP 可用就退出，不可用提示继续输入，并使用 awk 判断。

```sh
#!/bin/bash
function check_ip(){
 local IP=$1
 VALID_CHECK=$(echo $IP|awk -F. '$1<=255&&$2<=255&&$3<=255&&$4<=255{print "yes"}')
 if echo $IP|grep -E "^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$">/dev/null; then
   if [ $VALID_CHECK == "yes" ]; then
     return 0
   else
     echo "$IP not available!"
     return 1
   fi
 else
   echo "Format error! Please input again."
   return 1
 fi
}

while true; do
 read -p "Please enter IP: " IP
 check_ip $IP
 [ $? -eq 0 ] && break || continue
done
```

## Expect 实现 SSH 免交互执行命令

Expect 是一个自动交互式应用程序的工具，如 telnet，ftp，passwd 等。
需先安装 expect 软件包。

方法 1：EOF 标准输出作为 expect 标准输入

```sh
#!/bin/bash
USER=root
PASS=123.com
IP=192.168.1.120
expect << EOF
set timeout 30
spawn ssh $USER@$IP
expect {
 "(yes/no)" {send "yes\r"; exp_continue}
 "password:" {send "$PASS\r"}
}
expect "$USER@*" {send "$1\r"}
expect "$USER@*" {send "exit\r"}
expect eof
EOF
```

方法 2

```sh
#!/bin/bash
USER=root
PASS=123.com
IP=192.168.1.120
expect -c "
 spawn ssh $USER@$IP
 expect {
   \"(yes/no)\" {send \"yes\r\"; exp_continue}
   \"password:\" {send \"$PASS\r\"; exp_continue}
   \"$USER@*\" {send \"df -h\r exit\r\"; exp_continue}
 }"
```

方法 3：将 expect 脚本独立出来

登录脚本：

`login.exp`

```sh
# cat login.exp
#!/usr/bin/expect
set ip [lindex $argv 0]
set user [lindex $argv 1]
set passwd [lindex $argv 2]
set cmd [lindex $argv 3]
if { $argc != 4 } {
  puts "Usage: expect login.exp ip user passwd"
  exit 1
}

set timeout 30
spawn ssh $user@$ip
expect {
   "(yes/no)" {send "yes\r"; exp_continue}
   "password:" {send "$passwd\r"}
}
expect "$user@*" {send "$cmd\r"}
expect "$user@*" {send "exit\r"}
expect eof
```

执行命令脚本：写个循环可以批量操作多台服务器

```sh
#!/bin/bash
HOST_INFO=user_info.txt
for ip in $(awk '{print $1}' $HOST_INFO)
do
 user=$(awk -v I="$ip" 'I==$1{print $2}' $HOST_INFO)
 pass=$(awk -v I="$ip" 'I==$1{print $3}' $HOST_INFO)
 expect login.exp $ip $user $pass $1
done
```

Linux 主机 SSH 连接信息：

```sh
# cat user_info.txt
192.168.1.120 root 123456
```

## 其他

### 自动压缩和解压

```sh
# 自动解压：判断文件后缀名并调用相应解压命令
function q-extract() {
    if [ -f $1 ] ; then
        case $1 in
        *.tar.bz2)   tar -xvjf $1    ;;
        *.tar.gz)    tar -xvzf $1    ;;
        *.tar.xz)    tar -xvJf $1    ;;
        *.bz2)       bunzip2 $1     ;;
        *.rar)       rar x $1       ;;
        *.gz)        gunzip $1      ;;
        *.tar)       tar -xvf $1     ;;
        *.tbz2)      tar -xvjf $1    ;;
        *.tgz)       tar -xvzf $1    ;;
        *.zip)       unzip $1       ;;
        *.Z)         uncompress $1  ;;
        *.7z)        7z x $1        ;;
        *)           echo "don't know how to extract '$1'..." ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
}

# 自动压缩：判断后缀名并调用相应压缩程序
function q-compress() {
    if [ -n "$1" ] ; then
        FILE=$1
        case $FILE in
        *.tar) shift && tar -cf $FILE $* ;;
        *.tar.bz2) shift && tar -cjf $FILE $* ;;
        *.tar.xz) shift && tar -cJf $FILE $* ;;
        *.tar.gz) shift && tar -czf $FILE $* ;;
        *.tgz) shift && tar -czf $FILE $* ;;
        *.zip) shift && zip $FILE $* ;;
        *.rar) shift && rar $FILE $* ;;
        esac
    else
        echo "usage: q-compress <foo.tar.gz> ./foo ./bar"
    fi
}
```

### 获取命令行选项

```sh
while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do case $1 in
  -V | --version )
    echo "$version"
    exit
    ;;
  -s | --string )
    shift; string=$1
    ;;
  -f | --flag )
    flag=1
    ;;
esac; shift; done
if [[ "$1" == '--' ]]; then shift; fi
```

处理命令行参数的一个样例

```sh
while [ "$1" != "" ]; do
    case $1 in
        -s  )   shift
		SERVER=$1 ;;
        -d  )   shift
		DATE=$1 ;;
        --paramter|p ) shift
		PARAMETER=$1;;
        -h|help  )   usage # function call
                exit ;;
        * )     usage # All other parameters
                exit 1
    esac
    shift
done
```

### 使用 while 循环处理文本文件

#### 整行处理

对 while 语句使用输入重定向读取文本文件

```sh
while read -r line; do
  echo "$line"
done < filename
```

将文本文件内容通过管道传给 while 语句

```sh
cat filename |while read line;do
  echo $line
done
```

读取文件使用 for 循环的方式

```sh
#!/bin/bash
for i in `cat users.txt`
do
  #echo "$i"
  id $i &>/dev/null
  if [ "$?" -eq 0 ];then
    echo "$i already exists...."
  else
    echo "add $i .... && create $i...."
  fi
done
```

#### 区分字段处理

对 while 语句使用输入重定向读取文本文件

```sh
while read -r file1 file2 file3; do
  echo $file , $file2 , $file3
done < filename
```

将文本文件内容通过管道传给 while 语句

```sh
cat filename |while read file1 file2 file3 ;do
  echo $file , $file2 , $file3
done
```

代码示例

```sh
##-----------------------整行处理-----------------------------------

# 读取文件方法 1
count=1
cat test | while read line ; do
echo "Line $count: $line"
    count=$[ $count + 1 ]
done
echo "Finished processing the file"

# 读取文件方法 2
#!/bin/bash
while read LINE;do
  NAME=`echo $LINE | awk '{print $1}'`
  AGE=`echo $LINE | awk '{print $2}'`
  Sex=`echo $LINE | awk '{print $3}'`
  echo "My name is $NAME, I'm $AGE years old, I'm a $Sex"
done < student_info.txt



##-----------------------区分字段处理-----------------------------------
#!/bin/sh
file=$1
if [ $# -lt ]; then
    echo "Usage: $0 FILEPATH"
    exit
fi
while read -r f1 f2 f3
do
    echo "Field 1: $f1 ===> Field2:$f2===>Field3:$f3"
done <"$file"
```

### 脚本路径

```sh
# 脚本目录
DIR="${0%/*}"
```

```sh
# 取当前运行脚本绝对路径的示例：（注：Linux 下可以用）
dirname $(readlink -f $0)
```

```sh
set_cwd() {
  cd $(dirname $0)
}
```

### echo 和 printf 打印

```sh
#!/bin/bash
#Version:2.0
function clear1() {
  clear
  echo -e "\033[42m---------------------------------\033[0m"
  echo -e "\e[2;10H这里是菜单\t\t#"
  echo -e "#\e[32m 1.查看网卡信息\e[0m                #"
  echo -e "#\e[33m 2.查看内存信息\e[0m                #"
  echo -e "#\e[34m 3.查看磁盘信息\e[0m                #"
  echo -e "#\e[35m 4.查看CPU信息\e[0m                 #"
  echo -e "#\e[36m 5.查看账户信息\e[0m                #"
  echo -e "\033[42m---------------------------------\033[0m"
  echo
}

function clear2() {
  clear
  printf  "\e[42m%s\n\e[0m" "---------------------------------"
  printf  "\e[2;10H%s\t\t\n" "这里是菜单"
  printf  "\e[32m%s\e[0m\n"  "1.查看网卡信息"
  printf  "\e[35m%s\e[0m\n"  "2.查看内存信息"
  printf  "\e[36m%s\e[0m\n"  "3.查看磁盘信息"
  printf  "\e[34m%s\e[0m\n"  "4.查看CPU信息"
  printf  "\e[33m%s\e[0m\n"  "5.查看账户信息"
  printf  "\e[42m%s\n\e[0m" "---------------------------------"
}

printf "%-5s %-10s %-4s\n" NO Name Mark
printf "%-5s %-10s %-4.2f\n" 01 Tom 90.3456
printf "%-5s %-10s %-4.2f\n" 02 Jack 89.2345
printf "%-5s %-10s %-4.2f\n" 03 Jeff 98.4323
# %-5s 格式为左对齐且宽度为5的字符串代替（-表示左对齐），不使用则是又对齐。
# %-4.2f 格式为左对齐宽度为4，保留两位小数。
```

## 字符串

### 简单的字符串匹配

```sh
match_string () {
  MATCH=0
  NOMATCH=90
  PARAMS=2
  # 此函数需要2个参数.
  BAD_PARAMS=91
  [ $# -eq $PARAMS ] || return $BAD_PARAMS

  case "$1" in
    "$2") return $MATCH;;
    *
    ) return $NOMATCH;;
    esac
}

a=one
b=two
c=three
d=two

match_string $a
echo $? # 参数个数错误.
# 91

match_string $a $b
echo $? # 不匹配
# 90

match_string $b $d
echo $? # 匹配
# 0

exit 0
```

### 大小写转换函数

```sh
# 将字符串转换为全大写
to_upper() {
  echo "$1" | tr '[:lower:]' '[:upper:]'
}

# 将字符串转换为全小写
to_lower() {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

```

### 检查第一个字符是否是字母表上的字符

```sh
# 检查输入的第一个字符是否是字母表上的字符
is_first_char_alpha() {
  first_char="${1:0:1}"
  if [[$first_char =~ [[:alpha:]] ]]; then
    echo "First character is an alphabet"
  else
    echo "First character is not an alphabet"
  fi
}
```

### 测试整个字符串是否都是字母表上的字符

```sh
# 测试整个字符串是否都是字母表上的字符
is_alpha_string() {
  if [[$1 =~ ^[[:alpha:]]+$ ]]; then
    echo "The entire string contains only alphabets"
  else
    echo "The entire string does not contain only alphabets"
  fi
}
```

### 测试整个字符串是否都是数字

```sh
# 测试整个字符串是否都是数字
is_numeric_string() {
  if [[$1 =~ ^[[:digit:]]+$ ]]; then
    echo "The entire string contains only digits"
  else
    echo "The entire string does not contain only digits"
  fi
}
```

### 获取字符串长度

```sh
string_length() {
    echo ${#1}
}
```

### 反转字符串

```sh
reverse_string() {
    echo "$1" | rev
}
```

### 检查字符串包含特定子字符串

```sh
contains_substring() {
    if [[ $1 == *"$2"* ]]; then
        echo "String contains '$2'"
    else
        echo "String does not contain '$2'"
    fi
}
```

### 将字符串拆分为数组

```sh
split_string_to_array() {
    IFS=' ' read -r -a array <<< "$1"
    for element in "${array[@]}"; do
        echo "$element"
    done
}
```

## 进度条

```sh
#!/bin/bash

# 进度条函数
progress_bar() {
    local total_steps=$1
    local step_name=$2
    local current_step=0

    # 控制台最上方显示大纲名称，并添加闪烁效果
    echo -ne "\033[5mProgress: $step_name\033[0m"

    # 初始化进度
    local progress=0
    echo

    # 模拟执行
    while [ $current_step -lt $total_steps ]; do
        # 更新进度条
        progress=$((current_step * 100 / total_steps))
        printf "\r[%-${total_steps}s] %d%%" "$(printf "#%.0s" $(seq 1 $current_step))" "$progress"

        # 模拟执行内容
        echo -ne " Step $((current_step + 1))/$total_steps: Executing...\033[K"

        ((current_step++))

        # 模拟执行时间
        sleep 0.1
    done

    # 完成后显示完成信息，并以绿色显示
    echo -e "\nStep $total_steps/$total_steps: $step_name \t[ \033[32m完成\033[0m ]"
}

# 测试进度条函数
progress_bar 20 "Process A"
```

```sh
#!/bin/bash
[[ -n $DEBUG ]] && set -x
set -o errtrace # Make sure any error trap is inherited
set -o nounset  # Disallow expansion of unset variables
set -o pipefail # Use last non-zero exit code in a pipeline

# 初始化变量
STEP_COUNT=5 # 总步骤数
CURRENT_STEP=1

# 显示标题的函数
function display_title() {
  echo -e "\e[1mInstalling Software Package...\e[0m" # 加粗标题
}

# 进度条函数
function update_progress_bar() {
  local PROGRESS=$((CURRENT_STEP * 100 / STEP_COUNT))
  local TITLE="["
  local BAR=""
  local END="] $PROGRESS%"

  # 构建进度条
  for ((i = 0; i < 20; i++)); do
    if [[ $((i * STEP_COUNT / 20)) -lt CURRENT_STEP ]]; then
      BAR+="="
    else
      BAR+=" "
    fi
  done

  # 添加颜色和样式
  echo -ne "\r\033[K$TITLE\e[32m$BAR\e[0m$END"
  # if [[ $CURRENT_STEP == $STEP_COUNT ]]; then
  #   echo -e "\n" # 在最后一次更新后换行输出
  # fi
}

# 步骤函数示例
function step() {
  local DESCRIPTION=$1
  local DELAY=$2
  echo -e "$DESCRIPTION"
  update_progress_bar
  ((CURRENT_STEP++))
  sleep $DELAY
  echo -e " \e\t[32m[✔]\e[0m" # 显示绿色的勾表示完成
}

# 主安装函数
function install_with_steps() {
  display_title
  step "Step 1: Setting up environment..." 1

  step "Step 2: Downloading package..." 1

  step "Step 3: Verifying package integrity..." 1

  step "Step 4: Installing dependencies..." 1

  step "Step 5: Finalizing installation..." 1
  echo
  # 闪烁显示
  echo -ne "\033[5mProgress:Installation finished successfully.\033[0m"
  echo
}

# 调用主安装函数
install_with_steps
```

### bash 实现动态进度条

通过符号#填充[ ]完成进度

```sh
#!/bin/bash
i=0
str=""
arry=("\\" "|" "/" "-")
while [ $i -le 100 ]
do
    let index=i%4
    printf "[%-100s] %d %c\r" "$str" "$i" "${arry[$index]}"
    sleep 0.1
    let i=i+1
    str+="#"
done
echo ""
```

高级玩法

https://github.com/Cocean001/progress_bar_shell

## ini 配置读取

```sh
#!/bin/bash
#
# Introduction
# ------------
#
# Functions for parsing INI-style file natively in bash.
#
# The INI file format supports the following features:
#
# Sections:   [section]
# Properties: name=value
# Comments:   ; comment
#             # comment
#
# Blank lines and trailing writespace are ignored as is whitespace around
# the '=' - ie.
#
#    name  =  value
#
# is equivalent to
#
#    name=value
#
# Whitespace and quotes within a value are preserved (though values don't
# in general need to be quoted and will not be subject to shell parameter
# splitting)
#
# Values can be continuted onto subsequent lines if these are prefixed with
# whitespace - ie.
#
#    name=line1
#         line2
#
# is equivalent to:
#
#    name = line1 line2
#
# Properties are stored in the global _CONFIG array as ( k1 v1 k2 v2 ... ) with
# keys in the format "<section>.<name>" (properties without an associated
# section are stored as ".<name>". In most cases this is transparent as the
# list/get commands can be used to query the data
#
# The functionality is more or less equivalent to the Python ConfigParser
# module with the following exceptions
#
# - Properties are allowed outside sections
# - Multi-line properties are joined with ' ' rather than '\n' (due to shell
#   quoting issues)
#
# Usage
# -----
#
# Given the following ini file (test.ini) -
#
#   ; A test ini file
#   global = a global value
#   [section1]
#   abc = def ; a comment
#   ghi = jkl
#   [section2]
#   xyz = abc ; extends over two lines
#         def
#
# Parse config file -
#
# $ parseIniFile < test/t2.ini
#
# $ listKeys
# .global
# section1.abc
# section1.ghi
# section2.xyz
#
# $ listAll
# .global a global value
# section1.abc def
# section1.ghi jkl
# section2.xyz abc def
#
# $ listSection section1
# section1.abc def
# section1.ghi jkl
#
# $ getProperty global
# a global value
#
# $ getProperty section2.xyz
# abc def
#
# $ getPropertyVar XYZ section2.xyz && echo OK
# OK
#
# $ echo ">${XYZ}<"
# >abc def<
#

shopt -s extglob

_CONFIG=()

# Commands
# --------
#
# parseIniFile < file
#
#   Parse ini file (reads from stdin) and saves data to global _CONFIG var
#

function parseIniFile() {

    local LINE=""
    local SECTION=""
    local KEY=""
    local VALUE=""

    local IFS=""

    while read LINE
    do
        LINE=${LINE%%[;#]*}                             # Strip comments
        LINE=${LINE%%*( )}                              # Strip trailing whitespace

        if [[ -n $KEY && $LINE =~ ^[[:space:]]+(.+) ]]  # Continuation - append value
        then
            VALUE+=" ${BASH_REMATCH[1]}"
        else
            if [[ -n $KEY ]]                            # No continuation
            then
                _CONFIG=(${_CONFIG[@]} "${SECTION}.${KEY}" "${VALUE}")
                KEY=""
                VALUE=""
            fi

            if [[ $LINE =~ ^\[([[:alnum:]]+)\] ]]       # Section
            then
                SECTION=${BASH_REMATCH[1]}
                KEY=""
            elif [[ $LINE =~ ^([^[:space:]]+)[[:space:]]*=[[:space:]]*(.+) ]] # Property
            then
                KEY=${BASH_REMATCH[1]}
                VALUE="${BASH_REMATCH[2]}"
            fi
        fi
    done

    if [[ -n $KEY ]]
    then
        _CONFIG=(${_CONFIG[@]} "${SECTION}.${KEY}" "${VALUE}")
    fi
}

# listKeys
#
#   List keys present in config file in format "<section>.<property>"
#

function listKeys() {
    local -i i
    for ((i=0; i<${#_CONFIG[@]}; i+=2))
    do
        echo ${_CONFIG[i]}
    done
}

# listAll
#
#   List keys and data in format "<section>.<property> <value>"
#

function listAll() {
    local -i i
    for ((i=0; i<${#_CONFIG[@]}; i+=2))
    do
        echo ${_CONFIG[i]} ${_CONFIG[((i+1))]}
    done
}

# listSection <section>
#
#   List keys and data for given section (sepcified as $1) in format
#   "<property> <value>"
#

function listSection() {
    local -i i
    local SECTION=$1
    for ((i=0; i<${#_CONFIG[@]}; i+=2))
    do
        if [[ ${_CONFIG[$i]} =~ ^${SECTION}\.(.+) ]]
        then
            echo ${_CONFIG[i]} ${_CONFIG[((i+1))]}
        fi
    done
}

# getProperty [name|section.name]
#
#   Print value for given property (sepcified as $1)
#   Properties without a section can be queried directly as
#   "name" (rather than ".name")
#
#   Returns 0 (true) if property found otherwise 1 (false)
#

function getProperty() {
    local -i i
    local KEY=$1
    for ((i=0; i<${#_CONFIG[@]}; i+=2))
    do
        if [[ ${_CONFIG[$i]} =~ ^\.?${KEY} ]]
        then
            echo ${_CONFIG[((i+1))]}
            return 0
        fi
    done
    return 1
}

# getPropertyVar <variable> [name|section.name]
#
#   Save value for given property (sepcified as $2)
#   into shell variable (specified as $1)
#   Properties without a section can be queried directly as
#   "name" (rather than ".name")
#
#   Returns 0 (true) if property found otherwise 1 (false)
#

function getPropertyVar() {
    local -i i
    local VAR=$1
    local KEY=$2
    for ((i=0; i<${#_CONFIG[@]}; i+=2))
    do
        if [[ ${_CONFIG[$i]} =~ ^\.?${KEY} ]]
        then
            local VAL=${_CONFIG[((i+1))]}
            eval ${VAR}="\${VAL}"
            return 0
        fi
    done
    return 1
}

function testIniParser() {
    echo $ parseIniFile \< test/t2.ini
    parseIniFile < test/t2.ini
    echo $ listKeys
    listKeys
    echo $ listAll
    listAll
    echo $ listSection section1
    listSection section1
    echo $ getProperty global
    getProperty global
    echo $ getProperty section2.xyz
    getProperty section2.xyz
    echo $ getPropertyVar XYZ section2.xyz \&\& echo OK
    getPropertyVar XYZ section2.xyz && echo OK
    echo $ echo ">\${XYZ}<"
    echo ">${XYZ}<"
}

```

`readini.sh`

```sh
#!/bin/bash

file=$1;section=$2;var=$3
var_value=`awk -F '=' '/\['$section'\]/{a=1}a==1&&$1~/^'$var'/{print $2;exit}' $file`
echo $var_value
```

## centos 初始化

```sh
#!/bin/bash

set -e

if [ "$(id -u)" -ne 0 ]; then
    echo "当前用户不是管理员。请使用管理员权限运行此脚本。"
    exit 1
fi

echo "========start============="

function setup_selinux_firewalld() {

    echo "========selinux==========="
    sed -i '/SELINUX/s/enforcing/disabled/' /etc/selinux/config
    setenforce 0

    echo "========firewalld========="
    iptables -F
    systemctl disable --now firewalld

}

function setup_format_history() {

    echo "========history format========"
    cat > /etc/profile.d/history_conf.sh << 'EOF'
export HISTFILE="$HOME/.bash_history"  # 写入文件
export HISTSIZE=1000  # history输出记录数
export HISTFILESIZE=10000  # HISTFILE文件记录数
export HISTIGNORE="cmd1:cmd2:..."  # 忽略指定cmd1,cmd2...的命令不被记录到文件；(加参数时会记录)
export HISTCONTOL=ignoredups   # ignoredups 不记录“重复”的命令；连续且相同 方为“重复”
export PROMPT_COMMAND="history -a"  # 设置每条命令执行完立即写入HISTFILE(默认等待退出会话写入)
export HISTTIMEFORMAT="$(whoami) %F %T "  # 设置命令执行时间格式，记录文件增加时间戳
shopt -s histappend  # 防止会话退出时覆盖其他会话写到HISTFILE的内容
EOF

    source /etc/profile.d/history_conf.sh

}

function setup_ssh() {

    echo "========add ssh key========"
    mkdir /root/.ssh || true
    chmod 700 /root/.ssh
    cat > /root/.ssh/authorized_keys << 'EOF'
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCeQZmPg93SNx6zzR/l4RiPnHtFPbDTSOL7AtJOIvrlMm300x1OM8a48VqYuKEx7B7WM7UhszVndg8efJv9UdOtOaa0o8L0Wd2uujn2rFKKok69c5i7c/jmU1my9MkEsKpkx1MHQWVZTFqayv/DB9L5GaE/ShChsTSlXoQ6rc6JC4k1zgSsoNSTLwPrbZcDOZWprt/AOhqCklf9mL1E50WTx9XsjxBLqJIwwVEzmHAhzIiVowjBKjJpQ6hEvygCz67gNVn0vAvHPvCz3amrkCQa333Z9r8tbY7mJpq2Anj4qWtlnL9kHreVK6YoKGvM8+DrbVoT5/zM7wMZ+tdLmreUsu4OhgDkE4IgUMHWQ3T1GyD1EjCkqCdSfJbrLaAR8v7g92uDXO5irIyYMc/iQJ8v4okus9Iid61zFF0SPgZEykOVfT7jJqH0a/630D41uD0TK90v5PicVdh1FfEfok8P4F4UHGLUly2jRVBESQ/TXVGPaMITHPEtYEpmT3kmnOk= 15810243114@163.com
EOF
    chmod 600 /root/.ssh/authorized_keys

    echo "=========setup ssh========"
    echo "UseDNS no" >> /etc/ssh/sshd_config

}

function setup_yum() {

    echo "====backup repo==========="
    mkdir /etc/yum.repos.d/bak || true
    mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak/ || true

    echo "====configure tuna repo===="
    cat > /etc/yum.repos.d/centos-tuna.repo << 'EOF'
[base]
name=CentOS-$releasever - Base
baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/
gpgcheck=0

[updates]
name=CentOS-$releasever - Updates
baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/
gpgcheck=0

[extras]
name=CentOS-$releasever - Extras
baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/
gpgcheck=0

EOF

    echo "====upgrade yum============"
    yum clean all
    yum makecache fast

    echo "====dowload tools========="
    yum install -y wget net-tools vim bash-completion ntpdate

}

function setup_time_limit() {

    echo "=======setup timezone and ntp======"
    timedatectl set-timezone Asia/Shanghai
    ntpdate time.windows.com

    echo "=======modify limit========="
    cat >> /etc/security/limits.conf << 'EOF'
* soft nofile 65535
* hard nofile 65535
* soft nproc 65535
* hard nproc 65535
EOF

}

function setup_kernel() {

    echo "========Optimize kernel========"
    cat >> /etc/sysctl.d/99-sysctl.conf << 'EOF'
# 关闭ipv6
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1

# 避免放大攻击
net.ipv4.icmp_echo_ignore_broadcasts = 1

# 开启恶意icmp错误消息保护
net.ipv4.icmp_ignore_bogus_error_responses = 1

# 开启反向路径过滤
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1

# 关闭sysrq功能
kernel.sysrq = 0

# core文件名中添加pid作为扩展名
kernel.core_uses_pid = 1
net.ipv4.tcp_syncookies = 1

# 修改消息队列长度
kernel.msgmnb = 65536
kernel.msgmax = 65536

# 设置最大内存共享段大小bytes
kernel.shmmax = 68719476736
kernel.shmall = 4294967296

# timewait的数量，默认180000
net.ipv4.tcp_max_tw_buckets = 6000
net.ipv4.tcp_sack = 1
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_rmem = 4096        87380   4194304
net.ipv4.tcp_wmem = 4096        16384   4194304
net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.core.netdev_max_backlog = 262144

# 限制仅仅是为了防止简单的DoS 攻击
net.ipv4.tcp_max_orphans = 3276800

# 收到客户端确认信息的连接请求的最大值
net.ipv4.tcp_max_syn_backlog = 262144
net.ipv4.tcp_timestamps = 0

# 内核放弃建立连接之前发送SYNACK 包的数量
net.ipv4.tcp_synack_retries = 1

# 内核放弃建立连接之前发送SYN 包的数量
net.ipv4.tcp_syn_retries = 1

# 启用timewait 快速回收
net.ipv4.tcp_tw_recycle = 1

# 开启重用。允许将TIME-WAIT sockets 重新用于新的TCP连接
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_mem = 94500000 915000000 927000000
net.ipv4.tcp_fin_timeout = 1

# 当keepalive 起用的时候，TCP 发送keepalive 消息的频度。缺省是2 小时
net.ipv4.tcp_keepalive_time = 30

# 修改防火墙表大小，默认65536
#net.netfilter.nf_conntrack_max=655350
#net.netfilter.nf_conntrack_tcp_timeout_established=1200

EOF

    sysctl -p

}

setup_selinux_firewalld
setup_format_history
setup_ssh
setup_yum
setup_time_limit
setup_kernel

echo "=========finish============"

exit 0
```

## 使用 shell 脚本基于 kubeadmin 一键安装 kubernetes 高可用集群和 addon 组件

- https://github.com/lework/kainstall.git

## 用于检查 deployment 的所有 pod 是否就绪的 kubectl 插件

- https://github.com/lework/kubectl-check.git

## kainstall 安装程序的离线包

- https://github.com/lework/kainstall-offline.git

## 一个逗比写的各种逗比脚本

- https://github.com/ToyoDAdoubi/doubi.git
