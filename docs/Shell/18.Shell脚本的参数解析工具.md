# 18.Shell 脚本的参数解析工具

## 1.简单 demo

该脚本是一个简单的命令行工具，可以通过命令行参数来指定不同的选项。

```shell
#!/bin/bash

version="1.0.0"
string=""
flag=0

while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do
case $1 in
  -V | --version )
    echo $version
    exit
    ;;
  -s | --string )
    shift; string=$1
    ;;
  -f | --flag )
    flag=1
    ;;
esac;
shift; # shift n 表示把第n+1个参数移到第1个参数, 即命令结束后$1的值等于$n+1的值
done


echo $string
echo $flag
```

其中 [options] 是您要传递给脚本的选项。下面是该脚本支持的选项说明：

```shell
-V 或 --version: 显示版本信息并退出脚本。
-s 或 --string: 指定一个字符串作为参数，并将其赋值给变量 string。
-f 或 --flag: 设置一个标志变量 flag
```

使用

```shell

./script.sh -V      # 显示版本信息
./script.sh -s hello  # 指定字符串参数为 "hello"
./script.sh -f       # 设置标志变量 flag
./script.sh -s world -f  # 指定字符串参数为 "world" 并设置标志变量 flag

```

## 2.使用空格分隔

实际用法

```shell
./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts
```

实现脚本

```shell

#!/bin/bash
POSITIONAL=()
while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    -e|--extension)
      EXTENSION="$2"
      shift # past argument
      shift # past value
      ;;
    -s|--searchpath)
      SEARCHPATH="$2"
      shift # past argument
      shift # past value
      ;;
    -l|--lib)
      LIBPATH="$2"
      shift # past argument
      shift # past value
      ;;
    --default)
      DEFAULT=YES
      shift # past argument
      ;;
      *)
    POSITIONAL+=("$1") # save it in an array for later
      shift # past argument
      ;;
  esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters
echo FILE EXTENSION  = "${EXTENSION}"
echo SEARCH PATH     = "${SEARCHPATH}"
echo LIBRARY PATH    = "${LIBPATH}"
echo DEFAULT         = "${DEFAULT}"
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
if [[ -n $1 ]]; then
  echo "Last line of file specified as non-opt/last argument:"
  tail -1 "$1"
fi
```

image_help.sh

一个图形转换脚本

```sh
#!/bin/bash
#文件名：image_help.sh
#用途:图像管理脚本
if [ $# -ne 4 -a $# -ne 6 -a $# -ne 8 ];
then
	echo Incorrect number of arguments
	exit 2
fi

while [ $# -ne 0 ];
do
	case $1 in
		-source) shift; source_dir=$1 ; shift ;;
		-scale) shift; scale=$1 ; shift ;;
		-percent) shift; percent=$1 ; shift ;;
		-dest) shift ; dest_dir=$1 ; shift ;;
		-ext) shift ; ext=$1 ; shift ;;
		*) echo Wrong parameters; exit 2 ;;
	esac;
done

for img in `echo $source_dir/*` ;
do
	source_file=$img

	if [[ -n $ext ]];
	then
		dest_file=${img%.*}.$ext
	else
		dest_file=$img
	fi

	if [[ -n $dest_dir ]];
	then
		dest_file=${dest_file##*/}
		dest_file="$dest_dir/$dest_file"
	fi

	if [[ -n $scale ]];
	then
		PARAM="-resize $scale"
	elif [[ -n $percent ]]; then
		PARAM="-resize $percent%"
	fi

	echo Processing file : $source_file
	convert $source_file $PARAM $dest_file
done
```

```sh
# 以下是一个示例输出，将目录sample_dir中的图像缩放到20%大小：
$ ./image_help.sh -source sample_dir -percent 20%
Processing file :sample/IMG_4455.JPG
Processing file :sample/IMG_4456.JPG
Processing file :sample/IMG_4457.JPG
Processing file :sample/IMG_4458.JPG

# 为了将图像缩放到宽度 1024，请使用：
$ ./image_help.sh -source sample_dir –scale 1024x

# 将文件更改为 PNG 格式，方法是在上述命令中添加-ext png。
# 按照以下方式指定目标目录来缩放或转换文件：
$ ./image_help.sh -source sample -scale 50% -ext png -dest newdir
# newdir is the new destination directory
```

### getopt

我们可以在脚本中使用 getopt 命令来格式化脚本所携带的任何命令行选项或参数，但用起来略显复杂。
难点在于要使用 getopt 命令生成的格式化版本替换已有的命令行选项和参数。这得求助于 set 命令。

set 命令有一个选项是双连字符（ -- ），可以将位置变量的值替换成 set 命令所指定的值。

具体做法是将脚本的命令行参数传给 getopt 命令，然后再将 getopt 命令的输出传给 set 命令，用 getopt 格式化后的命令行参数来替换原始的命令行参数，如下所示：

```sh
set -- $(getopt -o -q ab:cd "$@")
```

现在，位置变量原先的值会被 getopt 命令的输出替换掉，后者已经为我们格式化好了命令行参数。

利用这种方法，就可以写出处理命令行参数的脚本了：

```sh
#!/bin/bash
# Extract command-line options and values with getopt
#
set -- $(getopt -q ab:cd "$@")
#
echo
while [ -n "$1" ]
do
  case "$1" in
    -a) echo "Found the -a option" ;;
    -b) param=$2
      echo "Found the -b option with parameter value $param"
      shift;;
    -c) echo "Found the -c option" ;;
    --) shift
      break;;
    *) echo "$1 is not an option" ;;
  esac
shift
done
#
echo
count=1
for param in $@;do
  echo "Parameter #$count: $param"
  count=$[ $count + 1 ]
done
exit
```

```sh
$ ./extractwithgetopt.sh -c -d -b BValue -a test1 test2
Found the -c option
-d is not an option
Found the -b option with parameter value 'BValue'
Found the -a option
Parameter #1: 'test1'
Parameter #2: 'test2'
```

- register_exporter_with_metadata.sh

```sh
#!/bin/bash

show_usage="args: [-i , -n , -a , -p, -t, -c, m]\n[--id=atompi_node, --name=atompi_node, --address=atompi, --port=9100, --tags='\"node_exporter\"', --consul=consul:8500, --meta='\"meta\":{\"module\":\"http_2xx\",\"target\":\"https://baidu.com\"}']"

id=""
name=""
address=""
port=""
tags=""
consul=""
meta=""

GETOPT_ARGS=`getopt -o i:n:a:p:t:c:m: -al id:,name:,address:,port:,tags:,consul:,meta: -- "$@"`

eval set -- "$GETOPT_ARGS"

while [ -n "$1" ]
do
    case "$1" in
        -i|--id) id=$2; shift 2;;
        -n|--name) name=$2; shift 2;;
        -a|--address) address=$2; shift 2;;
        -p|--port) port=$2; shift 2;;
        -t|--tags) tags=$2; shift 2;;
        -c|--consul) consul=$2; shift 2;;
        -m|--meta) meta=$2; shift 2;;
        --) break ;;
        *) echo $1,$2,$show_usage; break ;;
    esac
done

if [[ -z $id || -z $name || -z $address || -z $port || -z $tags || -z $consul ]]; then
    echo -e $show_usage
    echo "id: $id , name: $name , address: $address , port: $port , tags: $tags , consul: $consul , meta: $meta"
    exit 0
else
    curl -X PUT -d '{"id": "'"$id"'","name": "'"$name"'","address": "'"$address"'","port": '"$port"',"tags": ['"$tags"'],"checks": [{"http": "http://'"$address"':'"$port"'/","interval": "5s"}],'"$meta"'}' "http://$consul/v1/agent/service/register"
fi

```

- deregister_exporter.sh

```sh
#!/bin/bash

show_usage="args: [-n , -c] [--name=atompi-node, --consul=consul:8500]"

name=""
consul=""

GETOPT_ARGS=`getopt -o n:c: -al name:,consul: -- "$@"`

eval set -- "$GETOPT_ARGS"

while [ -n "$1" ]
do
    case "$1" in
        -n|--name) name=$2; shift 2;;
        -c|--consul) consul=$2; shift 2;;
        --) break ;;
        *) echo $1,$2,$show_usage; break ;;
    esac
done

if [[ -z $name || -z $consul ]]; then
    echo -e $show_usage
    echo "name: $name , consul: $consul"
    exit 0
else
    curl --request PUT "http://$consul/v1/agent/service/deregister/$name"
fi
```

使用`set -- $@`方法将命令行参数传递给 Shell 脚本，并利用这些参数发送 curl 的 GET 或 POST 请求来注册 node-export 信息到 Consul。以下是一个示例脚本：

```sh
#!/bin/bash

# 检查命令行参数数量
if [ $# -ne 5 ]; then
    echo "Usage: $0 <consul_address> <node_name> <node_address> <node_port> <request_type>"
    exit 1
fi

# 将命令行参数传递给脚本
set -- "$@"

# 从命令行参数中获取Consul地址、节点名称、节点地址、节点端口和请求类型
consul_address=$1
node_name=$2
node_address=$3
node_port=$4
request_type=$5

# 构造注册信息
registration_data='{
  "ID": "'"$node_name"'",
  "Name": "node-export",
  "Address": "'"$node_address"'",
  "Port": '"$node_port"'
}'

# 发送注册请求到Consul
if [ "$request_type" == "get" ]; then
    curl -X GET "$consul_address/v1/agent/members"
elif [ "$request_type" == "post" ]; then
    curl -X PUT -d "$registration_data" "$consul_address/v1/agent/service/register"
else
    echo "Invalid request type. Please choose either 'get' or 'post'."
    exit 1
fi
```

将脚本保存为 `register_node_export.sh`。

在命令行中执行脚本，并传递 Consul 地址、节点名称、节点地址、节点端口以及请求类型（get 或 post）作为参数。

- 对于 GET 请求，使用命令格式：`./register_node_export.sh <consul_address> <node_name> <node_address> <node_port> get`

- 对于 POST 请求，使用命令格式：`./register_node_export.sh <consul_address> <node_name> <node_address> <node_port> post`

## 3.使用等号分隔

实际用法

```shell
./myscript.sh -e=conf -s=/etc -l=/usr/lib /etc/hosts
```

实现脚本

```shell
#!/bin/bash
for key in "$@"; do
  case $key in
    -e=*|--extension=*)
      EXTENSION="${key#*=}"
      shift # past argument=value
      ;;
    -s=*|--searchpath=*)
      SEARCHPATH="${key#*=}"
      shift # past argument=value
      ;;
    -l=*|--lib=*)
      LIBPATH="${key#*=}"
      shift # past argument=value
      ;;
    --default)
      DEFAULT=YES
      shift # past argument with no value
      ;;
    *)
      ;;
  esac
done
echo "FILE EXTENSION  = ${EXTENSION}"
echo "SEARCH PATH     = ${SEARCHPATH}"
echo "LIBRARY PATH    = ${LIBPATH}"
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
if [[ -n $1 ]]; then
  echo "Last line of file specified as non-opt/last argument:"
  tail -1 $1
fi

```

## 4.使用 getopts 工具

getopts 是一个解析脚本选项参数的工具。

命令格式：`getopts optstring name [arg]`

初次使用你要注意这几点：

```sh
1）脚本位置参数会与 optstring 中的单个字母逐个匹配，如果匹配到就赋值给 name，否则赋值 name为问号；

2）optstring 中单个字母是一个选项，如果字母后面加冒号，表示该选项后面带参数，参数值并会赋值给 OPTARG 变量；

3）optstring 中第一个是冒号，表示屏蔽系统错误（test.sh: illegal option -- h）；

4）允许把选项放一起，例如-ab
```

### deamo1

实现脚本

```shell
#!/bin/sh
# 重置以防止在前面的shell中使用getopts工具(这是一个POSIX变量)
OPTIND=1
# 初始化变量名称
OUTPUT_FILE=""
VERSION=0
# getopts的缺点就是它只能处理短选项，如-h，而不能是--help格式
while getopts "h?vf:" key; do
    case "$key" in
    h|\?)
        show_help
        exit 0
        ;;
    v)
        VERSION=1
        ;;
    f)
        output_file=$OPTARG
        ;;
    esac
done
shift $((OPTIND-1))
[ "${1:-}" = "--" ] && shift
echo "verbose=$VERSION, output_file='$output_file', Leftovers: $@" |

```

实际用法

```sh
./myscript.sh -h
./myscript.sh -v -f
```

### deamo2

```sh
#!/usr/bin/env bash
vflag=off
filename=""
output=""

function usage() {
    echo "USAGE"
    echo    "    myscript [-h] [-v] [-f <filename>] [-o <filename>]"
    exit -1
}

# 在while循环中使用getopts解析命令行选项
# 要解析的的选项有-h、-v、-f和-o，其中-f和-o选项带有参数
# 字符串选项中第一个冒号表示getopts使用抑制错误报告模式
while getopts :hvf:o: opt; do
    case "$opt" in
    v)
       vflag=on
       ;;
    f)
        # 将-f选项的参数赋值给变量filename       
        filename=$OPTARG
        # 如果文件不存在，则显示提示信息，并退出脚本的执行       
        if [ ! -f $filename ]
        then
            echo "The source file $filename doesn't exist!"
            exit
        fi
       ;;
    o)
        output=$OPTARG
        if [ ! -d `dirname $output` ]; then
            echo "The output path `dirname $output` doesn't exist!"
            exit
        fi
       ;;
    h)
        # 显示脚本的使用信息
        usage
        exit
       ;;
    :)
        # 如果没有为需要参数的选项指定参数，则显示提示信息，并退出脚本的运行       
        echo "The option -$OPTARG requires an argument."
        exit 1
        ;;
    ?)
        echo "Invalid option: -$OPTARG"
        usage
        exit 2
        ;;
    esac
done
```

### deamo3

下面写一个打印文件指定行的简单例子，用于引导你思路，扩展你的脚本选项功能：

```sh
#!/bin/bash
NO_ARGS=0
E_OPTERROR=65

function usage() {
  echo "Usage: $0 -f <file_path> -n <line_number>"
  echo "-f, --file specified file"
  echo "-n, --line-number print specified line"
  exit $E_OPTERROR
}

[[ $# -eq $NO_ARGS ]] && usage

if [[ "$*" != *"-f"* || "$*" != *"-n"* ]]; then
  usage
fi

while getopts :f:n: option; do
  case $option in
  f)
    FILE=$OPTARG
    [ ! -f $FILE ] && echo "$FILE File not exist!" && exit
    ;;
  n)
    sed -n "${OPTARG}p" $FILE
    ;;
  ?) usage ;;
  esac
done
```

### deamo4

批量修改文件名

```sh
#!/bin/bash

printHelp ()
{
  echo "Usage: $0 -f find -r replace FILES_TO_RENAME*"
  echo -e "\t-f The text to find in the filename"
  echo -e "\t-r The text used to replace with in the filename"
  exit 1
}

while getopts "f:r:" opt; do
  case "$opt" in
    r ) replace="$OPTARG"    ;;
    f ) fnd="$OPTARG"        ;;
    ? ) printHelp            ;;
  esac
done

shift $(( $OPTIND - 1 ))

if [ -z $replace ] || [ -z $fnd ]
then
  echo "Need a string to find and a string to replace";
  printHelp
fi

for i in $@
do
  newname=$(echo $i | sed "s/$fnd/$replace/")
  mv $i $newname
  echo "Renamed file $i to $newname"
done
```

shell 命令行参数解析工具：getopts

- https://www.orchome.com/1327

getopt(s)：命令行选项、参数处理

- https://www.haxi.cc/archives/getopts-getopt.html

## 5.使用 argbash 工具

这个工具主要提供脚本参数的解析功能，而且不再引用任何第三方库的情况下。一般会比普通脚本多 30 多行而且，但是效果非常好。
详细信息可以通过官方网站地址了解。

https://argbash.io/generate#results

```shell
#!/bin/bash
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
# [可选参数]
# ARG_OPTIONAL_SINGLE([option], [o], [optional argument help msg])
# [可选布尔参数]
# ARG_OPTIONAL_BOOLEAN([print], , [boolean optional argument help msg])
# [固定参数]
# ARG_POSITIONAL_SINGLE([positional-arg], [positional argument help  msg], )
# [帮助信息]
# ARG_HELP([The general script's help msg])
# ARGBASH_GO
# [ <-- needed because of Argbash
echo "Value of --option: $_arg_option"
echo "print is $_arg_print"
echo "Value of positional-arg: $_arg_positional_arg"
# ] <-- needed because of Argbash |

```

## 6.使用 getopt 命令

```sh
#!/bin/bash
function usage() {
  cat <<EOF
Usage: $0 [options]

Options:
  -h, --help     Display this help message
  -v, --version  Display version information
  -f, --file     Specify the input file
  -t, --type     Specify the type of operation
EOF
}

# 检查是否有参数传入
if [ $# -eq 0 ]; then
  usage
  exit 1
fi

# 定义选项
SHORT_OPTS="h,v,f:,t:"
LONG_OPTS="help,version,file:,type:"

# 解析选项
PARSED_OPTS=$(getopt --options $SHORT_OPTS --longoptions $LONG_OPTS --name "$0" -- "$@")

# 如果解析失败，打印错误信息并退出
if [ $? -ne 0 ]; then
  usage >&2
  exit 2
fi

# 设置选项变量
eval set -- "$PARSED_OPTS"

# 处理选项
while true; do
  case "$1" in
  -h | --help)
    usage
    exit 0
    ;;
  -v | --version)
    echo "Version 2.0"
    exit 0
    ;;
  -f | --file)
    FILE="$2"
    shift 2
    ;;
  -t | --type)
    TYPE="$2"
    shift 2
    ;;
  --)
    shift
    break
    ;;
  *)
    echo "Invalid option: $1"
    usage >&2
    exit 1
    ;;
  esac
done

# 打印选项值
echo "File: $FILE"
echo "Type: $TYPE"
```

## 7.kolla-ansible 命令行示例

```sh
#!/bin/bash
#
# This script can be used to interact with kolla via ansible.


# 这个函数用于检查当前环境中是否安装了Ansible，以及Ansible的Python环境是否正常。
# 它首先检查Ansible是否安装，然后检查Ansible脚本的shebang行是否正确，接着验证Ansible使用的Python版本，并确保kolla_ansible模块在Ansible的PYTHONPATH中可用。
# 最后，它还会检查Ansible的版本是否在指定的范围内（2.8到2.9之间）
function check_environment_coherence {
    local ansible_path
    ansible_path=$(which ansible)

    if [[ $? -ne 0 ]]; then
        echo "ERROR: Ansible is not installed in the current (virtual) environment." >&2
        exit 1
    fi

    local ansible_shebang_line
    ansible_shebang_line=$(head -n1 "$ansible_path")

    if ! echo "$ansible_shebang_line" | egrep "^#!" &>/dev/null; then
        echo "ERROR: Ansible script is malformed (missing shebang line)." >&2
        exit 1
    fi

    local ansible_python_cmdline
    # NOTE(yoctozepto): may have multiple parts
    ansible_python_cmdline=${ansible_shebang_line#\#\!}
    ansible_python_version=$($ansible_python_cmdline -c 'import sys; print(str(sys.version_info[0])+"."+str(sys.version_info[1]))')

    if ! $ansible_python_cmdline --version &>/dev/null; then
        echo "ERROR: Ansible Python is not functional." >&2
        echo "Tried '$ansible_python_cmdline'" >&2
        exit 1
    fi

    # Check for existence of kolla_ansible module using Ansible's Python.
    if ! $ansible_python_cmdline -c 'import kolla_ansible' &>/dev/null; then
        echo "ERROR: kolla_ansible has to be available in the Ansible PYTHONPATH." >&2
        echo "Please install both in the same (virtual) environment." >&2
        exit 1
    fi

    local ansible_version_output
    ansible_full_version=$($ansible_python_cmdline -c 'import ansible; print(ansible.__version__)')

    if [[ $? -ne 0 ]]; then
        echo "ERROR: Failed to obtain Ansible version:" >&2
        echo "$ansible_full_version" >&2
        exit 1
    fi

    local ansible_version
    ansible_version=$(echo "$ansible_full_version" | egrep -o '^[0-9]+\.[0-9]+')

    if [[ $? -ne 0 ]]; then
        echo "ERROR: Failed to parse Ansible version:" >&2
        echo "$ansible_full_version" >&2
        exit 1
    fi

    local ANSIBLE_VERSION_MIN=2.8
    local ANSIBLE_VERSION_MAX=2.9

    if [[ $(printf "%s\n" "$ANSIBLE_VERSION_MIN" "$ANSIBLE_VERSION_MAX" "$ansible_version" | sort -V | head -n1) != "$ANSIBLE_VERSION_MIN" ]] ||
       [[ $(printf "%s\n" "$ANSIBLE_VERSION_MIN" "$ANSIBLE_VERSION_MAX" "$ansible_version" | sort -V | tail -n1) != "$ANSIBLE_VERSION_MAX" ]]; then
        echo "ERROR: Ansible version should be between $ANSIBLE_VERSION_MIN and $ANSIBLE_VERSION_MAX. Current version is $ansible_full_version which is not supported."
        exit 1
    fi
}

# 这个函数用于确定Kolla-Ansible的基础目录。
# 它会根据不同的安装情况（如系统安装、用户安装、虚拟环境等）来确定正确的基础目录路径。
function find_base_dir {
    local dir_name
    local python_dir
    dir_name=$(dirname "$0")
    # NOTE(yoctozepto): Fix the case where dir_name is a symlink and VIRTUAL_ENV might not be. This
    # happens with pyenv-virtualenv, see https://bugs.launchpad.net/kolla-ansible/+bug/1903887
    dir_name=$(readlink -e "$dir_name")
    python_dir="python${ansible_python_version}"
    if [ -z "$SNAP" ]; then
        if [[ ${dir_name} == "/usr/bin" ]]; then
            if test -f /usr/lib/${python_dir}/*-packages/kolla-ansible.egg-link; then
                # Editable install.
                BASEDIR="$(head -n1 /usr/lib/${python_dir}/*-packages/kolla-ansible.egg-link)"
            else
                BASEDIR=/usr/share/kolla-ansible
            fi
        elif [[ ${dir_name} == "/usr/local/bin" ]]; then
            if test -f /usr/local/lib/${python_dir}/*-packages/kolla-ansible.egg-link; then
                # Editable install.
                BASEDIR="$(head -n1 /usr/local/lib/${python_dir}/*-packages/kolla-ansible.egg-link)"
            else
                BASEDIR=/usr/local/share/kolla-ansible
            fi
        elif [[ ${dir_name} == ~/.local/bin ]]; then
            if test -f ~/.local/lib/${python_dir}/*-packages/kolla-ansible.egg-link; then
                # Editable install.
                BASEDIR="$(head -n1 ~/.local/lib/${python_dir}/*-packages/kolla-ansible.egg-link)"
            else
                BASEDIR=~/.local/share/kolla-ansible
            fi
        elif [[ -n ${VIRTUAL_ENV} ]] && [[ ${dir_name} == "$(readlink -e "${VIRTUAL_ENV}/bin")" ]]; then
            if test -f ${VIRTUAL_ENV}/lib/${python_dir}/site-packages/kolla-ansible.egg-link; then
                # Editable install.
                BASEDIR="$(head -n1 ${VIRTUAL_ENV}/lib/${python_dir}/*-packages/kolla-ansible.egg-link)"
            else
                BASEDIR="${VIRTUAL_ENV}/share/kolla-ansible"
            fi
        else
            # Running from sources (repo).
            BASEDIR="$(dirname ${dir_name})"
        fi
    else
        BASEDIR="$SNAP/share/kolla-ansible"
    fi
}

# 直接执行拼接的CMD命令（CMD命令即：ansible-playbook -i 加指定参数）。
function process_cmd {
    echo "$ACTION : $CMD"
    $CMD
    if [[ $? -ne 0 ]]; then
        echo "Command failed $CMD"
        exit 1
    fi
}


# 使用手册打印值（即在xshell中直接执行kolla-ansible后返回值，用于命令行添加参数--help返回的帮助文档）
function usage {
    cat <<EOF
Usage: $0 COMMAND [options]

Options:
    --inventory, -i <inventory_path>   Specify path to ansible inventory file
    --playbook, -p <playbook_path>     Specify path to ansible playbook file
    --configdir <config_path>          Specify path to directory with globals.yml
    --key -k <key_path>                Specify path to ansible vault keyfile
    --help, -h                         Show this usage information
    --tags, -t <tags>                  Only run plays and tasks tagged with these values
    --skip-tags <tags>                 Only run plays and tasks whose tags do not match these values
    --extra, -e <ansible variables>    Set additional variables as key=value or YAML/JSON passed to ansible-playbook
    --passwords <passwords_path>       Specify path to the passwords file
    --limit <host>                     Specify host to run plays
    --forks <forks>                    Number of forks to run Ansible with
    --vault-id <@prompt or path>       Specify @prompt or password file (Ansible >=  2.4)
    --ask-vault-pass                   Ask for vault password
    --vault-password-file <path>       Specify password file for vault decrypt
    --verbose, -v                      Increase verbosity of ansible-playbook

Environment variables:
    EXTRA_OPTS                         Additional arguments to pass to ansible-playbook

Commands:
    prechecks           Do pre-deployment checks for hosts
    check               Do post-deployment smoke tests
    mariadb_recovery    Recover a completely stopped mariadb cluster
    mariadb_backup      Take a backup of MariaDB databases
                            --full (default)
                            --incremental
    bootstrap-servers   Bootstrap servers with kolla deploy dependencies
    destroy             Destroy Kolla containers, volumes and host configuration
                            --include-images to also destroy Kolla images
                            --include-dev to also destroy dev mode repos
    deploy              Deploy and start all kolla containers
    deploy-bifrost      Deploy and start bifrost container
    deploy-servers      Enroll and deploy servers with bifrost
    deploy-containers   Only deploy and start containers (no config updates or bootstrapping)
    post-deploy         Do post deploy on deploy node
    pull                Pull all images for containers (only pulls, no running container changes)
    reconfigure         Reconfigure OpenStack service
    stop                Stop Kolla containers
    certificates        Generate self-signed certificate for TLS *For Development Only*
    upgrade             Upgrades existing OpenStack Environment
    upgrade-bifrost     Upgrades an existing bifrost container
    genconfig           Generate configuration files for enabled OpenStack services
    prune-images        Prune orphaned Kolla images
EOF
}

# 这个函数提供了Bash自动补全的支持。它会列出所有支持的命令和选项，以便在Bash中使用时能够自动补全。
function bash_completion {
cat <<EOF
--inventory -i
--playbook -p
--configdir
--key -k
--help -h
--skip-tags
--tags -t
--extra -e
--passwords
--limit
--forks
--vault-id
--ask-vault-pass
--vault-password-file
--verbose -v
prechecks
check
mariadb_recovery
mariadb_backup
bootstrap-servers
destroy
deploy
deploy-bifrost
deploy-containers
deploy-servers
post-deploy
pull
reconfigure
stop
certificates
upgrade
upgrade-bifrost
genconfig
prune-images
EOF
}

check_environment_coherence


# 这部分代码使用getopt来解析命令行参数。它定义了短选项和长选项，并将它们映射到相应的处理逻辑上。
SHORT_OPTS="hi:p:t:k:e:v"
LONG_OPTS="help,inventory:,playbook:,skip-tags:,tags:,key:,extra:,verbose,configdir:,passwords:,limit:,forks:,vault-id:,ask-vault-pass,vault-password-file:,yes-i-really-really-mean-it,include-images,include-dev:,full,incremental"

RAW_ARGS="$*"
ARGS=$(getopt -o "${SHORT_OPTS}" -l "${LONG_OPTS}" --name "$0" -- "$@") || { usage >&2; exit 2; }

eval set -- "$ARGS"

find_base_dir

# INVENTORY默认值
INVENTORY="${BASEDIR}/ansible/inventory/all-in-one"
# 若不指定PLAYBOOK变量，则默认值/usr/local/share/kolla-ansible/ansible/site.yml
PLAYBOOK="${BASEDIR}/ansible/site.yml"
VERBOSITY=
EXTRA_OPTS=${EXTRA_OPTS}
CONFIG_DIR="/etc/kolla"
DANGER_CONFIRM=
INCLUDE_IMAGES=
INCLUDE_DEV=
BACKUP_TYPE="full"
# Serial is not recommended and disabled by default. Users can enable it by
# configuring ANSIBLE_SERIAL variable.
ANSIBLE_SERIAL=${ANSIBLE_SERIAL:-0}


# While判断，当参数个数不为0，开始匹配参数，以”kolla-ansible -i ./multinode deploy”为例分析
while [ "$#" -gt 0 ]; do
    case "$1" in

    (--inventory|-i)
            INVENTORY="$2"    # 获取第二个参数，如上例，即把’/multinode’赋值给INVENTORY
            shift 2           # shift命令用于位置参数左移，如上例，shift 2执行前，$1是’-i’，执行后$1是’deploy’，（多个条件处理时，用shift可适配不同个数的参数）
            ;;                # case固定用法，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;
                              # 其它参数类似处理
    (--playbook|-p)
            PLAYBOOK="$2"
            shift 2
            ;;

    (--skip-tags)
            EXTRA_OPTS="$EXTRA_OPTS --skip-tags $2"
            shift 2
            ;;

    (--tags|-t)
            EXTRA_OPTS="$EXTRA_OPTS --tags $2"
            shift 2
            ;;

    (--verbose|-v)
            VERBOSITY="$VERBOSITY --verbose"
            shift 1
            ;;

    (--configdir)
            CONFIG_DIR="$2"
            shift 2
            ;;

    (--yes-i-really-really-mean-it)
            if [[ ${RAW_ARGS} =~ "$1" ]]
            then
                DANGER_CONFIRM="$1"
            fi
            shift 1
            ;;

    (--include-images)
            INCLUDE_IMAGES="$1"
            shift 1
            ;;

    (--include-dev)
            INCLUDE_DEV="$1"
            shift 1
            ;;

    (--key|-k)
            VAULT_PASS_FILE="$2"
            EXTRA_OPTS="$EXTRA_OPTS --vault-password-file=$VAULT_PASS_FILE"
            shift 2
            ;;

    (--extra|-e)
            EXTRA_OPTS="$EXTRA_OPTS -e $2"
            shift 2
            ;;

    (--passwords)
            PASSWORDS_FILE="$2"
            shift 2
            ;;

    (--limit)
            EXTRA_OPTS="$EXTRA_OPTS --limit $2"
            shift 2
            ;;

    (--forks)
            EXTRA_OPTS="$EXTRA_OPTS --forks $2"
            shift 2
            ;;

    (--vault-id)
            EXTRA_OPTS="$EXTRA_OPTS --vault-id $2"
            shift 2
            ;;

    (--ask-vault-pass)
            VERBOSITY="$EXTRA_OPTS --ask-vault-pass"
            shift 1
            ;;

    (--vault-password-file)
            EXTRA_OPTS="$EXTRA_OPTS --vault-password-file $2"
            shift 2
            ;;

    (--full)
            BACKUP_TYPE="full"
            shift 1
            ;;

    (--incremental)
            BACKUP_TYPE="incremental"
            shift 1
            ;;

    (--help|-h)
            usage
            shift
            exit 0
            ;;

    (--)
            shift
            break
            ;;

    (*)
            echo "error"
            exit 3
            ;;
esac
done

case "$1" in

(prechecks)
        ACTION="Pre-deployment checking"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=precheck"
        ;;
(check)
        ACTION="Post-deployment checking"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=check"
        ;;
(mariadb_recovery)
        ACTION="Attempting to restart mariadb cluster"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy -e common_run=true"
        PLAYBOOK="${BASEDIR}/ansible/mariadb_recovery.yml"
        ;;
(mariadb_backup)
        ACTION="Backup MariaDB databases"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=backup -e mariadb_backup_type=${BACKUP_TYPE} -e common_run=true"
        PLAYBOOK="${BASEDIR}/ansible/mariadb_backup.yml"
        ;;
(destroy)
        ACTION="Destroy Kolla containers, volumes and host configuration"
        PLAYBOOK="${BASEDIR}/ansible/destroy.yml"
        if [[ "${INCLUDE_IMAGES}" == "--include-images" ]]; then
            EXTRA_OPTS="$EXTRA_OPTS -e destroy_include_images=yes"
        fi
        if [[ "${INCLUDE_DEV}" == "--include-dev" ]]; then
            EXTRA_OPTS="$EXTRA_OPTS -e destroy_include_dev=yes"
        fi
        if [[ "${DANGER_CONFIRM}" != "--yes-i-really-really-mean-it" ]]; then
            cat << EOF
WARNING:
    This will PERMANENTLY DESTROY all deployed kolla containers, volumes and host configuration.
    There is no way to recover from this action. To confirm, please add the following option:
    --yes-i-really-really-mean-it
EOF
            exit 1
        fi
        ;;
(bootstrap-servers)
        ACTION="Bootstrapping servers"
        PLAYBOOK="${BASEDIR}/ansible/kolla-host.yml"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=bootstrap-servers"
        ;;
(deploy)
        ACTION="Deploying Playbooks"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy"
        ;;
(deploy-bifrost)
        ACTION="Deploying Bifrost"
        PLAYBOOK="${BASEDIR}/ansible/bifrost.yml"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy"
        ;;
(deploy-containers)
        ACTION="Deploying Containers"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy-containers"
        ;;
(deploy-servers)
        ACTION="Deploying servers with bifrost"
        PLAYBOOK="${BASEDIR}/ansible/bifrost.yml"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy-servers"
        ;;
(post-deploy)
        ACTION="Post-Deploying Playbooks"
        PLAYBOOK="${BASEDIR}/ansible/post-deploy.yml"
        ;;
(pull)
        ACTION="Pulling Docker images"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=pull"
        ;;
(upgrade)
        ACTION="Upgrading OpenStack Environment"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=upgrade -e kolla_serial=${ANSIBLE_SERIAL}"
        ;;
(upgrade-bifrost)
        ACTION="Upgrading Bifrost"
        PLAYBOOK="${BASEDIR}/ansible/bifrost.yml"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=upgrade"
        ;;
(reconfigure)
        ACTION="Reconfigure OpenStack service"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=reconfigure -e kolla_serial=${ANSIBLE_SERIAL}"
        ;;
(stop)
        ACTION="Stop Kolla containers"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=stop"
        if [[ "${DANGER_CONFIRM}" != "--yes-i-really-really-mean-it" ]]; then
            cat << EOF
WARNING:
    This will stop all deployed kolla containers, limit with tags is possible and also with
    skip_stop_containers variable. To confirm, please add the following option:
    --yes-i-really-really-mean-it
EOF
            exit 1
        fi
        ;;
(certificates)
        ACTION="Generate TLS Certificates"
        PLAYBOOK="${BASEDIR}/ansible/certificates.yml"
        ;;
(genconfig)
        ACTION="Generate configuration files for enabled OpenStack services"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=config"
        ;;
(prune-images)
        ACTION="Prune orphaned Kolla images"
        PLAYBOOK="${BASEDIR}/ansible/prune-images.yml"
        if [[ "${DANGER_CONFIRM}" != "--yes-i-really-really-mean-it" ]]; then
            cat << EOF
WARNING:
    This will PERMANENTLY DELETE all orphaned kolla images. To confirm, please add the following option:
    --yes-i-really-really-mean-it
EOF
            exit 1
        fi
        ;;
(bash-completion)
        bash_completion
        exit 0
        ;;
(*)     usage
        exit 3
        ;;
esac

PASSWORDS_FILE="${PASSWORDS_FILE:-${CONFIG_DIR}/passwords.yml}"
CONFIG_OPTS="-e @${CONFIG_DIR}/globals.yml -e @${PASSWORDS_FILE} -e CONFIG_DIR=${CONFIG_DIR}"

# ansible-playbook指定参数变量的调用，参数都是以上shell脚本内容处理之后的值
# INVENTORY参数，即INVENTORY文件，用于ansible配置主机组信息；（Ansible可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置. 默认的文件路径为/etc/ansible/hosts）
# CONFIG_OPTS，用于指定globals.yml,passwords.yml，配置文件目录，主要是指定一些配置相关;
# EXTRA_OPTS主要是指定执行的动作，例如”-e kolla_action=deploy”;
# PLAYBOOK为roles的入口文件site.yml.（Playbooks是Ansible的配置、部署、编排语言.可以被描述为一个需要远程主机执行命令的方案,或者一组IT程序运行的命令集合。）
CMD="ansible-playbook -i $INVENTORY $CONFIG_OPTS $EXTRA_OPTS $PLAYBOOK $VERBOSITY"

# Deploy动作的调用过程为：kolla-ansible -i multinode deploy ---->调用/usr/local/share/kolla-ansible/ansible/site.yml ---->根据site.yml文件的task调用执行各role

# 整个脚本的调用入口，其实只是调用了CMD命令
process_cmd
```

常用命令

```sh
kolla-ansible prechecks -i multinode   #部署前环境检测
kolla-genpwd  #生成/etc/kolla/password.yml密码配置文件
kolla-ansible post-deploy -i multinode   #生成认证文件
kolla-ansible mariadb_recovery -i /opt/mutinode #恢复数据库
kolla-ansible -i multinode pull  #拉取镜像
```

kolla-ansible 脚本详解

- https://github.com/simba-cn/kolla-ansible/blob/main/kolla-ansible%20脚本详解（yoga）.md

## 8.选项标准化

在编写 shell 脚本时，一切尽在你的控制中。选用哪些选项字母以及选项的具体用法，完全由你掌握。

但在 Linux 中，有些选项字母在某种程度上已经有了标准含义。

如果能在 shell 脚本中支持这些选项，则你的脚本会对用户更友好。

下表 显示了 Linux 中用到的一些命令行选项的常用含义。

| 选 项 | 描 述                        |
| ----- | ---------------------------- |
| -a    | 显示所有对象                 |
| -c    | 生成计数                     |
| -d    | 指定目录                     |
| -e    | 扩展对象                     |
| -f    | 指定读入数据的文件           |
| -h    | 显示命令的帮助信息           |
| -i    | 忽略文本大小写               |
| -l    | 产生长格式输出               |
| -n    | 使用非交互模式（批处理）     |
| -o    | 将所有输出重定向至指定的文件 |
| -q    | 以静默模式运行               |
| -r    | 递归处理目录和文件           |
| -s    | 以静默模式运行               |
| -v    | 生成详细输出                 |
| -x    | 排除某个对象                 |
| -y    | 对所有问题回答 yes           |

如果你的脚本选项也遵循同样的含义，那么用户在使用的时候就不用再查手册了。

参考文献:

https://www.escapelife.site/posts/9b814911.html

## 9.清理镜像脚本示例

脚本提供了多种选项来指定要删除的镜像类型，包括所有 Kolla 镜像、孤立镜像、特定版本的镜像或特定名称的镜像。

```sh
#!/bin/bash

# Move to top level directory
REAL_PATH=$(python -c "import os,sys;print os.path.realpath('$0')")
cd "$(dirname "$REAL_PATH")/.."

function process_cmd {
    if [[ -z "$KOLLA_IMAGES" ]]; then
        echo "No images to cleanup, exit now."
        exit 0
    fi

    $CMD

    if [[ $? -ne 0 ]]; then
        echo "Command failed $CMD"
        exit 1
    fi
}

function usage {
    cat <<EOF
Usage: $0 COMMAND [options]

Options:
    --all, -a                              Remove all kolla images
    --dangling                             Remove orphaned images
    --help, -h                             Show this usage information
    --image, -i <image>                    Delete selected images
    --image-version <image_version>        Set Kolla image version
EOF
}

SHORT_OPTS="ahi:"
LONG_OPTS="all,dangling,help,image:,image-version:"
ARGS=$(getopt -o "${SHORT_OPTS}" -l "${LONG_OPTS}" --name "$0" -- "$@") || { usage >&2; exit 2; }

eval set -- "$ARGS"

case "$1" in

    (--all|-a)
            KOLLA_IMAGES="$(docker images -a --filter "label=kolla_version" --format "{{.ID}}")"
            shift
            ;;

    (--dangling)
            KOLLA_IMAGES="$(docker images -a --filter dangling=true --format "{{.ID}}")"
            shift
            ;;

    (--image|-i)
            KOLLA_IMAGES="$(docker images -a --filter "label=kolla_version" --format "{{.Repository}}\t{{.ID}}" | grep -E "$2" | awk '{print $2}')"
            shift 2
            ;;

    (--image-version)
            KOLLA_IMAGES="$(docker images -a --filter "label=kolla_version=${2}" --format "{{.ID}}")"
            shift 2
            ;;

    (--help|-h)
            usage
            shift
            exit 0
            ;;

    (--)
            echo -e "Error: no argument passed\n"
            usage
            exit 0
            ;;

esac

CMD="docker rmi -f $@ $KOLLA_IMAGES"
process_cmd
```

## 10.构建镜像命令示例 1

```sh
#!/bin/bash

work_path=$(dirname $0)
cd ./${work_path} # 跳到脚本位置

Dir=''
ImageName=''
DockerHubAccount='local'
Tag=()

# 打印的帮助信息
usage() {
  echo -ne "
  Usage:
    bash $(basename $0)
    -d, --dir <dir> \t\t\t\033[33m构建目录\033[0m
    -i, --image [name] \t\t\t\033[33m镜像名称\033[0m
    -a, --account [id] \t\t\t\033[33mDocker Hub Account ID\033[0m
    -t, --tag <tag> \t\033[33mTag, 可多次传递以支持设置多个 tag\033[0m
";
}

[ $# -eq 0 ] && usage

ARGS=$(getopt -l "dir:,image:,account:,tag:" -o "d:i:a:t:" -- "$@")
if [ $? != 0 ] ; then exit 1 ; fi
eval set -- "$ARGS"

while true; do
  case $1 in
    -d|--dir)
      Dir="$2"
      shift 2
      ;;
    -i|--image)
      ImageName="$2"
      shift 2
      ;;
    -a|--account)
      DockerHubAccount="$2"
      shift 2
      ;;
    -t|--tag)
      Tag[${#Tag[@]}]=$2
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      usage
      exit 1;
      ;;
    esac
  done

[[ -z "$Dir" ]] && echo -ne "Error: Invalid option\n" && usage && exit 1;

if [ -d "./packages/$Dir" ]; then
  echo -ne "docker build start...\n"
  docker build -t $DockerHubAccount/${ImageName:-${Dir}} ./packages/$Dir

  for a in "${Tag[@]}"; do
    echo -ne "docker tag: ${Tag[@]}\n"
    docker tag $DockerHubAccount/${ImageName:-${Dir}} ${DockerHubAccount}/${ImageName:-${Dir}}:${a}
  done

fi
```

## 11.构建镜像命令示例 2

```sh
#!/bin/bash

work_path=$(dirname $0)
cd ./${work_path} # 跳到脚本位置

Dir=''
ImageName=''
DockerHubAccount='local'
Tag=()
Build='0'
Publish='0'
Remove='0'

# 打印的帮助信息
usage() {
  echo -ne "
  Usage:
    bash $(basename $0)
    -d, --dir <dir>     \033[33m构建目录\033[0m
    -i, --image [name]  \033[33m镜像名称\033[0m
    -a, --account [id]  \033[33mDocker Hub Account ID\033[0m
    -t, --tag <tag>     \033[33mTag, 可多次传递以支持设置多个 tag\033[0m
    -b, --build         \033[33m构建镜像\033[0m
    -p, --publish       \033[33m自动发布镜像\033[0m
    --rm                \033[33m最后删除构建的镜像\033[0m
";
}

[ $# -eq 0 ] && usage

ARGS=$(getopt -l "help,build,publish,dir:,image:,account:,tag:,rm" -o "hbpd:i:a:t:" -- "$@")
if [ $? != 0 ] ; then exit 1 ; fi
eval set -- "$ARGS"

while true; do
  case $1 in
    -d|--dir)
      Dir="$2"
      shift 2
      ;;
    -i|--image)
      ImageName="$2"
      shift 2
      ;;
    -a|--account)
      DockerHubAccount="$2"
      shift 2
      ;;
    -t|--tag)
      Tag[${#Tag[@]}]=$2
      shift 2
      ;;
    -b|--build)
      Build="1"
      shift
      ;;
    -p|--publish)
      Publish="1"
      shift
      ;;
    --rm)
      Remove="1"
      shift
      ;;
    -h|--help)
      usage
      shift
      exit 0;
      ;;
    --)
      shift
      break
      ;;
    *)
      if [[ "$1" != 'error' ]]; then echo -ne "\nInvaild option: '$1'\n\n"; fi
      usage
      exit 1;
      ;;
  esac
done

[[ -z "$Dir" ]] && echo -ne "Error: Invalid option\n" && usage && exit 1;

TagStr=""
for a in "${Tag[@]}"; do
  TagStr="${TagStr:+${TagStr}} -t ${a}"
done

if [ "$Build" == '1' ]; then
  ./build.sh -d $Dir -i ${ImageName:-${Dir}} -a $DockerHubAccount $TagStr
fi

if [ "$Publish" == '1' ]; then
  ./publish.sh -i ${ImageName:-${Dir}} -a $DockerHubAccount
fi

if [ "$Remove" == '1' ]; then
  ./clean.sh -i ${ImageName:-${Dir}} -a $DockerHubAccount
fi
```

## 12.监控机器 CPU 利用率脚本

```sh
#!/bin/bash
# CPU Utilization Statistics plugin for Nagios
#
# USAGE     :   ./check_cpu_utili.sh [-w <user,system,iowait>] [-c <user,system,iowait>] ( [ -i <intervals in second> ] [ -n <report number> ])
#
# Exemple: ./check_cpu_utili.sh
#          ./check_cpu_utili.sh -w 70,40,30 -c 90,60,40
#          ./check_cpu_utili.sh -w 70,40,30 -c 90,60,40 -i 3 -n 5
# Paths to commands used in this script.  These may have to be modified to match your system setup.
IOSTAT="/usr/bin/iostat"

# Nagios return codes
STATE_OK=0
STATE_WARNING=1
STATE_CRITICAL=2
STATE_UNKNOWN=3

# Plugin parameters value if not define
LIST_WARNING_THRESHOLD="70,40,30"
LIST_CRITICAL_THRESHOLD="90,60,40"
INTERVAL_SEC=1
NUM_REPORT=1
# Plugin variable description
PROGNAME=$(basename $0)

if [ ! -x $IOSTAT ]; then
    echo "UNKNOWN: iostat not found or is not executable by the nagios user."
    exit $STATE_UNKNOWN
fi

print_usage() {
        echo ""
        echo "$PROGNAME $RELEASE - CPU Utilization check script for Nagios"
        echo ""
        echo "Usage: check_cpu_utili.sh -w -c (-i -n)"
        echo ""
        echo "  -w  Warning threshold in % for warn_user,warn_system,warn_iowait CPU (default : 70,40,30)"
        echo "  Exit with WARNING status if cpu exceeds warn_n"
        echo "  -c  Critical threshold in % for crit_user,crit_system,crit_iowait CPU (default : 90,60,40)"
        echo "  Exit with CRITICAL status if cpu exceeds crit_n"
        echo "  -i  Interval in seconds for iostat (default : 1)"
        echo "  -n  Number report for iostat (default : 3)"
        echo "  -h  Show this page"
        echo ""
    echo "Usage: $PROGNAME"
    echo "Usage: $PROGNAME --help"
    echo ""
    exit 0
}

print_help() {
    print_usage
        echo ""
        echo "This plugin will check cpu utilization (user,system,CPU_Iowait in %)"
        echo ""
    exit 0
}

# Parse parameters
while [ $# -gt 0 ]; do
    case "$1" in
        -h | --help)
            print_help
            exit $STATE_OK
            ;;
        -v | --version)
                print_release
                exit $STATE_OK
                ;;
        -w | --warning)
                shift
                LIST_WARNING_THRESHOLD=$1
                ;;
        -c | --critical)
               shift
                LIST_CRITICAL_THRESHOLD=$1
                ;;
        -i | --interval)
               shift
               INTERVAL_SEC=$1
                ;;
        -n | --number)
               shift
               NUM_REPORT=$1
                ;;
        *)  echo "Unknown argument: $1"
            print_usage
            exit $STATE_UNKNOWN
            ;;
        esac
shift
done

# List to Table for warning threshold (compatibility with
TAB_WARNING_THRESHOLD=(`echo $LIST_WARNING_THRESHOLD | sed 's/,/ /g'`)
if [ "${#TAB_WARNING_THRESHOLD[@]}" -ne "3" ]; then
  echo "ERROR : Bad count parameter in Warning Threshold"
  exit $STATE_WARNING
else
USER_WARNING_THRESHOLD=`echo ${TAB_WARNING_THRESHOLD[0]}`
SYSTEM_WARNING_THRESHOLD=`echo ${TAB_WARNING_THRESHOLD[1]}`
IOWAIT_WARNING_THRESHOLD=`echo ${TAB_WARNING_THRESHOLD[2]}`
fi

# List to Table for critical threshold
TAB_CRITICAL_THRESHOLD=(`echo $LIST_CRITICAL_THRESHOLD | sed 's/,/ /g'`)
if [ "${#TAB_CRITICAL_THRESHOLD[@]}" -ne "3" ]; then
  echo "ERROR : Bad count parameter in CRITICAL Threshold"
  exit $STATE_WARNING
else
USER_CRITICAL_THRESHOLD=`echo ${TAB_CRITICAL_THRESHOLD[0]}`
SYSTEM_CRITICAL_THRESHOLD=`echo ${TAB_CRITICAL_THRESHOLD[1]}`
IOWAIT_CRITICAL_THRESHOLD=`echo ${TAB_CRITICAL_THRESHOLD[2]}`
fi

if [ ${TAB_WARNING_THRESHOLD[0]} -ge ${TAB_CRITICAL_THRESHOLD[0]} -o ${TAB_WARNING_THRESHOLD[1]} -ge ${TAB_CRITICAL_THRESHOLD[1]} -o ${TAB_WARNING_THRESHOLD[2]} -ge ${TAB_CRITICAL_THRESHOLD[2]} ]; then
  echo "ERROR : Critical CPU Threshold lower as Warning CPU Threshold "
  exit $STATE_WARNING
fi

CPU_REPORT=`iostat -c $INTERVAL_SEC $NUM_REPORT | sed -e 's/,/./g' | tr -s ' ' ';' | sed '/^$/d' | tail -1`
CPU_REPORT_SECTIONS=`echo ${CPU_REPORT} | grep ';' -o | wc -l`
CPU_USER=`echo $CPU_REPORT | cut -d ";" -f 2`
CPU_SYSTEM=`echo $CPU_REPORT | cut -d ";" -f 4`
CPU_IOWAIT=`echo $CPU_REPORT | cut -d ";" -f 5`
CPU_STEAL=`echo $CPU_REPORT | cut -d ";" -f 6`
CPU_IDLE=`echo $CPU_REPORT | cut -d ";" -f 7`
NAGIOS_STATUS="user=${CPU_USER}%,system=${CPU_SYSTEM}%,iowait=${CPU_IOWAIT}%,idle=${CPU_IDLE}%"
NAGIOS_DATA="CpuUser=${CPU_USER};${TAB_WARNING_THRESHOLD[0]};${TAB_CRITICAL_THRESHOLD[0]};0"

CPU_USER_MAJOR=`echo $CPU_USER| cut -d "." -f 1`
CPU_SYSTEM_MAJOR=`echo $CPU_SYSTEM | cut -d "." -f 1`
CPU_IOWAIT_MAJOR=`echo $CPU_IOWAIT | cut -d "." -f 1`
CPU_IDLE_MAJOR=`echo $CPU_IDLE | cut -d "." -f 1`



# Return
if [ ${CPU_USER_MAJOR} -ge $USER_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_CRITICAL
    elif [ ${CPU_SYSTEM_MAJOR} -ge $SYSTEM_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_CRITICAL
    elif [ ${CPU_IOWAIT_MAJOR} -ge $IOWAIT_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_CRITICAL
    elif [ ${CPU_USER_MAJOR} -ge $USER_WARNING_THRESHOLD ] && [ ${CPU_USER_MAJOR} -lt $USER_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_WARNING
      elif [ ${CPU_SYSTEM_MAJOR} -ge $SYSTEM_WARNING_THRESHOLD ] && [ ${CPU_SYSTEM_MAJOR} -lt $SYSTEM_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_WARNING
      elif  [ ${CPU_IOWAIT_MAJOR} -ge $IOWAIT_WARNING_THRESHOLD ] && [ ${CPU_IOWAIT_MAJOR} -lt $IOWAIT_CRITICAL_THRESHOLD ]; then
        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_WARNING
else

        echo "CPU STATISTICS OK:${NAGIOS_STATUS} | CPU_USER=${CPU_USER}%;70;90;0;100"
        exit $STATE_OK
fi
```
