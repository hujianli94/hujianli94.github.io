# 18.Shell 脚本的参数解析工具

## 1.简单 demo

该脚本是一个简单的命令行工具，可以通过命令行参数来指定不同的选项。

```shell
#!/bin/bash

version="1.0.0"
string=""
flag=0

while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do
case $1 in
  -V | --version )
    echo $version
    exit
    ;;
  -s | --string )
    shift; string=$1
    ;;
  -f | --flag )
    flag=1
    ;;
esac;
shift; # shift n 表示把第n+1个参数移到第1个参数, 即命令结束后$1的值等于$n+1的值
done


echo $string
echo $flag
```

其中 [options] 是您要传递给脚本的选项。下面是该脚本支持的选项说明：

```shell
-V 或 --version: 显示版本信息并退出脚本。
-s 或 --string: 指定一个字符串作为参数，并将其赋值给变量 string。
-f 或 --flag: 设置一个标志变量 flag
```

使用

```shell

./script.sh -V      # 显示版本信息
./script.sh -s hello  # 指定字符串参数为 "hello"
./script.sh -f       # 设置标志变量 flag
./script.sh -s world -f  # 指定字符串参数为 "world" 并设置标志变量 flag

```

## 2.使用空格分隔

实际用法

```shell
./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts
```

实现脚本

```shell

#!/bin/bash
POSITIONAL=()
while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    -e|--extension)
      EXTENSION="$2"
      shift # past argument
      shift # past value
      ;;
    -s|--searchpath)
      SEARCHPATH="$2"
      shift # past argument
      shift # past value
      ;;
    -l|--lib)
      LIBPATH="$2"
      shift # past argument
      shift # past value
      ;;
    --default)
      DEFAULT=YES
      shift # past argument
      ;;
      *)
    POSITIONAL+=("$1") # save it in an array for later
      shift # past argument
      ;;
  esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters
echo FILE EXTENSION  = "${EXTENSION}"
echo SEARCH PATH     = "${SEARCHPATH}"
echo LIBRARY PATH    = "${LIBPATH}"
echo DEFAULT         = "${DEFAULT}"
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
if [[ -n $1 ]]; then
  echo "Last line of file specified as non-opt/last argument:"
  tail -1 "$1"
fi
```

image_help.sh

一个图形转换脚本

```sh
#!/bin/bash
#文件名：image_help.sh
#用途:图像管理脚本
if [ $# -ne 4 -a $# -ne 6 -a $# -ne 8 ];
then
	echo Incorrect number of arguments
	exit 2
fi

while [ $# -ne 0 ];
do
	case $1 in
		-source) shift; source_dir=$1 ; shift ;;
		-scale) shift; scale=$1 ; shift ;;
		-percent) shift; percent=$1 ; shift ;;
		-dest) shift ; dest_dir=$1 ; shift ;;
		-ext) shift ; ext=$1 ; shift ;;
		*) echo Wrong parameters; exit 2 ;;
	esac;
done

for img in `echo $source_dir/*` ;
do
	source_file=$img

	if [[ -n $ext ]];
	then
		dest_file=${img%.*}.$ext
	else
		dest_file=$img
	fi

	if [[ -n $dest_dir ]];
	then
		dest_file=${dest_file##*/}
		dest_file="$dest_dir/$dest_file"
	fi

	if [[ -n $scale ]];
	then
		PARAM="-resize $scale"
	elif [[ -n $percent ]]; then
		PARAM="-resize $percent%"
	fi

	echo Processing file : $source_file
	convert $source_file $PARAM $dest_file
done
```

```sh
# 以下是一个示例输出，将目录sample_dir中的图像缩放到20%大小：
$ ./image_help.sh -source sample_dir -percent 20%
Processing file :sample/IMG_4455.JPG
Processing file :sample/IMG_4456.JPG
Processing file :sample/IMG_4457.JPG
Processing file :sample/IMG_4458.JPG

# 为了将图像缩放到宽度 1024，请使用：
$ ./image_help.sh -source sample_dir –scale 1024x

# 将文件更改为 PNG 格式，方法是在上述命令中添加-ext png。
# 按照以下方式指定目标目录来缩放或转换文件：
$ ./image_help.sh -source sample -scale 50% -ext png -dest newdir
# newdir is the new destination directory
```

### getopt

我们可以在脚本中使用 getopt 命令来格式化脚本所携带的任何命令行选项或参数，但用起来略显复杂。
难点在于要使用 getopt 命令生成的格式化版本替换已有的命令行选项和参数。这得求助于 set 命令。

set 命令有一个选项是双连字符（ -- ），可以将位置变量的值替换成 set 命令所指定的值。

具体做法是将脚本的命令行参数传给 getopt 命令，然后再将 getopt 命令的输出传给 set 命令，用 getopt 格式化后的命令行参数来替换原始的命令行参数，如下所示：

```sh
set -- $(getopt -o -q ab:cd "$@")
```

现在，位置变量原先的值会被 getopt 命令的输出替换掉，后者已经为我们格式化好了命令行参数。

利用这种方法，就可以写出处理命令行参数的脚本了：

```sh
#!/bin/bash
# Extract command-line options and values with getopt
#
set -- $(getopt -q ab:cd "$@")
#
echo
while [ -n "$1" ]
do
  case "$1" in
    -a) echo "Found the -a option" ;;
    -b) param=$2
      echo "Found the -b option with parameter value $param"
      shift;;
    -c) echo "Found the -c option" ;;
    --) shift
      break;;
    *) echo "$1 is not an option" ;;
  esac
shift
done
#
echo
count=1
for param in $@;do
  echo "Parameter #$count: $param"
  count=$[ $count + 1 ]
done
exit
```

```sh
$ ./extractwithgetopt.sh -c -d -b BValue -a test1 test2
Found the -c option
-d is not an option
Found the -b option with parameter value 'BValue'
Found the -a option
Parameter #1: 'test1'
Parameter #2: 'test2'
```

- register_exporter_with_metadata.sh

```sh
#!/bin/bash

show_usage="args: [-i , -n , -a , -p, -t, -c, m]\n[--id=atompi_node, --name=atompi_node, --address=atompi, --port=9100, --tags='\"node_exporter\"', --consul=consul:8500, --meta='\"meta\":{\"module\":\"http_2xx\",\"target\":\"https://baidu.com\"}']"

id=""
name=""
address=""
port=""
tags=""
consul=""
meta=""

GETOPT_ARGS=`getopt -o i:n:a:p:t:c:m: -al id:,name:,address:,port:,tags:,consul:,meta: -- "$@"`

eval set -- "$GETOPT_ARGS"

while [ -n "$1" ]
do
    case "$1" in
        -i|--id) id=$2; shift 2;;
        -n|--name) name=$2; shift 2;;
        -a|--address) address=$2; shift 2;;
        -p|--port) port=$2; shift 2;;
        -t|--tags) tags=$2; shift 2;;
        -c|--consul) consul=$2; shift 2;;
        -m|--meta) meta=$2; shift 2;;
        --) break ;;
        *) echo $1,$2,$show_usage; break ;;
    esac
done

if [[ -z $id || -z $name || -z $address || -z $port || -z $tags || -z $consul ]]; then
    echo -e $show_usage
    echo "id: $id , name: $name , address: $address , port: $port , tags: $tags , consul: $consul , meta: $meta"
    exit 0
else
    curl -X PUT -d '{"id": "'"$id"'","name": "'"$name"'","address": "'"$address"'","port": '"$port"',"tags": ['"$tags"'],"checks": [{"http": "http://'"$address"':'"$port"'/","interval": "5s"}],'"$meta"'}' "http://$consul/v1/agent/service/register"
fi

```

- deregister_exporter.sh

```sh
#!/bin/bash

show_usage="args: [-n , -c] [--name=atompi-node, --consul=consul:8500]"

name=""
consul=""

GETOPT_ARGS=`getopt -o n:c: -al name:,consul: -- "$@"`

eval set -- "$GETOPT_ARGS"

while [ -n "$1" ]
do
    case "$1" in
        -n|--name) name=$2; shift 2;;
        -c|--consul) consul=$2; shift 2;;
        --) break ;;
        *) echo $1,$2,$show_usage; break ;;
    esac
done

if [[ -z $name || -z $consul ]]; then
    echo -e $show_usage
    echo "name: $name , consul: $consul"
    exit 0
else
    curl --request PUT "http://$consul/v1/agent/service/deregister/$name"
fi
```

使用`set -- $@`方法将命令行参数传递给 Shell 脚本，并利用这些参数发送 curl 的 GET 或 POST 请求来注册 node-export 信息到 Consul。以下是一个示例脚本：

```sh
#!/bin/bash

# 检查命令行参数数量
if [ $# -ne 5 ]; then
    echo "Usage: $0 <consul_address> <node_name> <node_address> <node_port> <request_type>"
    exit 1
fi

# 将命令行参数传递给脚本
set -- "$@"

# 从命令行参数中获取Consul地址、节点名称、节点地址、节点端口和请求类型
consul_address=$1
node_name=$2
node_address=$3
node_port=$4
request_type=$5

# 构造注册信息
registration_data='{
  "ID": "'"$node_name"'",
  "Name": "node-export",
  "Address": "'"$node_address"'",
  "Port": '"$node_port"'
}'

# 发送注册请求到Consul
if [ "$request_type" == "get" ]; then
    curl -X GET "$consul_address/v1/agent/members"
elif [ "$request_type" == "post" ]; then
    curl -X PUT -d "$registration_data" "$consul_address/v1/agent/service/register"
else
    echo "Invalid request type. Please choose either 'get' or 'post'."
    exit 1
fi
```

将脚本保存为 `register_node_export.sh`。

在命令行中执行脚本，并传递 Consul 地址、节点名称、节点地址、节点端口以及请求类型（get 或 post）作为参数。

- 对于 GET 请求，使用命令格式：`./register_node_export.sh <consul_address> <node_name> <node_address> <node_port> get`

- 对于 POST 请求，使用命令格式：`./register_node_export.sh <consul_address> <node_name> <node_address> <node_port> post`

## 3.使用等号分隔

实际用法

```shell
./myscript.sh -e=conf -s=/etc -l=/usr/lib /etc/hosts
```

实现脚本

```shell
#!/bin/bash
for key in "$@"; do
  case $key in
    -e=*|--extension=*)
      EXTENSION="${key#*=}"
      shift # past argument=value
      ;;
    -s=*|--searchpath=*)
      SEARCHPATH="${key#*=}"
      shift # past argument=value
      ;;
    -l=*|--lib=*)
      LIBPATH="${key#*=}"
      shift # past argument=value
      ;;
    --default)
      DEFAULT=YES
      shift # past argument with no value
      ;;
    *)
      ;;
  esac
done
echo "FILE EXTENSION  = ${EXTENSION}"
echo "SEARCH PATH     = ${SEARCHPATH}"
echo "LIBRARY PATH    = ${LIBPATH}"
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
if [[ -n $1 ]]; then
  echo "Last line of file specified as non-opt/last argument:"
  tail -1 $1
fi

```

## 4.使用 getopts 工具

getopts 是一个解析脚本选项参数的工具。

命令格式：`getopts optstring name [arg]`

初次使用你要注意这几点：

```sh
1）脚本位置参数会与 optstring 中的单个字母逐个匹配，如果匹配到就赋值给 name，否则赋值 name为问号；

2）optstring 中单个字母是一个选项，如果字母后面加冒号，表示该选项后面带参数，参数值并会赋值给 OPTARG 变量；

3）optstring 中第一个是冒号，表示屏蔽系统错误（test.sh: illegal option -- h）；

4）允许把选项放一起，例如-ab
```

### deamo1

实现脚本

```shell
#!/bin/sh
# 重置以防止在前面的shell中使用getopts工具(这是一个POSIX变量)
OPTIND=1
# 初始化变量名称
OUTPUT_FILE=""
VERSION=0
# getopts的缺点就是它只能处理短选项，如-h，而不能是--help格式
while getopts "h?vf:" key; do
    case "$key" in
    h|\?)
        show_help
        exit 0
        ;;
    v)
        VERSION=1
        ;;
    f)
        output_file=$OPTARG
        ;;
    esac
done
shift $((OPTIND-1))
[ "${1:-}" = "--" ] && shift
echo "verbose=$VERSION, output_file='$output_file', Leftovers: $@" |

```

实际用法

```sh
./myscript.sh -h
./myscript.sh -v -f
```

### deamo2

```sh
#!/usr/bin/env bash
vflag=off
filename=""
output=""

function usage() {
    echo "USAGE"
    echo    "    myscript [-h] [-v] [-f <filename>] [-o <filename>]"
    exit -1
}

# 在while循环中使用getopts解析命令行选项
# 要解析的的选项有-h、-v、-f和-o，其中-f和-o选项带有参数
# 字符串选项中第一个冒号表示getopts使用抑制错误报告模式
while getopts :hvf:o: opt; do
    case "$opt" in
    v)
       vflag=on
       ;;
    f)
        # 将-f选项的参数赋值给变量filename       
        filename=$OPTARG
        # 如果文件不存在，则显示提示信息，并退出脚本的执行       
        if [ ! -f $filename ]
        then
            echo "The source file $filename doesn't exist!"
            exit
        fi
       ;;
    o)
        output=$OPTARG
        if [ ! -d `dirname $output` ]; then
            echo "The output path `dirname $output` doesn't exist!"
            exit
        fi
       ;;
    h)
        # 显示脚本的使用信息
        usage
        exit
       ;;
    :)
        # 如果没有为需要参数的选项指定参数，则显示提示信息，并退出脚本的运行       
        echo "The option -$OPTARG requires an argument."
        exit 1
        ;;
    ?)
        echo "Invalid option: -$OPTARG"
        usage
        exit 2
        ;;
    esac
done
```

### deamo3

下面写一个打印文件指定行的简单例子，用于引导你思路，扩展你的脚本选项功能：

```sh
#!/bin/bash
NO_ARGS=0
E_OPTERROR=65

function usage() {
  echo "Usage: $0 -f <file_path> -n <line_number>"
  echo "-f, --file specified file"
  echo "-n, --line-number print specified line"
  exit $E_OPTERROR
}

[[ $# -eq $NO_ARGS ]] && usage

if [[ "$*" != *"-f"* || "$*" != *"-n"* ]]; then
  usage
fi

while getopts :f:n: option; do
  case $option in
  f)
    FILE=$OPTARG
    [ ! -f $FILE ] && echo "$FILE File not exist!" && exit
    ;;
  n)
    sed -n "${OPTARG}p" $FILE
    ;;
  ?) usage ;;
  esac
done
```

### deamo4

批量修改文件名

```sh
#!/bin/bash

printHelp ()
{
  echo "Usage: $0 -f find -r replace FILES_TO_RENAME*"
  echo -e "\t-f The text to find in the filename"
  echo -e "\t-r The text used to replace with in the filename"
  exit 1
}

while getopts "f:r:" opt; do
  case "$opt" in
    r ) replace="$OPTARG"    ;;
    f ) fnd="$OPTARG"        ;;
    ? ) printHelp            ;;
  esac
done

shift $(( $OPTIND - 1 ))

if [ -z $replace ] || [ -z $fnd ]
then
  echo "Need a string to find and a string to replace";
  printHelp
fi

for i in $@
do
  newname=$(echo $i | sed "s/$fnd/$replace/")
  mv $i $newname
  echo "Renamed file $i to $newname"
done
```

shell 命令行参数解析工具：getopts

- https://www.orchome.com/1327

getopt(s)：命令行选项、参数处理

- https://www.haxi.cc/archives/getopts-getopt.html

## 5.使用 argbash 工具

这个工具主要提供脚本参数的解析功能，而且不再引用任何第三方库的情况下。一般会比普通脚本多 30 多行而且，但是效果非常好。
详细信息可以通过官方网站地址了解。

https://argbash.io/generate#results

```shell
#!/bin/bash
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
# [可选参数]
# ARG_OPTIONAL_SINGLE([option], [o], [optional argument help msg])
# [可选布尔参数]
# ARG_OPTIONAL_BOOLEAN([print], , [boolean optional argument help msg])
# [固定参数]
# ARG_POSITIONAL_SINGLE([positional-arg], [positional argument help  msg], )
# [帮助信息]
# ARG_HELP([The general script's help msg])
# ARGBASH_GO
# [ <-- needed because of Argbash
echo "Value of --option: $_arg_option"
echo "print is $_arg_print"
echo "Value of positional-arg: $_arg_positional_arg"
# ] <-- needed because of Argbash |

```

## 6.使用 getopt 命令

```sh
#!/bin/bash
function usage() {
  cat <<EOF
Usage: $0 [options]

Options:
  -h, --help     Display this help message
  -v, --version  Display version information
  -f, --file     Specify the input file
  -t, --type     Specify the type of operation
EOF
}

# 检查是否有参数传入
if [ $# -eq 0 ]; then
  usage
  exit 1
fi

# 定义选项
SHORT_OPTS="h,v,f:,t:"
LONG_OPTS="help,version,file:,type:"

# 解析选项
PARSED_OPTS=$(getopt --options $SHORT_OPTS --longoptions $LONG_OPTS --name "$0" -- "$@")

# 如果解析失败，打印错误信息并退出
if [ $? -ne 0 ]; then
  usage >&2
  exit 2
fi

# 设置选项变量
eval set -- "$PARSED_OPTS"

# 处理选项
while true; do
  case "$1" in
  -h | --help)
    usage
    exit 0
    ;;
  -v | --version)
    echo "Version 2.0"
    exit 0
    ;;
  -f | --file)
    FILE="$2"
    shift 2
    ;;
  -t | --type)
    TYPE="$2"
    shift 2
    ;;
  --)
    shift
    break
    ;;
  *)
    echo "Invalid option: $1"
    usage >&2
    exit 1
    ;;
  esac
done

# 打印选项值
echo "File: $FILE"
echo "Type: $TYPE"
```

## 7.kolla-ansible 命令行示例

```sh
#!/bin/bash
#
# This script can be used to interact with kolla via ansible.


# 这个函数用于检查当前环境中是否安装了Ansible，以及Ansible的Python环境是否正常。
# 它首先检查Ansible是否安装，然后检查Ansible脚本的shebang行是否正确，接着验证Ansible使用的Python版本，并确保kolla_ansible模块在Ansible的PYTHONPATH中可用。
# 最后，它还会检查Ansible的版本是否在指定的范围内（2.8到2.9之间）
function check_environment_coherence {
    # 执行which ansible获取ansible路径；
    # 获取并校验ansible shebang line，从shebang line中截取python cmdline；
    # 根据ansible_python_cmdline获取python版本；
    # 检查python环境检查是否存在kolla_ansible模块；
    # 获取ansible具体版本，定义最小版本2.8，最大版本2.9；检查若不在规定版本范围内，则报错退出。
    local ansible_path
    ansible_path=$(which ansible)

    if [[ $? -ne 0 ]]; then
        echo "ERROR: Ansible is not installed in the current (virtual) environment." >&2
        exit 1
    fi

    local ansible_shebang_line
    ansible_shebang_line=$(head -n1 "$ansible_path")

    if ! echo "$ansible_shebang_line" | egrep "^#!" &>/dev/null; then
        echo "ERROR: Ansible script is malformed (missing shebang line)." >&2
        exit 1
    fi

    local ansible_python_cmdline
    # NOTE(yoctozepto): may have multiple parts
    ansible_python_cmdline=${ansible_shebang_line#\#\!}
    ansible_python_version=$($ansible_python_cmdline -c 'import sys; print(str(sys.version_info[0])+"."+str(sys.version_info[1]))')

    if ! $ansible_python_cmdline --version &>/dev/null; then
        echo "ERROR: Ansible Python is not functional." >&2
        echo "Tried '$ansible_python_cmdline'" >&2
        exit 1
    fi

    # Check for existence of kolla_ansible module using Ansible's Python.
    if ! $ansible_python_cmdline -c 'import kolla_ansible' &>/dev/null; then
        echo "ERROR: kolla_ansible has to be available in the Ansible PYTHONPATH." >&2
        echo "Please install both in the same (virtual) environment." >&2
        exit 1
    fi

    local ansible_version_output
    ansible_full_version=$($ansible_python_cmdline -c 'import ansible; print(ansible.__version__)')

    if [[ $? -ne 0 ]]; then
        echo "ERROR: Failed to obtain Ansible version:" >&2
        echo "$ansible_full_version" >&2
        exit 1
    fi

    local ansible_version
    ansible_version=$(echo "$ansible_full_version" | egrep -o '^[0-9]+\.[0-9]+')

    if [[ $? -ne 0 ]]; then
        echo "ERROR: Failed to parse Ansible version:" >&2
        echo "$ansible_full_version" >&2
        exit 1
    fi

    local ANSIBLE_VERSION_MIN=2.8
    local ANSIBLE_VERSION_MAX=2.9

    if [[ $(printf "%s\n" "$ANSIBLE_VERSION_MIN" "$ANSIBLE_VERSION_MAX" "$ansible_version" | sort -V | head -n1) != "$ANSIBLE_VERSION_MIN" ]] ||
       [[ $(printf "%s\n" "$ANSIBLE_VERSION_MIN" "$ANSIBLE_VERSION_MAX" "$ansible_version" | sort -V | tail -n1) != "$ANSIBLE_VERSION_MAX" ]]; then
        echo "ERROR: Ansible version should be between $ANSIBLE_VERSION_MIN and $ANSIBLE_VERSION_MAX. Current version is $ansible_full_version which is not supported."
        exit 1
    fi
}

# 这个函数用于确定Kolla-Ansible的基础目录。
# 它会根据不同的安装情况（如系统安装、用户安装、虚拟环境等）来确定正确的基础目录路径。
function find_base_dir {
    # 根据dirname "$0"，获取dir_name，用于找到kolla-ansible脚本所在的路径。
    # 根据返回不同的dir_name，拼接不同的BASEDIR，作为全局变量【此处dirname执行时，不是以root用户，而是以kolla用户的身份执行，返回的不是"/bin",而是"/usr/local/bin"】
    local dir_name
    local python_dir
    dir_name=$(dirname "$0")
    # NOTE(yoctozepto): Fix the case where dir_name is a symlink and VIRTUAL_ENV might not be. This
    # happens with pyenv-virtualenv, see https://bugs.launchpad.net/kolla-ansible/+bug/1903887
    dir_name=$(readlink -e "$dir_name")
    python_dir="python${ansible_python_version}"
    if [ -z "$SNAP" ]; then
        if [[ ${dir_name} == "/usr/bin" ]]; then
            if test -f /usr/lib/${python_dir}/*-packages/kolla-ansible.egg-link; then
                # Editable install.
                BASEDIR="$(head -n1 /usr/lib/${python_dir}/*-packages/kolla-ansible.egg-link)"
            else
                BASEDIR=/usr/share/kolla-ansible
            fi
        elif [[ ${dir_name} == "/usr/local/bin" ]]; then
            if test -f /usr/local/lib/${python_dir}/*-packages/kolla-ansible.egg-link; then
                # Editable install.
                BASEDIR="$(head -n1 /usr/local/lib/${python_dir}/*-packages/kolla-ansible.egg-link)"
            else
                BASEDIR=/usr/local/share/kolla-ansible
            fi
        elif [[ ${dir_name} == ~/.local/bin ]]; then
            if test -f ~/.local/lib/${python_dir}/*-packages/kolla-ansible.egg-link; then
                # Editable install.
                BASEDIR="$(head -n1 ~/.local/lib/${python_dir}/*-packages/kolla-ansible.egg-link)"
            else
                BASEDIR=~/.local/share/kolla-ansible
            fi
        elif [[ -n ${VIRTUAL_ENV} ]] && [[ ${dir_name} == "$(readlink -e "${VIRTUAL_ENV}/bin")" ]]; then
            if test -f ${VIRTUAL_ENV}/lib/${python_dir}/site-packages/kolla-ansible.egg-link; then
                # Editable install.
                BASEDIR="$(head -n1 ${VIRTUAL_ENV}/lib/${python_dir}/*-packages/kolla-ansible.egg-link)"
            else
                BASEDIR="${VIRTUAL_ENV}/share/kolla-ansible"
            fi
        else
            # Running from sources (repo).
            BASEDIR="$(dirname ${dir_name})"
        fi
    else
        BASEDIR="$SNAP/share/kolla-ansible"
    fi
}

# 直接执行拼接的CMD命令（CMD命令即：ansible-playbook -i 加指定参数）。
function process_cmd {
    echo "$ACTION : $CMD"
    $CMD
    if [[ $? -ne 0 ]]; then
        echo "Command failed $CMD"
        exit 1
    fi
}


# 使用手册打印值（即在xshell中直接执行kolla-ansible后返回值，用于命令行添加参数--help返回的帮助文档）
function usage {
    cat <<EOF
Usage: $0 COMMAND [options]

Options:
    --inventory, -i <inventory_path>   Specify path to ansible inventory file
    --playbook, -p <playbook_path>     Specify path to ansible playbook file
    --configdir <config_path>          Specify path to directory with globals.yml
    --key -k <key_path>                Specify path to ansible vault keyfile
    --help, -h                         Show this usage information
    --tags, -t <tags>                  Only run plays and tasks tagged with these values
    --skip-tags <tags>                 Only run plays and tasks whose tags do not match these values
    --extra, -e <ansible variables>    Set additional variables as key=value or YAML/JSON passed to ansible-playbook
    --passwords <passwords_path>       Specify path to the passwords file
    --limit <host>                     Specify host to run plays
    --forks <forks>                    Number of forks to run Ansible with
    --vault-id <@prompt or path>       Specify @prompt or password file (Ansible >=  2.4)
    --ask-vault-pass                   Ask for vault password
    --vault-password-file <path>       Specify password file for vault decrypt
    --verbose, -v                      Increase verbosity of ansible-playbook

Environment variables:
    EXTRA_OPTS                         Additional arguments to pass to ansible-playbook

Commands:
    prechecks           Do pre-deployment checks for hosts
    check               Do post-deployment smoke tests
    mariadb_recovery    Recover a completely stopped mariadb cluster
    mariadb_backup      Take a backup of MariaDB databases
                            --full (default)
                            --incremental
    bootstrap-servers   Bootstrap servers with kolla deploy dependencies
    destroy             Destroy Kolla containers, volumes and host configuration
                            --include-images to also destroy Kolla images
                            --include-dev to also destroy dev mode repos
    deploy              Deploy and start all kolla containers
    deploy-bifrost      Deploy and start bifrost container
    deploy-servers      Enroll and deploy servers with bifrost
    deploy-containers   Only deploy and start containers (no config updates or bootstrapping)
    post-deploy         Do post deploy on deploy node
    pull                Pull all images for containers (only pulls, no running container changes)
    reconfigure         Reconfigure OpenStack service
    stop                Stop Kolla containers
    certificates        Generate self-signed certificate for TLS *For Development Only*
    upgrade             Upgrades existing OpenStack Environment
    upgrade-bifrost     Upgrades an existing bifrost container
    genconfig           Generate configuration files for enabled OpenStack services
    prune-images        Prune orphaned Kolla images
EOF
}

# 这个函数提供了Bash自动补全的支持。它会列出所有支持的命令和选项，以便在Bash中使用时能够自动补全。
function bash_completion {
cat <<EOF
--inventory -i
--playbook -p
--configdir
--key -k
--help -h
--skip-tags
--tags -t
--extra -e
--passwords
--limit
--forks
--vault-id
--ask-vault-pass
--vault-password-file
--verbose -v
prechecks
check
mariadb_recovery
mariadb_backup
bootstrap-servers
destroy
deploy
deploy-bifrost
deploy-containers
deploy-servers
post-deploy
pull
reconfigure
stop
certificates
upgrade
upgrade-bifrost
genconfig
prune-images
EOF
}

check_environment_coherence


# 这部分代码使用getopt来解析命令行参数。它定义了短选项和长选项，并将它们映射到相应的处理逻辑上。
SHORT_OPTS="hi:p:t:k:e:v"
LONG_OPTS="help,inventory:,playbook:,skip-tags:,tags:,key:,extra:,verbose,configdir:,passwords:,limit:,forks:,vault-id:,ask-vault-pass,vault-password-file:,yes-i-really-really-mean-it,include-images,include-dev:,full,incremental"

RAW_ARGS="$*"
ARGS=$(getopt -o "${SHORT_OPTS}" -l "${LONG_OPTS}" --name "$0" -- "$@") || { usage >&2; exit 2; }

eval set -- "$ARGS"

find_base_dir

# INVENTORY默认值
INVENTORY="${BASEDIR}/ansible/inventory/all-in-one"
# 若不指定PLAYBOOK变量，则默认值/usr/local/share/kolla-ansible/ansible/site.yml
PLAYBOOK="${BASEDIR}/ansible/site.yml"
VERBOSITY=
EXTRA_OPTS=${EXTRA_OPTS}
CONFIG_DIR="/etc/kolla"
DANGER_CONFIRM=
INCLUDE_IMAGES=
INCLUDE_DEV=
BACKUP_TYPE="full"
# Serial is not recommended and disabled by default. Users can enable it by
# configuring ANSIBLE_SERIAL variable.
ANSIBLE_SERIAL=${ANSIBLE_SERIAL:-0}


# While判断，当参数个数不为0，开始匹配参数，以”kolla-ansible -i ./multinode deploy”为例分析
while [ "$#" -gt 0 ]; do
    case "$1" in

    (--inventory|-i)
            INVENTORY="$2"    # 获取第二个参数，如上例，即把’/multinode’赋值给INVENTORY
            shift 2           # shift命令用于位置参数左移，如上例，shift 2执行前，$1是’-i’，执行后$1是’deploy’，（多个条件处理时，用shift可适配不同个数的参数）
            ;;                # case固定用法，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;
                              # 其它参数类似处理
    (--playbook|-p)
            PLAYBOOK="$2"
            shift 2
            ;;

    (--skip-tags)
            EXTRA_OPTS="$EXTRA_OPTS --skip-tags $2"
            shift 2
            ;;

    (--tags|-t)
            EXTRA_OPTS="$EXTRA_OPTS --tags $2"
            shift 2
            ;;

    (--verbose|-v)
            VERBOSITY="$VERBOSITY --verbose"
            shift 1
            ;;

    (--configdir)
            CONFIG_DIR="$2"
            shift 2
            ;;

    (--yes-i-really-really-mean-it)
            if [[ ${RAW_ARGS} =~ "$1" ]]
            then
                DANGER_CONFIRM="$1"
            fi
            shift 1
            ;;

    (--include-images)
            INCLUDE_IMAGES="$1"
            shift 1
            ;;

    (--include-dev)
            INCLUDE_DEV="$1"
            shift 1
            ;;

    (--key|-k)
            VAULT_PASS_FILE="$2"
            EXTRA_OPTS="$EXTRA_OPTS --vault-password-file=$VAULT_PASS_FILE"
            shift 2
            ;;

    (--extra|-e)
            EXTRA_OPTS="$EXTRA_OPTS -e $2"
            shift 2
            ;;

    (--passwords)
            PASSWORDS_FILE="$2"
            shift 2
            ;;

    (--limit)
            EXTRA_OPTS="$EXTRA_OPTS --limit $2"
            shift 2
            ;;

    (--forks)
            EXTRA_OPTS="$EXTRA_OPTS --forks $2"
            shift 2
            ;;

    (--vault-id)
            EXTRA_OPTS="$EXTRA_OPTS --vault-id $2"
            shift 2
            ;;

    (--ask-vault-pass)
            VERBOSITY="$EXTRA_OPTS --ask-vault-pass"
            shift 1
            ;;

    (--vault-password-file)
            EXTRA_OPTS="$EXTRA_OPTS --vault-password-file $2"
            shift 2
            ;;

    (--full)
            BACKUP_TYPE="full"
            shift 1
            ;;

    (--incremental)
            BACKUP_TYPE="incremental"
            shift 1
            ;;

    (--help|-h)
            usage
            shift
            exit 0
            ;;

    (--)
            shift
            break
            ;;

    (*)
            echo "error"
            exit 3
            ;;
esac
done

case "$1" in

(prechecks)
        ACTION="Pre-deployment checking"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=precheck"
        ;;
(check)
        ACTION="Post-deployment checking"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=check"
        ;;
(mariadb_recovery)
        ACTION="Attempting to restart mariadb cluster"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy -e common_run=true"
        PLAYBOOK="${BASEDIR}/ansible/mariadb_recovery.yml"
        ;;
(mariadb_backup)
        ACTION="Backup MariaDB databases"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=backup -e mariadb_backup_type=${BACKUP_TYPE} -e common_run=true"
        PLAYBOOK="${BASEDIR}/ansible/mariadb_backup.yml"
        ;;
(destroy)
        ACTION="Destroy Kolla containers, volumes and host configuration"
        PLAYBOOK="${BASEDIR}/ansible/destroy.yml"
        if [[ "${INCLUDE_IMAGES}" == "--include-images" ]]; then
            EXTRA_OPTS="$EXTRA_OPTS -e destroy_include_images=yes"
        fi
        if [[ "${INCLUDE_DEV}" == "--include-dev" ]]; then
            EXTRA_OPTS="$EXTRA_OPTS -e destroy_include_dev=yes"
        fi
        if [[ "${DANGER_CONFIRM}" != "--yes-i-really-really-mean-it" ]]; then
            cat << EOF
WARNING:
    This will PERMANENTLY DESTROY all deployed kolla containers, volumes and host configuration.
    There is no way to recover from this action. To confirm, please add the following option:
    --yes-i-really-really-mean-it
EOF
            exit 1
        fi
        ;;
(bootstrap-servers)
        ACTION="Bootstrapping servers"
        PLAYBOOK="${BASEDIR}/ansible/kolla-host.yml"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=bootstrap-servers"
        ;;
(deploy)
        ACTION="Deploying Playbooks"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy"
        ;;
(deploy-bifrost)
        ACTION="Deploying Bifrost"
        PLAYBOOK="${BASEDIR}/ansible/bifrost.yml"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy"
        ;;
(deploy-containers)
        ACTION="Deploying Containers"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy-containers"
        ;;
(deploy-servers)
        ACTION="Deploying servers with bifrost"
        PLAYBOOK="${BASEDIR}/ansible/bifrost.yml"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=deploy-servers"
        ;;
(post-deploy)
        ACTION="Post-Deploying Playbooks"
        PLAYBOOK="${BASEDIR}/ansible/post-deploy.yml"
        ;;
(pull)
        ACTION="Pulling Docker images"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=pull"
        ;;
(upgrade)
        ACTION="Upgrading OpenStack Environment"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=upgrade -e kolla_serial=${ANSIBLE_SERIAL}"
        ;;
(upgrade-bifrost)
        ACTION="Upgrading Bifrost"
        PLAYBOOK="${BASEDIR}/ansible/bifrost.yml"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=upgrade"
        ;;
(reconfigure)
        ACTION="Reconfigure OpenStack service"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=reconfigure -e kolla_serial=${ANSIBLE_SERIAL}"
        ;;
(stop)
        ACTION="Stop Kolla containers"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=stop"
        if [[ "${DANGER_CONFIRM}" != "--yes-i-really-really-mean-it" ]]; then
            cat << EOF
WARNING:
    This will stop all deployed kolla containers, limit with tags is possible and also with
    skip_stop_containers variable. To confirm, please add the following option:
    --yes-i-really-really-mean-it
EOF
            exit 1
        fi
        ;;
(certificates)
        ACTION="Generate TLS Certificates"
        PLAYBOOK="${BASEDIR}/ansible/certificates.yml"
        ;;
(genconfig)
        ACTION="Generate configuration files for enabled OpenStack services"
        EXTRA_OPTS="$EXTRA_OPTS -e kolla_action=config"
        ;;
(prune-images)
        ACTION="Prune orphaned Kolla images"
        PLAYBOOK="${BASEDIR}/ansible/prune-images.yml"
        if [[ "${DANGER_CONFIRM}" != "--yes-i-really-really-mean-it" ]]; then
            cat << EOF
WARNING:
    This will PERMANENTLY DELETE all orphaned kolla images. To confirm, please add the following option:
    --yes-i-really-really-mean-it
EOF
            exit 1
        fi
        ;;
(bash-completion)
        bash_completion
        exit 0
        ;;
(*)     usage
        exit 3
        ;;
esac

PASSWORDS_FILE="${PASSWORDS_FILE:-${CONFIG_DIR}/passwords.yml}"
CONFIG_OPTS="-e @${CONFIG_DIR}/globals.yml -e @${PASSWORDS_FILE} -e CONFIG_DIR=${CONFIG_DIR}"

# ansible-playbook指定参数变量的调用，参数都是以上shell脚本内容处理之后的值
# INVENTORY参数，即INVENTORY文件，用于ansible配置主机组信息；（Ansible可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置. 默认的文件路径为/etc/ansible/hosts）
# CONFIG_OPTS，用于指定globals.yml,passwords.yml，配置文件目录，主要是指定一些配置相关;
# EXTRA_OPTS主要是指定执行的动作，例如”-e kolla_action=deploy”;
# PLAYBOOK为roles的入口文件site.yml.（Playbooks是Ansible的配置、部署、编排语言.可以被描述为一个需要远程主机执行命令的方案,或者一组IT程序运行的命令集合。）
CMD="ansible-playbook -i $INVENTORY $CONFIG_OPTS $EXTRA_OPTS $PLAYBOOK $VERBOSITY"

# Deploy动作的调用过程为：kolla-ansible -i multinode deploy ---->调用/usr/local/share/kolla-ansible/ansible/site.yml ---->根据site.yml文件的task调用执行各role

# 整个脚本的调用入口，其实只是调用了CMD命令
process_cmd
```

## 8.选项标准化

在编写 shell 脚本时，一切尽在你的控制中。选用哪些选项字母以及选项的具体用法，完全由你掌握。

但在 Linux 中，有些选项字母在某种程度上已经有了标准含义。

如果能在 shell 脚本中支持这些选项，则你的脚本会对用户更友好。

下表 显示了 Linux 中用到的一些命令行选项的常用含义。

| 选 项 | 描 述                        |
| ----- | ---------------------------- |
| -a    | 显示所有对象                 |
| -c    | 生成计数                     |
| -d    | 指定目录                     |
| -e    | 扩展对象                     |
| -f    | 指定读入数据的文件           |
| -h    | 显示命令的帮助信息           |
| -i    | 忽略文本大小写               |
| -l    | 产生长格式输出               |
| -n    | 使用非交互模式（批处理）     |
| -o    | 将所有输出重定向至指定的文件 |
| -q    | 以静默模式运行               |
| -r    | 递归处理目录和文件           |
| -s    | 以静默模式运行               |
| -v    | 生成详细输出                 |
| -x    | 排除某个对象                 |
| -y    | 对所有问题回答 yes           |

如果你的脚本选项也遵循同样的含义，那么用户在使用的时候就不用再查手册了。

参考文献:

https://www.escapelife.site/posts/9b814911.html

## 9.并发批量管理 500 台以上服务器脚本分享

用法：

```sh
Usage: ./multi_main.sh [-h|--help]
                 [-v|-V|--version]
                 [-l|--iplist ... ]
                 [-c|--config ... ]
                 [-t|--sshtimeout ... ]
                 [-T|--fttimeout ... ]
                 [-L|--bwlimit ... ]
                 [-n|--ignore]
```

cat config.txt #上传文件和执行命令

```sh
file:::~/scripts/test.sh /root/ push
com:::./test.sh
```

cat iplist.txt #ip 列表

```sh
# Usage:
#ip port user password [password_2] [password_3] [password_4]
# Example:
#192.168.0.100 22 root 123456
192.168.0.200 22 root 123456
192.168.0.201 22 root 123456
...
```

```sh
./multi_main.sh -c config.txt -l iplist.txt #开始执行，可查看result目录下的日志来分析是否执行成功
```

### 脚本如下

- mssh.exp 执行远程服务器命令 expect 脚本
- mscp.exp 向远程服务器上传或下载文件 expect 脚本（rsync）
- thread.sh 向一台服务器发起动作
- ckssh.py 检查 ssh 是否通
- multi_main.sh 批量执行，对每台调用 thread.sh

`mssh.exp`

```sh
#!/usr/bin/expect --

if { [llength $argv] < 4 } {
        puts "Usage: $argv0 ip user passwd port commands timeout"
        exit 1
}

match_max 600000

set ipcode [lindex $argv 0]
set ip [exec dc -e $ipcode]
set user [lindex $argv 1]
set passwdcode [lindex $argv 2]
set passwd [exec dc -e $passwdcode]
set portcode [lindex $argv 3]
set port [exec dc -e $portcode]
set commands [lindex $argv 4]
set timeoutflag [lindex $argv 5]

set yesnoflag 0
set timeout $timeoutflag


for {} {1} {} {
# for is only used to retry when "Interrupted system call" occured

spawn /usr/bin/ssh -o GSSAPIAuthentication=no -q -l$user -p$port $ip

expect  {

        "assword:" {
                send "$passwd\r"
                break;
        }

        "yes/no)?" {
                set yesnoflag 1
                send "yes\r"
                break;
        }

        "FATAL" {
                puts "\nCONNECTERROR: $ip occur FATAL ERROR!!!\n"
                exit 1
        }

        timeout {
                puts "\nCONNECTERROR: $ip Logon timeout!!!\n"
                exit 1
        }

        "No route to host" {
                puts "\nCONNECTERROR: $ip No route to host!!!\n"
                exit 1
        }

        "Connection Refused" {
                puts "\nCONNECTERROR: $ip Connection Refused!!!\n"
                exit 1
        }

        "Connection refused" {
                puts "\nCONNECTERROR: $ip Connection Refused!!!\n"
                exit 1
        }

        "Host key verification failed" {
                puts "\nCONNECTERROR: $ip Host key verification failed!!!\n"
                exit 1
        }

        "Illegal host key" {
                puts "\nCONNECTERROR: $ip Illegal host key!!!\n"
                exit 1
        }

        "Connection Timed Out" {
                puts "\nCONNECTERROR: $ip Logon timeout!!!\n"
                exit 1
        }

        "Interrupted system call" {
                puts "\n$ip Interrupted system call!!!\n"
        }
}
}

if { $yesnoflag == 1 } {
        expect {
                "assword:" {
                        send "$passwd\r"
                }

                "yes/no)?" {
                        set yesnoflag 2
                        send "yes\r"
                }
        }
}

if { $yesnoflag == 2 } {
        expect {
                "assword:" {
                        send "$passwd\r"
                }
        }
}

expect {
        "]" {send "$commands \r"}
        "assword:" {
                send "$passwd\r"
                puts "\nPASSWORDERROR: $ip Password error!!!\n"
                exit 1
        }
}

expect {
        "]" {send "sleep 1 \r"}
}

expect {
        "]" {send "exit\r"}
}

expect eof {
        puts "OK_SSH: $ip\n"
        exit 0;
}
```

mscp.exp

```sh
#!/usr/bin/expect --

proc Usage_Exit {self} {
        puts ""
        puts "Usage: $self ip user passwd port sourcefile destdir direction bwlimit timeout"
        puts ""
        puts "       sourcefile: a file or directory to be transferred"
        puts "                   需要拷贝目录时目录名后不要带 /, 否则会拷贝该目录下的所有文件"
        puts "       destdir:    the location that the sourcefile to be put into"
        puts "       direction:  pull or push"
        puts "                   pull: remote -> local"
        puts "                   push: local -> remote"
        puts "       bwlimit:    bandwidth limit, kbit/s, 0 means no limit"
        puts "       timeout:    timeout of expect, s, -1 means no timeout"
        puts ""
        exit 1
}

if { [llength $argv] < 9 } {
        Usage_Exit $argv0
}

set ipcode [lindex $argv 0]
set ip [exec dc -e $ipcode]
set user [lindex $argv 1]
set passwduncode [lindex $argv 2]
set passwd [exec dc -e $passwduncode]
set portcode [lindex $argv 3]
set port [exec dc -e $portcode]
set sourcefile [lindex $argv 4]
set destdir [lindex $argv 5]
set direction [lindex $argv 6]
set bwlimit [lindex $argv 7]
set timeoutflag [lindex $argv 8]

set yesnoflag 0
set timeout $timeoutflag

for {} {1} {} {
# for is only used to retry when "Interrupted system call" occured

if { $direction == "pull" } {

        if { $bwlimit > 0 } {
                spawn rsync -crazP --bwlimit=$bwlimit -e "/usr/bin/ssh -o GSSAPIAuthentication=no -q -l$user -p$port" $ip:$sourcefile $destdir
        } elseif { $bwlimit == 0 } {
                spawn rsync -crazP -e "/usr/bin/ssh -o GSSAPIAuthentication=no -q -l$user -p$port" $ip:$sourcefile $destdir
        } else {
                Usage_Exit $argv0
        }

} elseif { $direction == "push" } {

        if { $bwlimit > 0 } {
                spawn rsync -crazP --bwlimit=$bwlimit -e "/usr/bin/ssh -o GSSAPIAuthentication=no -q -l$user -p$port" $sourcefile $ip:$destdir
        } elseif { $bwlimit == 0 } {
                spawn rsync -crazP -e "/usr/bin/ssh -o GSSAPIAuthentication=no -q -l$user -p$port" $sourcefile $ip:$destdir
        } else {
                Usage_Exit $argv0
        }

} else {
        Usage_Exit $argv0
}

expect  {

        "assword:" {
                send "$passwd\r"
                break;
        }

        "yes/no)?" {
                set yesnoflag 1
                send "yes\r"
                break;
        }

        "FATAL" {
                puts "\nCONNECTERROR: $ip occur FATAL ERROR!!!\n"
                exit 1
        }

        timeout {
                puts "\nCONNECTERROR: $ip Logon timeout!!!\n"
                exit 1
        }

        "No route to host" {
                puts "\nCONNECTERROR: $ip No route to host!!!\n"
                exit 1
        }

        "Connection Refused" {
                puts "\nCONNECTERROR: $ip Connection Refused!!!\n"
                exit 1
        }

        "Connection refused" {
                puts "\nCONNECTERROR: $ip Connection Refused!!!\n"
                exit 1
        }

        "Host key verification failed" {
                puts "\nCONNECTERROR: $ip Host key verification failed!!!\n"
                exit 1
        }

        "Illegal host key" {
                puts "\nCONNECTERROR: $ip Illegal host key!!!\n"
                exit 1
        }

        "Connection Timed Out" {
                puts "\nCONNECTERROR: $ip Logon timeout!!!\n"
                exit 1
        }

        "Interrupted system call" {
                puts "\n$ip Interrupted system call!!!\n"
        }
}

}

if { $yesnoflag == 1 } {
        expect {
                "assword:" {
                        send "$passwd\r"
                }

                "yes/no)?" {
                        set yesnoflag 2
                        send "yes\r"
                }
        }
}

if { $yesnoflag == 2 } {
        expect {
                "assword:" {
                        send "$passwd\r"
                }
        }
}

expect {
        "assword:" {
                send "$passwd\r"
                puts "\nPASSWORDERROR: $ip Password error!!!\n"
                exit 1
        }

        eof {
                puts "OK_SCP: $ip\n"
                exit 0;
        }
}
```

`thread.sh`

```sh
#!/bin/bash

# Default Parameters
myIFS=":::"     # 配置文件中的分隔符
TOOLDIR=~/scripts
cd $TOOLDIR

#BEGINDATETIME=`date "+%F %T"`

IP=$1P
PORT=$2P
USER=$3
PASSWD=$4P
CONFIG_FILE=$5                # 命令列表和文件传送配置列表，关键字为com:::和file:::
SSHTIMEOUT=$6                 # 远程命令执行相关操作的超时设定，单位为秒
SCPTIMEOUT=$7                 # 文件传送相关操作的超时设定，单位为秒
BWLIMIT=$8                    # 文件传送的带宽限速，单位为kbit/s

# 针对一个$IP，执行配置文件中的一整套操作
while read eachline
do
        # 必须以com或file开头
        [ -z "`echo $eachline | grep -E '^com|^file'`" ] && continue

        myKEYWORD=`echo $eachline | awk -F"$myIFS" '{ print $1 }'`
        myCONFIGLINE=`echo $eachline | awk -F"$myIFS" '{ print $2 }'`

        # 配置文件中有关键字file:::，就调用mscp.exp进行文件传送
        if [ "$myKEYWORD"x == "file"x ]; then
                SOURCEFILE=`echo $myCONFIGLINE | awk '{ print $1 }'`
                DESTDIR=`echo $myCONFIGLINE | awk '{ print $2 }'`
                DIRECTION=`echo $myCONFIGLINE | awk '{ print $3 }'`
                $TOOLDIR/mscp.exp $IP $USER $PASSWD $PORT $SOURCEFILE $DESTDIR $DIRECTION $BWLIMIT $SCPTIMEOUT

                [ $? -ne 0 ] && echo -e "\033[31mSCP Try Out All Password Failed\033[0m\n"

        # 配置文件中有关键字com:::，就调用mssh.exp进行远程命令执行
        elif [ "$myKEYWORD"x == "com"x ]; then
                $TOOLDIR/mssh.exp $IP $USER $PASSWD $PORT "${myCONFIGLINE}" $SSHTIMEOUT
                #echo  $IP $USER $PASSWD $PORT "${myCONFIGLINE}" $SSHTIMEOUT
                [ $? -ne 0 ] && echo -e "\033[31mSSH Try Out All Password Failed\033[0m\n"

        else
                echo "ERROR: configuration wrong! [$eachline] "
                echo "       where KEYWORD should not be [$myKEYWORD], but 'com' or 'file'"
                echo "       if you dont want to run it, you can comment it with '#'"
                echo ""
                exit
        fi

done < $CONFIG_FILE

#ENDDATETIME=`date "+%F %T"`

#echo "$BEGINDATETIME -- $ENDDATETIME"
#echo "$0 $* --excutes over!"

exit 0
```

`ckssh.py`

```python
#!/usr/bin/python
import socket,sys
sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sk.settimeout(1)
try:
    sk.connect((sys.argv[1],int(sys.argv[2])))
    print 'ok'
except Exception:
    print 'no'
sk.close()
```

`multi_main.sh`

```sh
#!/bin/bash
#Blog: linuxeye.com

######################  proc defination  ########################
# ignore rule
ignore_init()
{
        # ignore password
        array_ignore_pwd_length=0
        if [ -f ./ignore_pwd ]; then
                while read IGNORE_PWD
                do
                        array_ignore_pwd[$array_ignore_pwd_length]=$IGNORE_PWD
                        let array_ignore_pwd_length=$array_ignore_pwd_length+1
                done < ./ignore_pwd
        fi

        # ignore ip address
        array_ignore_ip_length=0
        if [ -f ./ignore_ip ]; then
                while read IGNORE_IP
                do
                        array_ignore_ip[$array_ignore_ip_length]=$IGNORE_IP
                        let array_ignore_ip_length=$array_ignore_ip_length+1
                done < ./ignore_ip
        fi
}

show_version()
{
        echo "version: 1.0"
        echo "updated date: 2014-05-28"
}

show_usage()
{
        echo -e "`printf %-16s "Usage: $0"` [-h|--help]"
        echo -e "`printf %-16s ` [-v|-V|--version]"
        echo -e "`printf %-16s ` [-l|--iplist ... ]"
        echo -e "`printf %-16s ` [-c|--config ... ]"
        echo -e "`printf %-16s ` [-t|--sshtimeout ... ]"
        echo -e "`printf %-16s ` [-T|--fttimeout ... ]"
        echo -e "`printf %-16s ` [-L|--bwlimit ... ]"
        echo -e "`printf %-16s ` [-n|--ignore]"
        #echo "ignr_flag: 'ignr'-some ip will be ignored; otherwise-all ip will be handled"
}

TOOLDIR=~/scripts
cd $TOOLDIR

IPLIST="iplist.txt"                     # IP列表，格式为IP 端口 用户名 密码
CONFIG_FILE="config.txt"                # 命令列表和文件传送配置列表，关键字为com:::和file:::
IGNRFLAG="noignr"                       # 如果置为ignr，则脚本会进行忽略条件的判断
SSHTIMEOUT=100                          # 远程命令执行相关操作的超时设定，单位为秒
SCPTIMEOUT=2000                         # 文件传送相关操作的超时设定，单位为秒
BWLIMIT=1024000                         # 文件传送的带宽限速，单位为kbit/s
[ ! -d "result" ] && mkdir result

# 入口参数分析
TEMP=`getopt -o hvVl:c:t:T:L:n --long help,version,iplist:,config:,sshtimeout:,fttimeout:,bwlimit:,ignore -- "$@" 2>/dev/null`

[ $? != 0 ] && echo -e "\033[31mERROR: unknown argument! \033[0m\n" && show_usage && exit 1

# 会将符合getopt参数规则的参数摆在前面，其他摆在后面，并在最后面添加--
eval set -- "$TEMP"

while :
do
        [ -z "$1" ] && break;
        case "$1" in
                -h|--help)
                        show_usage; exit 0
                        ;;
                -v|-V|--version)
                        show_version; exit 0
                        ;;
                -l|--iplist)
                        IPLIST=$2; shift 2
                        ;;
                -c|--config)
                        CONFIG_FILE=$2; shift 2
                        ;;
                -t|--sshtimeout)
                        SSHTIMEOUT=$2; shift 2
                        ;;
                -T|--fttimeout)
                        SCPTIMEOUT=$2; shift 2
                        ;;
                -L|--bwlimit)
                        BWLIMIT=$2; shift 2
                        ;;
                -n|--ignore)
                        IGNRFLAG="ignr"; shift
                        ;;
                --)
                        shift
                        ;;
                *)
                        echo -e "\033[31mERROR: unknown argument! \033[0m\n" && show_usage && exit 1
                        ;;
        esac
done

################  main  #######################
BEGINDATETIME=`date "+%F %T"`
[ ! -f $IPLIST ] && echo -e "\033[31mERROR: iplist \"$IPLIST\" not exists, please check! \033[0m\n" && exit 1

[ ! -f $CONFIG_FILE ] && echo -e "\033[31mERROR: config \"$CONFIG_FILE\" not exists, please check! \033[0m\n" && exit 1

IP_count=$(egrep -v '^#|^$' $IPLIST|wc -l)
IP_init=1
while [[ $IP_init -le $IP_count ]]
do
        egrep -v '^#|^$' $IPLIST | sed -n "$IP_init,$(expr $IP_init + 50)p" > $IPLIST.tmp #并发50

        IPSEQ=0

        while read IP PORT USER PASSWD PASSWD_2ND PASSWD_3RD PASSWD_4TH OTHERS
       # while read Line
        do
                [ -z "`echo $IP | grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}|CNS'`" ] && continue
                if [ "`python $TOOLDIR/ckssh.py $IP $PORT`" == 'no' ];then
                        [ ! -e ipnologin.txt ] && > ipnologin.txt
                        [ -z "`grep $IP ipnologin.txt | grep $(date +%F)`" ] && echo "`date +%F_%H%M` $IP" >> ipnologin.txt
                        continue
                fi

                let IPSEQ=$IPSEQ+1

                # 如果启用了忽略，则进入忽略流程
                if [ $IGNRFLAG == "ignr" ]; then
                        ignore_init
                        ignored_flag=0

                        i=0
                        while [ $i -lt $array_ignore_pwd_length ]
                        do
                                [ ${PASSWD}x == ${array_ignore_pwd[$i]}x ] && ignored_flag=1 && break
                                let i=$i+1
                        done

                        [ $ignored_flag -eq 1 ] && continue

                        j=0
                        while [ $j -lt $array_ignore_ip_length ]
                        do
                                [ ${IP}x == ${array_ignore_ip[$j]}x ] && ignored_flag=1 && break
                                let j=$j+1
                        done

                        [ $ignored_flag -eq 1 ] && continue
                fi

                ####### Try password from here ####
                #for PW in $PASSWD $PASSWD_2ND $PASSWD_3RD $PASSWD_4TH
                #do
                #        PASSWD_USE=$PW
                #        $TOOLDIR/ssh.exp $IP $USER $PW $PORT true $SSHTIMEOUT
                #        [ $? -eq 0 ] && PASSWD_USE=$PW && break
                #done
                PASSWD_USE=$PASSWD

                IPcode=$(echo "ibase=16;$(echo "$IP" | xxd -ps -u)"|bc|tr -d '\\'|tr -d '\n')
                Portcode=$(echo "ibase=16;$(echo "$PORT" | xxd -ps -u)"|bc|tr -d '\\'|tr -d '\n')
                #USER=$USER
                PWcode=$(echo "ibase=16;$(echo "$PASSWD_USE" | xxd -ps -u)"|bc|tr -d '\\'|tr -d '\n')
                Othercode=$(echo "ibase=16;$(echo "$OTHERS" | xxd -ps -u)"|bc|tr -d '\\'|tr -d '\n')
                #echo $IPcode $Portcode $USER $PWcode $CONFIG_FILE $SSHTIMEOUT $SCPTIMEOUT $BWLIMIT $Othercode
                ./thread.sh $IPcode $Portcode $USER $PWcode $CONFIG_FILE $SSHTIMEOUT $SCPTIMEOUT $BWLIMIT $Othercode | tee result/$IP.log &
        done < $IPLIST.tmp
        sleep 3
        IP_init=$(expr $IP_init + 50)
done

ENDDATETIME=`date "+%F %T"`

echo "$BEGINDATETIME -- $ENDDATETIME"
echo "$0 $* --excutes over!"

exit 0
```

参考文献：

- https://linuxeye.com/398.html
