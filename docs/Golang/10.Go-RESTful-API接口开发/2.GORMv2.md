# 2.GORMv2

## 1 什么是ORM

orm是一种术语而不是软件

1）orm英文全称object relational mapping，就是对象映射关系程序

2）简单来说类似python这种面向对象的程序来说一切皆对象，但是我们使用的数据库都是关系型的

3）为了保证一致的使用习惯，通过orm将编程语言的对象模型和数据库的关系模型建立映射关系

4）这样我们直接使用编程语言的对象模型进行操作数据库就可以了，而不用直接使用sql语言




## 2 什么是GORM

[官方文档](https://gorm.io/zh_CN/)


GORM是一个神奇的，对开发人员友好的golang orm库

- 全特性orm（几乎包含所有特性）
- 模型关联（一对一，一对多，一对多（反向），多对多，多态关联）
- 钩子（Before/After Create/Save/Update/Delete/Find)
- 预加载
- 事务
- 复合主键
- sql构造器
- 自动迁移
- 日志
- 基于gorm回调编写可扩展插件
- 全特性测试覆盖
- 开发者友好


## 3 GORMv1.23.8


### 3.1 安装

```shell
go get -u gorm.io/gorm
go get -u gorm.io/driver/mysql      # mysql
go get -u gorm.io/driver/sqlite     # sqlite
```


### 3.2 连接Mysql 

[参考文档](https://gorm.io/zh_CN/docs/connecting_to_the_database.html)

先创建一个数据库

```shell
mysql -u root -p        #进入sql
mysql> create database test_db charset utf8; #创建数据库
mysql> use test_db;     #切换到数据库
mysql> show tables;     #查看是否生成表
mysql> desc users;      #查看表的字段是否正常
```

创建mysql连接 

连接到数据库

```go
package main

import (
	"fmt"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func main() {
	/*
		dsn:="user:password@tcp(127.0.0.1:3006)/dbname?charset=utf8mb4&parseTime=True&loc=Local"

	*/
	dsn := "root:123456@tcp(127.0.0.1:3306)/chat?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic(err)
	}
	fmt.Println("db", db)
	fmt.Println("err", err)
}

```


### 3.3 自动创建表

(迁移数据)

[参考文档](https://gorm.io/zh_CN/docs/migration.html)


```go
package main

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

// User表的结构体ORM映射
type User struct {
	Id       int64 `gorm:"primary_key" json:"id"`
	Username string
	Password string
}

func main() {
	/*
		dsn:="user:password@tcp(127.0.0.1:3006)/dbname?charset=utf8mb4&parseTime=True&loc=Local"

	*/
	//1、连接数据库
	dsn := "root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic(err)
	}

	// 启用日志记录功能
	// db = db.Debug()

	//2、自动创建表
	db.AutoMigrate(
		User{},
	)
}

/*
2022/07/19 16:21:16 D:/goproject/Ginedu/02gorm/01demo_gorm/main.go:33 SLOW SQL >= 200ms
[702.140ms] [rows:0] CREATE TABLE `users` (`id` bigint AUTO_INCREMENT,`username` longtext,`password` longtext,PRIMARY KEY (`id`))
*/
```

### 3.4 操作示范


```go
package main

import (
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

type Product struct {
	gorm.Model
	Code  string
	Price uint
}

func main() {
	dsn := "root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic("failed to connect database")
	}

	// 迁移 schema
	db.AutoMigrate(&Product{})

	// Create
	db.Create(&Product{Code: "D42", Price: 100})

	// // Read
	var product Product
	db.First(&product, 1)                 // 根据整型主键查找
	db.First(&product, "code = ?", "D42") // 查找 code 字段值为 D42 的记录

	// Update - 将 product 的 price 更新为 200
	db.Model(&product).Update("Price", 200)
	// Update - 更新多个字段
	db.Model(&product).Updates(Product{Price: 200, Code: "F42"}) // 仅更新非零值字段
	db.Model(&product).Updates(map[string]interface{}{"Price": 200, "Code": "F42"})

	// Delete - 删除 product
	db.Delete(&product, 1)
}
```



## 4.CRUD接口



### 4.1 创建 

https://gorm.io/zh_CN/docs/create.html


#### 1.创建记录

```go
package main

import (
	"fmt"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

type User struct {
	gorm.Model
	ID       uint      // 主键自增ID
	Name     string    // 用户名
	Age      uint      // 年龄
	Birthday time.Time // 生日
}

func main() {
	dsn := "root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic("failed to connect database")
	}

	user := User{Name: "hujianli", Age: 18, Birthday: time.Now()}

	// 迁移 schema
	err = db.AutoMigrate(&User{})
	if err != nil {
		panic("failed to migrate schema")
	}
	db = db.Debug()

	result := db.Create(&user) // 通过数据的指针来创建//id默认自增
	fmt.Println(result.RowsAffected)

	// user.ID             // 返回插入数据的主键
	// result.Error        // 返回 error
	// result.RowsAffected // 返回插入记录的条数
}

```


#### 2.用指定的字段创建记录


创建记录并更新给出的字段

比如生日的记录不创建。

```go
// .....
	user := User{Name: "hujianli", Age: 18, Birthday: time.Now()}

	// 迁移 schema
	err = db.AutoMigrate(&User{})
	if err != nil {
		panic("failed to migrate schema")
	}
	db = db.Debug()

	db.Select("Name", "Age").Create(&user)
}
```

 创建一个记录且一同忽略传递给略去的字段值。  

```go
//此时插入，如果id已被赋予，主键重复
db.Omit("Name", "Age", "CreatedAt").Create(&user)
// INSERT INTO `users` (`birthday`,`updated_at`) VALUES ("2020-01-01 00:00:00.000", "2020-07-04 11:05:21.775")
```



#### 3.批量插入


要有效地插入大量记录，请将一个 slice 传递给 Create 方法。 GORM 将生成单独一条SQL语句来插入所有数据，并回填主键的值，钩子方法也会被调用。


```go
package main

import (
	"fmt"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

type User struct {
	gorm.Model
	ID   uint   `gorm:"primaryKey"` // 添加ID字段并标记为主键
	Name string // 用户名
}

func main() {
	dsn := "root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic("failed to connect database")
	}

	// 迁移 schema
	err = db.AutoMigrate(&User{})
	if err != nil {
		panic("failed to migrate schema")
	}
	db = db.Debug()

	var users = []User{{Name: "jinzhu1"}, {Name: "jinzhu2"}, {Name: "jinzhu3"}}
	db.Create(&users)

	for _, user := range users {
		fmt.Println(user.ID)
	}
}
```

编译输出

```shell
2023/09/07 18:10:34 D:/golang/go/src/gitee.com/hujianli94net/gorm-demo/main.go:31
[45.120ms] [rows:3] INSERT INTO `users` (`created_at`,`updated_at`,`deleted_at`,`name`) VALUES ('2023-09-07 18:10:34.907','2023-09-07 18:10:34.907',NULL,'jinzhu1'),('2023-09-07 18:10:34.907','2023-09-07 18:10:34.907',NULL,'jinzhu2'),('2023-09-07 18:10:34.907','2023-09-07 18:10:34.907',NULL,'jinzhu3')
1
2
3
```

使用 CreateInBatches 分批创建时，你可以指定每批的数量，例如：  

```go
var users = []User{{name: "jinzhu_1"}, ...., {Name: "jinzhu_10000"}}

// 数量为 100
db.CreateInBatches(users, 100)
```

 [Upsert](https://gorm.io/zh_CN/docs/create.html#%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5) 和 [Create With Associations](https://gorm.io/zh_CN/docs/create.html#create_with_associations) 也支持批量插入 



#### 4.创建钩子

GORM 允许用户定义的钩子有 BeforeSave, BeforeCreate, AfterSave, AfterCreate 创建记录时将调用这些钩子方法，请参考 [Hooks](https://gorm.io/zh_CN/docs/hooks.html) 中关于生命周期的详细信息  


```go
func (u *User) BeforeCreate(tx *gorm.DB) (err error) {
  u.UUID = uuid.New()

    if u.Role == "admin" {
        return errors.New("invalid role")
    }
    return
}
```



如果您想跳过 钩子 方法，您可以使用 SkipHooks 会话模式，例如：  

```go
DB.Session(&gorm.Session{SkipHooks: true}).Create(&user)

DB.Session(&gorm.Session{SkipHooks: true}).Create(&users)

DB.Session(&gorm.Session{SkipHooks: true}).CreateInBatches(users, 100)
```


#### 5.根据map创建

GORM 支持根据 map[string]interface{} 和 []map[string]interface{}{} 创建记录，例如：  


```go
db.Model(&User{}).Create(map[string]interface{}{
  "Name": "jinzhu", "Age": 18,
})

// batch insert from `[]map[string]interface{}{}`
db.Model(&User{}).Create([]map[string]interface{}{
  {"Name": "jinzhu_1", "Age": 18},
  {"Name": "jinzhu_2", "Age": 20},
})
```

注意： 根据 map 创建记录时，association 不会被调用，且主键也不会自动填充  


#### 6.使用 SQL 表达式、Context Valuer 创建记录

[使用 SQL 表达式、Context Valuer 创建记录](https://gorm.io/zh_CN/docs/create.html#%E4%BD%BF%E7%94%A8-SQL-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81Context-Valuer-%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95)



#### 7.高级选项

[高级选项](https://gorm.io/zh_CN/docs/create.html#%E9%AB%98%E7%BA%A7%E9%80%89%E9%A1%B9)




### 4.2 查询


#### 1.检索单个对象

GORM 提供了 First、Take、Last 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 LIMIT 1 条件，且没有找到记录时，它会返回 ErrRecordNotFound 错误

```go
	var user1 User
	// 获取第一条记录（主键升序）
	db.First(&user1)
	// SELECT * FROM users ORDER BY id LIMIT 1;
	fmt.Println("user1",user1)

	var user2 User
	// 获取一条记录，没有指定排序字段
	db.Take(&user2)
	// SELECT * FROM users LIMIT 1;
	fmt.Println("user2",user2)

	var user3 User
	// 获取最后一条记录（主键降序）
	db.Last(&user3)
	// SELECT * FROM users ORDER BY id DESC LIMIT 1;
	fmt.Println("user3",user3)

	var user4 User
	result := db.First(&user4)
	fmt.Println(result.RowsAffected) // 返回找到的记录数
	fmt.Println(result.Error)        // returns error or nil

	// 检查 ErrRecordNotFound 错误
	fmt.Println(errors.Is(result.Error, gorm.ErrRecordNotFound))
```

如果你想避免ErrRecordNotFound错误，你可以使用Find，比如`db.Limit(1).Find(&user)`，Find方法可以接受struct和slice的数据。 

First 和 Last 会根据主键排序，分别查询第一条和最后一条记录。 

只有在目标 struct 是指针或者通过 `db.Model()` 指定 model 时，该方法才有效。 此外，如果相关 model 没有定义主键，那么将按 model 的第一个字段进行排序。 例如:  


```go
var user User
var users []User

// works because destination struct is passed in
db.First(&user)
// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1

// works because model is specified using `db.Model()`
result := map[string]interface{}{}
db.Model(&User{}).First(&result)
// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1

// doesn't work
result := map[string]interface{}{}
db.Table("users").First(&result)

// works with Take
result := map[string]interface{}{}
db.Table("users").Take(&result)

// no primary key defined, results will be ordered by first field (i.e., `Code`)
type Language struct {
  Code string
  Name string
}
db.First(&Language{})
// SELECT * FROM `languages` ORDER BY `languages`.`code` LIMIT 1
```


#### 2.用主键检索

如果主键是数字类型，您可以使用 [内联条件](https://gorm.io/zh_CN/docs/query.html#inline_conditions) 来检索对象。 
 
传入字符串参数时，需要特别注意 SQL 注入问题，查看 [安全](https://gorm.io/zh_CN/docs/security.html) 获取详情.  



```go
db.First(&user, 10)
// SELECT * FROM users WHERE id = 10;

db.First(&user, "10")
// SELECT * FROM users WHERE id = 10;

db.Find(&users, []int{1,2,3})
// SELECT * FROM users WHERE id IN (1,2,3);
```


如果主键是字符串（例如像 uuid），查询将被写成这样：  

```go
db.First(&user, "id = ?", "1b74413f-f3b8-409f-ac47-e8c062e3472a")
// SELECT * FROM users WHERE id = "1b74413f-f3b8-409f-ac47-e8c062e3472a";
```

当目标对象具有主键值时，主键将用于构建条件，例如：

```go
var user = User{ID: 10}
db.First(&user)
// SELECT * FROM users WHERE id = 10;
```

#### 3.检索全部对象

```go
// Get all records
result := db.Find(&users)
// SELECT * FROM users;

result.RowsAffected // returns found records count, equals `len(users)`
result.Error        // returns error
```


### 4.3 条件


#### String 条件

```go
// Get first matched record
db.Where("name = ?", "jinzhu").First(&user)
// SELECT * FROM users WHERE name = 'jinzhu' ORDER BY id LIMIT 1;

//var users []User//users可以一直用，user不可以，会报错record not found
// Get all matched records//<>是不等于的意思
db.Where("name <> ?", "jinzhu").Find(&users)
// SELECT * FROM users WHERE name <> 'jinzhu';

// IN
db.Where("name IN ?", []string{"jinzhu", "jinzhu 2"}).Find(&users)
// SELECT * FROM users WHERE name IN ('jinzhu','jinzhu 2');

// LIKE
db.Where("name LIKE ?", "%jin%").Find(&users)
// SELECT * FROM users WHERE name LIKE '%jin%';

// AND
db.Where("name = ? AND age >= ?", "jinzhu", "22").Find(&users)
// SELECT * FROM users WHERE name = 'jinzhu' AND age >= 22;

// Time
db.Where("updated_at > ?", lastWeek).Find(&users)
// SELECT * FROM users WHERE updated_at > '2000-01-01 00:00:00';

// BETWEEN
db.Where("created_at BETWEEN ? AND ?", lastWeek, today).Find(&users)
// SELECT * FROM users WHERE created_at BETWEEN '2000-01-01 00:00:00' AND '2000-01-08 00:00:00';
```


#### Struct & Map 条件

```go
// Struct
db.Where(&User{Name: "jinzhu", Age: 20}).First(&user)
// SELECT * FROM users WHERE name = "jinzhu" AND age = 20 ORDER BY id LIMIT 1;

// Map
db.Where(map[string]interface{}{"name": "jinzhu", "age": 20}).Find(&users)
// SELECT * FROM users WHERE name = "jinzhu" AND age = 20;

// Slice of primary keys
db.Where([]int64{20, 21, 22}).Find(&users)
// SELECT * FROM users WHERE id IN (20, 21, 22);
```

