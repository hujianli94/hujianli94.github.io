# 4.图书管理系统

## 前端设计

前端项目的技术栈

- Vue.js 3
- Element Plus
- Vue-Router4
- Vuex
- Axios
- Echarts


### 1 框架搭建

#### 1.1 创建vue3项目

命令行创建Vue项目

(1)执行Vue CLI创建项目命令（<project-name>替换为准备好的项目），这里叫bookmanage：


```shell
vue create bookmanage
```



(2)选择Manually select features（手动选择特性）



(3)使用键盘上的上下键往下，此处默认`Babel`、 `Linter/Formatter`，我们加一个`Router`和`Vuex`，下一步

```
(*) Babel//转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。
( ) TypeScript//一个JavaScript（后缀.js）的超集（后缀.ts）包含并扩展了JavaScript的语法，需要被编译输出为JavaScript在浏览器运行
( ) Progressive Web App (PWA) Support//渐进式Web应用程序
(*) Router//vue-router（vue路由）
(*) Vuex//vue的状态管理模式，先不选择
( ) CSS Pre-processors//CSS预处理器（如：less、sass）
(*) Linter / Formatter//代码风格检查和格式化（如：ESlint）
( ) Unit Testing//单元测试（unit tests）
( ) E2E Testing//e2e(end to end)测试
```




(4)按回车键后，选择Vue版本号，选择3.x后按回车键确定




(5)根据需要选择是否使用history路由模式，笔者这里选择否，直接输入n后按回车键，之后的步骤与安装Vue Router无关，直接保持默认设置即可。


选择ESLint代码校验规则

```
? Use history mode for router? (Requires proper server setup for index fallback in production) n
? Pick a linter / formatter config: (Use arrow keys)
> ESLint with error prevention only
  ESLint + Airbnb config
  ESLint + Standard config
  ESLint + Prettier
```

(6) 选择什么时候进行代码校验

- Lint on save:保存就检查
- Lint and fix on commit:fix 或者commit的时候检查

建议选择保存就检测，等到commit的时候，问题可能都已经积累很多了。



(7)选择如何保存配置
- In dedicated config files:存放到独立文件中
- In package.json:存放到package.json中

这里选择`In dedicated config files`。






(6)根据需要选择是否保存预设以供将来的项目使用，如果选择保存这样的设置，下次再通过Vue CLI创建项目时，可以直接使用这个预设创建一个和本次设置相同的Vue项目。这里选择不保存，然后按回车键确认后项目会自动安装依赖。

```
? Save this as a preset for future projects? No
```




启动项目：(Windows前不需要加$)

```shell
$ cd bookmanage
$ yarn serve
```



!!! abstract "参考文献"

      [Vue前端开发](https://www.yuque.com/docs/share/c6858711-7751-4e3b-a3a3-f06e8d2fafad?#) 





或使用编辑器创建


或使用ui界面创建的方式如下：

- [Vue-UI 创建cli3.0项目](https://www.kancloud.cn/wangjiachong/vue_notes/1964087)





#### 1.2 使用编辑器初始化项目


##### 1.2.1 项目目录介绍

|目录/文件|	说明|
|----|----|
|node_modules	|项目开发依赖的一些模块，不用管|
|public	|主要存放首页、favicon|
|src	|源码目录，这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件:<br>assets:放入资源，例如图片、CSS等<br>components:公共组件目录<br>routes:前端路由<br>store:应用级数据（state）Vuex<br>views:单页面组件目录<nr>App.vue：项目的入口文件（根组件）<br>main.js:项目的全局配置，在任意一个文件中都有效的|
|.gitignore文件   |	git提交忽略文件|
|babel.config.js | babel配置，例如es5转es6|
|package.json	   | 项目配置文件。npm包配置文件，里面定义了项目的npm脚本，依赖包等信息|
|README.md       |	项目的说明文档，markdown格式|


##### 1.2.2 修改配置文件

关闭语法检查配置文件，关闭语法检测、配置路径别名。


`vue.config.js`

```js
const {defineConfig} = require('@vue/cli-service')

const path = require('path');

module.exports = defineConfig({
    devServer: {
        host: '0.0.0.0',//监听地址
        port: 7070, // 启动端口号
        open: true // 启动后是否自动打开网页
    },
    configureWebpack: {
        resolve: {
            alias: {
                '@': path.resolve(__dirname, 'src'),                    // 将 @ 设置为指向 src 目录
                'components': path.resolve(__dirname, 'src/components'), // 将 components 设置为指向 src/components 目录
                'layout': path.resolve(__dirname, 'src/layout'),
                'views': path.resolve(__dirname, 'src/views'),
                'apis': path.resolve(__dirname, 'src/apis')
                // 可以根据需要添加更多的别名配置
            }
        }
    },
    // 当你的 Vue 项目依赖的某些模块或库使用了 ES6+ 或其他较新的 JavaScript 语法时，这些代码可能并不兼容旧版本的浏览器。
    // 为了确保你的项目能够在这些浏览器中正常运行，你需要对这些依赖库进行转译，将其转换为可以在目标浏览器中执行的代码。
    transpileDependencies: true,
    //关闭语法检测
    lintOnSave: false
})
```



`.eslintrc.js`

```js
module.exports = {
  root: true,
  env: {
    node: true
  },
  'extends': [
    'plugin:vue/vue3-essential',
    'eslint:recommended'
  ],
  parserOptions: {
    parser: '@babel/eslint-parser'
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    // 关闭驼峰命名规则
    'vue/multi-word-component-names': 0,
    // 引号类型 `` "" ''
    quotes: [1, 'single'],
    // 禁止多余的冒号
    'no-extra-semi': 2,
    // 函数定义时括号前面要不要有空格
    'space-before-function-paren': [0, 'always']
  }
}
```



##### 1.2.3 初始化main.js以及安装插件


element-plus 依赖安装如下

```shell
# NPM
$ npm install element-plus@latest --save
$ npm install @element-plus/icons-vue
  
# Yarn
$ yarn add element-plus

# pnpm
$ pnpm install element-plus  --save
$ pnpm install @element-plus/icons-vue
```



请按如下操作

- 引入 `Element Plus`
- 引入 `vuex`
- 引入 `process`
- 引入 `axios`


```shell
$ npm install element-plus@latest --save
$ npm install @element-plus/icons-vue
$ npm install axios
$ npm install vuex@next --save
$ npm install process
$ npm install nprogress
$ npm install echarts 
```


##### 1.2.4 使用 .env 文件来配置环境变量


在 Vue CLI 3+ 中，您可以使用 .env 文件来配置环境变量。.env 文件是在项目构建过程中被读取并注入到应用程序中的。


`.env.local`

```
NODE_ENV=dev

VUE_APP_CURRENTMODE=serve

VUE_APP_BASEURL=http://127.0.0.1:8888/

#VUE_APP_WSURL=ws://127.0.0.1:8888/server/terminal
```


`.env.prod`

```
NODE_ENV=prod

VUE_APP_CURRENTMODE=build

VUE_APP_BASEURL=http://api.scajy.cn/

VUE_APP_WSURL=ws://api.scajy.cn/server/terminal
```

在`package.json`中配置编译命令


```js
{
  "name": "bookmanage",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "vue-cli-service serve  --mode local",
    "prod": "vue-cli-service build --mode prod",
    "lint": "vue-cli-service lint"
  },
  .......
}
```


使用dev本地环境运行

```shell
npm run dev
```


使用编译后的静态文件，用于生产环境

```shell
npm run prod
```

会自动生成dist目录，把dist目录下的所有文件拷贝到nginx对应目录处理





`main.js`

```js
import {createApp} from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'

// 导入 ElementPlus 和 css
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
// 使用中文
import zhCn from 'element-plus/dist/locale/zh-cn.mjs'

// 我们使用 Day.js 库来管理组件的日期和时间
import 'dayjs/locale/zh-cn'

// 注册icon图标
import * as ElementPlusIconsVue from '@element-plus/icons-vue'


// 创建实例
const app = createApp(App)

// 统一注册el-icon图标
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
    app.component(key, component)
}


// 注册store
app.use(store)
// 注册router
app.use(router)
// 注册 ElementPlus 并用中文国际化显示
app.use(ElementPlus, {
    locale: zhCn,
})
// 挂载实例
app.mount('#app')

```


##### 1.2.5 初始化App.vue

`App.vue`

```html
<template>
  <!--配置路由占位符-->
  <router-view></router-view>
</template>

<style>
/* 设置margin和padding都为0px */
html,
body,
#app,
.common-layout,
.el-container {
  margin: 0px;
  padding: 0px;
  height: 100%;
}
</style>
```


#### 1.3 封装路由


`src/views/dashboard/index.vue`

```html
<template>
  <h1 style="line-height: 400px">我是dashboard界面</h1>
  <router-view></router-view>
</template>

<script>
export default {
}
</script>
```


`router/index.js`

```js
//导入router的路由模式
import {createRouter, createWebHistory} from 'vue-router'
// //导入整体布局Layout
// import Layout from "@/layout/Layout"
//路由规则
const routes = [
    {
        path: "/dashboard",
        name: "仪表盘",
        icon: "HomeFilled",
        meta: {title: "概要", requireAuth: true},
        component: () => import('@/views/dashboard/index.vue')
    },
    ]
// createRouter 创建路由实例
const router = createRouter({
    /**
     * hash模式：createWebHashHistory，
     * history模式：createWebHistory
     */
    history: createWebHistory(),
    routes
})
// 抛出路由实例, 在 main.js 中引用
export default router
```






#### 1.4 添加进度

`router/index.js`


```js
//导入进度条组件
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'
//递增进度条，这将获取当前状态值并添加0.2直到状态为0.994
NProgress.inc(100)
//easing 动画字符串
// speed 动画速度
// showSpinner 进度环显示隐藏
NProgress.configure({ easing: 'ease', speed: 600, showSpinner: false })
//router.beforeEach（）一般用来做一些进入页面的限制。比如没有登录，就不能进入某些
// 页面，只有登录了之后才有权限查看某些页面。。。说白了就是路由拦截。
// to 要去到某个页面的属性
// from 从哪个页面来的属性
// next 处理路由跳转及放行
router.beforeEach((to, from, next) => {
    // 启动进度条
    NProgress.start()
    // 设置头部
    if (to.meta.title) {
        document.title = to.meta.title
    } else {
        document.title = "图书管理系统"
    }
    //放行
    next()
})
router.afterEach(() => {
    // 关闭进度条
    NProgress.done()
})
```

#### 1.5 启动/测试

```shell
npm run serve
# npm install 缺啥装啥
```


#### 1.6 封装axios

封装axios请求，添加自定义配置，如超时、重试、header等等

Axios为所有支持的请求方法提供了别名，例如

- axios.get发送GET请求
- axios.post发送POST请求
- axios.delete发送DELETE请求
- axios.put发送PUT请求
- axios.patch发送PATCH请求



(1) 统一请求配置。

将Axios通用配置写入文件中，代码如下：


`request/config.js`

```js
export default {
    method: 'get',
    // 基础url前缀
    baseURL: process.env.VUE_APP_BASEURL,
    // 请求头信息
    headers: {
        'Content-Type': 'application/json;charset=UTF-8'
    },
    // 设置超时时间
    timeout: 10000,
    // 携带凭证
    withCredentials: true,
    // 返回数据类型
    responseType: 'json'
}
```


(2) 统一API请求。

- 通过`axios.create`创建一个Axios实例

- 添加 request 请求拦截器、检验token。

- 添加response 响应拦截器，统一进行错误处理。

- 最后，处理正确返回了结果的数据。
  

正确返回结果时，统一返回格式为JSON，包含3个属性：code、msg和data。code表示成功标识，为200时表示成功，成功时通常会带回数据data，如果不是200，则为失败，其中-1表示正常的失败行为，-2表示登录失效，需要跳回登录页面，失败时通常会返回错误原因msg。



`request/index.js`

```js
import axios from 'axios';
import config from './config';
import {ElMessage} from 'element-plus';
import router from '../router';

export default function request(options) {
    return new Promise((resolve, reject) => {
        const instance = axios.create({...config});
        // request 请求拦截器
        instance.interceptors.request.use(
            (config) => {
                let token = localStorage.getItem('pm_token');
                // 发送请求时携带token
                if (token) {
                    config.headers.token = token;
                } else {
                    router.push('/login');
                }
                return config;
            },
            (error) => {
                // 请求发生错误时
                console.log('request:', error);
                // 判断请求超时
                if (
                    error.code === 'ECONNABORTED' &&
                    error.message.indexOf('timeout') !== -1
                ) {
                    ElMessage({message: '请求超时', type: 'error', showClose: true});
                }

                return Promise.reject(error);
            }
        );

        // response 响应拦截器
        instance.interceptors.response.use(
            (response) => {
                return response.data;
            },
            (err) => {
                if (err && err.response) {
                    switch (err.response.status) {
                        case 400:
                            err.message = '请求错误';
                            break;
                        case 401:
                            err.message = '未授权，请登录';
                            break;
                        case 403:
                            err.message = '拒绝访问';
                            break;
                        case 404:
                            err.message = `请求地址出错: ${err.response.config.url}`;
                            break;
                        case 408:
                            err.message = '请求超时';
                            break;
                        case 500:
                            err.message = '服务器内部错误';
                            break;
                        case 501:
                            err.message = '服务未实现';
                            break;
                        case 502:
                            err.message = '网关错误';
                            break;
                        case 503:
                            err.message = '服务不可用';
                            break;
                        case 504:
                            err.message = '网关超时';
                            break;
                        case 505:
                            err.message = 'HTTP版本不受支持';
                            break;
                        default:
                    }
                }
                console.error(err);
                if (err.message) {
                    ElMessage({message: err.message, type: 'error', showClose: true});
                }
                return Promise.reject(err); // 返回接口返回的错误信息
            }
        );
        // 请求处理
        instance(options)
            .then((res) => {
                /**
                 * response 统一格式
                 * {
                 *    code: 200,
                 *    msg: '消息[String]',
                 *    data: '返回数据[Any]'
                 * }
                 * code说明：
                 * 200 成功
                 * -1 失败，可能网络不通，可能后台服务异常或其它异常
                 * -2 登录失效跳回登录
                 */
                if (res.code === 200) {
                    resolve(res);
                } else {
                    // 未登录
                    if (res.code === -2) {
                        router.push('/login');
                    }
                    ElMessage({message: res.msg || '操作失败', type: 'error', showClose: true});
                    reject(res);
                }
            })
            .catch((error) => {
                reject(error);
            });
    });
}
```



然后为了统一管理请求，在src下创建apis文件夹，用于存放各模块的远程请求方法。

接着在src/api上创建login文件夹，写入登录和退出接口的请求方法，代码如下：

`src/api/login.js`

```js
import request from '@/request';
// 登录
export const login = (data) => {
    return request({
        url: 'login',
        method: 'post',
        data,
    });
};

// 登出
export const logout = () => {
    return request({
        url: 'logout',
        method: 'get',
    });
};
```




#### 1.7 处理404页面


(1) 404页面

`views/common/404.vue`

```html
<template>
  <div class="main-body-div">
    <el-row>
      <!-- 图片 -->
      <el-col :span="24">
        <div>
          <img class="main-body-img" src="../../assets/img/404.png" />
        </div>
      </el-col>
      <!-- 描述 -->
      <el-col :span="24">
        <div>
          <p class="status-code">404</p>
          <p class="status-describe">你所访问的页面不存在······</p>
        </div>
      </el-col>
    </el-row>
  </div>
</template>
<script>
export default { }
</script>
<style scoped>
/* 图片属性 */
.main-body-img {
  margin-top: 150px
}
/* 整体位置 */
.main-body-div {
  text-align: center;
  height: 100vh;
  width: 100vw;
}
/* 状态码 */
.status-code {
  margin-top: 20px;
  margin-bottom: 10px;
  font-size: 95px;
  font-weight: bold;
  color: rgb(54, 95, 230);
}
/* 描述 */
.status-describe {
  color: rgb(145, 143, 143);
}
</style>
```



(2) 403页面

`views/common/403.vue`

```html
<template>
  <div class="main-body-div">
    <el-row>
      <!-- 图片 -->
      <el-col :span="24">
        <div>
          <img class="main-body-img" src="../../assets/img/403.png" />
        </div>
      </el-col>
      <el-col :span="24">
        <!-- 描述 -->
        <div>
          <p class="status-code">403</p>
          <p class="status-describe">你暂时无权限访问该页面······</p>
        </div>
      </el-col>
    </el-row>
  </div>
</template>
<script>
export default { }
</script>
<style scoped>
/* 图片属性 */
.main-body-img {
  margin-top: 150px
}
/* 整体位置 */
.main-body-div {
  text-align: center;
  height: 100vh;
  width: 100vw;
}
/* 状态码 */
.status-code {
  margin-top: 20px;
  margin-bottom: 10px;
  font-size: 95px;
  font-weight: bold;
  color: rgb(54, 95, 230);
}
/* 描述 */
.status-describe {
  color: rgb(145, 143, 143);
}
</style>
```



(3) 404路由规则

`router/index.js`中添加

```js
    {
        path: '/404',
        component: () => import('@/views/common/404.vue'),
        meta: {
            title: '404'
        }
    },
    {
        path: '/403',
        component: () => import('@/views/common/403'),
        meta: {
            title: '403'
        }
    },
    //其他路径跳转至404页面
    {
        path: '/:pathMatch(.*)',
        redirect: '/404'
    },
```


### 2 前端开发


#### 2.1.1 整体布局

![image](https://cdn.staticaly.com/gh/hujianli94/Picgo-atlas@main/image.4f743t5xa7w0.webp)





##### Container布局框架

`layout/index.vue`

```html
<template>
  <div class="common-layout">
    <el-container>
      <el-aside width="auto">
        <CommonAside/>
      </el-aside>
      <el-container>
        <el-header>
          <CommonHeader/>
        </el-header>
        <el-main>
          <CommonFrame/>
        </el-main>
      </el-container>
    </el-container>
  </div>
</template>

<script>
import CommonHeader from '@/layout/components/CommonHeader.vue'
import CommonAside from '@/layout/components/CommonAside.vue'
import CommonFrame from '@/layout/components/CommonFrame.vue'


// 导入子组件，缩写格式 CommonAside: CommonHeader
export default {
  components: {CommonAside, CommonHeader, CommonFrame}
}

</script>


<style scoped>
.el-header {
  height: 50px;
  background: linear-gradient(to left, rgba(1, 170, 237, 1), rgba(82, 183, 109, 1));
  display: flex; /* 使用flex布局 */
  align-items: center; /* flex水平居中 */
  justify-content: space-between; /* flex水平平分 */
  color: #fff;
}

.el-aside {
  background-color: #545c64;
  height: 100%;
}

.el-main {
}

</style>
```

##### aside-侧边栏

`layout/components/CommonAside.vue`

```html
<script>
export default {
  name: 'CommonAside',

  computed: {
    isCollapse() {
      return this.$store.state.tab.isCollapse;
    },
    isTitle() {
      return this.$store.state.tab.isTitle;
    },
  }
}
</script>

<template>
  <!--
         :default-active="this.$route.path"  绑定菜单栏index索引
         router    开启路由导航
         :collapse="isCollapse"   导航栏显示与隐藏
         unique-opened   开启导航栏同时只显示一个菜单
         :collapse-transition='false'  关闭折叠动画
         -->
  <el-menu active-text-color="#ffd04b" background-color="#545c64" class="el-menu-vertical-demo"
           default-active="this.$route.path" text-color="#fff" router unique-opened :collapse="isCollapse"
           :collapse-transition="false">
    <!-- 给页面添加logo -->
    <div class="logo-title">
      <img src="../../assets/touxiang.jpeg"/>
      <!--默认显示logo字体，侧边栏搜索隐藏logo字体-->
      <span v-if="isTitle">图书管理系统</span>
    </div>
    <template v-for="menu in this.$router.options.routes" :key="menu">
      <!--处理一级菜单没有子路由-->
      <el-menu-item v-if="!menu.children && menu.path !== '/login'" :index="menu.path">
        <!--字体图标-->
        <span>{{ menu.name }}</span>
      </el-menu-item>

      <!-- 处理仪表盘 -->
      <el-menu-item v-if="menu.path == '/'" :index="menu.children[0].path">
        <!--字体图标-->
        <el-icon>
          <component :is="menu.children[0].icon" color="#79bbff"></component>
        </el-icon>
        <span>{{ menu.children[0].name }}</span>
      </el-menu-item>

      <!--处理一级菜单有子路由-->
      <el-sub-menu v-else-if="menu.children" :index="menu.path">
        <template #title>
          <!--字体图标-->
          <el-icon>
            <component :is="menu.icon" color="#79bbff"></component>
          </el-icon>
          <span>{{ menu.name }}</span>
        </template>
        <!-- 循环二级菜单 -->
        <el-menu-item v-for="child in menu.children" :key="child" :index="child.path">
          <!--字体图标-->
          <el-icon>
            <component :is="child.icon" color="#79bbff"></component>
          </el-icon>
          {{ child.name }}
        </el-menu-item>
      </el-sub-menu>
    </template>
  </el-menu>
</template>

<style scoped>

/* 处理左侧边框无法对齐，修改代码 */
.el-menu {
  border-right: none;
}

/* 优化左侧菜单宽度 */
.el-menu-vertical-demo:not(.el-menu--collapse) {
  width: 200px;
  min-height: 400px;
}

.logo-title {
  background-color: rgba(82, 183, 109, 1);
  margin-bottom: 10px;
  height: 50px;
  border: none;
  line-height: 50px;
  display: flex;
  align-items: center;
  padding-left: 15px;
  color: #fff;
}

.logo-title img {
  width: 32px;
  height: 32px;
  margin-right: 10px;
  border-radius: 50%;
}

.logo-title span {
  font-weight: bold;
  font-size: 16px;
  line-height: 50px;
  font-family: Averir, Helvetica Neue, Arial, Helvetica, sans-serif;
  vertical-align: middle;
}
</style>
```



##### Header-头部栏

`layout/components/CommonHeader.vue`



```html
<template>
  <!-- 折叠 -->
  <div class="toggle-butten">
    <!--绑定一个触发的折叠按钮-->
    <el-icon :size="25">
      <!-- 使用v-show进行控制导航栏图标展示，显示收缩图标栏先进行取反，由于导航栏默认是false取反就成了true就显示，收缩我们判断的是false才显示 -->
      <i v-show="!isCollapse" @click="toggleCollapse">
        <Fold/>
      </i>
      <i v-show="isCollapse" @click="toggleCollapse">
        <Expand/>
      </i>
    </el-icon>
  </div>

  <!--用户标识-->
  <div>
    <img src="../../assets/touxiang.jpeg" class="touxiang"/>
    <el-dropdown>
              <span class="el-dropdown-link">
                {{ username }}
                <el-icon class="el-icon--right">
                  <arrow-down/>
                </el-icon>
              </span>
      <template #dropdown>
        <el-dropdown-menu>
          <el-dropdown-item @click="UserList">用户信息</el-dropdown-item>
          <el-dropdown-item @click="UserPasswordDialog = true">修改密码</el-dropdown-item>
          <el-dropdown-item @click="logout">退出登陆</el-dropdown-item>
        </el-dropdown-menu>
      </template>
    </el-dropdown>
  </div>

  <!--修改密码对话框-->
  <el-dialog v-model="UserPasswordDialog" width="30%" v-on:close="closDialogForm()">
    <!--标题-->
    <template #header>
      <div style="font-size:18px; color:#409eff; font-weight:bold;">用户密码修改</div>
    </template>

    <!--内容-->
    <el-form :model="UserPasswordForm" label-width="100px" :rules="rules" ref="UserPasswordForm">
      <el-form-item label="原密码：" prop="old_password">
        <el-input v-model="UserPasswordForm.old_password" type="password" show-password></el-input>
      </el-form-item>
      <el-form-item label="新密码：" prop="new_password">
        <el-input v-model="UserPasswordForm.new_password" type="password" show-password></el-input>
      </el-form-item>
      <el-form-item label="再次确认：" prop="confirm_password">
        <el-input v-model="UserPasswordForm.confirm_password" type="password" show-password></el-input>
      </el-form-item>
    </el-form>
    <template #footer>
      <span class="dialog-footer">
        <el-button @click="closDialogForm">取消</el-button>
        <el-button type="primary" @click="changePasswordSubmit">确定</el-button>
      </span>
    </template>
  </el-dialog>

  <!-- 用户信息展示 -->
  <el-dialog v-model="UserListDialog" width="30%" center v-on:close="closUserListDialog()">
    <!--标题-->
    <template #header>
      <div style="font-size:18px; color:#409eff; font-weight:bold;">用户信息展示</div>
    </template>

    <!--内容-->
    <el-descriptions direction="horizontal" :column="2">
      <el-descriptions-item label-align=center align=center label="用户名：" v-for='value in UserListinfo'
                            v-if='value==username'>{{ value }}
      </el-descriptions-item>
      <el-descriptions-item label-align=center align=center label="用户邮箱:" v-for='value in UserListinfo'
                            v-if='value==eamil'>{{ value }}
      </el-descriptions-item>
    </el-descriptions>
  </el-dialog>
</template>


<script>
export default {
  name: 'CommonHeader',

  data() {
    // 表单自定义数据判断
    const checkNewOldPassword = (rule, value, callback) => {
      if (value == this.UserPasswordForm.old_password) {
        callback(new Error('新密码不能与旧密码一样！'))
      } else {
        return callback()
      }
    }
    const checkNewPassword = (rule, value, callback) => {
      if (value != this.UserPasswordForm.new_password) {
        callback(new Error('两次输入密码不一致！'))
      } else {
        return callback()
      }
    }

    return {
      username: window.sessionStorage.getItem('username'), // 获取login保存到会话存储的username
      UserPasswordDialog: false, // 显示修改密码对话框
      UserListDialog: false, // 显示用户信息对话框

      // ======================== 修改密码弹出框配置 ======================
      UserPasswordForm: {
        username: window.sessionStorage.getItem('username'),
        old_password: '',
        new_password: '',
        confirm_password: ''
      },
      // ======================== 查看用户信息弹出框配置 ====================
      UserListinfo: [],
      UserListinfoForm: {
        username: window.sessionStorage.getItem('username'),
      },
      // ======================== 修改密码表单验证 ======================
      rules: {
        old_password: [
          {required: true, message: '请输入原密码', trigger: 'blur'},
          {min: 6, message: '用户名长度应不小于6个字符', trigger: 'blur'}
        ],
        new_password: [
          {required: true, message: '请输入新密码', trigger: 'blur'},
          {min: 6, message: '用户名长度应不小于6个字符', trigger: 'blur'},
          {validator: checkNewOldPassword, trigger: 'blur'}
        ],
        confirm_password: [
          {required: true, message: '请确认新密码', trigger: 'blur'},
          {min: 6, message: '用户名长度应不小于6个字符', trigger: 'blur'},
          {validator: checkNewPassword, trigger: 'blur'}
        ]
      }
    }
  },
  methods: {
    // 触发折叠按钮
    toggleCollapse() {
      this.$store.commit('collapseMenu')
      this.$store.commit('titleMenu')
    },
    // 退出登陆
    logout() {
      // 清除token
      window.sessionStorage.clear()
      // 跳转到登陆
      this.$router.push('/login')
    },
    // 修改密码
    changePasswordSubmit() {
      this.$refs.UserPasswordForm.validate(valid => {
        if (valid) {
          this.$http.post('change_password/', this.UserPasswordForm).then(res => {
            if (res.data.code == 200) {
              this.$message.success('修改密码成功')
              // 调用关闭弹框函数
              this.closDialogForm()
            }
          })
        }
      })
    },
    UserList() {
      this.UserListDialog = true  // 开启弹出框
      this.$http.post('user_info/', this.UserListinfoForm).then(res => {
        if (res.data.code == 200) {
          this.UserListinfo = res.data.data
        }
      })
    },
    // 关闭修改弹出框的表单
    closDialogForm() {
      // 清空表单数据
      this.UserPasswordForm.old_password = ''
      this.UserPasswordForm.new_password = ''
      this.UserPasswordForm.confirm_password = ''

      // 关闭弹出框
      this.UserPasswordDialog = false
    },
    // 关闭查看用户信息弹出框
    closUserListDialog() {
      this.UserListDialog = false
    }
  },
  computed: {
    isCollapse() {
      return this.$store.state.tab.isCollapse;
    },
    isTitle() {
      return this.$store.state.tab.isTitle;
    },
  }
}
</script>

<style scoped>

.el-dropdown-link {
  color: #fff;
  margin: 3px 5px 0px 10px;
}

/* 处理头像图片大小 */
.touxiang {
  width: 25px;
  height: 25px;
  border-radius: 3px;
}


.logo-title img {
  width: 32px;
  height: 32px;
  margin-right: 10px;
  border-radius: 50%;
}
.logo-title span {
  font-weight: bold;
  font-size: 16px;
  line-height: 50px;
  font-family: Averir, Helvetica Neue, Arial, Helvetica, sans-serif;
  vertical-align: middle;
}
</style>
```


##### main栏

`layout/components/CommonFrame.vue`

功能：路由占位符

```html
<script>
export default {
  name: 'CommonFrame'
}
</script>

<template>
  <!--路由占位符-->
  <router-view/>
</template>

<style scoped>

</style>
```


##### 添加路由规则

```js
//导入router的路由模式
import {createRouter, createWebHistory} from 'vue-router'
// 导入整体布局Layout
import LayoutView from '@/layout/index.vue'
//导入进度条组件
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'

const routes = [
    // 配置首页导航并强制跳转仪表盘
    {
        path: '/',
        name: '首页',
        component: LayoutView,
        // 重定向跳转到仪表盘
        redirect: '/dashboard',
        children: [
            {
                path: '/dashboard',
                name: '仪表盘',
                icon: 'HomeFilled',
                component: () => import('@/views/Dashboard/index.vue')
            }
        ]
    },
    {
        path: '/books',
        name: '图书管理',
        icon: 'Notebook',
        component: LayoutView,
        children: [
            {
                path: '/books/electronic-book',
                name: '电子书管理',
                icon: 'Document',
                component: () => import('../views/electronic/index.vue')
            },
            {
                path: '/books/paper-book',
                name: '纸质书籍管理',
                icon: 'Reading',
                component: () => import('../views/paper/index.vue')
            }
        ]
    },
    {
        path: '/404',
        component: () => import('@/views/common/404.vue'),
        meta: {
            title: '404'
        }
    },
    {
        path: '/403',
        component: () => import('@/views/common/403.vue'),
        meta: {
            title: '403'
        }
    },
    //其他路径跳转至404页面
    {
        path: '/:pathMatch(.*)',
        redirect: '/404'
    },
]

const router = createRouter({
    history: createWebHistory(),
    routes
})


//递增进度条，这将获取当前状态值并添加0.2直到状态为0.994
NProgress.inc(100)
//easing 动画字符串
// speed 动画速度
// showSpinner 进度环显示隐藏
NProgress.configure({easing: 'ease', speed: 600, showSpinner: false})
//router.beforeEach（）一般用来做一些进入页面的限制。比如没有登录，就不能进入某些
// 页面，只有登录了之后才有权限查看某些页面。。。说白了就是路由拦截。
// to 要去到某个页面的属性
// from 从哪个页面来的属性
// next 处理路由跳转及放行
router.beforeEach((to, from, next) => {
    // 启动进度条
    NProgress.start()
    // 设置头部
    if (to.meta.title) {
        document.title = to.meta.title
    } else {
        document.title = "图书管理系统"
    }
    //放行
    next()
})
router.afterEach(() => {
    // 关闭进度条
    NProgress.done()
})

export default router
```



整体布局弄好之后，如下所示界面：


![](https://cdn.staticaly.com/gh/hujianli94/Picgo-atlas@main/img/image.21zguj0t3wo0.webp)






























## 后端API设计

后端项目技术栈

- Gin
- jwt-go
- mysql
- gorm



### 1 初始化项目环境

#### 1.1 go常用项目结构


bookManage项目结构

```shell
.
├── README.md               # 项目说明（帮助你快速的属性和了解项目） 
├── config                  # 配置文件（mysql配置 ip 端口 用户名 密码，不能写死到代码中） 
├── controller              # CLD：服务入口，负责处理路由、参数校验、请求转发 
├── service                 # CLD：逻辑（服务）层，负责业务逻辑处理 
├── dao                     # CLD：负责数据与存储相关功能（mysql、redis、ES等） 
│	├── mysql 
├── model                   # 模型（定义表结构） 
├── logging                 # 日志处理 
├── main.go                 # 项目启动入口
├── middleware              # 中间件 
├── pkg                     # 公共服务（所有模块都能访问的服务） 
├── router                  # 路由(路由分发)
```

#### 1.2 创建数据库
```shell
mysql> create database books charset utf8;
```


#### 1.3 当前项目架构

```shell
go mod init bookManage
```
图书管理服务:

1. 用户服务：登录，注册 
2. 书籍服务：对书籍的增删改查的操作

```shell
.
├── controller    # CLD：服务入口，负责处理路由、参数校验、请求转发 
│ 	├── book.go 
│ 	└── user.go 
├── dao           # CLD：负责数据与存储相关功能（mysql、redis、ES等） 
│ 	└── mysql 
│	      └── mysql.go 
├── main.go       # 项目启动入口 
├── middleware    # 中间件: token验证 
│ 	└── auth.go 
├── model         # 模型 
│	 ├── book.go 
│	 ├── user.go 
│ 	└── user_m2m_book.go 
└── router        # 路由 
  ├── api_router.go 
  ├── init_router.go 
  └── test_router.go
```


### 2 添加路由分层


#### 2.1 main.go

```go
// bookManage project main.go
package main

import "bookManage/router"

/**
 * @author hujianli
 */
func main() {
	//1、初始化路由分层，将实例化router服务的方法拆分到router文件下
	r := router.InitRouter()
	r.Run(":8888")
}

```


#### 2.2 router/init_router.go

```go
package router

import (
	"github.com/gin-gonic/gin"
)

/**
 * @author hujianli
 * 加载其他路由文件中的路由
 */

// 这个方法作用：初始化其他文件中的路由
func InitRouter() *gin.Engine {
	//初始化gin服务
	r := gin.Default()
	TestRouters(r)
	//SetupApiRouters(r)
	return r
}
```


#### 2.3 router/test_router.go


```go
package router

import "github.com/gin-gonic/gin"

/**
 * @author hujianli
 */
func TestRouters(r *gin.Engine) {
	v1 := r.Group("/api/v1")
	v1.GET("test", TestHandler)
}

// 测试路由访问，http://127.0.0.1:8888/api/v1/test
func TestHandler(c *gin.Context) {
	c.String(200, "ok")
}
```

测试路由访问，`http://127.0.0.1:8888/api/v1/test`说明路由分组已经跑通了。



### 3 初始化mysql连接


#### 3.1 main.go


```go
// bookManage project main.go
package main

import (
	"bookManage/dao/mysql"
	"bookManage/router"
)

/**
 * @author hujianli
 */
func main() {
	// 初始化mysql连接
	mysql.InitMysql()

	//初始化路由分层，将实例化router服务的方法拆分到router文件下
	r := router.InitRouter()
	r.Run(":8888")
}

```

#### 3.2 dao/mysql/mysql.go

```go
// mysql project mysql.go
package mysql

import (
	"fmt"

	gmysql "gorm.io/driver/mysql"
	"gorm.io/gorm"
)

/**
 * @author hujianli
 */
var DB *gorm.DB

func InitMysql() {
	//1、连接数据库
	dsn := "root:124456@tcp(127.0.0.1:4406)/books?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(gmysql.Open(dsn), &gorm.Config{})
	if err != nil {
		fmt.Println("初始化mysql连接错误", err)
	}
	DB = db
}
```


### 4 定义多对多表结构

书和用户是多对多的关系。

书可以供多个用户借阅,一个用户也可以借阅过多本书，所以是多对多


#### 4.1 model/user.go


```go
package model

/**
 * @author hujianli
 */
type User struct {
	Id       int64  `gorm:"primary_key" json:"id"`
	Username string `gorm:"not null" json:"username" binging:"required"`
	Password string `gorm:"not null" json:"password" binding:"required"`
	Token    string `json:"token"`
}

func (User) TableName() string {
	return "user"
}

```


#### 4.2 model/book.go

```go
package model

/*
@author hujianli
*/
type Book struct {
	Id uint `gorm:"primary_key" json:"id"`
	// Name string `gorm:"not null" json:"name" binding:"required"`
	Name string `gorm:"not null" json:"name"`
	Desc string `json:"desc"`
	//一本书多个用户借阅过,一个用户也可以借阅过多本书，所以是多对多
	Users []User `gorm:"many2many:book_users;"`
}

func (Book) TableName() string {
	return "book"
}
```


#### 4.3 model/user_m2m_book.go

```go
package model

/*
@author hujianli
*/

// 自定义第三张表
type BookUser struct {
	UserID uint `gorm:"primaryKey"`
	BookID uint `gorm:"primaryKey"`
}
```



#### 4.4 自动生成表结构

dao/mysql/mysql.go


```go
// mysql project mysql.go
package mysql

import (
	"fmt"

	"bookManage/model"

	gmysql "gorm.io/driver/mysql"
	"gorm.io/gorm"
)

/**
 * @author hujianli
 */
var DB *gorm.DB

func InitMysql() {
	//1、连接数据库
	dsn := "root:123456@tcp(127.0.0.1:3306)/books?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(gmysql.Open(dsn), &gorm.Config{})
	if err != nil {
		fmt.Println("初始化mysql连接错误", err)
	}
	DB = db

	//自动创建表结构
	if err := DB.AutoMigrate(model.User{}, model.Book{}); err != nil {
		fmt.Println("自动创建表结构失败：", err)
	}
}
```

### 5 注册登录


#### 5.1 router/init_router.go


```go
package router

import (
	"github.com/gin-gonic/gin"
)

/**
 * @author hujianli
 * 加载其他路由文件中的路由
 */

// 这个方法作用：初始化其他文件中的路由
func InitRouter() *gin.Engine {
	//初始化gin服务
	r := gin.Default()
	TestRouters(r)
	SetupApiRouters(r)
	return r
}
```

#### 5.2 router/api_router.go


```go
package router

import (
	"bookManage/controller"

	"github.com/gin-gonic/gin"
)

/**
 * @author hujianli
 */
func SetupApiRouters(r *gin.Engine) {
	r.POST("/register", controller.RegisterHandler)
	r.POST("/login", controller.LoginHandler)
}
```


#### 5.3 controller/user.go

```go
package controller

import (
	"bookManage/dao/mysql"
	"bookManage/model"
	"crypto/sha256"
	"encoding/hex"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

/**
@author hujianli
*/

// 密码加密函数
func encryptPassword(password string) string {
	hash := sha256.Sum256([]byte(password))
	encryptedPassword := hex.EncodeToString(hash[:])
	return encryptedPassword
}

// 比对密码函数
func comparePasswords(hashedPassword string, password string) bool {
	encryptedPassword := encryptPassword(password)
	return hashedPassword == encryptedPassword
}

// 注册
func RegisterHandler(c *gin.Context) {
	p := new(model.User)
	//参数校验
	if err := c.ShouldBindJSON(p); err != nil {
		c.JSON(400, gin.H{"err": err.Error()})
		return
	}
	// 这里应该是客户端已加密后的密码
	password := p.Password
	p.Password = encryptPassword(password)

	mysql.DB.Create(p)
	c.JSON(200, gin.H{"msg": p})
}

// 登录
func LoginHandler(c *gin.Context) {
	p := new(model.User)
	//参数校验
	if err := c.ShouldBindJSON(p); err != nil {
		c.JSON(400, gin.H{"err": err.Error()})
		return
	}

	//查找用户
	var user model.User
	result := mysql.DB.Where(&model.User{Username: p.Username}).First(&user)
	if result.Error != nil {
		c.JSON(403, gin.H{"msg": "用户名密码错误"})
		return
	}

	//比对密码
	if !comparePasswords(user.Password, p.Password) {
		c.JSON(403, gin.H{"msg": "用户名密码错误"})
		return
	}

	//生成token
	token := uuid.New().String()
	mysql.DB.Model(&user).Update("token", token)
	c.JSON(200, gin.H{"token": token})
}

```


#### 5.4 测试注册功能

> 建议使用的工具： postman


```shell
POST: http://127.0.0.1:8888/register
# 携带数据：
# body-raw-json：
{ 
"username": "hujianli",
"password": "oschina"
} 
```

postman返回信息如下

```shell
{
    "msg": {
        "id": 1,
        "username": "hujianli",
        "password": "94b377d9c64df9fc85f8c87de846cb44dc64ba40beec3139d4cc1a10fd3860a7",
        "token": ""
    }
}
```



#### 5.5 登录获取token

```shell
POST: http://127.0.0.1:8888/login
# 携带数据：
# body-raw-json：
{ 
"username": "hujianli",
"password": "oschina"
} 
```

postman返回信息如下

```shell
{
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTQ1NzQwODEsImlkIjoxfQ.z3dCZxKUh--bADn1zxBRZ9sXx90JXpVfE3xCbnW-5xU"
}
```


### 6 图书管理


#### 6.1 router/api_router.go


```go
package router

import (
	"bookManage/controller"

	"github.com/gin-gonic/gin"
)

/**
 * @author hujianli
 */
func SetupApiRouters(r *gin.Engine) {
	r.POST("/register", controller.RegisterHandler)
	r.POST("/login", controller.LoginHandler)

	v1 := r.Group("/api/v1")
	// 书籍CRUD
	v1.POST("book", controller.CreateBookHandler)
	v1.GET("book", controller.GetBookListHandler)
	v1.GET("book/:id", controller.GetBookDetailHandler)
	v1.PUT("book", controller.UpdateBookHandler)
	v1.DELETE("book/:id", controller.DeleteBookHandler)

	// 添加一条借阅记录
	v1.POST("bookuser", controller.CreateBookUsersHandler)
	// 查找书籍的借阅记录
	v1.GET("bookuser", controller.GetBookrecordsHandler)
}
```


#### 6.2 controller/book.go

```go
package controller

import (
	"bookManage/dao/mysql"
	"bookManage/model"
	"strconv"

	"github.com/gin-gonic/gin"
)

/**
 * @author hujianli
 */

// 无论是在获取书籍列表还是获取特定书籍详情时，都将返回一个新的结构体 BookResponse，
// 其中用户的密码和 Token 字段已被排除。这样就可以保证在视图中不返回用户表的密码和 Token 信息。
type BookResponse struct {
	ID        uint     `json:"id"`
	Name      string   `json:"name"`
	Desc      string   `json:"desc"`
	UserIDs   []uint   `json:"user_ids"`
	Usernames []string `json:"usernames"`
}

// 增
func CreateBookHandler(c *gin.Context) {
	p := new(model.Book)
	if err := c.ShouldBindJSON(p); err != nil {
		c.JSON(400, gin.H{"err": err.Error()})
		return
	}
	mysql.DB.Create(p)
	c.JSON(200, gin.H{"msg": "success"})
}

// 查看书籍列表
func GetBookListHandler(c *gin.Context) {
	books := []model.Book{}
	mysql.DB.Preload("Users").Find(&books)
	// //mysql.DB.Find(&books)//只查书籍，不查关联User
	// c.JSON(200, gin.H{"books": books})
	// 构建响应对象
	bookResponses := []BookResponse{}
	for _, book := range books {
		userIDs := []uint{}
		usernames := []string{}
		for _, user := range book.Users {
			userIDs = append(userIDs, user.Id)
			usernames = append(usernames, user.Username)
		}

		bookResponse := BookResponse{
			ID:        book.Id,
			Name:      book.Name,
			Desc:      book.Desc,
			UserIDs:   userIDs,
			Usernames: usernames,
		}
		bookResponses = append(bookResponses, bookResponse)
	}

	c.JSON(200, gin.H{"books": bookResponses})
}

// 查看指定书籍
func GetBookDetailHandler(c *gin.Context) {
	pipelineIdStr := c.Param("id") //获取URL参数
	bookId, _ := strconv.ParseUint(pipelineIdStr, 10, 64)
	book := model.Book{Id: uint(bookId)}
	mysql.DB.Preload("Users").Find(&book)
	// mysql.DB.Find(&book) //只查书籍，不查关联User
	userIDs := []uint{}
	usernames := []string{}
	for _, user := range book.Users {
		userIDs = append(userIDs, user.Id)
		usernames = append(usernames, user.Username)
	}

	bookResponse := BookResponse{
		ID:        book.Id,
		Name:      book.Name,
		Desc:      book.Desc,
		UserIDs:   userIDs,
		Usernames: usernames,
	}

	c.JSON(200, gin.H{"book": bookResponse})
	// c.JSON(200, gin.H{"books": book})
}

// 改
func UpdateBookHandler(c *gin.Context) {
	p := new(model.Book)
	if err := c.ShouldBindJSON(p); err != nil {
		c.JSON(400, gin.H{"err": err.Error()})
		return
	}
	oldBook := &model.Book{Id: p.Id}
	var newBook model.Book
	if p.Name != "" {
		newBook.Name = p.Name
	}
	if p.Desc != "" {
		newBook.Desc = p.Desc
	}
	mysql.DB.Model(&oldBook).Updates(newBook)
	c.JSON(200, gin.H{"book": newBook})
}

// 删除
func DeleteBookHandler(c *gin.Context) {
	pipelineIdStr := c.Param("id") //获取URL参数
	//字符串，进制，64表示int64
	bookId, _ := strconv.ParseUint(pipelineIdStr, 10, 64)
	//删除book时，也删除四三张表中的用户对应关系记录
	mysql.DB.Select("Users").Delete(&model.Book{Id: uint(bookId)})
	c.JSON(200, gin.H{"msg": "success"})
}

// 增加一条借阅记录
func CreateBookUsersHandler(c *gin.Context) {
	u := new(model.BookUser)
	if err := c.ShouldBindJSON(u); err != nil {
		c.JSON(400, gin.H{"err": err.Error()})
		return
	}
	mysql.DB.Create(u)
	c.JSON(200, gin.H{"msg": "success"})
}

// 查看书籍的借阅记录
func GetBookrecordsHandler(c *gin.Context) {
	book := new(model.Book)
	if err := c.ShouldBindJSON(book); err != nil {
		c.JSON(400, gin.H{"err": err.Error()})
		return
	}
	mysql.DB.Preload("Users").Find(&book)
	usernames := []string{}
	for i := 0; i < len(book.Users); i++ {
		usernames = append(usernames, strconv.FormatInt(int64(book.Users[i].Id), 10))
		usernames = append(usernames, book.Users[i].Username)
	}
	c.JSON(200, usernames)
}


```

#### 6.3 创建图书


```shell
POST:http://127.0.0.1:8888/api/v1/book/
# 携带数据：
# body-raw-json：
{ 
"name": "水浒传", 
"desc": "武松打虎" 
}
```

#### 6.4 查看图书列表


```shell
GET：http://127.0.0.1:8888/api/v1/book/
```

postman返回信息如下

```json
{
    "books": [
        {
            "id": 1,
            "name": "三国演义",
            "desc": "三顾茅庐请诸葛亮、曹操煮酒论英雄",
            "user_ids": [
                1,
                2
            ],
            "usernames": [
                "hujianli1",
                "hujianli2"
            ]
        },
        {
            "id": 2,
            "name": "西游记",
            "desc": "你挑着担，我牵着马，历经千辛万苦...",
            "user_ids": [],
            "usernames": []
        },
        {
            "id": 3,
            "name": "红楼梦",
            "desc": "刘姥姥走进了大观园.",
            "user_ids": [],
            "usernames": []
        },
        {
            "id": 4,
            "name": "水浒传",
            "desc": "武松打虎",
            "user_ids": [],
            "usernames": []
        }
    ]
}
```


#### 6.5 查看图书详情

```shell
GET：http://127.0.0.1:8888/api/v1/book/3/
# 没有这本书，返回空数据
GET：http://127.0.0.1:8888/api/v1/book/1/
```
postman返回信息如下

```json
{
    "book": {
        "id": 1,
        "name": "三国演义",
        "desc": "三顾茅庐请诸葛亮、曹操煮酒论英雄",
        "user_ids": [
            1,
            2
        ],
        "usernames": [
            "hujianli1",
            "hujianli2"
        ]
    }
}
```


#### 6.6 修改图书信息

```shell
PUT：http://127.0.0.1:8888/api/v1/book/
# 携带数据：
# body-raw-json：
{ 
"id": 1, 
"name": "三国演义",
"desc": "三顾茅庐请诸葛亮、曹操煮酒论英雄"
}

```

postman返回信息如下

```json
{
    "book": {
        "id": 0,
        "name": "三国演义",
        "desc": "三顾茅庐请诸葛亮、曹操煮酒论英雄",
        "Users": null
    }
}
```


#### 6.7 删除图书信息

```shell
DELETE： http://127.0.0.1:8888/api/v1/book/1/ 
```

postman返回信息如下

```json
{
    "msg": "success"
}
```


#### 6.8 添加一条借阅记录


```shell
POST: http://127.0.0.1:8888/api/v1/bookuser/

# 携带数据：
# body-raw-json：
{ 
"bookid": 1, 
"userid": 2
}
```


postman返回信息如下

```json
{
    "msg": "success"
}
```


#### 6.9 查看书籍的借阅记录


```shell
GET: http://127.0.0.1:8888/api/v1/bookuser

# 请求数据
# body：
{ 
"id": 3
}
```
postman返回信息如下

```json
[
    "1",
    "hujianli1",
    "2",
    "hujianli2"
]
```

### 7 中间件身份验证


#### 7.1 middleware/auth.go


```go
package middleware

import (
	"bookManage/dao/mysql"
	"bookManage/model"

	"github.com/gin-gonic/gin"
)

func AuthMiddleware() func(c *gin.Context) {
	return func(c *gin.Context) {
		//客户端携带Token有三种方式
		// 1、放在请求头
		// 2、放在请求体
    // 3、放在URL
		//token验证成功，返回c.Next继续，否则返回c.Abort()直接返回
		token := c.Request.Header.Get("token")
		var u model.User
		//如果没有当前用户
		if rows := mysql.DB.Where("token=?", token).First(&u).RowsAffected; rows != 1 {
			c.JSON(403, gin.H{"msg": "当前token错误"})
			c.Abort()
			return
		}
		//将当前请求的userID信息保存到请求的上下文c上
		c.Set("UserId", u.Id)
		c.Next()
	}
}

```


#### 7.2 router/api_router.go


```go
package router

import (
	"bookManage/controller"
	"bookManage/middleware"

	"github.com/gin-gonic/gin"
)

/**
 * @author hujianli
 */
func SetupApiRouters(r *gin.Engine) {
	r.POST("/register", controller.RegisterHandler)
	r.POST("/login", controller.LoginHandler)

	v1 := r.Group("/api/v1")
	//添加中间验证
	v1.Use(middleware.AuthMiddleware())
	// 书籍CRUD
	v1.POST("book", controller.CreateBookHandler)
  .....
}
```



#### 7.3 测试登录功能

```shell
POST: http://127.0.0.1:8888/login
# 携带数据：
# body-raw-json：
{ 
"username": "hujianli1",
"password": "oschina"
} 
```

postman返回信息如下

```shell
{
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTQ1OTQ1NzIsImlkIjoxfQ.k2JAkllOHSxl-wYCpm4GR4KHuX3Wm_sarLMAaOIAM7A"
}
```


#### 7.4 测试无token获取图书列表

```shell
GET: http://127.0.0.1:8888/api/v1/book 
```

postman返回信息如下

```json
{ "msg": "当前token错误" }
```



#### 7.5 携带token访问

在 Postman 中传入 Token 有以下几种方式：
```shell
放在请求头（Header）中：
打开 Postman。
在请求的 Headers 部分，添加一个键值对，键为 "token"，值为您要传递的 Token。
```

放在请求体（Body）中：
```shell
打开 Postman。
在请求的 Body 部分，选择 "raw"（原始数据）选项。
在输入框中输入 Token。
```

放在 URL 参数中：

```shell
打开 Postman。
在请求的 URL 后面追加参数，例如：http://example.com/api?token=your_token
```

```shell
GET: http://127.0.0.1:8888/api/v1/book
#  Headers 部分，添加一个键值对，键为 "token"
token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTQ1OTQ1NzIsImlkIjoxfQ.k2JAkllOHSxl-wYCpm4GR4KHuX3Wm_sarLMAaOIAM7A"
```

postman返回信息如下

```json
{
    "books": [
        {
            "id": 1,
            "name": "三国演义",
            "desc": "三顾茅庐请诸葛亮、曹操煮酒论英雄",
            "user_ids": [
                1,
                2
            ],
            "usernames": [
                "hujianli1",
                "hujianli2"
            ]
        },
        {
            "id": 2,
            "name": "西游记",
            "desc": "你挑着担，我牵着马，历经千辛万苦...",
            "user_ids": [],
            "usernames": []
        },
        {
            "id": 3,
            "name": "红楼梦",
            "desc": "刘姥姥走进了大观园.",
            "user_ids": [],
            "usernames": []
        },
        {
            "id": 4,
            "name": "水浒传",
            "desc": "武松打虎",
            "user_ids": [],
            "usernames": []
        }
    ]
}
```