# 12. Element Plus


## 12.1 认识Element Plus

### 1. Element Plus介绍


Element-UI是基于vue实现的一套不依赖业务的UI组件库，提供了丰富的PC端组件，减少用户对常用组件的封装，降低了开发的难度。

Element-UI：基于vue2，不支持vue3

Element-Plus：基于vue3

官网：https://element-plus.gitee.io/zh-CN/




### 2. 引入Element Plus



引入Element Plus

使用Element Plus的三种方式：
1. 在HTML中以CDN包的形式导入
2. 下载JS文件保存到本地再导入
3. 使用npm安装，Vue项目使用该方法

参考文档: https://element-plus.gitee.io/zh-CN/guide/installation.html


npm安装：

1. npm install element-plus

2. 在vue项目main.js中引入element-plus组件以及css文件

3. 在vue文件里使用element组件



`src/main.js`

```js
import { createApp } from "vue";
import App from "./App.vue";
import axios from "./api/http"; //导入axios配置
import router from "./router";

//引入element-plus组件以及css文件
import ElementPlus from "element-plus";
import "element-plus/dist/index.css";

const app = createApp(App);

//注册
app.config.globalProperties.$http = axios;
app.use(ElementPlus);
app.use(router);
app.mount("#app");
```

### 3. Vue3 setup

Vue3引入了一大特性

> 函数：setup


#### 选项式API(vue2)

```js
// src/components/UserRepositories.vue

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: { 
      type: String,
      required: true
    }
  },
  data () {
    return {
      repositories: [], // 1
      filters: { ... }, // 3
      searchQuery: '' // 2
    }
  },
  computed: {
    filteredRepositories () { ... }, // 3
    repositoriesMatchingSearchQuery () { ... }, // 2
  },
  watch: {
    user: 'getUserRepositories' // 1
  },
  methods: {
    getUserRepositories () {
      // 使用 `this.user` 获取用户仓库
    }, // 1
    updateFilters () { ... }, // 3
  },
  mounted () {
    this.getUserRepositories() // 1
  }
}
```

#### 组合式API(vue3,2020年9月发布，目前还不常用)

```js
// src/components/UserRepositories.vue
import { toRefs } from 'vue'
import useUserRepositories from '@/composables/useUserRepositories'
import useRepositoryNameSearch from '@/composables/useRepositoryNameSearch'
import useRepositoryFilters from '@/composables/useRepositoryFilters'

export default {
  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },
  props: {
    user: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const { user } = toRefs(props)

    const { repositories, getUserRepositories } = useUserRepositories(user)

    const {
      searchQuery,
      repositoriesMatchingSearchQuery
    } = useRepositoryNameSearch(repositories)

    const {
      filters,
      updateFilters,
      filteredRepositories
    } = useRepositoryFilters(repositoriesMatchingSearchQuery)

    return {
      // 因为我们并不关心未经过滤的仓库
      // 我们可以在 `repositories` 名称下暴露过滤后的结果
      repositories: filteredRepositories,
      getUserRepositories,
      searchQuery,
      filters,
      updateFilters
    }
  }
}
```

## 12.2 Element Plus基础组件


### 组件介绍

Element Plus组件：带有el-前缀的标签

使用方法：
1. Vue导入Element Plus
2. 在官方文档中找到需要的样式组件
3. 复制代码到对应的.vue中
4. 修改为对应的数据

https://element-plus.gitee.io/zh-CN/component/button.html




从官网复制一段代码

![image](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/image.1x4ozyywcdy8.png)


```html
<template>
  <div class="flex flex-wrap gap-2 my-2">
    <el-tag
      v-for="item in items"
      :key="item.label"
      :type="item.type"
      class="mx-1"
      effect="dark"
      round
    >
      {{ item.label }}
    </el-tag>
  </div>
  <div class="flex flex-wrap gap-2">
    <el-tag
      v-for="item in items"
      :key="item.label"
      :type="item.type"
      class="mx-1"
      effect="light"
      round
    >
      {{ item.label }}
    </el-tag>
  </div>
  <div class="flex flex-wrap gap-2 my-2">
    <el-tag
      v-for="item in items"
      :key="item.label"
      :type="item.type"
      class="mx-1"
      effect="plain"
      round
    >
      {{ item.label }}
    </el-tag>
  </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue'

import type { TagProps } from 'element-plus'

type Item = { type: TagProps['type']; label: string }

const items = ref<Array<Item>>([
  { type: '', label: 'Tag 1' },
  { type: 'success', label: 'Tag 2' },
  { type: 'info', label: 'Tag 3' },
  { type: 'danger', label: 'Tag 4' },
  { type: 'warning', label: 'Tag 5' },
])
</script>
```


加入路由后直接运行会报错，为什么呢，因为没加载typescript。



### 开启typescript

用**管理员身份**启动命令提示符程序进入vue项目文件夹：

```shell
$ vue add typescript
```

```shell
$ vue add typescript
 WARN  There are uncommitted changes in the current repository, it's recommended to commit or stash them first.
? Still proceed? Yes

📦  Installing @vue/cli-plugin-typescript...


added 27 packages in 2m
✔  Successfully installed plugin: @vue/cli-plugin-typescript

? Use class-style component syntax? Yes
? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes
? Convert all .js files to .ts? No
? Allow .js files to be compiled? Yes
? Skip type checking of all declaration files (recommended for apps)? Yes

🚀  Invoking generator for @vue/cli-plugin-typescript...
📦  Installing additional dependencies...


added 29 packages in 3m
\  Running completion hooks...
D:\demo\my-project\src\views\views\basic\Tag.vue
  1:1  error  Component name "Tag" should always be multi-word  vue/multi-word-component-names

✖ 1 problem (1 error, 0 warnings)
```

说明

```shell
Use class-style component syntax?                # 使用类样式组件语法？
Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)?        # 在TypeScript旁边使用Babel（现代模式、自动检测多边形填充、传输JSX所需）？
Convert all .js files to .ts?                   # 将所有.js文件转换为.ts？
Allow .js files to be compiled?                 # 允许编译.js文件吗？
Skip type checking of all declaration files (recommended for apps)?         # 跳过所有声明文件的类型检查（推荐用于应用程序）？
```

此时main.js已经变成了main.ts,虽然内容没什么变化


有个报错解释, 组件名应该使用复合单词（虽然目前觉得没什么问题）


`src/router/index.js`

```js
import { createRouter, createWebHashHistory } from "vue-router";
import HomeView from "../views/HomeView.vue";
import Tag from "@/views/views/basic/Tag.vue";

const routes = [
  {
    path: "/",
    name: "home",
    component: HomeView,
  },
  {
    path: "/views/basic/tag",
    name: "tag",
    component: Tag,
  },
  {
    path: "/about",
    name: "about",
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () =>
      import(/* webpackChunkName: "about" */ "../views/AboutView.vue"),
  },
];

const router = createRouter({
  history: createWebHashHistory(),
  routes,
});

export default router;
```


`src/App.vue`

```html
<template>
  <!--  <img alt="Vue logo" src="./assets/logo.png" />-->
  <!--  <HelloWorld msg="Welcome to Your Vue.js + TypeScript App" />-->
  <router-view /><!--根据路由显示页面内容-->
</template>

<script lang="ts">
import { Options, Vue } from "vue-class-component";
import HelloWorld from "./components/HelloWorld.vue";

@Options({
  components: {
    HelloWorld,
  },
})
export default class App extends Vue {}
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>
```


启动项目，访问 http://localhost:8080/#/views/basic/tag/

![image](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/image.1snb88wyf1z4.webp)

五种常见样式：默认、成功、提示、警告、报错