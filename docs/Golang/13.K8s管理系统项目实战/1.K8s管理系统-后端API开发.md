# K8s管理系统-后端API开发


本文档为后端服务器部分

kubernetes客户端库文档：

https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries/




[gitee仓库地址](https://gitee.com/wangzilong9570/k8s-platform)


> 提示：需要配置k8s集群和MySQL数据库



## 1. 项目背景

随着容器技术的广泛应用，kubernetes逐渐成为业内的核心技术，是容器编排技术的首选工具。

而k8s管理平台在日常的容器维护中也发挥着举足轻重的作用，但随着k8s的定制化功能越来越多，dashboard 已经无法满足日常的维护需求，且 dashboard 的源码学习成本较高，抽象程度较高，二次开发成本也就比较高。


本项目使用当下较主流的前端 vue+element plus 及后端 go+gin 框架，打造与dashboard对标的k8s管理功能，且可定制化程度高，

同学们在入门后可根据自身需求，进行灵活定制开发，且本课程除了学习相关知识点外，会带着大家逐渐掌握开发习惯与技巧，让大家在日常工作中高效、高质量的进行开发作业。




## 2. 前后端分离概述


前后端分离已成为互联网项目开发的业界标准使用方式，通过 nginx+tomcat 的方式（也可以中间加一个node.js）有效的进行解耦，

并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多段话服务（多种客户端，例如：浏览器，车载终端，安卓IOS等）打下坚实的基础。

这个步骤是系统架构学习的必经之路。



![1698135577748](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698135577748.6u24tknnt9w0.png){: .zoom}





前后分离的优势：


1. 可以实现真正的前后端解耦，前端服务器使用nginx
2. 发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象
3. 在大并发情况下，可以同时水平扩展前后端服务器。
4. 增加代码的维护性&易读性（前后端耦合在一起的代码阅读比较费劲）
5. 提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖




## 3. 功能设计


![1698135709154](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698135709154.3anyxowdo8m.webp){: .zoom}



## 4. Client-go介绍


### 4.1 简介


> ​client-go官方文档：https://github.com/kubernetes/client-go
> 
> https://www.bookstack.cn/read/huweihuang-kubernetes-notes/develop-client-go.md


client-go 是 kubernetes 官方提供的 go 语言的客户端库，go 应用使用该库可以访问 kubernetes 的 API Server，这样我们就能通过编程来对 kubernetes 资源进行增删改查操作。

除了提供丰富的 API 用于操作 kubernetes 资源，client-go 还为 controller 和 operator 提供了重要支持 client-go 的 informer 机制，可以将 controller 关注的资源变化及时带给此 controller，使 controller 能够及时响应变化。

通过 client-go 提供的客户端对象与 kubernetes 的 API Server 进行交互，而 client-go 提供了以下四种客户端对象：

1. RESTClient这是最基础的客户端对象，仅为HTTPRequest进行了封装，实现RESTFul风格API，这个对象的使用并不方便，因为很多参数都要使用者来设置，于是client-go基于RESTClient又实现了三种新的客户端对象。
2. ClientSet把Resource和Version也封装成了方法，用起来更简单直接，一个资源是一个客户端，多个资源就对应了多个客户端，所以ClientSet就是多个客户端的集合了，这样就好理解了，不过ClientSet只能访问内置资源，访问不了自定义资源
3. DynamicClient可以访问内置资源和自定义资源，个人感觉有点像java的集合操作，拿出的内容是Object类型，按实际情况自己去做强制转换，当然了也会有强制转换失败的风险
4. DiscoveryClient用于发现kubernetes的API Server支持的Group、Version、Resources等信息         //kubectl api-resources



### 4.2 环境搭建


#### 安装精简版K8S(K3S)环境

k3s的官方网址: https://k3s.io

github地址：https://github.com/k3s-io/k3s




> 前提

- [x] 安装centos7
- [x] 安装docker


```sh
yum install -y yum-utils device-mapper-persistent-data lvm2
# 阿里源或者清华源 
sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# sudo yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo
yum list docker-ce --showduplicates | sort -r
yum install docker-ce docker-ce-cli containerd.io

systemctl start docker
systemctl daemon-reload
systemctl restart docker

docker run -itd -p 80:80  nginx:1.18-alpine
```


> 安装

k3s的三个文件：

- k3s
- k3s-airgap-images-amd64.tar
- k3s-install.sh

对于国内用户来说，访问Github超级慢，为了方便下载，可以直接使用下面百度云盘方式下载：

百度网盘下载：

https://pan.baidu.com/s/1Ca1mxigeXOB7QaFLl5xM6A   提取码：8888


```sh
chmod +x k3s
cp k3s /usr/local/bin/

docker load -i k3s-airgap-images-amd64.tar

export INSTALL_K3S_SKIP_DOWNLOAD=true

export INSTALL_K3S_EXEC="--docker --bind-address=192.168.1.147 \
  --cluster-cidr=10.128.0.0/16 --service-cidr=10.129.0.0/16  \
  --kube-apiserver-arg service-node-port-range=30000-50000 \
  --no-deploy traefik --no-deploy servicelb \
  --write-kubeconfig ~/.kube/config --write-kubeconfig-mode 666"

sh k3s-install.sh

kubectl get pod -A
NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE
kube-system   local-path-provisioner-58fb86bdfd-dgjdm   1/1     Running   0          62s
kube-system   metrics-server-6d684c7b5-mcfv4            1/1     Running   0          62s
kube-system   coredns-6c6bb68b64-x9p6c                  1/1     Running   0          62s


# kubectl补全
# centos7上
yum -y install bash-completion
# ubuntu上
sudo apt install bash-completion

 
# 在 bash 中设置当前 shell 的自动补全
source <(kubectl completion bash) 
# 在你的 bash shell 中永久地添加自动补全
echo "source <(kubectl completion bash)" >> ~/.bashrc 
source /usr/share/bash-completion/bash_completion


# 快捷键
cat >> ~/.bashrc <<EOF
alias k=kubectl
complete -o default -F __start_kubectl k
EOF

source ~/.bashrc
```


[k3s安装](https://www.yuque.com/leryn/wiki/cloud.k8s.k3s)


[离线搭建部署高可用 k3s 集群](https://jueee.github.io/2021/09/2021-09-15-%E7%A6%BB%E7%BA%BF%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8k3s%E9%9B%86%E7%BE%A4/)


[k3s 国内离线安装方法](https://imroc.cc/kubernetes/deploy/k3s/offline-installation)


[k3s 官方离线安装方法](https://docs.k3s.io/zh/installation/airgap#%E5%AE%89%E8%A3%85-k3s)


[How to Install k3s Kubernetes Cluster on Ubuntu 22.04](https://www.linuxbuzz.com/install-k3s-kubernetes-cluster-on-ubuntu/)




#### 安装golang环境

在k8s-master节点上

```sh
# 一：yum安装
yum install -y epel-release
yum install -y golang
 

# 二：手动配置 去官网下载安装包手动编译安装
mkdir ~/go && cd ~/go
wget https://dl.google.com/go/go1.17.8.linux-amd64.tar.gz
# 解压到/usr/local目录下
tar -C /usr/local -zxvf go1.17.8.linux-amd64.tar.gz

# 添加/usr/local/go/bin目录到PATH变量中
vi ~/.bashrc
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin

# 刷新配置
source ~/.bashrc
```


新建k8s-platform项目，设置goland远程环境运行

![1698201779063](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698201779063.10verb6egj5c.png){: .zoom}


![1698202043803](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698202043803.56pntwrwyyg0.png){: .zoom}

户名，填写密钥



### 4.3 代码示例


#### 创建一个测试pod

```sh
kubectl run -i --tty alpine-$RANDOM --image=alpine:latest -- sh
# -restart=Never 意味着这个 Pod 不会被重启。

# --rm 会在退出时自动删除这个 Pod
# kubectl run -it --rm test-pod --image=appropriate/curl --restart=Never -- /bin/sh

kubectl run -i --tty busybox --image=busybox -- sh

kubectl run ubuntu --image=ubuntu:20.04 --restart=Always -- /bin/bash -c "while true; do sleep 30; done;"
# kubectl run -i --tty ubuntu --image=ubuntu:20.04 --restart=Never -- bash -il
```

我们这里在default名称空间下运行3个测试pod

```sh
kubectl get pod
NAME                           READY   STATUS    RESTARTS   AGE
alpine-9594-7997b99597-z2k6m   1/1     Running   1          14m
busybox-6cd57fd969-5sxvp       1/1     Running   1          13m
ubuntu-797bd794cf-bv75b        1/1     Running   0          3s
```



main.go


```go
package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"path/filepath"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd" //可能需要挂vpn,留意版本问题
)

func main() {
	//声明kubeconfig配置文件
	var kubeconfig *string
	//获取home环境变量，拿到$HOME/.kube/config配置文件
	if home := homeDir(); home != "" {
		kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"),
			"(optional) absolute path to the kubeconfig file")
	} else {
		//否则就根据kubeconfig传到获得config的路径
		kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
	}
	flag.Parse()
	//将kubeconfig文件转换成rest.config类型文件
	//*kubeconfig其实就是kubeconfig文件的默认位置地址，直接填入地址字符串也可
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		panic(err.Error())
	}
	//根据rest.config类型的对象，new一个clientset出来
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err.Error())
	}
	//通过client-go sdk获取pods列表，命名空间是default
	pods, err := clientset.CoreV1().Pods("default").List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		panic(err.Error())
	}
	//打印pod测试
	for _, pod := range pods.Items {
		fmt.Println(pod.Name, pod.Namespace)
	}
}

func homeDir() string {
	if h := os.Getenv("HOME"); h != "" {//linux
		return h
	}
	return os.Getenv("USERPROFILE") //windows
}

```

运行结果

```sh
alpine-9594-7997b99597-z2k6m default
busybox-6cd57fd969-5sxvp default
ubuntu-797bd794cf-bv75b default
```

获取到了pod名和命名空间



### 4.4 常用方法

```go
//获取pod列表 
podList, err := K8s.ClientSet.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{}) 

//获取pod详情 
pod, err = K8s.ClientSet.CoreV1().Pods(namespace).Get(context.TODO(), podName, metav1.GetOptions{}) 

//删除pod 
err = K8s.ClientSet.CoreV1().Pods(namespace).Delete(context.TODO(), podName, metav1.DeleteOptions{}) 

//更新pod（完整yaml） 
pod, err = K8s.ClientSet.CoreV1().Pods(namespace).Update(context.TODO(), pod, metav1.UpdateOptions{}) 

//获取deployment副本数 
scale, err := K8s.ClientSet.AppsV1().Deployments(namespace).GetScale(context.TODO(), deploymentName, metav1.GetOptions{}) 

//创建deployment 
deployment, err = K8s.ClientSet.AppsV1().Deployments(data.Namespace).Create(context.TODO(), deployment, metav1.CreateOptions{}) 

//更新deployment（部分yaml） 
deployment, err = K8s.ClientSet.AppsV1().Deployments(namespace).Patch(context.TODO(), deploymentName, "application/strategic-merge-patch+json", patchByte, metav1.PatchOptions{})
```

## 5. 项目目录结构


![1698204465060](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698204465060.6qcpqwmfgyo0.png){: .zoom}


- config：定义全局配置，如监听地址、管理员账号等。
- controller：controller层，定义路由规则，及接口入参和响应。
- service：服务层，处理接口的业务逻辑。
- dao：数据库操作，包含数据库的增删改查。
- model：定义数据库的表的字段。
- db: 用于初始化数据库连接以及配置。
- middle：中间件层，添加全局的逻辑处理，如跨域、jwt验证等。
- utils：工具目录，定义常用工具，如token解析，文件操作等。
- go.mod：定义项目的依赖包以及版本。
- main.go：项目的主入口 main函数。



## 6. 框架搭建


### 1. 创建go项目
```sh
/d/coder/go/src/gitee.com/k8s-platform tree
+--- config
+--- controller
+--- dao
+--- db
+--- go.mod
+--- main.go
+--- middle
+--- model
+--- service
+--- utils
```



### 2. 初始化Gin工程

（1）创建项目目录结构


（2）创建config/config.go文件，配置启动监听端口

```go
package config

const (
	// ListenAddr 配置启动监听端口
	ListenAddr = "0.0.0.0:9090"
)
```

（3）创建controller/router.go文件，初始化api路由规则，编写测试api接口

```go
package controller

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

// Router 实例化router结构体，可使用该对象点出首字母大写的方法（包外调用）
var Router router

// 创建router结构体
type router struct{}

// InitApiRouter 初始化路由规则，创建测试api接口
func (r *router) InitApiRouter(router *gin.Engine) {
	router.GET("/testapi", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{
			"msg":  "testapi success!",
			"data": nil,
		})
	})
}
```


（4）main.go文件中，启动gin程序


```go
package main

import (
	"gitee.com/k8s-platform/config"
	"gitee.com/k8s-platform/controller"

	"github.com/gin-gonic/gin"
)

func main() {
	//初始化gin对象
	r := gin.Default()
	//初始化路由规则
	controller.Router.InitApiRouter(r)
	//gin程序启动
	r.Run(config.ListenAddr)
}
```

```sh
curl http://127.0.0.1:9090/testapi
{"data":null,"msg":"testapi success!"}    
```


### 3. 初始化K8s Client

（1）在config.go中添加kubeconfig文件路径

```go
package config

const (
// 配置启动监听端口
ListenAddr = "0.0.0.0:9090"

// Linux上配置
// Kubeconfig = "/root/.kube/config"
// Windows上配置
Kubeconfig = "C:\\Users/18793/.kube/config"
)
```



（2）创建service/init.go文件，初始化k8s client

```go
package service

import (
"gitee.com/k8s-platform/config"

"github.com/wonderivan/logger"
"k8s.io/client-go/kubernetes"
"k8s.io/client-go/tools/clientcmd"
)

type k8s struct {
ClientSet *kubernetes.Clientset
}

var K8s k8s

func (k *k8s) Init() {
conf, err := clientcmd.BuildConfigFromFlags("", config.Kubeconfig)
if err != nil {
  panic("创建k8s配置失败，" + err.Error())
}
clientSet, err := kubernetes.NewForConfig(conf)
if err != nil {
  panic("创建K8s clientSet失败，" + err.Error())
} else {
  logger.Info("创建k8s clientSet成功")
}
k.ClientSet = clientSet
}
```


（3）main.go中添加k8s client启动项

```go
package main

import (
"gitee.com/k8s-platform/config"
"gitee.com/k8s-platform/controller"
"gitee.com/k8s-platform/service"

"github.com/gin-gonic/gin"
)

func main() {
//初始化gin对象
r := gin.Default()
//初始化k8s client
service.K8s.Init()
//初始化路由规则
controller.Router.InitApiRouter(r)
//gin程序启动
r.Run(config.ListenAddr)
}
```


### 4. 测试API接口


```sh
curl http://127.0.0.1:9090/testapi
{"data":null,"msg":"testapi success!"}    
```

## 7. API开发






### 1. 开发&响应流程


![1700452058796](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700452058796.77vrr972us00.png){: .zoom}



1. Model层：实体层 >> 表数据与类的映射关系，这里的类是strcut 
2. Dao层：持久层/数据访问层 >> 主要与数据库交互，增删改查
3. Service层：业务层 >> 控制业务逻辑，主要处理业务模块的功能逻辑
4. Controller层：控制层 >> 接收请求参数，调用不同的Service层代码来控制业务流程


![1700458875460](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700458875460.3ok9s1egqvk0.webp){: .zoom}


### 2. 工作负载

#### 2.1 数组的排序、过滤、分页

`service/dataselector.go`


(1)定义数据结构


```go
package service

import (
	corev1 "k8s.io/api/core/v1"
	"sort"
	"strings"
	"time"
)

// dataSelector 用于封装排序、过滤、分页的数据类型
type dataSelector struct {
	GenericDataList []DataCell
	dataSelectQuery *DataSelectQuery
}

// DataCell 接口，用于各种资源list的类型转换，转换后可以使用dataSelector的自定义排序方法
type DataCell interface {
	GetCreation() time.Time
	GetName() string
}

// DataSelectQuery 定义过滤和分页的属性，过滤：Name，分页：Limit和Page
// Limit是单页的数据条数
// Page是第几页
type DataSelectQuery struct {
	FilterQuery   *FilterQuery
	PaginateQuery *PaginateQuery
}
type FilterQuery struct {
	Name string
}
type PaginateQuery struct {
	Limit int
	Page  int
}
```

(2)排序

自定义类型排序参考文档：https://segmentfault.com/a/1190000008062661

```go
//实现自定义结构的排序，需要重写Len、Swap、Less方法
//Len方法用于获取数组长度
func(d *dataSelector)Len()int{
	return len(d.GenericDataList)
}
//Swap方法用于数组中的元素在比较大小后的位置交换，可定义升序或降序
func(d *dataSelector)Swap(i,j int){
	d.GenericDataList[i],d.GenericDataList[j]=d.GenericDataList[j],d.GenericDataList[i]
}
//Less方法用于定义数组中元素排序的“大小”的比较方式
func(d *dataSelector)Less(i,j int)bool{
	a:=d.GenericDataList[i].GetCreation()
	b:=d.GenericDataList[j].GetCreation()
	return b.Before(a)
}
//重写以上3个方法使用sort.Sort进行排序
func(d *dataSelector)Sort() *dataSelector{
	sort.Sort(d)
	return d
}
```

(3)过滤

```go
//Filter方法用于过滤元素，比较元素的Name属性，若包含，再返回
func (d *dataSelector) Filter() *dataSelector {
	//若Name的传参为空，则返回所有元素
	if d.dataSelectQuery.FilterQuery.Name == "" {
		return d
	}
	//若Name的传参不为空，则返回元素名中包含Name的所有元素
	filteredList := []DataCell{}
	for _, value := range d.GenericDataList {
		matches := true
		objName := value.GetName()
		//判断字符串s中是否包含子串str
		if !strings.Contains(objName, d.dataSelectQuery.FilterQuery.Name) {
			matches = false
			continue
		}
		if matches {
			filteredList = append(filteredList, value)
		}
	}
	d.GenericDataList = filteredList
	return d
}
```


(4)分页

```go
//Paginate方法用于数组分页，根据Limit和Page的传参，返回数据
func (d *dataSelector) Paginate() *dataSelector {
	limit := d.dataSelectQuery.PaginateQuery.Limit
	page := d.dataSelectQuery.PaginateQuery.Page
	//验证参数合法，若参数不合法，则返回所有数据
	if limit <= 0 || page <= 0 {
		return d
	}
    //定义取数范围
	//举例：25个元素的数组，limit是10，page是3，startIndex是20，endIndex是30（实际上endIndex是25）
	startIndex := limit * (page - 1)
	endIndex := limit * page
	//处理最后一页，这时候就把endIndex由30改为25了
	if len(d.GenericDataList) < endIndex {
		endIndex = len(d.GenericDataList)
	}
	d.GenericDataList = d.GenericDataList[startIndex:endIndex]
	return d
}
```

(5)定义podCell类型，实现DataCell接口，用于类型转换

```go
//定义podCell类型，实现GetCreation和getName方法后，可进行类型转换
type podCell corev1.Pod

func (p podCell) GetCreation() time.Time {
	return p.CreationTimestamp.Time
}
func (p podCell) GetName() string {
	return p.Name
}
```

(6)定义DataCell到Pod类型转换的方法

断言：判断一个变量是否属于某一种类型，前提是这一类型实现了这一变量类型接口

`service/pod.go`

```go
package service

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"gitee.com/k8s-platform/config"
	"github.com/wonderivan/logger"
	"io"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Pod 定义pod类型和Pod对象，用于包外的调用(包是指service目录)，例如Controller
var Pod pod

type pod struct{}

// toCells方法用于将pod类型数组，转换成DataCell类型数组
func (p *pod) toCells(std []corev1.Pod) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = podCell(std[i])
	}
	return cells
}

// fromCells方法用于将DataCell类型数组，转换成pod类型数组
func (p *pod) fromCells(cells []DataCell) []corev1.Pod {
	pods := make([]corev1.Pod, len(cells))
	for i := range cells {
		//cells[i].(podCell)就使用到了断言，断言后转换成了podCell类型，然后又转换成了Pod类型
		pods[i] = corev1.Pod(cells[i].(podCell))
	}
	return pods
}
```



#### 2.2 Pod

开发 pod 功能

|功能|是否实现|
|---|-----|
|获取所有pod信息 |√|
|获取pod的详细信息|√|
|删除pod|√|
|更新pod|√|
|获取pod容器名称|√|
|获取pod中容器日志|√|
|获取每个namespace的pod数量|√|




`service/pod.go`


(1)定义数据类型

看情况创建结构体

```go
//定义列表的返回内容，Item是pod元素列表，Total为pod元素数量
type PodsResp struct{
	Items []corev1.Pod `json:"items"`
	Total int `json:"total"`
}
//定义PodsNp类型，用于返回namespace中pod的数量
type PodsNp struct{
	Namespace string `json:"namespace"`
	PodNum int `json:"pod_num"`
}
```

(2)获取pod列表


```go
// GetPods 获取pod列表，支持过滤、排序、分页
func (p *pod) GetPods(filterName, namespace string, limit, page int) (podsResp *PodsResp, err error) {
	//获取podList类型的pod列表
	//context.TODO() 用于声明一个空的context上下文，用于List方法内设置这个请求的超时(3)，这里的常用用法
	//metav1.ListOptions{}用于过滤List数据，如使用label，field等
	//kubectl get services --all-namespace --field-seletor metadata.namespace != default
	podList, err := K8s.ClientSet.CoreV1().Pods(namespace).List(context.TODO(),
		metav1.ListOptions{})
	if err != nil {
		//logger用于打印日志
		//return用于返回response内容
		logger.Error(errors.New("获取Pod列表失败，" + err.Error()))
		return nil, errors.New("获取Pod列表失败，" + err.Error())
	}
	//实例化dataSelector对象
	selectableData := &dataSelector{
		GenericDataList: p.toCells(podList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}
	//先过滤
	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	//再排序和分页
	data := filtered.Sort().Paginate()
	//将[]DataCell类型的pod列表转为v1.pod列表
	pods := p.fromCells(data.GenericDataList)
	return &PodsResp{
		Items: pods,
		Total: total,
	}, nil
}
```

(3)获取Pod详情

```go
// GetPodDetail 获取pod详情
func (p *pod) GetPodDetail(podName, namespace string) (pod *corev1.Pod, err error) {
	pod, err = K8s.ClientSet.CoreV1().Pods(namespace).
		Get(context.TODO(), podName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Pod详情失败，" + err.Error()))
		return nil, errors.New("获取Pod详情失败，" + err.Error())
	}
	return pod, nil
}
```

(4)删除Pod

```go
// DeletePod 删除pod
func (p *pod) DeletePod(podName, namespace string) (err error) {
	err = K8s.ClientSet.CoreV1().Pods(namespace).
		Delete(context.TODO(), podName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除pod失败，" + err.Error()))
		return errors.New("删除pod失败，" + err.Error())
	}
	return nil
}
```


(5)更新pod

```go
// UpdatePod 更新pod
// content参数是请求中传入的pod对象的json数据
func (p *pod) UpdatePod(namespace, content string) (err error) {
	var pod = &corev1.Pod{}
	//反序列化为pod对象
	err = json.Unmarshal([]byte(content), pod)
	if err != nil {
		logger.Error(errors.New("反序列化失败, " + err.Error()))
		return errors.New("反序列化失败, " + err.Error())
	}
	//更新pod
	_, err = K8s.ClientSet.CoreV1().Pods(namespace).
		Update(context.TODO(), pod, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新Pod失败, " + err.Error()))
		return errors.New("更新Pod失败, " + err.Error())
	}
	return nil
}
```

(6)获取Pod中的容器名


```go
// GetPodContainer 获取Pod中的容器名
func (p *pod) GetPodContainer(podName, namespace string) (containers []string, err error) {
	//获取pod详情
	pod, err := p.GetPodDetail(podName, namespace)
	if err != nil {
		return nil, err
	}
	//从pod对象中拿到容器名
	for _, container := range pod.Spec.Containers {
		containers = append(containers, container.Name)
	}
	return containers, nil
}
```


(7)获取容器日志

```go
// GetPodLog 获取pod内容器日志
func (p *pod) GetPodLog(containerName, podName, namespace string) (log string, err error) {
	//设置日志的配置，容器名、tail的行数
	lineLimit := int64(config.PodLogTailLine)
	option := &corev1.PodLogOptions{
		Container: containerName,
		TailLines: &lineLimit,
	}
	//获取request实例
	req := K8s.ClientSet.CoreV1().Pods(namespace).GetLogs(podName, option)
	//发起request请求，返回一个io.ReadCloser类型（等同于response.boby)
	podLogs, err := req.Stream(context.TODO())
	if err != nil {
		logger.Error(errors.New("获取PodLog失败，" + err.Error()))
		return "", errors.New("获取PodLog失败，" + err.Error())
	}
	defer podLogs.Close()
	//将response body写入到缓冲区，目的是为了转成string返回
	buf := new(bytes.Buffer)
	_, err = io.Copy(buf, podLogs)
	if err != nil {
		logger.Error(errors.New("复制PodList失败，" + err.Error()))
		return "", errors.New("复制PodList失败，" + err.Error())
	}
	return buf.String(), nil
}
```

(8)获取每个namespace的pod数量

```go
// GetPodNumPerNp 获取每个namespace的pod数量
func (p *pod) GetPodNumPerNp() (podsNps []*PodsNp, err error) {
	//获取namespace列表
	namespaceList, err := K8s.ClientSet.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	for _, namespace := range namespaceList.Items {
		//获取pod列表
		podList, err := K8s.ClientSet.CoreV1().Pods(namespace.Name).
			List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			return nil, err
		}
		//组装数据
		PodsNp := &PodsNp{
			Namespace: namespace.Name,
			PodNum:    len(podList.Items),
		}
		//添加到podsNps数组中
		podsNps = append(podsNps, PodsNp)
	}
	return podsNps, nil
}

```


(9)编写Controller层的pod代码

`controller/pod.go`



```go
package controller

import (
	"gitee.com/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var Pod pod

type pod struct{}

//Controller中的方法入参是gin.Context，用于从上下文中获取请求参数及定义响应内容
//流程：绑定参数->调用service代码->根据调用结果响应具体内容

// GetPods 获取pod列表，支持过滤、排序、分页
func (p *pod) GetPods(ctx *gin.Context) {
	//匿名结构体，用于声明入参，get请求为form格式，其他请求为json格式
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	//绑定参数，给匿名结构体中的属性赋值，值是入参
	//form格式(Get)使用ctx.Bind方法，json格式使用ctx.ShouldBindJSON方法
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		//ctx.JSON方法用于返回响应内容，入参是状态码和响应内容，响应内容放入gin.H的map中
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	//service中的的方法通过 包名.结构体变量名.方法名 使用，serivce.Pod.GetPods()
	data, err := service.Pod.GetPods(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pod列表成功",
		"data": data,
	})
}

// GetPodDetail 获取pod详情
func (p *pod) GetPodDetail(ctx *gin.Context) {
	params := new(struct {
		PodName   string `form:"pod_name"`
		Namespace string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Pod.GetPodDetail(params.PodName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pod详情成功",
		"data": data,
	})
}

// DeletePod 删除Pod
func (p *pod) DeletePod(ctx *gin.Context) {
	params := new(struct {
		PodName   string `json:"pod_name"`
		Namespace string `json:"namespace"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Pod.DeletePod(params.PodName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Pod成功",
		"data": nil,
	})
}

// UpdatePod 更新pod
func (p *pod) UpdatePod(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Pod.UpdatePod(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新Pod成功",
		"data": nil,
	})
}

// GetPodContainer 获取pod容量
func (p *pod) GetPodContainer(ctx *gin.Context) {
	params := new(struct {
		PodName   string `form:"pod_name"`
		Namespace string `form:"namespace"`
	})
	//GET请求，绑定参数方法改为ctx.Bind
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Pod.GetPodContainer(params.PodName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pod容器成功",
		"data": data,
	})
}

// GetPodLog 获取pod中容器日志
func (p *pod) GetPodLog(ctx *gin.Context) {
	params := new(struct {
		ContainerName string `form:"container_name"`
		PodName       string `form:"pod_name"`
		Namespace     string `form:"namespace"`
	})
	//GET请求，绑定参数方法改为ctx.Bind
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Pod.GetPodLog(params.ContainerName, params.PodName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pod中容器日志成功",
		"data": data,
	})
}

// GetPodNumPerNp 获取每个namespace的pod数量
func (p *pod) GetPodNumPerNp(ctx *gin.Context) {
	data, err := service.Pod.GetPodNumPerNp()
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取每个namespace的pod数量成功",
		"data": data,
	})
}

```


(10)定义路由规则

`controller/router.go`


```go
package controller

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

// Router 实例化router结构体，可使用该对象点出首字母大写的方法（包外调用）
var Router router

// 创建router结构体
type router struct{}

// InitApiRouter 初始化路由规则
func (r *router) InitApiRouter(router *gin.Engine) {
	//创建测试api接口
	router.GET("/testapi", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{
			"msg":  "testapi success!",
			"data": nil,
		})
	}).
		// pod操作
		GET("/api/k8s/pods", Pod.GetPods).
		GET("/api/k8s/pod/detail", Pod.GetPodDetail).
		DELETE("/api/k8s/pod/del", Pod.DeletePod).
		PUT("/api/k8s/pod/update", Pod.UpdatePod).
		GET("/api/k8s/pod/container", Pod.GetPodContainer).
		GET("/api/k8s/pod/log", Pod.GetPodLog).
		GET("/api/k8s/pod/numnp", Pod.GetPodNumPerNp)
}
```

(11)做接口测试


- 获取所有pod信息

![1700558387506](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700558387506.5wwy3ial69c0.webp){: .zoom}



- 获取pod详细内容

![1700558473846](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700558473846.3h9rliiwuhs0.webp){: .zoom}



- 删除pod

![1700558519334](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700558519334.723iphdn21o0.webp){: .zoom}



#### 2.3 Deployment


`service/dataselector.go`


```go
// 实现 Deployment的 DataCell接口
type deploymentCell appsv1.Deployment //appsv1 "k8s.io/api/apps/v1"

func (d deploymentCell) GetCreation() time.Time {
	return d.CreationTimestamp.Time
}
func (d deploymentCell) GetName() string {
	return d.Name
}
```


`service/deployment.go`

开发deployment功能


|功能|是否实现|
|---|-----|
|deployment列表 |√|
|获取Deployment详情|√|
|修改Deployment副本数|√|
|创建Deployment|√|
|删除Deployment|√|
|重启Deployment|√|
|更新Deployment|√|
|获取每个namespace的Deployment数量|√|



```go
package service

import (
	"context"
	"encoding/json"
	"errors"
	"strconv"
	"time"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/util/intstr"

	"github.com/wonderivan/logger"
	appsv1 "k8s.io/api/apps/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var Deployment deployment

type deployment struct{}

// DeploymentsResp 定义列表的返回内容，Items是deployment元素列表，Total为deployment元素数量
type DeploymentsResp struct {
	Items []appsv1.Deployment `json:"items"`
	Total int                 `json:"total"`
}

// DeployCreate 结构体，用于创建deployment需要的参数属性的定义
type DeployCreate struct {
	Name          string            `json:"name"`
	Namespace     string            `json:"namespace"`
	Replicas      int32             `json:"replicas"`
	Image         string            `json:"image"`
	Label         map[string]string `json:"label"`
	Cpu           string            `json:"cpu"`
	Memory        string            `json:"memory"`
	ContainerPort int32             `json:"container_port"`
	HealthCheck   bool              `json:"health_check"`
	HealthPath    string            `json:"health_path"`
}

// DeploysNp 类型，用于返回namespace中deployment的数量
type DeploysNp struct {
	Namespace string `json:"namespace"`
	DeployNum int    `json:"deployment_num"`
}

func (d *deployment) toCells(std []appsv1.Deployment) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = deploymentCell(std[i])
	}
	return cells
}
func (d *deployment) fromCells(cells []DataCell) []appsv1.Deployment {
	deployments := make([]appsv1.Deployment, len(cells))
	for i := range cells {
		deployments[i] = appsv1.Deployment(cells[i].(deploymentCell))
	}
	return deployments
}

// GetDeployments 获取deployment列表，支持过滤、排序、分页
func (d *deployment) GetDeployments(filterName, namespace string, limit, page int) (deploymentsResp *DeploymentsResp, err error) {
	//获取deploymentList类型的deployment列表
	deploymentList, err := K8s.ClientSet.AppsV1().Deployments(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取Deployment列表失败，" + err.Error()))
		return nil, errors.New("获取Deployment列表失败，" + err.Error())
	}
	//将deploymentList中的deployment列表(Items),放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: d.toCells(deploymentList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}
	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()
	//将[]DataCell类型的deployment列表转为appsv1.deployment列表
	deployments := d.fromCells(data.GenericDataList)
	return &DeploymentsResp{
		Items: deployments,
		Total: total,
	}, nil
}

// GetDeploymentDetail 获取deployment详情
func (d *deployment) GetDeploymentDetail(deploymentName, namespace string) (deployment *appsv1.Deployment, err error) {
	deployment, err = K8s.ClientSet.AppsV1().Deployments(namespace).Get(context.TODO(), deploymentName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Deployment详情失败，" + err.Error()))
		return nil, errors.New("获取Deployment详情失败，" + err.Error())
	}
	return deployment, nil
}

// ScaleDeployment 设置deployment副本数
func (d *deployment) ScaleDeployment(deploymentName, namespace string, scaleNum int) (replica int32, err error) {
	//获取autoscalingv1.Scale类型的对象，能点出当前的副本数
	scale, err := K8s.ClientSet.AppsV1().Deployments(namespace).GetScale(context.TODO(), deploymentName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Deployment副本数信息失败，" + err.Error()))
		return 0, errors.New("获取Deployment副本数信息失败，" + err.Error())
	}
	//修改副本数
	scale.Spec.Replicas = int32(scaleNum)
	//更新副本数，传入scale对象
	newScale, err := K8s.ClientSet.AppsV1().Deployments(namespace).UpdateScale(context.TODO(), deploymentName, scale, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新Deployment副本数信息失败，" + err.Error()))
		return 0, errors.New("更新Deployment副本数信息失败，" + err.Error())
	}
	return newScale.Spec.Replicas, nil
}

// CreateDeployment 创建deployment，接收DeployCreate对象
func (d *deployment) CreateDeployment(data *DeployCreate) (err error) {
	//将data中的数据组装成appsv1.Deployment对象
	deployment := &appsv1.Deployment{
		//ObjectMeta中定义资源名、命名空间以及标签
		ObjectMeta: metav1.ObjectMeta{
			Name:      data.Name,
			Namespace: data.Namespace,
			Labels:    data.Label,
		},
		//Spec中定义副本数、选择器、以及pod属性
		Spec: appsv1.DeploymentSpec{
			Replicas: &data.Replicas,
			Selector: &metav1.LabelSelector{
				MatchLabels: data.Label,
			},
			Template: corev1.PodTemplateSpec{
				//定义pod名和标签
				ObjectMeta: metav1.ObjectMeta{
					Name:   data.Name,
					Labels: data.Label,
				},
				//定义容器名、镜像和端口
				Spec: corev1.PodSpec{
					Containers: []corev1.Container{
						{
							Name:  data.Name,
							Image: data.Image,
							Ports: []corev1.ContainerPort{
								{
									Name:          "http",
									Protocol:      corev1.ProtocolTCP,
									ContainerPort: data.ContainerPort,
								},
							},
						},
					},
				},
			},
		},
		//Status定义资源的运行状态，这里由于是新建，传入空的appsv1.DeploymentStatus{}对象即可
		Status: appsv1.DeploymentStatus{},
	}
	//判断是否打开健康检查功能，若打开，则定义ReadinessProbe和LivenessProbe
	if data.HealthCheck {
		//设置第一个容器的ReadinessProbe,因为我们pod中只有一个容器，所以直接使用index 0即可
		//若pod中有多个容器，则这里需要使用for循环去定义了
		deployment.Spec.Template.Spec.Containers[0].ReadinessProbe = &corev1.Probe{
			ProbeHandler: corev1.ProbeHandler{
				HTTPGet: &corev1.HTTPGetAction{
					Path: data.HealthPath,
					//intstr.IntOrString的作用是端口可以定义为整型，也可以定义为字符串
					//Type=0则表示该结构体实例内的数据为整型，转json时只使用IntVal的数据
					//Type=1则表示该结构体实例内的数据为字符串，转json时只使用StrVal的数据
					Port: intstr.IntOrString{
						Type:   0,
						IntVal: data.ContainerPort,
					},
				},
			},
			//初始化等待时间
			InitialDelaySeconds: 5,
			//超时时间
			TimeoutSeconds: 5,
			//执行间隔
			PeriodSeconds: 5,
		}
		deployment.Spec.Template.Spec.Containers[0].LivenessProbe = &corev1.Probe{
			ProbeHandler: corev1.ProbeHandler{
				HTTPGet: &corev1.HTTPGetAction{
					Path: data.HealthPath,
					Port: intstr.IntOrString{
						Type:   0,
						IntVal: data.ContainerPort,
					},
				},
			},
			InitialDelaySeconds: 15,
			TimeoutSeconds:      5,
			PeriodSeconds:       5,
		}
		//定义容器的limit和request资源
		deployment.Spec.Template.Spec.Containers[0].Resources.Limits = map[corev1.ResourceName]resource.Quantity{
			corev1.ResourceCPU:    resource.MustParse(data.Cpu),
			corev1.ResourceMemory: resource.MustParse(data.Memory),
		}
		deployment.Spec.Template.Spec.Containers[0].Resources.Requests = map[corev1.ResourceName]resource.Quantity{
			corev1.ResourceCPU:    resource.MustParse(data.Cpu),
			corev1.ResourceMemory: resource.MustParse(data.Memory),
		}
	}
	//调用sdk创建deployment
	_, err = K8s.ClientSet.AppsV1().Deployments(data.Namespace).Create(context.TODO(), deployment, metav1.CreateOptions{})
	if err != nil {
		logger.Error(errors.New("创建Deployment失败，" + err.Error()))
		return errors.New("创建Deployment失败," + err.Error())
	}
	return nil
}

// DeleteDeployment 删除deployment
func (d *deployment) DeleteDeployment(deploymentName, namespace string) (err error) {
	err = K8s.ClientSet.AppsV1().Deployments(namespace).Delete(context.TODO(), deploymentName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除Deployment失败，" + err.Error()))
		return errors.New("删除Deployment失败，" + err.Error())
	}
	return nil
}

// RestartDeployment 重启deployment
func (d *deployment) RestartDeployment(deploymentName, namespace, imageName, image string) (err error) {
	//此功能等同于以下kubectl命令
	//kubectl deployment ${service} -p \
	//'{"spec":{"template":{"spec":{"containers":[{"name":"'"${service}"'","env":
	//[{"name":"RESTART_","value":"'$(date +%s)'"}]}]}}}}'

	//使用patchData Map组装数据
	patchData := map[string]interface{}{
		"metadata": map[string]interface{}{
			"name":      deploymentName,
			"namespace": namespace,
		},
		"spec": map[string]interface{}{
			"template": map[string]interface{}{
				"spec": map[string]interface{}{
					"containers": []map[string]interface{}{
						{
							"name":  imageName,
							"image": image,
							"env": []map[string]string{{
								"name":  "RESTART_",
								"value": strconv.FormatInt(time.Now().Unix(), 10),
							}},
						},
					},
				},
			},
		},
	}
	//序列化为字节，因为patch方法只接收字节类型参数
	patchByte, err := json.Marshal(patchData)
	if err != nil {
		logger.Error(errors.New("json序列化失败，" + err.Error()))
		return errors.New("json序列化失败，" + err.Error())
	}
	//调用patch方法更新deployment
	_, err = K8s.ClientSet.AppsV1().Deployments(namespace).Patch(context.TODO(), deploymentName, "application/strategic-merge-patch+json", patchByte, metav1.PatchOptions{})
	if err != nil {
		logger.Error(errors.New("重启Deployment失败，" + err.Error()))
		return errors.New("重启Deployment失败，" + err.Error())
	}
	return nil
}

// UpdateDeployment 更新deployment
func (d *deployment) UpdateDeployment(namespace, content string) (err error) {
	var deploy = &appsv1.Deployment{}

	err = json.Unmarshal([]byte(content), deploy)
	if err != nil {
		logger.Error(errors.New("反序列化失败，" + err.Error()))
		return errors.New("反序列化失败，" + err.Error())
	}

	_, err = K8s.ClientSet.AppsV1().Deployments(namespace).Update(context.TODO(), deploy, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新Deployment失败，" + err.Error()))
		return errors.New("更新Deployment失败，" + err.Error())
	}
	return nil
}

// GetDeployNumPerNp 获取每个namespace的deployment数量
func (d *deployment) GetDeployNumPerNp() (deploysNps []*DeploysNp, err error) {
	namespaceList, err := K8s.ClientSet.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	for _, namespace := range namespaceList.Items {
		deploymentList, err := K8s.ClientSet.AppsV1().Deployments(namespace.Name).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			return nil, err
		}
		DeploysNp := &DeploysNp{
			Namespace: namespace.Name,
			DeployNum: len(deploymentList.Items),
		}
		deploysNps = append(deploysNps, DeploysNp)
	}
	return deploysNps, nil
}

```




`controller/deployment.go`

```go
package controller

import (
	"fmt"
	"gitee.com/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

type deployment struct{}

var Deployment deployment

// GetDeployments 获取deployment列表，支持过滤、排序、分页
func (d *deployment) GetDeployments(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Deployment.GetDeployments(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Deployment列表成功",
		"data": data,
	})
}

// GetDeploymentDetail 获取deployment详情
func (d *deployment) GetDeploymentDetail(ctx *gin.Context) {
	params := new(struct {
		DeploymentName string `form:"deployment_name"`
		Namespace      string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Deployment.GetDeploymentDetail(params.DeploymentName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Deployment详情成功",
		"data": data,
	})
}

// CreateDeployment 创建deployment
func (d *deployment) CreateDeployment(ctx *gin.Context) {
	var (
		deployCreate = new(service.DeployCreate)
		err          error
	)
	if err = ctx.ShouldBindJSON(deployCreate); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	if err = service.Deployment.CreateDeployment(deployCreate); err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "创建Deployment成功",
		"data": nil,
	})
}

// ScaleDeployment 设置deployment副本数
func (d *deployment) ScaleDeployment(ctx *gin.Context) {
	params := new(struct {
		DeploymentName string `json:"deployment_name"`
		Namespace      string `json:"namespace"`
		ScaleNum       int    `json:"scale_num"`
	})
	//PUT请求，绑定参数方法为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Deployment.ScaleDeployment(params.DeploymentName, params.Namespace, params.ScaleNum)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "设置Deployment副本数成功",
		"data": fmt.Sprintf("最新副本数：%d", data),
	})
}

// DeleteDeployment 删除deployment
func (d *deployment) DeleteDeployment(ctx *gin.Context) {
	params := new(struct {
		DeploymentName string `json:"deployment_name"`
		Namespace      string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Deployment.DeleteDeployment(params.DeploymentName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Deployment成功",
		"data": nil,
	})
}

// RestartDeployment 重启deployment
func (d *deployment) RestartDeployment(ctx *gin.Context) {
	params := new(struct {
		DeploymentName string `json:"deployment_name"`
		Namespace      string `json:"namespace"`
		ImageName      string `json:"image_name"`
		Image          string `json:"image"`
	})
	//PUT请求，绑定参数方法为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Deployment.RestartDeployment(params.DeploymentName, params.Namespace, params.ImageName, params.Image)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "重启Deployment成功",
		"data": nil,
	})
}

// UpdateDeployment 更新deployment
func (d *deployment) UpdateDeployment(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Deployment.UpdateDeployment(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新Deployment成功",
		"data": nil,
	})
}

// GetDeployNumPerNp 获取每个namespace的pod数量
func (d *deployment) GetDeployNumPerNp(ctx *gin.Context) {
	data, err := service.Deployment.GetDeployNumPerNp()
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取每个namespace的deployment数量成功",
		"data": data,
	})
}
```



`controller/router.go`

定义路由规则

```go
package controller

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

// Router 实例化router结构体，可使用该对象点出首字母大写的方法（包外调用）
var Router router

// 创建router结构体
type router struct{}

// InitApiRouter 初始化路由规则
func (r *router) InitApiRouter(router *gin.Engine) {
	// 创建测试api接口
	router.GET("/testapi", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{
			"msg":  "testapi success!",
			"data": nil,
		})
	}).
		// pod操作
		GET("/api/k8s/pods", Pod.GetPods).
		GET("/api/k8s/pod/detail", Pod.GetPodDetail).
		DELETE("/api/k8s/pod/del", Pod.DeletePod).
		PUT("/api/k8s/pod/update", Pod.UpdatePod).
		GET("/api/k8s/pod/container", Pod.GetPodContainer).
		GET("/api/k8s/pod/log", Pod.GetPodLog).
		GET("/api/k8s/pod/numnp", Pod.GetPodNumPerNp).
		// deployment操作
		GET("/api/k8s/deployments", Deployment.GetDeployments).
		GET("/api/k8s/deployment/detail", Deployment.GetDeploymentDetail).
		PUT("/api/k8s/deployment/scale", Deployment.ScaleDeployment).
		DELETE("/api/k8s/deployment/del", Deployment.DeleteDeployment).
		PUT("/api/k8s/deployment/restart", Deployment.RestartDeployment).
		PUT("/api/k8s/deployment/update", Deployment.UpdateDeployment).
		GET("/api/k8s/deployment/numnp", Deployment.GetDeployNumPerNp).
		POST("/api/k8s/deployment/create", Deployment.CreateDeployment)
}
```



#### 2.4 DaemonSet

> 注意：以下功能与Pod和Deployment是实现方式一致


|功能|是否实现|
|---|-----|
|DaemonSet列表 |√|
|获取DaemonSet详情|√|
|删除DaemonSet |√|
|更新DaemonSet |√|



`service/dataselector.go`

```go
// 实现 DaemonSet 的 DataCell接口
type daemonSetCell appsv1.DaemonSet

func (d daemonSetCell) GetCreation() time.Time {
	return d.CreationTimestamp.Time
}

func (d daemonSetCell) GetName() string {
	return d.Name
}
```


`service/daemonset.go`

```go
package service

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/wonderivan/logger"
	appsv1 "k8s.io/api/apps/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var DaemonSet daemonSet

type daemonSet struct{}

type DaemonSetsResp struct {
	Items []appsv1.DaemonSet `json:"items"`
	Total int                `json:"total"`
}

// GetDaemonSets 获取daemonset列表，支持过滤、排序、分页
func (d *daemonSet) GetDaemonSets(filterName, namespace string, limit, page int) (daemonSetsResp *DaemonSetsResp, err error) {
	//获取daemonSetList类型的daemonSet列表
	daemonSetList, err := K8s.ClientSet.AppsV1().DaemonSets(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取DaemonSet列表失败, " + err.Error()))
		return nil, errors.New("获取DaemonSet列表失败, " + err.Error())
	}
	//将daemonSetList中的daemonSet列表(Items)，放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: d.toCells(daemonSetList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}

	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()

	//将[]DataCell类型的daemonset列表转为v1.daemonset列表
	daemonSets := d.fromCells(data.GenericDataList)

	return &DaemonSetsResp{
		Items: daemonSets,
		Total: total,
	}, nil
}

// GetDaemonSetDetail 获取daemonset详情
func (d *daemonSet) GetDaemonSetDetail(daemonSetName, namespace string) (daemonSet *appsv1.DaemonSet, err error) {
	daemonSet, err = K8s.ClientSet.AppsV1().DaemonSets(namespace).Get(context.TODO(), daemonSetName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取DaemonSet详情失败, " + err.Error()))
		return nil, errors.New("获取DaemonSet详情失败, " + err.Error())
	}

	return daemonSet, nil
}

// DeleteDaemonSet 删除daemonset
func (d *daemonSet) DeleteDaemonSet(daemonSetName, namespace string) (err error) {
	err = K8s.ClientSet.AppsV1().DaemonSets(namespace).Delete(context.TODO(), daemonSetName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除DaemonSet失败, " + err.Error()))
		return errors.New("删除DaemonSet失败, " + err.Error())
	}

	return nil
}

// UpdateDaemonSet 更新daemonset
func (d *daemonSet) UpdateDaemonSet(namespace, content string) (err error) {
	var daemonSet = &appsv1.DaemonSet{}

	err = json.Unmarshal([]byte(content), daemonSet)
	if err != nil {
		logger.Error(errors.New("反序列化失败, " + err.Error()))
		return errors.New("反序列化失败, " + err.Error())
	}

	_, err = K8s.ClientSet.AppsV1().DaemonSets(namespace).Update(context.TODO(), daemonSet, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新DaemonSet失败, " + err.Error()))
		return errors.New("更新DaemonSet失败, " + err.Error())
	}
	return nil
}

func (d *daemonSet) toCells(std []appsv1.DaemonSet) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = daemonSetCell(std[i])
	}
	return cells
}

func (d *daemonSet) fromCells(cells []DataCell) []appsv1.DaemonSet {
	daemonSets := make([]appsv1.DaemonSet, len(cells))
	for i := range cells {
		daemonSets[i] = appsv1.DaemonSet(cells[i].(daemonSetCell))
	}

	return daemonSets
}
```

`controller/daemonset.go`

```go
package controller

import (
	"gitee.com/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var DaemonSet daemonSet

type daemonSet struct{}

// GetDaemonSets 获取daemonset列表，支持过滤、排序、分页
func (d *daemonSet) GetDaemonSets(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.DaemonSet.GetDaemonSets(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取DaemonSet列表成功",
		"data": data,
	})
}

// GetDaemonSetDetail 获取daemonset详情
func (d *daemonSet) GetDaemonSetDetail(ctx *gin.Context) {
	params := new(struct {
		DaemonSetName string `form:"daemonset_name"`
		Namespace     string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.DaemonSet.GetDaemonSetDetail(params.DaemonSetName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取DaemonSet详情成功",
		"data": data,
	})
}

// DeleteDaemonSet 删除daemonset
func (d *daemonSet) DeleteDaemonSet(ctx *gin.Context) {
	params := new(struct {
		DaemonSetName string `json:"daemonset_name"`
		Namespace     string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.DaemonSet.DeleteDaemonSet(params.DaemonSetName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除DaemonSet成功",
		"data": nil,
	})
}

// UpdateDaemonSet 更新daemonset
func (d *daemonSet) UpdateDaemonSet(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.DaemonSet.UpdateDaemonSet(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新DaemonSet成功",
		"data": nil,
	})
}

```


#### 2.5 StatefulSet

> 注意：以下功能与Pod和Deployment是实现方式一致

|功能|是否实现|
|---|-----|
|StatefulSet列表 |√|
|获取StatefulSet详情|√|
|删除StatefulSet |√|
|更新StatefulSet|√|



### 3. 集群

> 注意：以下3个资源是集群维度的，没有Namespace的概念

#### 3.1 Node 

|功能|是否实现|
|---|-----|
|Node列表 |√|
|获取Node详情|√|


