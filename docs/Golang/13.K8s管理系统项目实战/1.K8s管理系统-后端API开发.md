# K8s管理系统-后端API开发


本文档为后端服务器部分

kubernetes客户端库文档：

https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries/




[gitee仓库地址](https://gitee.com/wangzilong9570/k8s-platform)


> 提示：需要配置k8s集群和MySQL数据库



## 1. 项目背景

随着容器技术的广泛应用，kubernetes逐渐成为业内的核心技术，是容器编排技术的首选工具。

而k8s管理平台在日常的容器维护中也发挥着举足轻重的作用，但随着k8s的定制化功能越来越多，dashboard 已经无法满足日常的维护需求，且 dashboard 的源码学习成本较高，抽象程度较高，二次开发成本也就比较高。


本项目使用当下较主流的前端 vue+element plus 及后端 go+gin 框架，打造与dashboard对标的k8s管理功能，且可定制化程度高，

同学们在入门后可根据自身需求，进行灵活定制开发，且本课程除了学习相关知识点外，会带着大家逐渐掌握开发习惯与技巧，让大家在日常工作中高效、高质量的进行开发作业。




## 2. 前后端分离概述


前后端分离已成为互联网项目开发的业界标准使用方式，通过 nginx+tomcat 的方式（也可以中间加一个node.js）有效的进行解耦，

并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多段话服务（多种客户端，例如：浏览器，车载终端，安卓IOS等）打下坚实的基础。

这个步骤是系统架构学习的必经之路。



![1698135577748](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698135577748.6u24tknnt9w0.png){: .zoom}





前后分离的优势：


1. 可以实现真正的前后端解耦，前端服务器使用nginx
2. 发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象
3. 在大并发情况下，可以同时水平扩展前后端服务器。
4. 增加代码的维护性&易读性（前后端耦合在一起的代码阅读比较费劲）
5. 提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖




## 3. 功能设计


![1698135709154](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698135709154.3anyxowdo8m.webp){: .zoom}



## 4. Client-go介绍


### 4.1 简介


> ​client-go官方文档：https://github.com/kubernetes/client-go
> 
> https://www.bookstack.cn/read/huweihuang-kubernetes-notes/develop-client-go.md


client-go 是 kubernetes 官方提供的 go 语言的客户端库，go 应用使用该库可以访问 kubernetes 的 API Server，这样我们就能通过编程来对 kubernetes 资源进行增删改查操作。

除了提供丰富的 API 用于操作 kubernetes 资源，client-go 还为 controller 和 operator 提供了重要支持 client-go 的 informer 机制，可以将 controller 关注的资源变化及时带给此 controller，使 controller 能够及时响应变化。

通过 client-go 提供的客户端对象与 kubernetes 的 API Server 进行交互，而 client-go 提供了以下四种客户端对象：

1. RESTClient这是最基础的客户端对象，仅为HTTPRequest进行了封装，实现RESTFul风格API，这个对象的使用并不方便，因为很多参数都要使用者来设置，于是client-go基于RESTClient又实现了三种新的客户端对象。
2. ClientSet把Resource和Version也封装成了方法，用起来更简单直接，一个资源是一个客户端，多个资源就对应了多个客户端，所以ClientSet就是多个客户端的集合了，这样就好理解了，不过ClientSet只能访问内置资源，访问不了自定义资源
3. DynamicClient可以访问内置资源和自定义资源，个人感觉有点像java的集合操作，拿出的内容是Object类型，按实际情况自己去做强制转换，当然了也会有强制转换失败的风险
4. DiscoveryClient用于发现kubernetes的API Server支持的Group、Version、Resources等信息         //kubectl api-resources



### 4.2 环境搭建


#### 安装精简版K8S(K3S)环境

k3s的官方网址: https://k3s.io

github地址：https://github.com/k3s-io/k3s




> 前提

- [x] 安装 centos7
- [x] 安装 docker


```sh
yum install -y yum-utils device-mapper-persistent-data lvm2 vim
# 阿里源或者清华源 
sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# sudo yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo
yum list docker-ce --showduplicates | sort -r
yum install docker-ce docker-ce-cli containerd.io -y

systemctl start docker
systemctl enable docker
systemctl daemon-reload
systemctl restart docker


docker run -itd -p 80:80  nginx:1.18-alpine
```

Docker Compose v2安装

```shell
# 1、从项目发布页面下载适合你的系统的二进制文件，并将其复制到$HOME/.docker/cli-plugins，作为docker-compose来安装Compose V2

# 2、运行以下命令，下载Docker Compose的当前稳定版本
# 该命令为$HOME目录下的用户安装Compose V2。
$ mkdir -p ~/.docker/cli-plugins/
$ curl -SL https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-linux-x86_64 -o ~/.docker/cli-plugins/docker-compose
$ chmod +x ~/.docker/cli-plugins/docker-compose

#为系统中的所有用户安装Docker Compose
$ mkdir -p /usr/local/lib/docker/cli-plugins
$ curl -SL https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-linux-x86_64 -o /usr/local/lib/docker/cli-plugins/docker-compose
$ chmod +x /usr/local/lib/docker/cli-plugins/docker-compose

# 设置docker-compose命令兼容v1
$ sudo ln -s  ~/.docker/cli-plugins/docker-compose /usr/local/bin/docker-compose
# $ sudo ln -s  /usr/local/lib/docker/cli-plugins/docker-compose /usr/local/bin/docker-compose

# 3、测试安装
$ docker compose version
Docker Compose version v2.16.0
```



> 安装

k3s的三个文件：

- k3s
- k3s-airgap-images-amd64.tar
- k3s-install.sh

对于国内用户来说，访问Github超级慢，为了方便下载，可以直接使用下面百度云盘方式下载：

百度网盘下载：

https://pan.baidu.com/s/1Ca1mxigeXOB7QaFLl5xM6A   提取码：8888


```sh
chmod +x k3s
cp k3s /usr/local/bin/

docker load -i k3s-airgap-images-amd64.tar

export INSTALL_K3S_SKIP_DOWNLOAD=true

export INSTALL_K3S_EXEC="--docker --bind-address=192.168.1.147 \
  --cluster-cidr=10.128.0.0/16 --service-cidr=10.129.0.0/16  \
  --kube-apiserver-arg service-node-port-range=30000-50000 \
  --no-deploy traefik --no-deploy servicelb \
  --write-kubeconfig ~/.kube/config --write-kubeconfig-mode 666"

sh k3s-install.sh

kubectl get pod -A
NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE
kube-system   local-path-provisioner-58fb86bdfd-dgjdm   1/1     Running   0          62s
kube-system   metrics-server-6d684c7b5-mcfv4            1/1     Running   0          62s
kube-system   coredns-6c6bb68b64-x9p6c                  1/1     Running   0          62s


# kubectl补全
# centos7上
yum -y install bash-completion
# ubuntu上
sudo apt install bash-completion

 
# 在 bash 中设置当前 shell 的自动补全
source <(kubectl completion bash) 
# 在你的 bash shell 中永久地添加自动补全
echo "source <(kubectl completion bash)" >> ~/.bashrc 
source /usr/share/bash-completion/bash_completion


# 快捷键
cat >> ~/.bashrc <<EOF
alias k=kubectl
complete -o default -F __start_kubectl k
EOF

source ~/.bashrc
```


[k3s安装](https://www.yuque.com/leryn/wiki/cloud.k8s.k3s)


[离线搭建部署高可用 k3s 集群](https://jueee.github.io/2021/09/2021-09-15-%E7%A6%BB%E7%BA%BF%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8k3s%E9%9B%86%E7%BE%A4/)


[k3s 国内离线安装方法](https://imroc.cc/kubernetes/deploy/k3s/offline-installation)


[k3s 官方离线安装方法](https://docs.k3s.io/zh/installation/airgap#%E5%AE%89%E8%A3%85-k3s)


[How to Install k3s Kubernetes Cluster on Ubuntu 22.04](https://www.linuxbuzz.com/install-k3s-kubernetes-cluster-on-ubuntu/)




#### 安装golang环境

在k8s-master节点上

```sh
# 一：yum安装
yum install -y epel-release
yum install -y golang
 

# 二：手动配置 去官网下载安装包手动编译安装
mkdir ~/go && cd ~/go
wget https://dl.google.com/go/go1.17.8.linux-amd64.tar.gz
# 解压到/usr/local目录下
tar -C /usr/local -zxvf go1.17.8.linux-amd64.tar.gz

# 添加/usr/local/go/bin目录到PATH变量中
vi ~/.bashrc
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin

# 刷新配置
source ~/.bashrc
```


新建k8s-platform项目，设置goland远程环境运行

![1698201779063](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698201779063.10verb6egj5c.png){: .zoom}


![1698202043803](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698202043803.56pntwrwyyg0.png){: .zoom}

户名，填写密钥



### 4.3 代码示例


#### 创建一个测试pod

```sh
kubectl run -i --tty alpine-$RANDOM --image=alpine:latest -- sh
# -restart=Never 意味着这个 Pod 不会被重启。

# --rm 会在退出时自动删除这个 Pod
# kubectl run -it --rm test-pod --image=appropriate/curl --restart=Never -- /bin/sh

kubectl run -i --tty busybox --image=busybox -- sh

kubectl run ubuntu --image=ubuntu:20.04 --restart=Always -- /bin/bash -c "while true; do sleep 30; done;"
# kubectl run -i --tty ubuntu --image=ubuntu:20.04 --restart=Never -- bash -il
```

我们这里在default名称空间下运行3个测试pod

```sh
kubectl get pod
NAME                           READY   STATUS    RESTARTS   AGE
alpine-9594-7997b99597-z2k6m   1/1     Running   1          14m
busybox-6cd57fd969-5sxvp       1/1     Running   1          13m
ubuntu-797bd794cf-bv75b        1/1     Running   0          3s
```



main.go


```go
package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"path/filepath"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd" //可能需要挂vpn,留意版本问题
)

func main() {
	//声明kubeconfig配置文件
	var kubeconfig *string
	//获取home环境变量，拿到$HOME/.kube/config配置文件
	if home := homeDir(); home != "" {
		kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"),
			"(optional) absolute path to the kubeconfig file")
	} else {
		//否则就根据kubeconfig传到获得config的路径
		kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
	}
	flag.Parse()
	//将kubeconfig文件转换成rest.config类型文件
	//*kubeconfig其实就是kubeconfig文件的默认位置地址，直接填入地址字符串也可
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		panic(err.Error())
	}
	//根据rest.config类型的对象，new一个clientset出来
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err.Error())
	}
	//通过client-go sdk获取pods列表，命名空间是default
	pods, err := clientset.CoreV1().Pods("default").List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		panic(err.Error())
	}
	//打印pod测试
	for _, pod := range pods.Items {
		fmt.Println(pod.Name, pod.Namespace)
	}
}

func homeDir() string {
	if h := os.Getenv("HOME"); h != "" {//linux
		return h
	}
	return os.Getenv("USERPROFILE") //windows
}

```

运行结果

```sh
alpine-9594-7997b99597-z2k6m default
busybox-6cd57fd969-5sxvp default
ubuntu-797bd794cf-bv75b default
```

获取到了pod名和命名空间



### 4.4 常用方法

```go
//获取pod列表 
podList, err := K8s.ClientSet.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{}) 

//获取pod详情 
pod, err = K8s.ClientSet.CoreV1().Pods(namespace).Get(context.TODO(), podName, metav1.GetOptions{}) 

//删除pod 
err = K8s.ClientSet.CoreV1().Pods(namespace).Delete(context.TODO(), podName, metav1.DeleteOptions{}) 

//更新pod（完整yaml） 
pod, err = K8s.ClientSet.CoreV1().Pods(namespace).Update(context.TODO(), pod, metav1.UpdateOptions{}) 

//获取deployment副本数 
scale, err := K8s.ClientSet.AppsV1().Deployments(namespace).GetScale(context.TODO(), deploymentName, metav1.GetOptions{}) 

//创建deployment 
deployment, err = K8s.ClientSet.AppsV1().Deployments(data.Namespace).Create(context.TODO(), deployment, metav1.CreateOptions{}) 

//更新deployment（部分yaml） 
deployment, err = K8s.ClientSet.AppsV1().Deployments(namespace).Patch(context.TODO(), deploymentName, "application/strategic-merge-patch+json", patchByte, metav1.PatchOptions{})
```

## 5. 项目目录结构


![1698204465060](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698204465060.6qcpqwmfgyo0.png){: .zoom}


- config：定义全局配置，如监听地址、管理员账号等。
- controller：controller层，定义路由规则，及接口入参和响应。
- service：服务层，处理接口的业务逻辑。
- dao：数据库操作，包含数据库的增删改查。
- model：定义数据库的表的字段。
- db: 用于初始化数据库连接以及配置。
- middle：中间件层，添加全局的逻辑处理，如跨域、jwt验证等。
- utils：工具目录，定义常用工具，如token解析，文件操作等。
- go.mod：定义项目的依赖包以及版本。
- main.go：项目的主入口 main函数。



## 6. 框架搭建


### 1. 创建go项目
```sh
/d/coder/go/src/gitee.com/k8s-platform tree
+--- config
+--- controller
+--- dao
+--- db
+--- go.mod
+--- main.go
+--- middle
+--- model
+--- service
+--- utils
```



### 2. 初始化Gin工程

（1）创建项目目录结构


（2）创建config/config.go文件，配置启动监听端口

```go
package config

const (
	// ListenAddr 配置启动监听端口
	ListenAddr = "0.0.0.0:9090"
)
```

（3）创建controller/router.go文件，初始化api路由规则，编写测试api接口

```go
package controller

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

// Router 实例化router结构体，可使用该对象点出首字母大写的方法（包外调用）
var Router router

// 创建router结构体
type router struct{}

// InitApiRouter 初始化路由规则，创建测试api接口
func (r *router) InitApiRouter(router *gin.Engine) {
	router.GET("/testapi", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{
			"msg":  "testapi success!",
			"data": nil,
		})
	})
}
```


（4）main.go文件中，启动gin程序


```go
package main

import (
	"gitee.com/k8s-platform/config"
	"gitee.com/k8s-platform/controller"

	"github.com/gin-gonic/gin"
)

func main() {
	//初始化gin对象
	r := gin.Default()
	//初始化路由规则
	controller.Router.InitApiRouter(r)
	//gin程序启动
	r.Run(config.ListenAddr)
}
```

```sh
curl http://127.0.0.1:9090/testapi
{"data":null,"msg":"testapi success!"}    
```


### 3. 初始化K8s Client

（1）在config.go中添加kubeconfig文件路径

```go
package config

const (
// 配置启动监听端口
ListenAddr = "0.0.0.0:9090"

// Linux上配置
// Kubeconfig = "/root/.kube/config"
// Windows上配置
Kubeconfig = "C:\\Users/18793/.kube/config"
)
```



（2）创建service/init.go文件，初始化k8s client

```go
package service

import (
"gitee.com/k8s-platform/config"

"github.com/wonderivan/logger"
"k8s.io/client-go/kubernetes"
"k8s.io/client-go/tools/clientcmd"
)

type k8s struct {
ClientSet *kubernetes.Clientset
}

var K8s k8s

func (k *k8s) Init() {
conf, err := clientcmd.BuildConfigFromFlags("", config.Kubeconfig)
if err != nil {
  panic("创建k8s配置失败，" + err.Error())
}
clientSet, err := kubernetes.NewForConfig(conf)
if err != nil {
  panic("创建K8s clientSet失败，" + err.Error())
} else {
  logger.Info("创建k8s clientSet成功")
}
k.ClientSet = clientSet
}
```


（3）main.go中添加k8s client启动项

```go
package main

import (
"gitee.com/k8s-platform/config"
"gitee.com/k8s-platform/controller"
"gitee.com/k8s-platform/service"

"github.com/gin-gonic/gin"
)

func main() {
//初始化gin对象
r := gin.Default()
//初始化k8s client
service.K8s.Init()
//初始化路由规则
controller.Router.InitApiRouter(r)
//gin程序启动
r.Run(config.ListenAddr)
}
```


### 4. 测试API接口


```sh
curl http://127.0.0.1:9090/testapi
{"data":null,"msg":"testapi success!"}    
```

## 7. API开发






### 1. 开发&响应流程


![1700452058796](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700452058796.77vrr972us00.png){: .zoom}



1. Model层：实体层 >> 表数据与类的映射关系，这里的类是strcut 
2. Dao层：持久层/数据访问层 >> 主要与数据库交互，增删改查
3. Service层：业务层 >> 控制业务逻辑，主要处理业务模块的功能逻辑
4. Controller层：控制层 >> 接收请求参数，调用不同的Service层代码来控制业务流程


![1700458875460](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700458875460.3ok9s1egqvk0.webp){: .zoom}


### 2. 工作负载

#### 2.1 数组的排序、过滤、分页

`service/dataselector.go`


(1)定义数据结构


```go
package service

import (
	corev1 "k8s.io/api/core/v1"
	"sort"
	"strings"
	"time"
)

// dataSelector 用于封装排序、过滤、分页的数据类型
type dataSelector struct {
	GenericDataList []DataCell
	dataSelectQuery *DataSelectQuery
}

// DataCell 接口，用于各种资源list的类型转换，转换后可以使用dataSelector的自定义排序方法
type DataCell interface {
	GetCreation() time.Time
	GetName() string
}

// DataSelectQuery 定义过滤和分页的属性，过滤：Name，分页：Limit和Page
// Limit是单页的数据条数
// Page是第几页
type DataSelectQuery struct {
	FilterQuery   *FilterQuery
	PaginateQuery *PaginateQuery
}
type FilterQuery struct {
	Name string
}
type PaginateQuery struct {
	Limit int
	Page  int
}
```

(2)排序

自定义类型排序参考文档：https://segmentfault.com/a/1190000008062661

```go
//实现自定义结构的排序，需要重写Len、Swap、Less方法
//Len方法用于获取数组长度
func(d *dataSelector)Len()int{
	return len(d.GenericDataList)
}
//Swap方法用于数组中的元素在比较大小后的位置交换，可定义升序或降序
func(d *dataSelector)Swap(i,j int){
	d.GenericDataList[i],d.GenericDataList[j]=d.GenericDataList[j],d.GenericDataList[i]
}
//Less方法用于定义数组中元素排序的“大小”的比较方式
func(d *dataSelector)Less(i,j int)bool{
	a:=d.GenericDataList[i].GetCreation()
	b:=d.GenericDataList[j].GetCreation()
	return b.Before(a)
}
//重写以上3个方法使用sort.Sort进行排序
func(d *dataSelector)Sort() *dataSelector{
	sort.Sort(d)
	return d
}
```

(3)过滤

```go
//Filter方法用于过滤元素，比较元素的Name属性，若包含，再返回
func (d *dataSelector) Filter() *dataSelector {
	//若Name的传参为空，则返回所有元素
	if d.dataSelectQuery.FilterQuery.Name == "" {
		return d
	}
	//若Name的传参不为空，则返回元素名中包含Name的所有元素
	filteredList := []DataCell{}
	for _, value := range d.GenericDataList {
		matches := true
		objName := value.GetName()
		//判断字符串s中是否包含子串str
		if !strings.Contains(objName, d.dataSelectQuery.FilterQuery.Name) {
			matches = false
			continue
		}
		if matches {
			filteredList = append(filteredList, value)
		}
	}
	d.GenericDataList = filteredList
	return d
}
```


(4)分页

```go
//Paginate方法用于数组分页，根据Limit和Page的传参，返回数据
func (d *dataSelector) Paginate() *dataSelector {
	limit := d.dataSelectQuery.PaginateQuery.Limit
	page := d.dataSelectQuery.PaginateQuery.Page
	//验证参数合法，若参数不合法，则返回所有数据
	if limit <= 0 || page <= 0 {
		return d
	}
    //定义取数范围
	//举例：25个元素的数组，limit是10，page是3，startIndex是20，endIndex是30（实际上endIndex是25）
	startIndex := limit * (page - 1)
	endIndex := limit * page
	//处理最后一页，这时候就把endIndex由30改为25了
	if len(d.GenericDataList) < endIndex {
		endIndex = len(d.GenericDataList)
	}
	d.GenericDataList = d.GenericDataList[startIndex:endIndex]
	return d
}
```

(5)定义podCell类型，实现DataCell接口，用于类型转换

```go
//定义podCell类型，实现GetCreation和getName方法后，可进行类型转换
type podCell corev1.Pod

func (p podCell) GetCreation() time.Time {
	return p.CreationTimestamp.Time
}
func (p podCell) GetName() string {
	return p.Name
}
```

(6)定义DataCell到Pod类型转换的方法

断言：判断一个变量是否属于某一种类型，前提是这一类型实现了这一变量类型接口

`service/pod.go`

```go
package service

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"gitee.com/k8s-platform/config"
	"github.com/wonderivan/logger"
	"io"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Pod 定义pod类型和Pod对象，用于包外的调用(包是指service目录)，例如Controller
var Pod pod

type pod struct{}

// toCells方法用于将pod类型数组，转换成DataCell类型数组
func (p *pod) toCells(std []corev1.Pod) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = podCell(std[i])
	}
	return cells
}

// fromCells方法用于将DataCell类型数组，转换成pod类型数组
func (p *pod) fromCells(cells []DataCell) []corev1.Pod {
	pods := make([]corev1.Pod, len(cells))
	for i := range cells {
		//cells[i].(podCell)就使用到了断言，断言后转换成了podCell类型，然后又转换成了Pod类型
		pods[i] = corev1.Pod(cells[i].(podCell))
	}
	return pods
}
```



#### 2.2 Pod

开发 pod 功能

|功能|是否实现|
|---|-----|
|获取所有pod信息 |√|
|获取pod的详细信息|√|
|删除pod|√|
|更新pod|√|
|获取pod容器名称|√|
|获取pod中容器日志|√|
|获取每个namespace的pod数量|√|




##### service/pod.go


(1)定义数据类型

看情况创建结构体

```go
//定义列表的返回内容，Item是pod元素列表，Total为pod元素数量
type PodsResp struct{
	Items []corev1.Pod `json:"items"`
	Total int `json:"total"`
}
//定义PodsNp类型，用于返回namespace中pod的数量
type PodsNp struct{
	Namespace string `json:"namespace"`
	PodNum int `json:"pod_num"`
}
```

(2)获取pod列表


```go
// GetPods 获取pod列表，支持过滤、排序、分页
func (p *pod) GetPods(filterName, namespace string, limit, page int) (podsResp *PodsResp, err error) {
	//获取podList类型的pod列表
	//context.TODO() 用于声明一个空的context上下文，用于List方法内设置这个请求的超时(3)，这里的常用用法
	//metav1.ListOptions{}用于过滤List数据，如使用label，field等
	//kubectl get services --all-namespace --field-seletor metadata.namespace != default
	podList, err := K8s.ClientSet.CoreV1().Pods(namespace).List(context.TODO(),
		metav1.ListOptions{})
	if err != nil {
		//logger用于打印日志
		//return用于返回response内容
		logger.Error(errors.New("获取Pod列表失败，" + err.Error()))
		return nil, errors.New("获取Pod列表失败，" + err.Error())
	}
	//实例化dataSelector对象
	selectableData := &dataSelector{
		GenericDataList: p.toCells(podList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}
	//先过滤
	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	//再排序和分页
	data := filtered.Sort().Paginate()
	//将[]DataCell类型的pod列表转为v1.pod列表
	pods := p.fromCells(data.GenericDataList)
	return &PodsResp{
		Items: pods,
		Total: total,
	}, nil
}
```

(3)获取Pod详情

```go
// GetPodDetail 获取pod详情
func (p *pod) GetPodDetail(podName, namespace string) (pod *corev1.Pod, err error) {
	pod, err = K8s.ClientSet.CoreV1().Pods(namespace).
		Get(context.TODO(), podName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Pod详情失败，" + err.Error()))
		return nil, errors.New("获取Pod详情失败，" + err.Error())
	}
	return pod, nil
}
```

(4)删除Pod

```go
// DeletePod 删除pod
func (p *pod) DeletePod(podName, namespace string) (err error) {
	err = K8s.ClientSet.CoreV1().Pods(namespace).
		Delete(context.TODO(), podName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除pod失败，" + err.Error()))
		return errors.New("删除pod失败，" + err.Error())
	}
	return nil
}
```


(5)更新pod

```go
// UpdatePod 更新pod
// content参数是请求中传入的pod对象的json数据
func (p *pod) UpdatePod(namespace, content string) (err error) {
	var pod = &corev1.Pod{}
	//反序列化为pod对象
	err = json.Unmarshal([]byte(content), pod)
	if err != nil {
		logger.Error(errors.New("反序列化失败, " + err.Error()))
		return errors.New("反序列化失败, " + err.Error())
	}
	//更新pod
	_, err = K8s.ClientSet.CoreV1().Pods(namespace).
		Update(context.TODO(), pod, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新Pod失败, " + err.Error()))
		return errors.New("更新Pod失败, " + err.Error())
	}
	return nil
}
```

(6)获取Pod中的容器名


```go
// GetPodContainer 获取Pod中的容器名
func (p *pod) GetPodContainer(podName, namespace string) (containers []string, err error) {
	//获取pod详情
	pod, err := p.GetPodDetail(podName, namespace)
	if err != nil {
		return nil, err
	}
	//从pod对象中拿到容器名
	for _, container := range pod.Spec.Containers {
		containers = append(containers, container.Name)
	}
	return containers, nil
}
```


(7)获取容器日志

```go
// GetPodLog 获取pod内容器日志
func (p *pod) GetPodLog(containerName, podName, namespace string) (log string, err error) {
	//设置日志的配置，容器名、tail的行数
	lineLimit := int64(config.PodLogTailLine)
	option := &corev1.PodLogOptions{
		Container: containerName,
		TailLines: &lineLimit,
	}
	//获取request实例
	req := K8s.ClientSet.CoreV1().Pods(namespace).GetLogs(podName, option)
	//发起request请求，返回一个io.ReadCloser类型（等同于response.boby)
	podLogs, err := req.Stream(context.TODO())
	if err != nil {
		logger.Error(errors.New("获取PodLog失败，" + err.Error()))
		return "", errors.New("获取PodLog失败，" + err.Error())
	}
	defer podLogs.Close()
	//将response body写入到缓冲区，目的是为了转成string返回
	buf := new(bytes.Buffer)
	_, err = io.Copy(buf, podLogs)
	if err != nil {
		logger.Error(errors.New("复制PodList失败，" + err.Error()))
		return "", errors.New("复制PodList失败，" + err.Error())
	}
	return buf.String(), nil
}
```

(8)获取每个namespace的pod数量

```go
// GetPodNumPerNp 获取每个namespace的pod数量
func (p *pod) GetPodNumPerNp() (podsNps []*PodsNp, err error) {
	//获取namespace列表
	namespaceList, err := K8s.ClientSet.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	for _, namespace := range namespaceList.Items {
		//获取pod列表
		podList, err := K8s.ClientSet.CoreV1().Pods(namespace.Name).
			List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			return nil, err
		}
		//组装数据
		PodsNp := &PodsNp{
			Namespace: namespace.Name,
			PodNum:    len(podList.Items),
		}
		//添加到podsNps数组中
		podsNps = append(podsNps, PodsNp)
	}
	return podsNps, nil
}

```


##### controller/pod.go


(9)编写Controller层的pod代码


```go
package controller

import (
	"gitee.com/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var Pod pod

type pod struct{}

//Controller中的方法入参是gin.Context，用于从上下文中获取请求参数及定义响应内容
//流程：绑定参数->调用service代码->根据调用结果响应具体内容

// GetPods 获取pod列表，支持过滤、排序、分页
func (p *pod) GetPods(ctx *gin.Context) {
	//匿名结构体，用于声明入参，get请求为form格式，其他请求为json格式
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	//绑定参数，给匿名结构体中的属性赋值，值是入参
	//form格式(Get)使用ctx.Bind方法，json格式使用ctx.ShouldBindJSON方法
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		//ctx.JSON方法用于返回响应内容，入参是状态码和响应内容，响应内容放入gin.H的map中
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	//service中的的方法通过 包名.结构体变量名.方法名 使用，serivce.Pod.GetPods()
	data, err := service.Pod.GetPods(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pod列表成功",
		"data": data,
	})
}

// GetPodDetail 获取pod详情
func (p *pod) GetPodDetail(ctx *gin.Context) {
	params := new(struct {
		PodName   string `form:"pod_name"`
		Namespace string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Pod.GetPodDetail(params.PodName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pod详情成功",
		"data": data,
	})
}

// DeletePod 删除Pod
func (p *pod) DeletePod(ctx *gin.Context) {
	params := new(struct {
		PodName   string `json:"pod_name"`
		Namespace string `json:"namespace"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Pod.DeletePod(params.PodName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Pod成功",
		"data": nil,
	})
}

// UpdatePod 更新pod
func (p *pod) UpdatePod(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Pod.UpdatePod(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新Pod成功",
		"data": nil,
	})
}

// GetPodContainer 获取pod容量
func (p *pod) GetPodContainer(ctx *gin.Context) {
	params := new(struct {
		PodName   string `form:"pod_name"`
		Namespace string `form:"namespace"`
	})
	//GET请求，绑定参数方法改为ctx.Bind
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Pod.GetPodContainer(params.PodName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pod容器成功",
		"data": data,
	})
}

// GetPodLog 获取pod中容器日志
func (p *pod) GetPodLog(ctx *gin.Context) {
	params := new(struct {
		ContainerName string `form:"container_name"`
		PodName       string `form:"pod_name"`
		Namespace     string `form:"namespace"`
	})
	//GET请求，绑定参数方法改为ctx.Bind
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Pod.GetPodLog(params.ContainerName, params.PodName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pod中容器日志成功",
		"data": data,
	})
}

// GetPodNumPerNp 获取每个namespace的pod数量
func (p *pod) GetPodNumPerNp(ctx *gin.Context) {
	data, err := service.Pod.GetPodNumPerNp()
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取每个namespace的pod数量成功",
		"data": data,
	})
}

```

##### controller/router.go


(10)定义路由规则


```go
package controller

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

// Router 实例化router结构体，可使用该对象点出首字母大写的方法（包外调用）
var Router router

// 创建router结构体
type router struct{}

// InitApiRouter 初始化路由规则
func (r *router) InitApiRouter(router *gin.Engine) {
	//创建测试api接口
	router.GET("/testapi", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{
			"msg":  "testapi success!",
			"data": nil,
		})
	}).
		// pod操作
		GET("/api/k8s/pods", Pod.GetPods).
		GET("/api/k8s/pod/detail", Pod.GetPodDetail).
		DELETE("/api/k8s/pod/del", Pod.DeletePod).
		PUT("/api/k8s/pod/update", Pod.UpdatePod).
		GET("/api/k8s/pod/container", Pod.GetPodContainer).
		GET("/api/k8s/pod/log", Pod.GetPodLog).
		GET("/api/k8s/pod/numnp", Pod.GetPodNumPerNp)
}
```

(11)做接口测试


- 获取所有pod信息

![1700558387506](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700558387506.5wwy3ial69c0.webp){: .zoom}



- 获取pod详细内容

![1700558473846](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700558473846.3h9rliiwuhs0.webp){: .zoom}



- 删除pod

![1700558519334](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700558519334.723iphdn21o0.webp){: .zoom}



#### 2.3 Deployment


##### service/dataselector.go


```go
// 实现 Deployment的 DataCell接口
type deploymentCell appsv1.Deployment //appsv1 "k8s.io/api/apps/v1"

func (d deploymentCell) GetCreation() time.Time {
	return d.CreationTimestamp.Time
}
func (d deploymentCell) GetName() string {
	return d.Name
}
```


##### service/deployment.go

开发deployment功能


|功能|是否实现|
|---|-----|
|deployment列表 |√|
|获取Deployment详情|√|
|修改Deployment副本数|√|
|创建Deployment|√|
|删除Deployment|√|
|重启Deployment|√|
|更新Deployment|√|
|获取每个namespace的Deployment数量|√|



```go
package service

import (
	"context"
	"encoding/json"
	"errors"
	"strconv"
	"time"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/util/intstr"

	"github.com/wonderivan/logger"
	appsv1 "k8s.io/api/apps/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var Deployment deployment

type deployment struct{}

// DeploymentsResp 定义列表的返回内容，Items是deployment元素列表，Total为deployment元素数量
type DeploymentsResp struct {
	Items []appsv1.Deployment `json:"items"`
	Total int                 `json:"total"`
}

// DeployCreate 结构体，用于创建deployment需要的参数属性的定义
type DeployCreate struct {
	Name          string            `json:"name"`
	Namespace     string            `json:"namespace"`
	Replicas      int32             `json:"replicas"`
	Image         string            `json:"image"`
	Label         map[string]string `json:"label"`
	Cpu           string            `json:"cpu"`
	Memory        string            `json:"memory"`
	ContainerPort int32             `json:"container_port"`
	HealthCheck   bool              `json:"health_check"`
	HealthPath    string            `json:"health_path"`
}

// DeploysNp 类型，用于返回namespace中deployment的数量
type DeploysNp struct {
	Namespace string `json:"namespace"`
	DeployNum int    `json:"deployment_num"`
}

func (d *deployment) toCells(std []appsv1.Deployment) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = deploymentCell(std[i])
	}
	return cells
}
func (d *deployment) fromCells(cells []DataCell) []appsv1.Deployment {
	deployments := make([]appsv1.Deployment, len(cells))
	for i := range cells {
		deployments[i] = appsv1.Deployment(cells[i].(deploymentCell))
	}
	return deployments
}

// GetDeployments 获取deployment列表，支持过滤、排序、分页
func (d *deployment) GetDeployments(filterName, namespace string, limit, page int) (deploymentsResp *DeploymentsResp, err error) {
	//获取deploymentList类型的deployment列表
	deploymentList, err := K8s.ClientSet.AppsV1().Deployments(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取Deployment列表失败，" + err.Error()))
		return nil, errors.New("获取Deployment列表失败，" + err.Error())
	}
	//将deploymentList中的deployment列表(Items),放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: d.toCells(deploymentList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}
	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()
	//将[]DataCell类型的deployment列表转为appsv1.deployment列表
	deployments := d.fromCells(data.GenericDataList)
	return &DeploymentsResp{
		Items: deployments,
		Total: total,
	}, nil
}

// GetDeploymentDetail 获取deployment详情
func (d *deployment) GetDeploymentDetail(deploymentName, namespace string) (deployment *appsv1.Deployment, err error) {
	deployment, err = K8s.ClientSet.AppsV1().Deployments(namespace).Get(context.TODO(), deploymentName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Deployment详情失败，" + err.Error()))
		return nil, errors.New("获取Deployment详情失败，" + err.Error())
	}
	return deployment, nil
}

// ScaleDeployment 设置deployment副本数
func (d *deployment) ScaleDeployment(deploymentName, namespace string, scaleNum int) (replica int32, err error) {
	//获取autoscalingv1.Scale类型的对象，能点出当前的副本数
	scale, err := K8s.ClientSet.AppsV1().Deployments(namespace).GetScale(context.TODO(), deploymentName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Deployment副本数信息失败，" + err.Error()))
		return 0, errors.New("获取Deployment副本数信息失败，" + err.Error())
	}
	//修改副本数
	scale.Spec.Replicas = int32(scaleNum)
	//更新副本数，传入scale对象
	newScale, err := K8s.ClientSet.AppsV1().Deployments(namespace).UpdateScale(context.TODO(), deploymentName, scale, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新Deployment副本数信息失败，" + err.Error()))
		return 0, errors.New("更新Deployment副本数信息失败，" + err.Error())
	}
	return newScale.Spec.Replicas, nil
}

// CreateDeployment 创建deployment，接收DeployCreate对象
func (d *deployment) CreateDeployment(data *DeployCreate) (err error) {
	//将data中的数据组装成appsv1.Deployment对象
	deployment := &appsv1.Deployment{
		//ObjectMeta中定义资源名、命名空间以及标签
		ObjectMeta: metav1.ObjectMeta{
			Name:      data.Name,
			Namespace: data.Namespace,
			Labels:    data.Label,
		},
		//Spec中定义副本数、选择器、以及pod属性
		Spec: appsv1.DeploymentSpec{
			Replicas: &data.Replicas,
			Selector: &metav1.LabelSelector{
				MatchLabels: data.Label,
			},
			Template: corev1.PodTemplateSpec{
				//定义pod名和标签
				ObjectMeta: metav1.ObjectMeta{
					Name:   data.Name,
					Labels: data.Label,
				},
				//定义容器名、镜像和端口
				Spec: corev1.PodSpec{
					Containers: []corev1.Container{
						{
							Name:  data.Name,
							Image: data.Image,
							Ports: []corev1.ContainerPort{
								{
									Name:          "http",
									Protocol:      corev1.ProtocolTCP,
									ContainerPort: data.ContainerPort,
								},
							},
						},
					},
				},
			},
		},
		//Status定义资源的运行状态，这里由于是新建，传入空的appsv1.DeploymentStatus{}对象即可
		Status: appsv1.DeploymentStatus{},
	}
	//判断是否打开健康检查功能，若打开，则定义ReadinessProbe和LivenessProbe
	if data.HealthCheck {
		//设置第一个容器的ReadinessProbe,因为我们pod中只有一个容器，所以直接使用index 0即可
		//若pod中有多个容器，则这里需要使用for循环去定义了
		deployment.Spec.Template.Spec.Containers[0].ReadinessProbe = &corev1.Probe{
			ProbeHandler: corev1.ProbeHandler{
				HTTPGet: &corev1.HTTPGetAction{
					Path: data.HealthPath,
					//intstr.IntOrString的作用是端口可以定义为整型，也可以定义为字符串
					//Type=0则表示该结构体实例内的数据为整型，转json时只使用IntVal的数据
					//Type=1则表示该结构体实例内的数据为字符串，转json时只使用StrVal的数据
					Port: intstr.IntOrString{
						Type:   0,
						IntVal: data.ContainerPort,
					},
				},
			},
			//初始化等待时间
			InitialDelaySeconds: 5,
			//超时时间
			TimeoutSeconds: 5,
			//执行间隔
			PeriodSeconds: 5,
		}
		deployment.Spec.Template.Spec.Containers[0].LivenessProbe = &corev1.Probe{
			ProbeHandler: corev1.ProbeHandler{
				HTTPGet: &corev1.HTTPGetAction{
					Path: data.HealthPath,
					Port: intstr.IntOrString{
						Type:   0,
						IntVal: data.ContainerPort,
					},
				},
			},
			InitialDelaySeconds: 15,
			TimeoutSeconds:      5,
			PeriodSeconds:       5,
		}
		//定义容器的limit和request资源
		deployment.Spec.Template.Spec.Containers[0].Resources.Limits = map[corev1.ResourceName]resource.Quantity{
			corev1.ResourceCPU:    resource.MustParse(data.Cpu),
			corev1.ResourceMemory: resource.MustParse(data.Memory),
		}
		deployment.Spec.Template.Spec.Containers[0].Resources.Requests = map[corev1.ResourceName]resource.Quantity{
			corev1.ResourceCPU:    resource.MustParse(data.Cpu),
			corev1.ResourceMemory: resource.MustParse(data.Memory),
		}
	}
	//调用sdk创建deployment
	_, err = K8s.ClientSet.AppsV1().Deployments(data.Namespace).Create(context.TODO(), deployment, metav1.CreateOptions{})
	if err != nil {
		logger.Error(errors.New("创建Deployment失败，" + err.Error()))
		return errors.New("创建Deployment失败," + err.Error())
	}
	return nil
}

// DeleteDeployment 删除deployment
func (d *deployment) DeleteDeployment(deploymentName, namespace string) (err error) {
	err = K8s.ClientSet.AppsV1().Deployments(namespace).Delete(context.TODO(), deploymentName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除Deployment失败，" + err.Error()))
		return errors.New("删除Deployment失败，" + err.Error())
	}
	return nil
}

// RestartDeployment 重启deployment
func (d *deployment) RestartDeployment(deploymentName, namespace, imageName, image string) (err error) {
	//此功能等同于以下kubectl命令
	//kubectl deployment ${service} -p \
	//'{"spec":{"template":{"spec":{"containers":[{"name":"'"${service}"'","env":
	//[{"name":"RESTART_","value":"'$(date +%s)'"}]}]}}}}'

	//使用patchData Map组装数据
	patchData := map[string]interface{}{
		"metadata": map[string]interface{}{
			"name":      deploymentName,
			"namespace": namespace,
		},
		"spec": map[string]interface{}{
			"template": map[string]interface{}{
				"spec": map[string]interface{}{
					"containers": []map[string]interface{}{
						{
							"name":  imageName,
							"image": image,
							"env": []map[string]string{{
								"name":  "RESTART_",
								"value": strconv.FormatInt(time.Now().Unix(), 10),
							}},
						},
					},
				},
			},
		},
	}
	//序列化为字节，因为patch方法只接收字节类型参数
	patchByte, err := json.Marshal(patchData)
	if err != nil {
		logger.Error(errors.New("json序列化失败，" + err.Error()))
		return errors.New("json序列化失败，" + err.Error())
	}
	//调用patch方法更新deployment
	_, err = K8s.ClientSet.AppsV1().Deployments(namespace).Patch(context.TODO(), deploymentName, "application/strategic-merge-patch+json", patchByte, metav1.PatchOptions{})
	if err != nil {
		logger.Error(errors.New("重启Deployment失败，" + err.Error()))
		return errors.New("重启Deployment失败，" + err.Error())
	}
	return nil
}

// UpdateDeployment 更新deployment
func (d *deployment) UpdateDeployment(namespace, content string) (err error) {
	var deploy = &appsv1.Deployment{}

	err = json.Unmarshal([]byte(content), deploy)
	if err != nil {
		logger.Error(errors.New("反序列化失败，" + err.Error()))
		return errors.New("反序列化失败，" + err.Error())
	}

	_, err = K8s.ClientSet.AppsV1().Deployments(namespace).Update(context.TODO(), deploy, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新Deployment失败，" + err.Error()))
		return errors.New("更新Deployment失败，" + err.Error())
	}
	return nil
}

// GetDeployNumPerNp 获取每个namespace的deployment数量
func (d *deployment) GetDeployNumPerNp() (deploysNps []*DeploysNp, err error) {
	namespaceList, err := K8s.ClientSet.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	for _, namespace := range namespaceList.Items {
		deploymentList, err := K8s.ClientSet.AppsV1().Deployments(namespace.Name).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			return nil, err
		}
		DeploysNp := &DeploysNp{
			Namespace: namespace.Name,
			DeployNum: len(deploymentList.Items),
		}
		deploysNps = append(deploysNps, DeploysNp)
	}
	return deploysNps, nil
}

```




##### controller/deployment.go

```go
package controller

import (
	"fmt"
	"gitee.com/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

type deployment struct{}

var Deployment deployment

// GetDeployments 获取deployment列表，支持过滤、排序、分页
func (d *deployment) GetDeployments(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Deployment.GetDeployments(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Deployment列表成功",
		"data": data,
	})
}

// GetDeploymentDetail 获取deployment详情
func (d *deployment) GetDeploymentDetail(ctx *gin.Context) {
	params := new(struct {
		DeploymentName string `form:"deployment_name"`
		Namespace      string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Deployment.GetDeploymentDetail(params.DeploymentName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Deployment详情成功",
		"data": data,
	})
}

// CreateDeployment 创建deployment
func (d *deployment) CreateDeployment(ctx *gin.Context) {
	var (
		deployCreate = new(service.DeployCreate)
		err          error
	)
	if err = ctx.ShouldBindJSON(deployCreate); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	if err = service.Deployment.CreateDeployment(deployCreate); err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "创建Deployment成功",
		"data": nil,
	})
}

// ScaleDeployment 设置deployment副本数
func (d *deployment) ScaleDeployment(ctx *gin.Context) {
	params := new(struct {
		DeploymentName string `json:"deployment_name"`
		Namespace      string `json:"namespace"`
		ScaleNum       int    `json:"scale_num"`
	})
	//PUT请求，绑定参数方法为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Deployment.ScaleDeployment(params.DeploymentName, params.Namespace, params.ScaleNum)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "设置Deployment副本数成功",
		"data": fmt.Sprintf("最新副本数：%d", data),
	})
}

// DeleteDeployment 删除deployment
func (d *deployment) DeleteDeployment(ctx *gin.Context) {
	params := new(struct {
		DeploymentName string `json:"deployment_name"`
		Namespace      string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Deployment.DeleteDeployment(params.DeploymentName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Deployment成功",
		"data": nil,
	})
}

// RestartDeployment 重启deployment
func (d *deployment) RestartDeployment(ctx *gin.Context) {
	params := new(struct {
		DeploymentName string `json:"deployment_name"`
		Namespace      string `json:"namespace"`
		ImageName      string `json:"image_name"`
		Image          string `json:"image"`
	})
	//PUT请求，绑定参数方法为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Deployment.RestartDeployment(params.DeploymentName, params.Namespace, params.ImageName, params.Image)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "重启Deployment成功",
		"data": nil,
	})
}

// UpdateDeployment 更新deployment
func (d *deployment) UpdateDeployment(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Deployment.UpdateDeployment(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新Deployment成功",
		"data": nil,
	})
}

// GetDeployNumPerNp 获取每个namespace的pod数量
func (d *deployment) GetDeployNumPerNp(ctx *gin.Context) {
	data, err := service.Deployment.GetDeployNumPerNp()
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取每个namespace的deployment数量成功",
		"data": data,
	})
}
```



`controller/router.go`

定义路由规则

```go
package controller

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

// Router 实例化router结构体，可使用该对象点出首字母大写的方法（包外调用）
var Router router

// 创建router结构体
type router struct{}

// InitApiRouter 初始化路由规则
func (r *router) InitApiRouter(router *gin.Engine) {
	// 创建测试api接口
	router.GET("/testapi", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{
			"msg":  "testapi success!",
			"data": nil,
		})
	}).
		// pod操作
		GET("/api/k8s/pods", Pod.GetPods).
		GET("/api/k8s/pod/detail", Pod.GetPodDetail).
		DELETE("/api/k8s/pod/del", Pod.DeletePod).
		PUT("/api/k8s/pod/update", Pod.UpdatePod).
		GET("/api/k8s/pod/container", Pod.GetPodContainer).
		GET("/api/k8s/pod/log", Pod.GetPodLog).
		GET("/api/k8s/pod/numnp", Pod.GetPodNumPerNp).
		// deployment操作
		GET("/api/k8s/deployments", Deployment.GetDeployments).
		GET("/api/k8s/deployment/detail", Deployment.GetDeploymentDetail).
		PUT("/api/k8s/deployment/scale", Deployment.ScaleDeployment).
		DELETE("/api/k8s/deployment/del", Deployment.DeleteDeployment).
		PUT("/api/k8s/deployment/restart", Deployment.RestartDeployment).
		PUT("/api/k8s/deployment/update", Deployment.UpdateDeployment).
		GET("/api/k8s/deployment/numnp", Deployment.GetDeployNumPerNp).
		POST("/api/k8s/deployment/create", Deployment.CreateDeployment)
}
```



#### 2.4 DaemonSet

> 注意：以下功能与Pod和Deployment是实现方式一致


|功能|是否实现|
|---|-----|
|DaemonSet列表 |√|
|获取DaemonSet详情|√|
|删除DaemonSet |√|
|更新DaemonSet |√|



##### service/dataselector.go

```go
// 实现 DaemonSet 的 DataCell接口
type daemonSetCell appsv1.DaemonSet

func (d daemonSetCell) GetCreation() time.Time {
	return d.CreationTimestamp.Time
}

func (d daemonSetCell) GetName() string {
	return d.Name
}
```


##### service/daemonset.go

```go
package service

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/wonderivan/logger"
	appsv1 "k8s.io/api/apps/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var DaemonSet daemonSet

type daemonSet struct{}

type DaemonSetsResp struct {
	Items []appsv1.DaemonSet `json:"items"`
	Total int                `json:"total"`
}

// GetDaemonSets 获取daemonset列表，支持过滤、排序、分页
func (d *daemonSet) GetDaemonSets(filterName, namespace string, limit, page int) (daemonSetsResp *DaemonSetsResp, err error) {
	//获取daemonSetList类型的daemonSet列表
	daemonSetList, err := K8s.ClientSet.AppsV1().DaemonSets(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取DaemonSet列表失败, " + err.Error()))
		return nil, errors.New("获取DaemonSet列表失败, " + err.Error())
	}
	//将daemonSetList中的daemonSet列表(Items)，放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: d.toCells(daemonSetList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}

	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()

	//将[]DataCell类型的daemonset列表转为v1.daemonset列表
	daemonSets := d.fromCells(data.GenericDataList)

	return &DaemonSetsResp{
		Items: daemonSets,
		Total: total,
	}, nil
}

// GetDaemonSetDetail 获取daemonset详情
func (d *daemonSet) GetDaemonSetDetail(daemonSetName, namespace string) (daemonSet *appsv1.DaemonSet, err error) {
	daemonSet, err = K8s.ClientSet.AppsV1().DaemonSets(namespace).Get(context.TODO(), daemonSetName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取DaemonSet详情失败, " + err.Error()))
		return nil, errors.New("获取DaemonSet详情失败, " + err.Error())
	}

	return daemonSet, nil
}

// DeleteDaemonSet 删除daemonset
func (d *daemonSet) DeleteDaemonSet(daemonSetName, namespace string) (err error) {
	err = K8s.ClientSet.AppsV1().DaemonSets(namespace).Delete(context.TODO(), daemonSetName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除DaemonSet失败, " + err.Error()))
		return errors.New("删除DaemonSet失败, " + err.Error())
	}

	return nil
}

// UpdateDaemonSet 更新daemonset
func (d *daemonSet) UpdateDaemonSet(namespace, content string) (err error) {
	var daemonSet = &appsv1.DaemonSet{}

	err = json.Unmarshal([]byte(content), daemonSet)
	if err != nil {
		logger.Error(errors.New("反序列化失败, " + err.Error()))
		return errors.New("反序列化失败, " + err.Error())
	}

	_, err = K8s.ClientSet.AppsV1().DaemonSets(namespace).Update(context.TODO(), daemonSet, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新DaemonSet失败, " + err.Error()))
		return errors.New("更新DaemonSet失败, " + err.Error())
	}
	return nil
}

func (d *daemonSet) toCells(std []appsv1.DaemonSet) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = daemonSetCell(std[i])
	}
	return cells
}

func (d *daemonSet) fromCells(cells []DataCell) []appsv1.DaemonSet {
	daemonSets := make([]appsv1.DaemonSet, len(cells))
	for i := range cells {
		daemonSets[i] = appsv1.DaemonSet(cells[i].(daemonSetCell))
	}

	return daemonSets
}
```

##### controller/daemonset.go

```go
package controller

import (
	"gitee.com/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var DaemonSet daemonSet

type daemonSet struct{}

// GetDaemonSets 获取daemonset列表，支持过滤、排序、分页
func (d *daemonSet) GetDaemonSets(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.DaemonSet.GetDaemonSets(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取DaemonSet列表成功",
		"data": data,
	})
}

// GetDaemonSetDetail 获取daemonset详情
func (d *daemonSet) GetDaemonSetDetail(ctx *gin.Context) {
	params := new(struct {
		DaemonSetName string `form:"daemonset_name"`
		Namespace     string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.DaemonSet.GetDaemonSetDetail(params.DaemonSetName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取DaemonSet详情成功",
		"data": data,
	})
}

// DeleteDaemonSet 删除daemonset
func (d *daemonSet) DeleteDaemonSet(ctx *gin.Context) {
	params := new(struct {
		DaemonSetName string `json:"daemonset_name"`
		Namespace     string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.DaemonSet.DeleteDaemonSet(params.DaemonSetName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除DaemonSet成功",
		"data": nil,
	})
}

// UpdateDaemonSet 更新daemonset
func (d *daemonSet) UpdateDaemonSet(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.DaemonSet.UpdateDaemonSet(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新DaemonSet成功",
		"data": nil,
	})
}

```

#### 2.5 StatefulSet

> 注意：以下功能与Pod和Deployment是实现方式一致

|功能|是否实现|
|---|-----|
|StatefulSet列表 |√|
|获取StatefulSet详情|√|
|删除StatefulSet |√|
|更新StatefulSet|√|

##### service/dataselector.go

```go
// 实现 StatefulSet 的 DataCell接口
type statefulSetCell appsv1.StatefulSet

func (s statefulSetCell) GetCreation() time.Time {
	return s.CreationTimestamp.Time
}

func (s statefulSetCell) GetName() string {
	return s.Name
}
```


##### service/statefulset.go

```go
package service

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/wonderivan/logger"
	appsv1 "k8s.io/api/apps/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var StatefulSet statefulSet

type statefulSet struct{}

type StatusfulSetsResp struct {
	Items []appsv1.StatefulSet `json:"items"`
	Total int                  `json:"total"`
}

// GetStatefulSets 获取statefulset列表，支持过滤、排序、分页
func (s *statefulSet) GetStatefulSets(filterName, namespace string, limit, page int) (statusfulSetsResp *StatusfulSetsResp, err error) {
	//获取statefulSetList类型的statefulSet列表
	statefulSetList, err := K8s.ClientSet.AppsV1().StatefulSets(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取StatefulSet列表失败, " + err.Error()))
		return nil, errors.New("获取StatefulSet列表失败, " + err.Error())
	}
	//将statefulSetList中的StatefulSet列表(Items)，放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: s.toCells(statefulSetList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}

	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()

	//将[]DataCell类型的statefulset列表转为v1.statefulset列表
	statefulSets := s.fromCells(data.GenericDataList)

	return &StatusfulSetsResp{
		Items: statefulSets,
		Total: total,
	}, nil
}

// GetStatefulSetDetail 获取statefulset详情
func (s *statefulSet) GetStatefulSetDetail(statefulSetName, namespace string) (statefulSet *appsv1.StatefulSet, err error) {
	statefulSet, err = K8s.ClientSet.AppsV1().StatefulSets(namespace).Get(context.TODO(), statefulSetName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取StatefulSet详情失败, " + err.Error()))
		return nil, errors.New("获取StatefulSet详情失败, " + err.Error())
	}

	return statefulSet, nil
}

// DeleteStatefulSet 删除statefulset
func (s *statefulSet) DeleteStatefulSet(statefulSetName, namespace string) (err error) {
	err = K8s.ClientSet.AppsV1().StatefulSets(namespace).Delete(context.TODO(), statefulSetName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除StatefulSet失败, " + err.Error()))
		return errors.New("删除StatefulSet失败, " + err.Error())
	}

	return nil
}

// UpdateStatefulSet 更新statefulset
func (s *statefulSet) UpdateStatefulSet(namespace, content string) (err error) {
	var statefulSet = &appsv1.StatefulSet{}

	err = json.Unmarshal([]byte(content), statefulSet)
	if err != nil {
		logger.Error(errors.New("反序列化失败, " + err.Error()))
		return errors.New("反序列化失败, " + err.Error())
	}

	_, err = K8s.ClientSet.AppsV1().StatefulSets(namespace).Update(context.TODO(), statefulSet, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新StatefulSet失败, " + err.Error()))
		return errors.New("更新StatefulSet失败, " + err.Error())
	}
	return nil
}

func (s *statefulSet) toCells(std []appsv1.StatefulSet) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = statefulSetCell(std[i])
	}
	return cells
}

func (s *statefulSet) fromCells(cells []DataCell) []appsv1.StatefulSet {
	statefulSets := make([]appsv1.StatefulSet, len(cells))
	for i := range cells {
		statefulSets[i] = appsv1.StatefulSet(cells[i].(statefulSetCell))
	}

	return statefulSets
}

```


##### controller/statefulset.go

```go
package controller

import (
	"gitee.com/hujianli94net/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var StatefulSet statefulSet

type statefulSet struct{}

// GetStatefulSets 获取statefulset列表，支持过滤、排序、分页
func (s *statefulSet) GetStatefulSets(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.StatefulSet.GetStatefulSets(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取StatefulSet列表成功",
		"data": data,
	})
}

// GetStatefulSetDetail 获取statefulset详情
func (s *statefulSet) GetStatefulSetDetail(ctx *gin.Context) {
	params := new(struct {
		StatefulSetName string `form:"statefulset_name"`
		Namespace       string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.StatefulSet.GetStatefulSetDetail(params.StatefulSetName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取StatefulSet详情成功",
		"data": data,
	})
}

// DeleteStatefulSet 删除statefulset
func (s *statefulSet) DeleteStatefulSet(ctx *gin.Context) {
	params := new(struct {
		StatefulSetName string `json:"statefulset_name"`
		Namespace       string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.StatefulSet.DeleteStatefulSet(params.StatefulSetName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除StatefulSet成功",
		"data": nil,
	})
}

// UpdateStatefulSet 更新statefulSet
func (s *statefulSet) UpdateStatefulSet(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.StatefulSet.UpdateStatefulSet(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新StatefulSet成功",
		"data": nil,
	})
}
```


### 3. 集群

> 注意：以下3个资源是集群维度的，没有Namespace的概念

#### 3.1 Node 

|功能|是否实现|
|---|-----|
|Node列表 |√|
|获取Node详情|√|



##### service/dataselector.go


```go
// 实现 Node 的 DataCell接口
type nodeCell corev1.Node

func (n nodeCell) GetCreation() time.Time {
	return n.CreationTimestamp.Time
}

func (n nodeCell) GetName() string {
	return n.Name
}
```


##### service/node.go

```go
package service

import (
	"context"
	"errors"

	"github.com/wonderivan/logger"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var Node node

type node struct{}

type NodesResp struct {
	Items []corev1.Node `json:"items"`
	Total int           `json:"total"`
}

// GetNodes 获取node列表，支持过滤、排序、分页
func (n *node) GetNodes(filterName string, limit, page int) (nodesResp *NodesResp, err error) {
	//获取nodeList类型的node列表
	nodeList, err := K8s.ClientSet.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取Node列表失败, " + err.Error()))
		return nil, errors.New("获取Node列表失败, " + err.Error())
	}
	//将nodeList中的node列表(Items)，放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: n.toCells(nodeList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}

	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()

	//将[]DataCell类型的node列表转为v1.node列表
	nodes := n.fromCells(data.GenericDataList)

	return &NodesResp{
		Items: nodes,
		Total: total,
	}, nil
}

// GetNodeDetail 获取node详情
func (n *node) GetNodeDetail(nodeName string) (node *corev1.Node, err error) {
	node, err = K8s.ClientSet.CoreV1().Nodes().Get(context.TODO(), nodeName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Node详情失败, " + err.Error()))
		return nil, errors.New("获取Node详情失败, " + err.Error())
	}

	return node, nil
}

func (n *node) toCells(std []corev1.Node) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = nodeCell(std[i])
	}
	return cells
}

func (n *node) fromCells(cells []DataCell) []corev1.Node {
	nodes := make([]corev1.Node, len(cells))
	for i := range cells {
		nodes[i] = corev1.Node(cells[i].(nodeCell))
	}

	return nodes
}
```


##### controller/node.go


```go
package controller

import (
	"gitee.com/hujianli94net/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var Node node

type node struct{}

// GetNodes 获取node列表，支持过滤、排序、分页
func (n *node) GetNodes(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Node.GetNodes(params.FilterName, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Node列表成功",
		"data": data,
	})
}

// GetNodeDetail 获取node详情
func (n *node) GetNodeDetail(ctx *gin.Context) {
	params := new(struct {
		NodeName string `form:"node_name"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Node.GetNodeDetail(params.NodeName)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Node详情成功",
		"data": data,
	})
}
```



#### 3.2 Namespace


|功能|是否实现|
|---|-----|
|Namespace 列表 |√|
|获取Namespace详情|√|
|删除Namespace |√|



##### service/dataselector.go

```go
// 实现 Namespace 的 DataCell接口
type namespaceCell corev1.Namespace

func (n namespaceCell) GetCreation() time.Time {
	return n.CreationTimestamp.Time
}

func (n namespaceCell) GetName() string {
	return n.Name
}
```


##### service/namespace.go


```go
package service

import (
	"context"
	"errors"

	"github.com/wonderivan/logger"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type namespace struct{}

var Namespace namespace

type NamespacesResp struct {
	Items []corev1.Namespace `json:"items"`
	Total int                `json:"total"`
}

func (n *namespace) toCells(std []corev1.Namespace) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = namespaceCell(std[i])
	}
	return cells
}

func (n *namespace) fromCells(cells []DataCell) []corev1.Namespace {
	namespaces := make([]corev1.Namespace, len(cells))
	for i := range cells {
		namespaces[i] = corev1.Namespace(cells[i].(namespaceCell))
	}

	return namespaces
}

// GetNamespaces 获取namespace列表，支持过滤、排序、分页
func (n *namespace) GetNamespaces(filterName string, limit, page int) (namespaceResp *NamespacesResp, err error) {
	//获取namespaceList类型的namespace列表
	namespaceList, err := K8s.ClientSet.CoreV1().Namespaces().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取Namespace列表失败, " + err.Error()))
		return nil, errors.New("获取Namespace列表失败, " + err.Error())
	}
	//将namespaceList中的namespace列表(Items)，放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: n.toCells(namespaceList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}
	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()
	//将[]DataCell类型的namespace列表转为v1.namespace列表
	namespaces := n.fromCells(data.GenericDataList)
	return &NamespacesResp{
		Items: namespaces,
		Total: total,
	}, nil
}

// GetNamespaceDetail 获取namespace详情
func (n *namespace) GetNamespaceDetail(namespaceName string) (namespace *corev1.Namespace, err error) {
	namespace, err = K8s.ClientSet.CoreV1().Namespaces().Get(context.TODO(), namespaceName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Namespace详情失败，" + err.Error()))
		return nil, errors.New("获取Namespace详情失败，" + err.Error())
	}
	return namespace, nil
}

// DeleteNamespace 删除namespace
func (n *namespace) DeleteNamespace(namespaceName string) (err error) {
	err = K8s.ClientSet.CoreV1().Namespaces().Delete(context.TODO(), namespaceName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error("删除Namespace失败，" + err.Error())
		return errors.New("删除Namespace失败，" + err.Error())
	}
	return nil
}
```

##### controller/namespace.go

```go
package controller

import (
	"gitee.com/hujianli94net/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

type namespace struct{}

var Namespace namespace

// GetNamespaces 获取namespace列表，支持过滤、排序、分页
func (n *namespace) GetNamespaces(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Namespace.GetNamespaces(params.FilterName, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Namespace列表成功",
		"data": data,
	})
}

// GetNamespaceDetail 获取namespace详情
func (n *namespace) GetNamespaceDetail(ctx *gin.Context) {
	params := new(struct {
		NamespaceName string `form:"namespace_name"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Namespace.GetNamespaceDetail(params.NamespaceName)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Namespace详情成功",
		"data": data,
	})
}

// DeleteNamespace 删除namespace
func (n *namespace) DeleteNamespace(ctx *gin.Context) {
	params := new(struct {
		NamespaceName string `json:"namespace_name"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.Namespace.DeleteNamespace(params.NamespaceName)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Namespace成功",
		"data": nil,
	})
}
```

#### 3.3 PersistentVolume 


|功能|是否实现|
|---|-----|
|PersistentVolume 列表 |√|
|获取PersistentVolume详情|√|
|删除PersistentVolume |√|


##### service/dataselector.go

```go
// 实现 PersistentVolume 的 DataCell接口
type pvCell corev1.PersistentVolume

func (p pvCell) GetCreation() time.Time {
	return p.CreationTimestamp.Time
}

func (p pvCell) GetName() string {
	return p.Name
}
```

##### service/pv.go

```go
package service

import (
	"context"
	"errors"

	"github.com/wonderivan/logger"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var Pv pv

type pv struct{}

type PvsResp struct {
	Items []corev1.PersistentVolume `json:"items"`
	Total int                       `json:"total"`
}

// GetPvs 获取pv列表，支持过滤、排序、分页
func (p *pv) GetPvs(filterName string, limit, page int) (pvsResp *PvsResp, err error) {
	//获取pvList类型的pv列表
	pvList, err := K8s.ClientSet.CoreV1().PersistentVolumes().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取Pv列表失败, " + err.Error()))
		return nil, errors.New("获取Pv列表失败, " + err.Error())
	}
	//将pvList中的pv列表(Items)，放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: p.toCells(pvList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}

	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()

	//将[]DataCell类型的pv列表转为v1.pv列表
	pvs := p.fromCells(data.GenericDataList)

	return &PvsResp{
		Items: pvs,
		Total: total,
	}, nil
}

// GetPvDetail 获取pv详情
func (p *pv) GetPvDetail(pvName string) (pv *corev1.PersistentVolume, err error) {
	pv, err = K8s.ClientSet.CoreV1().PersistentVolumes().Get(context.TODO(), pvName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Pv详情失败, " + err.Error()))
		return nil, errors.New("获取Pv详情失败, " + err.Error())
	}

	return pv, nil
}

// DeletePv 删除pv
func (p *pv) DeletePv(pvName string) (err error) {
	err = K8s.ClientSet.CoreV1().PersistentVolumes().Delete(context.TODO(), pvName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除Pv失败, " + err.Error()))
		return errors.New("删除Pv失败, " + err.Error())
	}

	return nil
}

func (p *pv) toCells(std []corev1.PersistentVolume) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = pvCell(std[i])
	}
	return cells
}

func (p *pv) fromCells(cells []DataCell) []corev1.PersistentVolume {
	pvs := make([]corev1.PersistentVolume, len(cells))
	for i := range cells {
		pvs[i] = corev1.PersistentVolume(cells[i].(pvCell))
	}

	return pvs
}
```


##### controller/pv.go


```go
package controller

import (
	"gitee.com/hujianli94net/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var Pv pv

type pv struct{}

// GetPvs 获取pv列表，支持过滤、排序、分页
func (p *pv) GetPvs(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Pv.GetPvs(params.FilterName, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pv列表成功",
		"data": data,
	})
}

// GetPvDetail 获取pv详情
func (p *pv) GetPvDetail(ctx *gin.Context) {
	params := new(struct {
		PvName string `form:"pv_name"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Pv.GetPvDetail(params.PvName)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pv详情成功",
		"data": data,
	})
}

// DeletePv 删除pv
func (p *pv) DeletePv(ctx *gin.Context) {
	params := new(struct {
		PvName string `json:"pv_name"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.Pv.DeletePv(params.PvName)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Pv成功",
		"data": nil,
	})
}
```



### 4. 负载均衡


#### 4.1 Service

|功能|是否实现|
|---|-----|
|Service 列表 |√|
|获取Service详情|√|
|创建Service|√|
|删除Service|√|
|更新Service|√|




##### service/dataselector.go


```go
// 实现 Service 的 DataCell接口
type serviceCell corev1.Service //corev1 "k8s.io/api/core/v1"

func (s serviceCell) GetCreation() time.Time {
	return s.CreationTimestamp.Time
}
func (s serviceCell) GetName() string {
	return s.Name
}
```


##### service/service.go


```go
package service

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/wonderivan/logger"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

var Service service

type service struct{}

// ServicesResp 定义列表的返回内容，Items是Services元素列表，Total为Services元素数量
type ServicesResp struct {
	Items []corev1.Service `json:"items"`
	Total int              `json:"total"`
}

// ServicesNp 定义ServicesNp类型，用于返回namespace中service的数量
type ServicesNp struct {
	Namespace  string `json:"namespace"`
	ServiceNum int    `json:"service_num"`
}

func (s *service) toCells(std []corev1.Service) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = serviceCell(std[i])
	}
	return cells
}
func (s *service) fromCells(cells []DataCell) []corev1.Service {
	services := make([]corev1.Service, len(cells))
	for i := range cells {
		services[i] = corev1.Service(cells[i].(serviceCell))
	}
	return services
}

// ServiceCreate 定义ServiceCreate结构体，用于创建service需要的参数属性的定义
type ServiceCreate struct {
	Name          string            `json:"name"`
	Namespace     string            `json:"namespace"`
	Type          string            `json:"type"`
	ContainerPort int32             `json:"container_port"`
	Port          int32             `json:"port"`
	NodePort      int32             `json:"node_port"`
	Label         map[string]string `json:"label"`
}

// GetServices 获取service列表，支持过滤、排序、分页
func (s *service) GetServices(filterName, namespace string, limit, page int) (servicesResp *ServicesResp, err error) {
	//获取serviceList类型的service列表
	serviceList, err := K8s.ClientSet.CoreV1().Services(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取Service列表失败," + err.Error()))
		return nil, errors.New("获取Service列表失败，" + err.Error())
	}
	//将serviceList中的service列表（Item），放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: s.toCells(serviceList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}
	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()
	//将[]DataCell类型的service列表转为v1.service列表
	services := s.fromCells(data.GenericDataList)
	return &ServicesResp{
		Items: services,
		Total: total,
	}, nil
}

// GetServiceDetail 获取service详情
func (s *service) GetServiceDetail(serviceName, namespace string) (service *corev1.Service, err error) {
	service, err = K8s.ClientSet.CoreV1().Services(namespace).Get(context.TODO(), serviceName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Service详情失败，" + err.Error()))
		return nil, errors.New("获取Service详情失败，" + err.Error())
	}
	return service, nil
}

// CreateService 创建service，接收ServiceCreate对象
func (s *service) CreateService(data *ServiceCreate) (err error) {
	//将data中的数据组装成corev1.Service对象
	service := &corev1.Service{
		//ObjectMeta中定义资源名、命名空间以及标签
		ObjectMeta: metav1.ObjectMeta{
			Name:      data.Name,
			Namespace: data.Namespace,
			Labels:    data.Label,
		},
		//Spec中定义类型，端口，选择器
		Spec: corev1.ServiceSpec{
			Type: corev1.ServiceType(data.Type),
			Ports: []corev1.ServicePort{
				{
					Name:     "http",
					Port:     data.Port,
					Protocol: "TCP",
					TargetPort: intstr.IntOrString{
						Type:   0,
						IntVal: data.ContainerPort,
					},
				},
			},
			Selector: data.Label,
		},
	}
	//默认ClusterIP,这里是判断NodePort，添加配置
	if data.NodePort != 0 && data.Type == "NodePort" {
		service.Spec.Ports[0].NodePort = data.NodePort
	}
	//创建Service
	_, err = K8s.ClientSet.CoreV1().Services(data.Namespace).Create(context.TODO(), service, metav1.CreateOptions{})
	if err != nil {
		logger.Error(errors.New("创建Service失败，" + err.Error()))
		return errors.New("创建Service失败，" + err.Error())
	}
	return nil
}

// DeleteService 删除service
func (s *service) DeleteService(serviceName, namespace string) (err error) {
	err = K8s.ClientSet.CoreV1().Services(namespace).Delete(context.TODO(), serviceName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除Service失败，" + err.Error()))
		return errors.New("删除Service失败，" + err.Error())
	}
	return nil
}

// UpdateService 更新service
func (s *service) UpdateService(namespace, content string) (err error) {
	var service = &corev1.Service{}
	err = json.Unmarshal([]byte(content), service)
	if err != nil {
		logger.Error(errors.New("反序列化失败，" + err.Error()))
		return errors.New("反序列化失败," + err.Error())
	}
	_, err = K8s.ClientSet.CoreV1().Services(namespace).Update(context.TODO(), service, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新service失败，" + err.Error()))
		return errors.New("更新service失败，" + err.Error())
	}
	return nil
}

```

对标

```yaml
apiVersion: v1 
kind: Service 
metadata:
  name: myapp-svc 
  namespace: default 
spec: 
  selector: 
    app: myapp 
  ports:
  - name: http 
    port: 80 #service的端口
    protocol：tcp #协议
    targetPort: 80 #pod的端口
```


##### controller/service.go

```go
package controller

import (
	"gitee.com/hujianli94net/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var Servicev1 servicev1

type servicev1 struct{}

// GetServices 获取service列表，支持过滤、排序、分页
func (s *servicev1) GetServices(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Service.GetServices(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Servicet列表成功",
		"data": data,
	})
}

// GetServiceDetail 获取service详情
func (s *servicev1) GetServiceDetail(ctx *gin.Context) {
	params := new(struct {
		ServiceName string `form:"service_name"`
		Namespace   string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Service.GetServiceDetail(params.ServiceName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Service详情成功",
		"data": data,
	})
}

// CreateService 创建service
func (s *servicev1) CreateService(ctx *gin.Context) {
	var (
		serviceCreate = new(service.ServiceCreate)
		err           error
	)

	if err = ctx.ShouldBindJSON(serviceCreate); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	if err = service.Service.CreateService(serviceCreate); err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "创建Service成功",
		"data": nil,
	})
}

// DeleteService 删除service
func (s *servicev1) DeleteService(ctx *gin.Context) {
	params := new(struct {
		ServiceName string `json:"service_name"`
		Namespace   string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.Service.DeleteService(params.ServiceName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Service成功",
		"data": nil,
	})
}

// UpdateService 更新service
func (s *servicev1) UpdateService(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.Service.UpdateService(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新Service成功",
		"data": nil,
	})
}

```


#### 4.2 Ingress

|功能|是否实现|
|---|-----|
|Ingress 列表 |√|
|获取Ingress详情|√|
|创建Ingress|√|
|删除Ingress|√|
|更新Ingress|√|


##### service/dataselector.go

```go

import (
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	nwv1 "k8s.io/api/networking/v1"
	"sort"
	"strings"
	"time"
)

// 实现 Ingress 的 DataCell接口
type ingressCell nwv1.Ingress //nwv1 "k8s.io/api/networking/v1"

func (i ingressCell) GetCreation() time.Time {
	return i.CreationTimestamp.Time
}
func (i ingressCell) GetName() string {
	return i.Name
}
```

创建Ingress

##### service/ingress.go

```go
package service

import (
	"context"
	"encoding/json"
	"errors"

	nwv1 "k8s.io/api/networking/v1"

	"github.com/wonderivan/logger"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var Ingress ingress

type ingress struct{}

// IngressesResp 定义列表的返回内容，Items是ingress元素列表，Total为ingress元素数量
type IngressesResp struct {
	Items []nwv1.Ingress `json:"items"`
	Total int            `json:"total"`
}

func (s *ingress) toCells(std []nwv1.Ingress) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = ingressCell(std[i])
	}
	return cells
}
func (s *ingress) fromCells(cells []DataCell) []nwv1.Ingress {
	ingresses := make([]nwv1.Ingress, len(cells))
	for i := range cells {
		ingresses[i] = nwv1.Ingress(cells[i].(ingressCell))
	}
	return ingresses
}

// HttpPath 定义ingress的path结构体
type HttpPath struct {
	Path        string        `json:"path"`
	PathType    nwv1.PathType `json:"path_type"`
	ServiceName string        `json:"service_name"`
	ServicePort int32         `json:"service_port"`
}

// IngressCreate 定义IngressCreate结构体，用于创建ingress需要的参数属性的定义
type IngressCreate struct {
	Name      string                 `json:"name"`
	Namespace string                 `json:"namespace"`
	Label     map[string]string      `json:"label"`
	Hosts     map[string][]*HttpPath `json:"hosts"`
}

// GetIngresses 获取ingress列表，支持过滤、排序、分页
func (i *ingress) GetIngresses(filterName, namespace string, limit, page int) (ingressesResp *IngressesResp, err error) {
	//获取ingressList类型的ingress列表
	ingressList, err := K8s.ClientSet.NetworkingV1().Ingresses(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取Ingress列表失败，" + err.Error()))
		return nil, errors.New("获取Ingress列表失败，" + err.Error())
	}
	//将ingressList中的ingress列表（Items），放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: i.toCells(ingressList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{
				Name: filterName,
			},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}
	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()
	//将[]DataCell类型的ingress列表转为v1.ingress列表
	ingresses := i.fromCells(data.GenericDataList)
	return &IngressesResp{
		Items: ingresses,
		Total: total,
	}, nil
}

// GetIngressDetail 获取ingress详情
func (i *ingress) GetIngressDetail(ingressName, namespace string) (ingress *nwv1.Ingress, err error) {
	ingress, err = K8s.ClientSet.NetworkingV1().Ingresses(namespace).Get(context.TODO(), ingressName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Ingress详情失败，" + err.Error()))
		return nil, errors.New("获取Ingress详情失败，" + err.Error())
	}
	return ingress, nil
}

// CreateIngress 创建ingress，接收IngressCreate对象
func (i *ingress) CreateIngress(data *IngressCreate) (err error) {
	//声明nwv1.IngressRule和nwv1.HTTPIngressPath变量，后面组装数据用到
	var ingressRules []nwv1.IngressRule
	var httpIngressPATHs []nwv1.HTTPIngressPath
	//将data中的数据组装成nwv1.Ingress对象
	ingress := &nwv1.Ingress{
		//ObjectMeta中定义资源名、命名空间以及标签
		ObjectMeta: metav1.ObjectMeta{
			Name:      data.Name,
			Namespace: data.Namespace,
			Labels:    data.Label,
		},
		Status: nwv1.IngressStatus{},
	}
	//第一层for循环是将host组装成nwv1.IngressRule类型性的对象
	//一个host对应一个ingressrule,每个ingressrule中包含一个host和多个path
	for key, value := range data.Hosts {
		ir := nwv1.IngressRule{
			Host: key,
			//这里现将nwv1.HTTPIngressRuleValue类型中的Paths置为空，后面组装好数据再赋值
			IngressRuleValue: nwv1.IngressRuleValue{
				HTTP: &nwv1.HTTPIngressRuleValue{Paths: nil},
			},
		}
		//第二层for循环是将path组装成nwv1.HTTPIngressPath类型的对象
		for _, HttpPath := range value {
			hip := nwv1.HTTPIngressPath{
				Path:     HttpPath.Path,
				PathType: &HttpPath.PathType,
				Backend: nwv1.IngressBackend{
					Service: &nwv1.IngressServiceBackend{
						Name: HttpPath.ServiceName,
						Port: nwv1.ServiceBackendPort{
							Number: HttpPath.ServicePort,
						},
					},
				},
			}
			//将每个hip对象组装成数组
			httpIngressPATHs = append(httpIngressPATHs, hip)
		}
		//给Paths赋值，前面置为空了
		ir.IngressRuleValue.HTTP.Paths = httpIngressPATHs
		//将每个ir对象组装成数组，这个ir对象就是IngressRule，每个元素是一个host和多个path
		ingressRules = append(ingressRules, ir)
	}
	//将ingressRules对象加入到ingress的规则中
	ingress.Spec.Rules = ingressRules
	//创建ingress
	_, err = K8s.ClientSet.NetworkingV1().Ingresses(data.Namespace).Create(context.TODO(), ingress, metav1.CreateOptions{})
	if err != nil {
		logger.Error(errors.New("创建Ingress失败，" + err.Error()))
		return errors.New("创建Ingress失败，" + err.Error())
	}
	return nil
}

// DeleteIngress 删除ingress
func (i *ingress) DeleteIngress(ingressName, namespace string) (err error) {
	err = K8s.ClientSet.NetworkingV1().Ingresses(namespace).Delete(context.TODO(), ingressName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除Ingress失败，" + err.Error()))
		return errors.New("删除Ingress失败，" + err.Error())
	}
	return nil
}

// UpdateIngress 更新ingress
func (i *ingress) UpdateIngress(namespace, content string) (err error) {
	var ingress = &nwv1.Ingress{}
	err = json.Unmarshal([]byte(content), ingress)
	if err != nil {
		logger.Error(errors.New("反序列化失败，" + err.Error()))
		return errors.New("反序列化失败，" + err.Error())
	}
	_, err = K8s.ClientSet.NetworkingV1().Ingresses(namespace).Update(context.TODO(), ingress, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新ingress失败，" + err.Error()))
		return errors.New("更新ingress失败，" + err.Error())
	}
	return nil
}
```


##### controller/ingress.go

```go
package controller

import (
	"gitee.com/hujianli94net/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var Ingress ingress

type ingress struct{}

// GetIngresses 获取ingress列表，支持过滤、排序、分页
func (i *ingress) GetIngresses(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Ingress.GetIngresses(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Ingresst列表成功",
		"data": data,
	})
}

// GetIngressDetail 获取ingress详情
func (i *ingress) GetIngressDetail(ctx *gin.Context) {
	params := new(struct {
		IngressName string `form:"ingress_name"`
		Namespace   string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Ingress.GetIngressDetail(params.IngressName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Ingress详情成功",
		"data": data,
	})
}

// DeleteIngress 删除ingress
func (i *ingress) DeleteIngress(ctx *gin.Context) {
	params := new(struct {
		IngressName string `json:"ingress_name"`
		Namespace   string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.Ingress.DeleteIngress(params.IngressName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Ingress成功",
		"data": nil,
	})
}

// CreateIngress 创建ingress
func (i *ingress) CreateIngress(ctx *gin.Context) {
	var (
		ingressCreate = new(service.IngressCreate)
		err           error
	)

	if err = ctx.ShouldBindJSON(ingressCreate); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	if err = service.Ingress.CreateIngress(ingressCreate); err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "创建Ingress成功",
		"data": nil,
	})
}

// UpdateIngress 更新ingress
func (i *ingress) UpdateIngress(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.Ingress.UpdateIngress(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新Ingress成功",
		"data": nil,
	})
}
```

### 5. 存储与配置


#### 5.1 ConfigMap

|功能|是否实现|
|---|-----|
|ConfigMap 列表 |√|
|获取ConfigMap详情|√|
|删除ConfigMap|√|
|更新ConfigMap|√|

##### service/dataselector.go

```go
// 实现 ConfigMap 的 DataCell接口
type configMapCell corev1.ConfigMap

func (c configMapCell) GetCreation() time.Time {
	return c.CreationTimestamp.Time
}

func (c configMapCell) GetName() string {
	return c.Name
}
```

##### service/configmap.go

```go
package service

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/wonderivan/logger"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type configMap struct{}

var ConfigMap configMap

type ConfigMapsResp struct {
	Items []corev1.ConfigMap `json:"items"`
	Total int                `json:"total"`
}

func (c *configMap) toCells(std []corev1.ConfigMap) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = configMapCell(std[i])
	}
	return cells
}

func (c *configMap) fromCells(cells []DataCell) []corev1.ConfigMap {
	configMaps := make([]corev1.ConfigMap, len(cells))
	for i := range cells {
		configMaps[i] = corev1.ConfigMap(cells[i].(configMapCell))
	}

	return configMaps
}

// GetConfigMaps 获取configmap列表，支持过滤、排序、分页
func (c *configMap) GetConfigMaps(filterName, namespace string, limit, page int) (configMapsResp *ConfigMapsResp, err error) {
	//获取configMapList类型的configMap列表
	configMapList, err := K8s.ClientSet.CoreV1().ConfigMaps(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取ConfigMap列表失败，" + err.Error()))
		return nil, errors.New("获取ConfigMap列表失败，" + err.Error())
	}
	//将configMapList中的configMap列表（Items），放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: c.toCells(configMapList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}
	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()
	//将[]DataCell类型的configmap列表转为v1.configmap列表
	configMaps := c.fromCells(data.GenericDataList)
	return &ConfigMapsResp{
		Items: configMaps,
		Total: total,
	}, nil
}

// GetConfigMapDetail 获取configmap详情
func (c *configMap) GetConfigMapDetail(configMapName, namespace string) (configMap *corev1.ConfigMap, err error) {
	configMap, err = K8s.ClientSet.CoreV1().ConfigMaps(namespace).Get(context.TODO(), configMapName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取ConfigMap详情失败，" + err.Error()))
		return nil, errors.New("获取ConfigMap详情失败，" + err.Error())
	}
	return configMap, nil
}

// DeleteConfigMap 删除configmap
func (c *configMap) DeleteConfigMap(configMapName, namespace string) (err error) {
	err = K8s.ClientSet.CoreV1().ConfigMaps(namespace).Delete(context.TODO(), configMapName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除ConfigMap失败，" + err.Error()))
		return errors.New("删除ConfigMap失败，" + err.Error())
	}
	return nil
}

// UpdateConfigMap 更新configMap
func (c *configMap) UpdateConfigMap(namespace, content string) (err error) {
	var configMap = &corev1.ConfigMap{}
	err = json.Unmarshal([]byte(content), configMap)
	if err != nil {
		logger.Error(errors.New("反序列化失败，" + err.Error()))
		return errors.New("反序列化失败，" + err.Error())
	}
	_, err = K8s.ClientSet.CoreV1().ConfigMaps(namespace).Update(context.TODO(), configMap, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新ConfigMap失败，" + err.Error()))
		return errors.New("更新ConfigMap失败，" + err.Error())
	}
	return nil
}
```

##### controller/configmap.go

```go
package controller

import (
	"k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

/**
 * @author 王子龙
 * 时间：2022/10/3 11:30
 */
type configMap struct{}

var ConfigMap configMap

//获取configmap列表，支持过滤、排序、分页
func (c *configMap) GetConfigMaps(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.ConfigMap.GetConfigMaps(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取ConfigMap列表失败",
		"data": data,
	})
}

//获取configmap详情
func (c *configMap) GetConfigMapDetail(ctx *gin.Context) {
	params := new(struct {
		ConfigMapName string `form:"configmap_name"`
		Namespace     string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.ConfigMap.GetConfigMapDetail(params.ConfigMapName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取ConfigMap详情成功",
		"data": data,
	})
}

//删除configmap
func (c *configMap) DeleteConfigMap(ctx *gin.Context) {
	params := new(struct {
		ConfigMapName string `json:"configmap_name"`
		Namespace     string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.ConfigMap.DeleteConfigMap(params.ConfigMapName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除ConfigMap成功",
		"data": nil,
	})
}

//更新configmap
func (c *configMap) UpdateConfigMap(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	err := service.ConfigMap.UpdateConfigMap(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新ConfigMap成功",
		"data": nil,
	})
}
```


#### 5.2 Secret 
|功能|是否实现|
|---|-----|
|Secret 列表 |√|
|获取Secret详情|√|
|删除Secret|√|
|更新Secret|√|


##### service/dataselector.go

```go
// 实现 Secret 的 DataCell接口
type secretCell corev1.Secret

func (s secretCell) GetCreation() time.Time {
	return s.CreationTimestamp.Time
}

func (s secretCell) GetName() string {
	return s.Name
}
```


##### service/secret.go

```go
package service

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/wonderivan/logger"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var Secret secret

type secret struct{}

type SecretsResp struct {
	Items []corev1.Secret `json:"items"`
	Total int             `json:"total"`
}

// GetSecrets 获取secret列表，支持过滤、排序、分页
func (s *secret) GetSecrets(filterName, namespace string, limit, page int) (secretsResp *SecretsResp, err error) {
	//获取secretList类型的secret列表
	secretList, err := K8s.ClientSet.CoreV1().Secrets(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取Secret列表失败, " + err.Error()))
		return nil, errors.New("获取Secret列表失败, " + err.Error())
	}
	//将secretList中的secret列表(Items)，放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: s.toCells(secretList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}

	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()

	//将[]DataCell类型的secret列表转为v1.secret列表
	secrets := s.fromCells(data.GenericDataList)

	return &SecretsResp{
		Items: secrets,
		Total: total,
	}, nil
}

// GetSecretDetail 获取secret详情
func (s *secret) GetSecretDetail(secretName, namespace string) (secret *corev1.Secret, err error) {
	secret, err = K8s.ClientSet.CoreV1().Secrets(namespace).Get(context.TODO(), secretName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Secret详情失败, " + err.Error()))
		return nil, errors.New("获取Secret详情失败, " + err.Error())
	}

	return secret, nil
}

// DeleteSecret 删除secret
func (s *secret) DeleteSecret(secretName, namespace string) (err error) {
	err = K8s.ClientSet.CoreV1().Secrets(namespace).Delete(context.TODO(), secretName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除Secret失败, " + err.Error()))
		return errors.New("删除Secret失败, " + err.Error())
	}

	return nil
}

// UpdateSecret 更新secret
func (s *secret) UpdateSecret(namespace, content string) (err error) {
	var secret = &corev1.Secret{}

	err = json.Unmarshal([]byte(content), secret)
	if err != nil {
		logger.Error(errors.New("反序列化失败, " + err.Error()))
		return errors.New("反序列化失败, " + err.Error())
	}

	_, err = K8s.ClientSet.CoreV1().Secrets(namespace).Update(context.TODO(), secret, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新Secret失败, " + err.Error()))
		return errors.New("更新Secret失败, " + err.Error())
	}
	return nil
}

func (s *secret) toCells(std []corev1.Secret) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = secretCell(std[i])
	}
	return cells
}

func (s *secret) fromCells(cells []DataCell) []corev1.Secret {
	secrets := make([]corev1.Secret, len(cells))
	for i := range cells {
		secrets[i] = corev1.Secret(cells[i].(secretCell))
	}

	return secrets
}
```


##### contrller/secret.go

```go
package controller

import (
	"gitee.com/hujianli94net/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var Secret secret

type secret struct{}

// GetSecrets 获取secret列表，支持过滤、排序、分页
func (s *secret) GetSecrets(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Secret.GetSecrets(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Secret列表成功",
		"data": data,
	})
}

// GetSecretDetail 获取secret详情
func (s *secret) GetSecretDetail(ctx *gin.Context) {
	params := new(struct {
		SecretName string `form:"secret_name"`
		Namespace  string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Secret.GetSecretDetail(params.SecretName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Secret详情成功",
		"data": data,
	})
}

// DeleteSecret 删除secret
func (s *secret) DeleteSecret(ctx *gin.Context) {
	params := new(struct {
		SecretName string `json:"secret_name"`
		Namespace  string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.Secret.DeleteSecret(params.SecretName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Secret成功",
		"data": nil,
	})
}

// UpdateSecret 更新secret
func (s *secret) UpdateSecret(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.Secret.UpdateSecret(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新Secret成功",
		"data": nil,
	})
}
```




#### 5.3 PersistentVolumeClaim 

|功能|是否实现|
|---|-----|
|PersistentVolumeClaim 列表 |√|
|获取PersistentVolumeClaim详情|√|
|删除PersistentVolumeClaim|√|
|更新PersistentVolumeClaim|√|


##### service/dataselector.go

```go

```


##### service/pvc.go

```go
package service

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/wonderivan/logger"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var Pvc pvc

type pvc struct{}

type PvcsResp struct {
	Items []corev1.PersistentVolumeClaim `json:"items"`
	Total int                            `json:"total"`
}

// GetPvcs 获取pvc列表，支持过滤、排序、分页
func (p *pvc) GetPvcs(filterName, namespace string, limit, page int) (pvcsResp *PvcsResp, err error) {
	//获取pvcList类型的pvc列表
	pvcList, err := K8s.ClientSet.CoreV1().PersistentVolumeClaims(namespace).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		logger.Error(errors.New("获取Pvc列表失败, " + err.Error()))
		return nil, errors.New("获取Pvc列表失败, " + err.Error())
	}
	//将pvcList中的pvc列表(Items)，放进dataselector对象中，进行排序
	selectableData := &dataSelector{
		GenericDataList: p.toCells(pvcList.Items),
		dataSelectQuery: &DataSelectQuery{
			FilterQuery: &FilterQuery{Name: filterName},
			PaginateQuery: &PaginateQuery{
				Limit: limit,
				Page:  page,
			},
		},
	}

	filtered := selectableData.Filter()
	total := len(filtered.GenericDataList)
	data := filtered.Sort().Paginate()

	//将[]DataCell类型的pvc列表转为v1.pvc列表
	pvcs := p.fromCells(data.GenericDataList)

	return &PvcsResp{
		Items: pvcs,
		Total: total,
	}, nil
}

// GetPvcDetail 获取pvc详情
func (p *pvc) GetPvcDetail(pvcName, namespace string) (pvc *corev1.PersistentVolumeClaim, err error) {
	pvc, err = K8s.ClientSet.CoreV1().PersistentVolumeClaims(namespace).Get(context.TODO(), pvcName, metav1.GetOptions{})
	if err != nil {
		logger.Error(errors.New("获取Pvc详情失败, " + err.Error()))
		return nil, errors.New("获取Pvc详情失败, " + err.Error())
	}

	return pvc, nil
}

// DeletePvc 删除pvc
func (p *pvc) DeletePvc(pvcName, namespace string) (err error) {
	err = K8s.ClientSet.CoreV1().PersistentVolumeClaims(namespace).Delete(context.TODO(), pvcName, metav1.DeleteOptions{})
	if err != nil {
		logger.Error(errors.New("删除Pvc失败, " + err.Error()))
		return errors.New("删除Pvc失败, " + err.Error())
	}

	return nil
}

// UpdatePvc 更新pvc
func (p *pvc) UpdatePvc(namespace, content string) (err error) {
	var pvc = &corev1.PersistentVolumeClaim{}

	err = json.Unmarshal([]byte(content), pvc)
	if err != nil {
		logger.Error(errors.New("反序列化失败, " + err.Error()))
		return errors.New("反序列化失败, " + err.Error())
	}

	_, err = K8s.ClientSet.CoreV1().PersistentVolumeClaims(namespace).Update(context.TODO(), pvc, metav1.UpdateOptions{})
	if err != nil {
		logger.Error(errors.New("更新Pvc失败, " + err.Error()))
		return errors.New("更新Pvc失败, " + err.Error())
	}
	return nil
}

func (p *pvc) toCells(std []corev1.PersistentVolumeClaim) []DataCell {
	cells := make([]DataCell, len(std))
	for i := range std {
		cells[i] = pvcCell(std[i])
	}
	return cells
}

func (p *pvc) fromCells(cells []DataCell) []corev1.PersistentVolumeClaim {
	pvcs := make([]corev1.PersistentVolumeClaim, len(cells))
	for i := range cells {
		pvcs[i] = corev1.PersistentVolumeClaim(cells[i].(pvcCell))
	}

	return pvcs
}
```

##### controller/pvc.go

```go
package controller

import (
	"gitee.com/hujianli94net/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

var Pvc pvc

type pvc struct{}

// GetPvcs 获取pvc列表，支持过滤、排序、分页
func (p *pvc) GetPvcs(ctx *gin.Context) {
	params := new(struct {
		FilterName string `form:"filter_name"`
		Namespace  string `form:"namespace"`
		Page       int    `form:"page"`
		Limit      int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Pvc.GetPvcs(params.FilterName, params.Namespace, params.Limit, params.Page)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pvc列表成功",
		"data": data,
	})
}

// GetPvcDetail 获取pvc详情
func (p *pvc) GetPvcDetail(ctx *gin.Context) {
	params := new(struct {
		PvcName   string `form:"pvc_name"`
		Namespace string `form:"namespace"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	data, err := service.Pvc.GetPvcDetail(params.PvcName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Pvc详情成功",
		"data": data,
	})
}

// DeletePvc 删除pvc
func (p *pvc) DeletePvc(ctx *gin.Context) {
	params := new(struct {
		PvcName   string `json:"pvc_name"`
		Namespace string `json:"namespace"`
	})
	//DELETE请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.Pvc.DeletePvc(params.PvcName, params.Namespace)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Pvc成功",
		"data": nil,
	})
}

// UpdatePvc 更新pvc
func (p *pvc) UpdatePvc(ctx *gin.Context) {
	params := new(struct {
		Namespace string `json:"namespace"`
		Content   string `json:"content"`
	})
	//PUT请求，绑定参数方法改为ctx.ShouldBindJSON
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败, " + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}

	err := service.Pvc.UpdatePvc(params.Namespace, params.Content)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "更新Pvc成功",
		"data": nil,
	})
}
```


### 6. 工作流


#### 6.1 流程设计

![1700633628391](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1700633628391.27c2ahp63lwk.webp){: .zoom}



#### 6.2 数据库操作(GORM)

##### (1)初始化数据库

`config/config.go`

```go
package config

import "time"

const (
	//配置启动监听端口
	ListenAddr = "0.0.0.0:9090"

	//Kubeconfig Linux上配置
	//Kubeconfig = "/root/.kube/config"
	//Windows上配置
	Kubeconfig = "C:\\Users/18793/.kube/config"
	//数据库配置
	DbType = "mysql"
	DbUser = "root"
	DbPwd  = "123456"
	DbHost = "127.0.0.1"
	DbPort = 3306
	DbName = "kubernetes-manage"
	//连接池的配置
	MaxIdleConns = 10               //最大空闲连接
	MaxOpenConns = 100              //最大连接数
	MaxLifeTime  = 30 * time.Second //最大生存时间
	//日志显示行数
	PodLogTailLine = 2000
)
```

`db/db.go`

```go
package db

import (
	"errors"
	"fmt"
	"gitee.com/hujianli94net/k8s-platform/config"
	"time"

	"github.com/wonderivan/logger"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

var (
	isInit bool
	GORM   *gorm.DB
	err    error
)

// Init db的初始化函数，与数据库建立连接
func Init() {
	//判断是否已经初始化了
	if isInit {
		return
	}
	// 组装连接配置
	// parseTime是查询结果是否自动解析为时间
	// loc是Mysql的时区设置
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8&parseTime=True&loc=Local",
		config.DbUser,
		config.DbPwd,
		config.DbHost,
		config.DbPort,
		config.DbName)
	// 与数据库建立连接，生成一个*gorm.DB类型的对象
	var DbType gorm.Dialector
	//DbType := *new(gorm.Dialector)
	if config.DbType == "mysql" {
		DbType = mysql.Open(dsn)
	} else {
		panic("config.DbType!=\"mysql\"")
	}
	GORM, err = gorm.Open(DbType, &gorm.Config{})
	if err != nil {
		panic("数据库连接失败" + err.Error())
	}
	////打印sql语句
	//fmt.Println("db", GORM)

	//开启连接池
	sqlDb, err := GORM.DB()
	if err != nil {
		logger.Error(errors.New("获取Deployment列表失败，" + err.Error()))
		return
	}
	//连接池最大允许的空闲连接数，如果没有sql任务需要执行的连接数大于20，超过的连接会被连接池关闭
	sqlDb.SetMaxIdleConns(config.MaxIdleConns)
	//设置了连接池最大数量
	sqlDb.SetMaxOpenConns(config.MaxOpenConns)
	//设置了连接可复用的最大时间
	sqlDb.SetConnMaxLifetime(time.Duration(config.MaxLifeTime))
	isInit = true
	logger.Info("连接数据库成功！")
}

// Close db的关闭函数
func Close() error {
	sqlDb, err := GORM.DB()
	if err != nil {
		logger.Error(errors.New("获取Deployment列表失败，" + err.Error()))
		panic(err.Error())
	}
	return sqlDb.Close()
}
```

> SetMaxOpenConns
默认情况下，连接池的最大数量是没有限制的。一般来说，连接数越多，访问数据库的性能越高。但是系统资源不是无限的，数据库的并发能力也不是无限的。因此为了减少系统和数据库崩溃的风险，可以给并发连接数设置一个上限，这个数值一般不超过进程的最大文件句柄打开数，不超过数据库服务自身支持的并发连接数，比如1000。 


> SetMaxIdleConns
理论上maxIdleConns连接的上限越高，也即允许在连接池中的空闲连接最大值越大，可以有效减少连接创建和销毁的次数，提高程序的性能。但是连接对象也是占用内存资源的，而且如果空闲连接越多，存在于连接池内的时间可能越长。 连接在经过一段时间后有可能会变得不可用 ，而这时连接还在连接池内没有回收的话，后续被征用的时候就会出问题。一般建议maxIdleConns的值为MaxOpenConns的 1/2 ，仅供参考。


> SetConnMaxLifetime
设置一个连接被使用的最长时间，即过了一段时间后会被强制回收，理论上这可以有效减少不可用连接出现的概率。当数据库方面也设置了连接的超时时间时，这个值应当不超过数据库的超时参数值。


main.go

```go
package main

import (
	"gitee.com/hujianli94net/k8s-platform/config"
	"gitee.com/hujianli94net/k8s-platform/controller"
	"gitee.com/hujianli94net/k8s-platform/db"
	"gitee.com/hujianli94net/k8s-platform/service"

	"github.com/gin-gonic/gin"
)

func main() {
	//初始化k8s client
	service.K8s.Init()
	//初始化数据库
	db.Init()
	//初始化gin对象
	r := gin.Default()
	//初始化k8s client
	service.K8s.Init()
	//初始化路由规则
	controller.Router.InitApiRouter(r)
	//gin程序启动
	r.Run(config.ListenAddr)
	//关闭db连接
	db.Close()
}
```


##### (2)建立表的映射关系

model/workflow.go

```go
package model

import "time"

// Workflow 定义结构体，属性与mysql表字段对齐
type Workflow struct {
	// gorm:"primaryKey"用于声明主键
	ID        uint       `json:"id" gorm:"primaryKey"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	DeletedAt *time.Time `json:"deleted_at"`

	Name       string `json:"name"`
	Namespace  string `json:"namespace"`
	Replicas   int32  `json:"replicas"`
	Deployment string `json:"deployment"`
	Service    string `json:"service"`
	Ingress    string `json:"ingress"`
	Type       string `json:"type" gorm:"column:type"`
	//Type: clusterip nodeport ingrress
}

// TableName 定义TableName方法，返回mysql表名，以此来定义mysql中的表名
func (*Workflow) TableName() string {
	return "workflow"
}
```

##### (3)数据库创建表

首先创建数据库

```sql
CREATE DATABASE `kubernetes-manage` CHARACTER SET 'utf8';
```


使用 AutoMigrate 迁移创建表。

AutoMigrate 会创建表、缺失的外键、约束、列和索引。


`db/db.go`

```go
//Init db的初始化函数，与数据库建立连接
func Init() {
	//判断是否已经初始化了
	if isInit {
		return
	}
	//组装连接配置
	//parseTime是查询结果是否自动解析为时间
	//loc是Mysql的时区设置
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8&parseTime=True&loc=Local",
		config.DbUser,
		config.DbPwd,
		config.DbHost,
		config.DbPort,
		config.DbName)
	//与数据库建立连接，生成一个*gorm.DB类型的对象
	var DbType gorm.Dialector
	//DbType := *new(gorm.Dialector)
	if config.DbType == "mysql" {
		DbType = mysql.Open(dsn)
	} else {
		panic("config.DbType!=\"mysql\"")
	}
	//连接数据库
	GORM, err = gorm.Open(DbType, &gorm.Config{})
	if err != nil {
		panic("数据库连接失败" + err.Error())
	}
	////打印sql语句
	//fmt.Println("db", GORM)
	//启用日志记录功能
	//GORM = GORM.Debug()

	//自动创建表
	GORM.AutoMigrate(
		model.Workflow{},
	)

	//开启连接池
	sqlDb, err := GORM.DB()
	if err != nil {
		logger.Error(errors.New("获取Deployment列表失败，" + err.Error()))
		return
	}

	//连接池最大允许的空闲连接数，如果没有sql任务需要执行的连接数大于20，超过的连接会被连接池关闭
	sqlDb.SetMaxIdleConns(config.MaxIdleConns)
	//设置了连接池最大数量
	sqlDb.SetMaxOpenConns(config.MaxOpenConns)
	//设置了连接可复用的最大时间
	sqlDb.SetConnMaxLifetime(time.Duration(config.MaxLifeTime))
	isInit = true
	logger.Info("连接数据库成功！")
}

```

<!-- ```sql
CREATE TABLE `workflow` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(32) COLLATE utf8mb4_general_ci NOT NULL,
  `namespace` varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `replicas` int DEFAULT NULL,
  `deployment` varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `service` varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `ingress` varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `type` varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `deleted_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci
``` -->


##### (4)表数据列表

`dao/workflow.go`

```go
package dao

import (
	"errors"
	"gitee.com/hujianli94net/k8s-platform/db"
	"gitee.com/hujianli94net/k8s-platform/model"

	"github.com/wonderivan/logger"
)

type workflow struct{}

var Workflow workflow

// WorkflowResp 定义列表的返回内容，Items是workflow元素列表，Total为workflow元素数量
type WorkflowResp struct {
	Items []*model.Workflow `json:"items"`
	Total int               `json:"total"`
}

// GetList 获取列表分页查询
func (w *workflow) GetList(namespace string, page, limit int) (data *WorkflowResp, err error) {
	//定义分页数据的起始位置
	startSet := (page - 1) * limit
	//定义数据库查询返回内容
	var workflowList []*model.Workflow
	//数据库查询，Limit方法用于限制条数，Offset方法设置起始位置
	tx := db.GORM.
		Where("namespace = ?", namespace).
		Limit(limit).
		Offset(startSet).
		Order("id desc").
		Find(&workflowList)
	//gorm会默认把空数据也放到err中，故这里要排除空数据的情况
	if tx.Error != nil && tx.Error.Error() != "record not found" {
		logger.Error("获取Workflow列表失败，" + tx.Error.Error())
		return nil, errors.New("获取Workflow列表失败，" + tx.Error.Error())
	}
	return &WorkflowResp{
		Items: workflowList,
		Total: len(workflowList),
	}, nil
}
```

##### (5)获取单条

```go
// GetById 获取workflow单条数据
func (w *workflow) GetById(id int) (workflow *model.Workflow, err error) {
	workflow = &model.Workflow{} //给空间
	tx := db.GORM.Where("id = ?", id).First(&workflow)
	if tx.Error != nil && tx.Error.Error() != "record not found" {
		logger.Error("获取Workflow单条数据失败，" + tx.Error.Error())
		return nil, errors.New("获取Workflow单条数据失败，" + tx.Error.Error())
	}
	return
}
```

##### (6)表数据新增


```go
// Add 新增workflow
func (w *workflow) Add(workflow *model.Workflow) (err error) {
	tx := db.GORM.Create(&workflow)
	if tx.Error != nil {
		logger.Error("添加Workflow失败，" + tx.Error.Error())
		return errors.New("添加Workflow失败，" + tx.Error.Error())
	}
	return
}

```

##### (7)表数据删除

```go
// DelById 删除workflow
// 软删除db.GORM.Delete("id = ?",id)
// model.Workflow 定义包含了 DeletedAt 字段，这通常是用于 GORM 软删除的。因此，在提供的代码中，Delete 方法执行的是软删除操作
// 软删除执行的是UPDATE语句，将deleted_at字段设置为时间即可，gorm默认就是软删
// 实际执行语句UPDATE 'workflow' SET 'deleted_at' = '2022-09-28 16:22:55' WHERE 'id' IN ('1')
// 硬删除db.GORM.Unscoped().Delete("id = ?",id)直接从表中删除这条数据
// 实际执行语句DELETE FROM 'workflow' WHERE 'id' IN ('1');
func (w *workflow) DelById(id int) (err error) {
	tx := db.GORM.Where("id = ?", id).Delete(&model.Workflow{})
	if tx.Error != nil {
		logger.Error("删除Workflow失败，" + tx.Error.Error())
		return errors.New("删除Workflow失败，" + tx.Error.Error())
	}
	return nil
}

```



#### 6.3 Workflow



##### (1)列表

`service/workflow.go`

```go
package service

import (
	"gitee.com/hujianli94net/k8s-platform/dao"
	"gitee.com/hujianli94net/k8s-platform/model"
)

type workflow struct{}

var Workflow workflow

// GetList 获取列表分页查询
func (w *workflow) GetList(namespace string, page, limit int) (data *dao.WorkflowResp, err error) {
	data, err = dao.Workflow.GetList(namespace, page, limit)
	if err != nil {
		return nil, err
	}
	return data, nil
}
```


##### (2)获取Workflow详情

```go
// GetById 查询workflow单条数据
func (w *workflow) GetById(id int) (data *model.Workflow, err error) {
	data, err = dao.Workflow.GetById(id)
	if err != nil {
		return nil, err
	}
	return data, nil
}
```

##### (3)新增Workflow


```go
// WorkflowCreate 定义WorkflowCreate结构体，用于创建workflow需要的参数属性的定义
type WorkflowCreate struct {
	Name          string                 `json:"name"`
	Namespace     string                 `json:"namespace"`
	Replicas      int32                  `json:"replicas"`
	Image         string                 `json:"image"`
	Label         map[string]string      `json:"label"`
	Cpu           string                 `json:"cpu"`
	Memory        string                 `json:"memory"`
	ContainerPort int32                  `json:"container_port"`
	HealthCheck   bool                   `json:"health_check"`
	HealthPath    string                 `json:"health_path"`
	Type          string                 `json:"type"`
	Port          int32                  `json:"port"`
	NodePort      int32                  `json:"node_port"`
	Hosts         map[string][]*HttpPath `json:"hosts"`
}

// workflow名字转换成ingress名字，添加-ing后缀
func getIngressName(workflowName string) (ingressName string) {
	return workflowName + "-ing"
}

// workflow名字转换成service名字，添加-svc后缀
func getServiceName(workflowName string) (ingressName string) {
	return workflowName + "-svc"
}

// 封装创建workflow对应的k8s资源
// 小写开头的函数，作用域只在当前包中，不支持跨包调用
func createWorkflowRes(data *WorkflowCreate) (err error) {
	//声明service类型
	var serviceType string
	//组装DeployCreate类型的数据
	dc := &DeployCreate{
		Name:          data.Name,
		Namespace:     data.Namespace,
		Replicas:      data.Replicas,
		Image:         data.Image,
		Label:         data.Label,
		Cpu:           data.Cpu,
		Memory:        data.Memory,
		ContainerPort: data.ContainerPort,
		HealthCheck:   data.HealthCheck,
		HealthPath:    data.HealthPath,
	}
	//创建deployemnt
	err = Deployment.CreateDeployment(dc)
	if err != nil {
		return err
	}
	//判断service类型
	if data.Type != "Ingress" {
		serviceType = data.Type
	} else {
		serviceType = "ClusterIP"
	}
	//组装ServiceCreate类型的数据
	sc := &ServiceCreate{
		Name:          getServiceName(data.Name),
		Namespace:     data.Namespace,
		Type:          serviceType,
		ContainerPort: data.ContainerPort,
		Port:          data.Port,
		NodePort:      data.NodePort,
		Label:         data.Label,
	}
	err = Service.CreateService(sc)
	if err != nil {
		return err
	}
	//组装IngressCreate类型的数据，创建ingress，只有ingress类型的workflow才有ingress资源，所以这里做了一层判断
	if data.Type == "Ingress" {
		ic := &IngressCreate{
			Name:      getIngressName(data.Name),
			Namespace: data.Namespace,
			Label:     data.Label,
			Hosts:     data.Hosts,
		}
		err = Ingress.CreateIngress(ic)
		if err != nil {
			return err
		}
	}
	return nil
}

// CreateWorkflow 创建workflow
func (w *workflow) CreateWorkflow(data *WorkflowCreate) (err error) {
	//若workflow不是ingress类型，传入空字符串即可
	var ingressName string
	if data.Type == "Ingress" {
		ingressName = getIngressName(data.Name)
	} else {
		ingressName = ""
	}
	//组装mysql中workflow的单条数据
	workflow := &model.Workflow{
		Name:       data.Name,
		Namespace:  data.Namespace,
		Replicas:   data.Replicas,
		Deployment: data.Name,
		Service:    getServiceName(data.Name),
		Ingress:    ingressName,
		Type:       data.Type,
	}
	//调用dao层执行数据库的添加操作
	err = dao.Workflow.Add(workflow)
	if err != nil {
		return err
	}
	//创建k8s资源
	err = createWorkflowRes(data)
	if err != nil {
		return err
	}
	return nil
}
```

##### (4)删除workflow

```go
// 封装删除workflow对应的k8s资源
func delWorkflowRes(workflow *model.Workflow) (err error) {
	//删除deployment
	err = Deployment.DeleteDeployment(workflow.Name, workflow.Namespace)
	if err != nil {
		return err
	}
	//删除service
	err = Service.DeleteService(getServiceName(workflow.Name), workflow.Namespace)
	if err != nil {
		return err
	}
	//删除ingress，这里多了一层判断，因为只有type为ingress的workflow才有ingress资源
	if workflow.Type == "Ingress" {
		err = Ingress.DeleteIngress(getIngressName(workflow.Name), workflow.Namespace)
		if err != nil {
			return err
		}
	}
	return nil
}

// DelById 删除workflow
func (w *workflow) DelById(id int) (err error) {
	//获取workflow数据
	workflow, err := dao.Workflow.GetById(id)
	if err != nil {
		return err
	}
	//删除k8s资源
	err = delWorkflowRes(workflow)
	if err != nil {
		return nil
	}
	//删除数据库数据
	err = dao.Workflow.DelById(id)
	if err != nil {
		return err
	}
	return nil
}
```


`controller/workflow.go`

```go
package controller

import (
	"gitee.com/hujianli94net/k8s-platform/service"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/wonderivan/logger"
)

type workflow struct{}

var Workflow workflow

// GetList 获取列表分页查询
func (w *workflow) GetList(ctx *gin.Context) {
	params := new(struct {
		Namespace string `form:"namespace"`
		Page      int    `form:"page"`
		Limit     int    `form:"limit"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Workflow.GetList(params.Namespace, params.Page, params.Limit)
	if err != nil {
		logger.Error("获取Workflow列表失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "获取Workflow列表成功",
		"data": data,
	})
}

// GetById 查询workflow单条数据
func (w *workflow) GetById(ctx *gin.Context) {
	params := new(struct {
		ID int `form:"id"`
	})
	if err := ctx.Bind(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"mag":  err.Error(),
			"data": nil,
		})
		return
	}
	data, err := service.Workflow.GetById(params.ID)
	if err != nil {
		logger.Error("查询Workflow单条数据失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "查询Workflow单条数据成功",
		"data": data,
	})
}

// Create 创建workflow
func (w *workflow) Create(ctx *gin.Context) {
	var (
		wc  = &service.WorkflowCreate{}
		err error
	)
	if err = ctx.ShouldBindJSON(wc); err != nil {
		logger.Error("Bind请求参数dc失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	if err = service.Workflow.CreateWorkflow(wc); err != nil {
		logger.Error("创建Workflow失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{})
	}
}

// DelById 删除workflow
func (w *workflow) DelById(ctx *gin.Context) {
	params := new(struct {
		ID int `json:"id"`
	})
	if err := ctx.ShouldBindJSON(params); err != nil {
		logger.Error("Bind请求参数失败，" + err.Error())
		ctx.JSON(http.StatusOK, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	if err := service.Workflow.DelById(params.ID); err != nil {
		logger.Error("删除Workflow失败，" + err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"msg":  err.Error(),
			"data": nil,
		})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{
		"msg":  "删除Workflow成功",
		"data": nil,
	})
}
```



`controller/router.go`

```go
package controller

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

// Router 实例化router结构体，可使用该对象点出首字母大写的方法（包外调用）
var Router router

// 创建router结构体
type router struct{}

// InitApiRouter 初始化路由规则
func (r *router) InitApiRouter(router *gin.Engine) {
	// 创建测试api接口
	router.GET("/testapi", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{
			"msg":  "testapi success!",
			"data": nil,
		})
	}).
		//工作流
		GET("/api/k8s/workflows", Workflow.GetList).
		GET("/api/k8s/workflow/detail", Workflow.GetById).
		POST("/api/k8s/workflow/create", Workflow.Create).
		DELETE("/api/k8s/workflow/del", Workflow.DelById).

		//pod操作
		GET("/api/k8s/pods", Pod.GetPods).
		GET("/api/k8s/pod/detail", Pod.GetPodDetail).
		DELETE("/api/k8s/pod/del", Pod.DeletePod).
		PUT("/api/k8s/pod/update", Pod.UpdatePod).
		GET("/api/k8s/pod/container", Pod.GetPodContainer).
		GET("/api/k8s/pod/log", Pod.GetPodLog).
		GET("/api/k8s/pod/numnp", Pod.GetPodNumPerNp).

		//deployment操作
		GET("/api/k8s/deployments", Deployment.GetDeployments).
		GET("/api/k8s/deployment/detail", Deployment.GetDeploymentDetail).
		PUT("/api/k8s/deployment/scale", Deployment.ScaleDeployment).
		DELETE("/api/k8s/deployment/del", Deployment.DeleteDeployment).
		PUT("/api/k8s/deployment/restart", Deployment.RestartDeployment).
		PUT("/api/k8s/deployment/update", Deployment.UpdateDeployment).
		GET("/api/k8s/deployment/numnp", Deployment.GetDeployNumPerNp).
		POST("/api/k8s/deployment/create", Deployment.CreateDeployment).

		//daemonset操作
		GET("/api/k8s/daemonsets", DaemonSet.GetDaemonSets).
		GET("/api/k8s/daemonset/detail", DaemonSet.GetDaemonSetDetail).
		DELETE("/api/k8s/daemonset/del", DaemonSet.DeleteDaemonSet).
		PUT("/api/k8s/daemonset/update", DaemonSet.UpdateDaemonSet).

		//statefulset操作
		GET("/api/k8s/statefulsets", StatefulSet.GetStatefulSets).
		GET("/api/k8s/statefulset/detail", StatefulSet.GetStatefulSetDetail).
		DELETE("/api/k8s/statefulset/del", StatefulSet.DeleteStatefulSet).
		PUT("/api/k8s/statefulset/update", StatefulSet.UpdateStatefulSet).

		//service操作
		GET("/api/k8s/services", Servicev1.GetServices).
		GET("/api/k8s/service/detail", Servicev1.GetServiceDetail).
		DELETE("/api/k8s/service/del", Servicev1.DeleteService).
		PUT("/api/k8s/service/update", Servicev1.UpdateService).
		POST("/api/k8s/service/create", Servicev1.CreateService).

		//ingress操作
		GET("/api/k8s/ingresses", Ingress.GetIngresses).
		GET("/api/k8s/ingress/detail", Ingress.GetIngressDetail).
		DELETE("/api/k8s/ingress/del", Ingress.DeleteIngress).
		PUT("/api/k8s/ingress/update", Ingress.UpdateIngress).
		POST("/api/k8s/ingress/create", Ingress.CreateIngress).

		//configmap操作
		GET("/api/k8s/configmaps", ConfigMap.GetConfigMaps).
		GET("/api/k8s/configmap/detail", ConfigMap.GetConfigMapDetail).
		DELETE("/api/k8s/configmap/del", ConfigMap.DeleteConfigMap).
		PUT("/api/k8s/configmap/update", ConfigMap.UpdateConfigMap).

		//sercret操作
		GET("/api/k8s/secrets", Secret.GetSecrets).
		GET("/api/k8s/secret/detail", Secret.GetSecretDetail).
		DELETE("/api/k8s/secret/del", Secret.DeleteSecret).
		PUT("/api/k8s/secret/update", Secret.UpdateSecret).

		//pvc操作
		GET("/api/k8s/pvcs", Pvc.GetPvcs).
		GET("/api/k8s/pvc/detail", Pvc.GetPvcDetail).
		DELETE("/api/k8s/pvc/del", Pvc.DeletePvc).
		PUT("/api/k8s/pvc/update", Pvc.UpdatePvc).

		//node操作
		GET("/api/k8s/nodes", Node.GetNodes).
		GET("/api/k8s/node/detail", Node.GetNodeDetail).

		//namespace操作
		GET("/api/k8s/namespaces", Namespace.GetNamespaces).
		GET("/api/k8s/namespace/detail", Namespace.GetNamespaceDetail).
		DELETE("/api/k8s/namespace/del", Namespace.DeleteNamespace).

		//pv操作
		GET("/api/k8s/pvs", Pv.GetPvs).
		GET("/api/k8s/pv/detail", Pv.GetPvDetail)
}
```


### 7. 中间件


#### 7.1什么是中间件



![1701079033842](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1701079033842.4xggjwpkrcw0.webp){: .zoom}


中间件，英译middleware，顾名思义，放在中间的物件，那么放在谁中间呢？本来，客户端可以直接请求到服务端接口。现在，中间件横插一脚，它能在请求到达接口之前拦截请求，做一些特殊处理，比如日志记录，故障处理等。




#### 7.2 gin中间件用法


![1701079134241](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1701079134241.71uglfgapns0.webp){: .zoom}


因为gin的中间件函数与业务逻辑处理函数是放到gin的队列中的，所以当一个中间件函数执行return语句时只代表当前中间件函数执行完了，gin框架会驱动index++,然后执行队列中后续的中间件函数或逻辑处理函数，当在中间件函数中执行context.Next()时，gin框架也会驱动index++，执行下一个函数。当执行context.Abort()时，会修改c.index = 63.5,由于该索引不存在，所以队列中后面的的中间件函数和逻辑处理函数就不会执行了。

（1）定义一个返回值是gin.HandlerFunc的方法

（2）在方法中根据context上下文添加中间件逻辑

（3）中间件逻辑未通过，使用context.Abort()和return停止下个函数的执行

（4）中间件逻辑通过时，使用context.Next()继续执行下个函数

（5）定义好中间件函数后，在main中使用use()将其加入到队列中，注意use一定要在初始化路由的前面，否则不会生效




#### 7.3 Cors跨域

代码层直接处理跨域请求，不需要前面再加一层nginx处理，解决前后端域名不同、IP不同甚至端口不同导致的跨域报错。

`middle/cors.go`

```go
package middle

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

// Cors 处理跨域请求，支持options访问
func Cors() gin.HandlerFunc {
	return func(c *gin.Context) {
		//获取请求方法
		method := c.Request.Method
		//添加跨域响应头
		c.Header("Content-Type", "application/json")
		//c.Header("Content-Type", "*")
		c.Header("Access-Control-Allow-Origin", "*")
		c.Header("Access-Control-Max-Age", "86400")
		c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE, UPDATE")
		//c.Header("Access-Control-Allow-Methods", "*")
		c.Header("Access-Control-Allow-Headers", "X-Token, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Max")
		c.Header("Access-Control-Allow-Credentials", "false")
		//旅行所有OPTIONS方法
		if method == "OPTIONS" {
			c.AbortWithStatus(http.StatusNoContent)
		}
		//fmt.Println("c.Request", c.Request)
		//处理请求
		c.Next()
	}
}
```

`main.go`

```go
package main

import (
	"gitee.com/hujianli94net/k8s-platform/config"
	"gitee.com/hujianli94net/k8s-platform/controller"
	"gitee.com/hujianli94net/k8s-platform/db"
	"gitee.com/hujianli94net/k8s-platform/middle"
	"gitee.com/hujianli94net/k8s-platform/service"

	"github.com/gin-gonic/gin"
)

func main() {
	//初始化k8s client
	service.K8s.Init()
	//初始化数据库
	db.Init()
	//初始化gin对象
	r := gin.Default()
	//初始化k8s client
	service.K8s.Init()
	//跨域配置
	r.Use(middle.Cors())
	//初始化路由规则
	controller.Router.InitApiRouter(r)
	//gin程序启动
	r.Run(config.ListenAddr)
	//关闭db连接
	db.Close()
}
```



#### 7.4 JWT token验证

验证请求的合法性，前端只有在登录状态下才会生成token，请求时将token放入Header中，后端接收的请求时，先由该中间件验证token是否合法，合法时才放行，继续执行业务函数的逻辑处理。


`utils/jwt.go`

```go
package utils

import (
	"errors"
	"github.com/dgrijalva/jwt-go"
	"github.com/wonderivan/logger"
)

type jwtToken struct{}

var JWTToken jwtToken

// CustomClaims token中包含的自定义信息以及jwt签名信息
type CustomClaims struct {
	Username string `json:"username"`
	Password string `json:"password"`
	jwt.StandardClaims
}

// 加解密因子
const (
	SECRET = "adoodevops"
)

// ParseToken 解析token
func (*jwtToken) ParseToken(tokenString string) (claim *CustomClaims, err error) {
	//使用jwt.ParseWithClaims方法解析token，这个token是前端传给我们的，获得一个*Token类型的对象
	token, err := jwt.ParseWithClaims(tokenString, &CustomClaims{}, func(token *jwt.Token) (interface{}, error) {
		return []byte(SECRET), nil
	})
	if err != nil {
		logger.Error("parse token failed", err)
		//处理token解析后的各种错误
		if ve, ok := err.(*jwt.ValidationError); ok {
			if ve.Errors&jwt.ValidationErrorMalformed != 0 {
				return nil, errors.New("TokenMalformed")
			} else if ve.Errors&jwt.ValidationErrorExpired != 0 {
				return nil, errors.New("TokenExpired")
			} else if ve.Errors&jwt.ValidationErrorNotValidYet != 0 {
				return nil, errors.New("TokenNotValidYet")
			} else {
				return nil, errors.New("TokenInvalid")
			}
		}
	}
	//转换成*CustomClaims类型并返回
	if claims, ok := token.Claims.(*CustomClaims); ok && token.Valid {
		return claims, nil
	}
	return nil, errors.New("解析Token失败")
}
```

`middle/jwt.go`

```go
package middle

import (
	"gitee.com/hujianli94net/k8s-platform/utils"
	"net/http"

	"github.com/gin-gonic/gin"
)

// 中间件，检查token
func JWTAuth() gin.HandlerFunc {
	return func(c *gin.Context) {
		//对登录接口放行
		if len(c.Request.URL.String()) >= 10 && c.Request.URL.String()[0:10] == "/api/login" {
			c.Next()
		} else {
			//获取Header中的Authorization
			token := c.Request.Header.Get("Authorization")
			if token == "" {
				c.JSON(http.StatusBadRequest, gin.H{
					"msg":  "请求未携带token，无权限访问",
					"data": nil,
				})
				c.Abort()
				return
			}
			//parseToken解析token包含的信息
			claims, err := utils.JWTToken.ParseToken(token)
			if err != nil {
				//token延期错误
				if err.Error() == "TokenExpired" {
					c.JSON(http.StatusBadRequest, gin.H{
						"msg":  "授权已过期",
						"data": nil,
					})
					c.Abort()
					return
				}
				//其他解析错误
				c.JSON(http.StatusBadRequest, gin.H{
					"msg":  err.Error(),
					"data": nil,
				})
				c.Abort()
				return
			}
			//继续交由下一个路由处理，并将解析出的信息传递下去
			c.Set("claims", claims)
			c.Next()
		}
	}
}

```

`main.go`


```go
package main

import (
	"gitee.com/hujianli94net/k8s-platform/config"
	"gitee.com/hujianli94net/k8s-platform/controller"
	"gitee.com/hujianli94net/k8s-platform/db"
	"gitee.com/hujianli94net/k8s-platform/middle"
	"gitee.com/hujianli94net/k8s-platform/service"

	"github.com/gin-gonic/gin"
)

func main() {
	//初始化k8s client
	service.K8s.Init()
	//初始化数据库
	db.Init()
	//初始化gin对象
	r := gin.Default()
	//初始化k8s client
	service.K8s.Init()
	//跨域配置
	r.Use(middle.Cors())
	//jwt token验证
	r.Use(middle.JWTAuth())
	//初始化路由规则
	controller.Router.InitApiRouter(r)
	//gin程序启动
	r.Run(config.ListenAddr)
	//关闭db连接
	db.Close()
}
```
