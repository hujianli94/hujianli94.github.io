# K8s管理系统-后端API开发


本文档为后端服务器部分

kubernetes客户端库文档：

https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries/




[gitee仓库地址](https://gitee.com/wangzilong9570/k8s-platform)


> 提示：需要配置k8s集群和MySQL数据库



## 1. 项目背景

随着容器技术的广泛应用，kubernetes逐渐成为业内的核心技术，是容器编排技术的首选工具。

而k8s管理平台在日常的容器维护中也发挥着举足轻重的作用，但随着k8s的定制化功能越来越多，dashboard 已经无法满足日常的维护需求，且 dashboard 的源码学习成本较高，抽象程度较高，二次开发成本也就比较高。


本项目使用当下较主流的前端 vue+element plus 及后端 go+gin 框架，打造与dashboard对标的k8s管理功能，且可定制化程度高，

同学们在入门后可根据自身需求，进行灵活定制开发，且本课程除了学习相关知识点外，会带着大家逐渐掌握开发习惯与技巧，让大家在日常工作中高效、高质量的进行开发作业。




## 2. 前后端分离概述


前后端分离已成为互联网项目开发的业界标准使用方式，通过 nginx+tomcat 的方式（也可以中间加一个node.js）有效的进行解耦，

并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多段话服务（多种客户端，例如：浏览器，车载终端，安卓IOS等）打下坚实的基础。

这个步骤是系统架构学习的必经之路。



![1698135577748](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698135577748.6u24tknnt9w0.png){: .zoom}





前后分离的优势：


1. 可以实现真正的前后端解耦，前端服务器使用nginx
2. 发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象
3. 在大并发情况下，可以同时水平扩展前后端服务器。
4. 增加代码的维护性&易读性（前后端耦合在一起的代码阅读比较费劲）
5. 提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖




## 3. 功能设计


![1698135709154](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698135709154.3anyxowdo8m.webp){: .zoom}



## 4. Client-go介绍


### 4.1 简介

client-go 是 kubernetes 官方提供的 go 语言的客户端库，go 应用使用该库可以访问 kubernetes 的 API Server，这样我们就能通过编程来对 kubernetes 资源进行增删改查操作。

除了提供丰富的 API 用于操作 kubernetes 资源，client-go 还为 controller 和 operator 提供了重要支持 client-go 的 informer 机制，可以将 controller 关注的资源变化及时带给此 controller，使 controller 能够及时响应变化。

通过 client-go 提供的客户端对象与 kubernetes 的 API Server 进行交互，而 client-go 提供了以下四种客户端对象：

1. RESTClient这是最基础的客户端对象，仅为HTTPRequest进行了封装，实现RESTFul风格API，这个对象的使用并不方便，因为很多参数都要使用者来设置，于是client-go基于RESTClient又实现了三种新的客户端对象。
2. ClientSet把Resource和Version也封装成了方法，用起来更简单直接，一个资源是一个客户端，多个资源就对应了多个客户端，所以ClientSet就是多个客户端的集合了，这样就好理解了，不过ClientSet只能访问内置资源，访问不了自定义资源
3. DynamicClient可以访问内置资源和自定义资源，个人感觉有点像java的集合操作，拿出的内容是Object类型，按实际情况自己去做强制转换，当然了也会有强制转换失败的风险
4. DiscoveryClient用于发现kubernetes的API Server支持的Group、Version、Resources等信息         //kubectl api-resources



### 4.2 环境搭建


#### 安装精简版K8S(K3S)环境

k3s的官方网址: https://k3s.io

github地址：https://github.com/k3s-io/k3s




> 前提

- [x] 安装centos7
- [x] 安装docker


```sh
yum install -y yum-utils device-mapper-persistent-data lvm2
# 阿里源或者清华源 
sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# sudo yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo
yum list docker-ce --showduplicates | sort -r
yum install docker-ce docker-ce-cli containerd.io

systemctl start docker
systemctl daemon-reload
systemctl restart docker

docker run -itd -p 80:80  nginx:1.18-alpine
```


> 安装

k3s的三个文件：

- k3s
- k3s-airgap-images-amd64.tar
- k3s-install.sh

对于国内用户来说，访问Github超级慢，为了方便下载，可以直接使用下面百度云盘方式下载：

百度网盘下载：

https://pan.baidu.com/s/1Ca1mxigeXOB7QaFLl5xM6A   提取码：8888


```sh
chmod +x k3s
cp k3s /usr/local/bin/

docker load -i k3s-airgap-images-amd64.tar

export INSTALL_K3S_SKIP_DOWNLOAD=true

export INSTALL_K3S_EXEC="--docker --bind-address=192.168.1.147 \
  --cluster-cidr=10.128.0.0/16 --service-cidr=10.129.0.0/16  \
  --kube-apiserver-arg service-node-port-range=30000-50000 \
  --no-deploy traefik --no-deploy servicelb \
  --write-kubeconfig ~/.kube/config --write-kubeconfig-mode 666"

sh k3s-install.sh

kubectl get pod -A
NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE
kube-system   local-path-provisioner-58fb86bdfd-dgjdm   1/1     Running   0          62s
kube-system   metrics-server-6d684c7b5-mcfv4            1/1     Running   0          62s
kube-system   coredns-6c6bb68b64-x9p6c                  1/1     Running   0          62s


# kubectl补全
# centos7上
yum -y install bash-completion
# ubuntu上
sudo apt install bash-completion

 
# 在 bash 中设置当前 shell 的自动补全
source <(kubectl completion bash) 
# 在你的 bash shell 中永久地添加自动补全
echo "source <(kubectl completion bash)" >> ~/.bashrc 
source /usr/share/bash-completion/bash_completion


# 快捷键
cat >> ~/.bashrc <<EOF
alias k=kubectl
complete -o default -F __start_kubectl k
EOF
```


[k3s安装](https://www.yuque.com/leryn/wiki/cloud.k8s.k3s)


[离线搭建部署高可用 k3s 集群](https://jueee.github.io/2021/09/2021-09-15-%E7%A6%BB%E7%BA%BF%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8k3s%E9%9B%86%E7%BE%A4/)


[k3s 国内离线安装方法](https://imroc.cc/kubernetes/deploy/k3s/offline-installation)


[k3s 官方离线安装方法](https://docs.k3s.io/zh/installation/airgap#%E5%AE%89%E8%A3%85-k3s)


[How to Install k3s Kubernetes Cluster on Ubuntu 22.04](https://www.linuxbuzz.com/install-k3s-kubernetes-cluster-on-ubuntu/)




#### 安装golang环境

在k8s-master节点上

```sh
# 一：yum安装
yum install -y epel-release
yum install -y golang
 

# 二：手动配置 去官网下载安装包手动编译安装
mkdir ~/go && cd ~/go
wget https://dl.google.com/go/go1.17.8.linux-amd64.tar.gz
# 解压到/usr/local目录下
tar -C /usr/local -zxvf go1.17.8.linux-amd64.tar.gz

# 添加/usr/local/go/bin目录到PATH变量中
vi ~/.bashrc
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin

# 刷新配置
source ~/.bashrc
```


新建k8s-platform项目，设置goland远程环境运行

![1698201779063](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698201779063.10verb6egj5c.png){: .zoom}


![1698202043803](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698202043803.56pntwrwyyg0.png){: .zoom}

户名，填写密钥



### 4.3 代码示例


#### 创建一个测试pod

```sh
kubectl run -i --tty alpine-$RANDOM --image=alpine:latest -- sh
# -restart=Never 意味着这个 Pod 不会被重启。

# --rm 会在退出时自动删除这个 Pod
# kubectl run -it --rm test-pod --image=appropriate/curl --restart=Never -- /bin/sh

kubectl run -i --tty busybox --image=busybox -- sh

kubectl run ubuntu --image=ubuntu:20.04 --restart=Always -- /bin/bash -c "while true; do sleep 30; done;"
# kubectl run -i --tty ubuntu --image=ubuntu:20.04 --restart=Never -- bash -il
```

我们这里在default名称空间下运行3个测试pod

```sh
kubectl get pod
NAME                           READY   STATUS    RESTARTS   AGE
alpine-9594-7997b99597-z2k6m   1/1     Running   1          14m
busybox-6cd57fd969-5sxvp       1/1     Running   1          13m
ubuntu-797bd794cf-bv75b        1/1     Running   0          3s
```



main.go


```go
package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"path/filepath"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd" //可能需要挂vpn,留意版本问题
)

func main() {
	//声明kubeconfig配置文件
	var kubeconfig *string
	//获取home环境变量，拿到$HOME/.kube/config配置文件
	if home := homeDir(); home != "" {
		kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"),
			"(optional) absolute path to the kubeconfig file")
	} else {
		//否则就根据kubeconfig传到获得config的路径
		kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
	}
	flag.Parse()
	//将kubeconfig文件转换成rest.config类型文件
	//*kubeconfig其实就是kubeconfig文件的默认位置地址，直接填入地址字符串也可
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		panic(err.Error())
	}
	//根据rest.config类型的对象，new一个clientset出来
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err.Error())
	}
	//通过client-go sdk获取pods列表，命名空间是default
	pods, err := clientset.CoreV1().Pods("default").List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		panic(err.Error())
	}
	//打印pod测试
	for _, pod := range pods.Items {
		fmt.Println(pod.Name, pod.Namespace)
	}
}

func homeDir() string {
	if h := os.Getenv("HOME"); h != "" {//linux
		return h
	}
	return os.Getenv("USERPROFILE") //windows
}

```

运行结果

```sh
alpine-9594-7997b99597-z2k6m default
busybox-6cd57fd969-5sxvp default
ubuntu-797bd794cf-bv75b default
```

获取到了pod名和命名空间



### 4.4 常用方法

```go
//获取pod列表 
podList, err := K8s.ClientSet.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{}) 

//获取pod详情 
pod, err = K8s.ClientSet.CoreV1().Pods(namespace).Get(context.TODO(), podName, metav1.GetOptions{}) 

//删除pod 
err = K8s.ClientSet.CoreV1().Pods(namespace).Delete(context.TODO(), podName, metav1.DeleteOptions{}) 

//更新pod（完整yaml） 
pod, err = K8s.ClientSet.CoreV1().Pods(namespace).Update(context.TODO(), pod, metav1.UpdateOptions{}) 

//获取deployment副本数 
scale, err := K8s.ClientSet.AppsV1().Deployments(namespace).GetScale(context.TODO(), deploymentName, metav1.GetOptions{}) 

//创建deployment 
deployment, err = K8s.ClientSet.AppsV1().Deployments(data.Namespace).Create(context.TODO(), deployment, metav1.CreateOptions{}) 

//更新deployment（部分yaml） 
deployment, err = K8s.ClientSet.AppsV1().Deployments(namespace).Patch(context.TODO(), deploymentName, "application/strategic-merge-patch+json", patchByte, metav1.PatchOptions{})
```

## 5. 项目目录结构


![1698204465060](https://cdn.jsdelivr.net/gh/hujianli94/Picgo-atlas@main/img/1698204465060.6qcpqwmfgyo0.png){: .zoom}


- config：定义全局配置，如监听地址、管理员账号等。
- controller：controller层，定义路由规则，及接口入参和响应。
- service：服务层，处理接口的业务逻辑。
- dao：数据库操作，包含数据库的增删改查。
- model：定义数据库的表的字段。
- db: 用于初始化数据库连接以及配置。
- middle：中间件层，添加全局的逻辑处理，如跨域、jwt验证等。
- utils：工具目录，定义常用工具，如token解析，文件操作等。
- go.mod：定义项目的依赖包以及版本。
- main.go：项目的主入口 main函数。



## 6. 框架搭建
