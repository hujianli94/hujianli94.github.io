# Go基础语法


## 1.基础语法

### 1.1 Go语言标记

Go程序由关键字、字符串、常量、标识符、符号等多种标记组成。



### 1.2 行分隔符
如果多行语句在一行，必须用；分隔符隔开，Go编辑器会自动在行尾加速；分隔符，所以不需要手动再语句后面再加；



### 1.3 注释

单行注释
```
//
```



多行注册

``` 
/*
多行注释
多行注释
*/
```


### 1.4 标识符

标识符实际上就是一个或者多个字符、数字、下划线(_)组成的字符串序列。

标识符的命名需要遵守以下规则：

- 由 26 个英文字母、0~9、`_`组成；
- 不能以数字开头，例如 var 1num int 是错误的；
- Go语言中严格区分大小写；
- 标识符不能包含空格；
- 不能以系统保留关键字作为标识符，比如 break，if 等等。


命名标识符时还需要注意以下几点：

- 标识符的命名要尽量采取简短且有意义；
- 不能和标准库中的包名重复；
- 为变量、函数、常量命名时采用驼峰命名法，例如 stuName、getVal



正确命名的标识符

```
product  user add  user_name   abc_123
resultValue name1  _tmp k
```

错误命名的标识符

```
switch		(错误命名，Go语言的关键字)	
3ab			(错误命名: 以数字开通)
c-d			(错误命名：运算符是不允许的)
```


### 1.5 字符串拼接

字符串可以通过"+"号实现字符串连接。


如下所示：

```go
package main
import "fmt"
func main () {
    fmt.Println("Go web 编程实战" + "----从入门到精通")
}
```


### 1.6 Go语言的关键字

Go语言中的关键字一共有 25 个：


| break    | default     | func   | interface | select |
| -------- | ----------- | ------ | --------- | ------ |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |




### 1.7 Go语言中的空格

空格让代码更容易阅读，Goland编辑器可以使用"Ctrl+Alt+L"命令进行快速格式化。


## 2. 变量



### 2.1 声明


声明变量的一般形式是使用 var 关键字：

var name type


其中，var 是声明变量的关键字，name 是变量名，type 是变量的类型。


#### 2.1.1 标准格式

Go语言的变量声明的标准格式为：

```
var 变量名 变量类型
```

变量声明以关键字 var 开头，后置变量类型，行尾无须分号。

#### 2.1.2 批量格式

```go
var (
    a int
    b string
    c []float32
    d func() bool
    e struct {
        x int
    }
)
```

#### 2.1.3 简短格式

除 var 关键字外，还可使用更加简短的变量定义和初始化语法。

```
名字 := 表达式
```

需要注意的是，简短模式（short variable declaration）有以下限制：

- 定义变量，同时显式初始化。
- 不能提供数据类型。
- 只能用在函数内部。


和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：

```go
i, j := 0, 1
```

下面通过一段代码来演示简短格式变量声明的基本样式。

```go
func main() {   
	x:=100   
	a,s:=1, "abc"
}
```



### 2.2 赋值

#### 2.2.1 单个变量赋值


```go
var a int = 100
var b int = 200

var attack = 40
var defence = 20
var damageRate float32 = 0.17

// 短变量赋值
hp := 100
```



#### 2.2.2 多个变量赋值

声明一个用户的年龄、名字、余额

```go
var (
	age int=18
	name string = "shirdon"
	balance float32 = 99999.99
)
```

另外一种声明形式

```go
var age,name,balance = 18,"shirdon",99999.99
```

简单的形式

```go
age,name,balance := 18,"shirdon",99999.99
```

变量的交换

```go
d,c:="D","C"
c,d = d,c
```



#### 2.2.3 变量作用域



##### 1. 局部变量

局部变量作用域只在函数体内。

**局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。**

```go
package main
import (
    "fmt"
)
func main() {
    //声明局部变量 a 和 b 并赋值
    var a int = 3
    var b int = 4
    //声明局部变量 c 并计算 a 和 b 的和
    c := a + b
    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
```



##### 2. 全局变量

在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用"import"关键字引入全局变量所在的源文件之后才能使用这个全局变量。

全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。

```go
package main
import "fmt"
//声明全局变量
var c int
func main() {
    //声明局部变量
    var a, b int
    //初始化参数
    a = 3
    b = 4
    c = a + b
    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
```

#### 2.2.4 实践-编程实现人机交互

```go

package main

import "fmt"

func main() {
	// 定义变量name, age, addr
	// 用于存储用户输入的数据
	var name, age, addr string
	// 输出操作提示
	fmt.Printf("请输入你的名字：\n")
	// 存储用户输入数据
	fmt.Scanln(&name)
	// 输出操作提示
	fmt.Printf("请输入你的年龄：\n")
	// 存储用户输入数据
	fmt.Scanln(&age)
	// 输出操作提示
	fmt.Printf("请输入你的居住地：\n")
	// 存储用户输入数据
	fmt.Scanln(&addr)
	// 输出用户输入的所有数据
	fmt.Printf("你的名字是：%v，年龄：%v，居住地：%v", name, age, addr)
}
```

## 3. 常量

常量的定义格式和变量的声明语法类似：`const name [type] = value`，例如：

```go

const pi = 3.14159 // 相当于 math.Pi 的近似值

```

在Go语言中，你可以省略类型说明符 [type]，因为**编译器可以根据变量的值来推断其类型。**

- 显式类型定义： const b string = "abc"
- 隐式类型定义： const b = "abc"



和变量声明一样，可以批量声明多个常量:

```go
const (
    e  = 2.7182818
    pi = 3.1415926
)
```

如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。例如：

```go
const (
    a = 1
    b
    c = 2
    d
)
fmt.Println(a, b, c, d) // "1 1 2 2"
```

### 3.1 iota常量生成器

常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。

```go
type Weekday int
const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```


周日将对应 0，周一为 1，以此类推。



### 3.2 延迟明确常量的具体类型

Go语言的常量有一个不同寻常指出：虽然一个常量可以有任意一个确定的基础类型（例如`int`或`float64`，或者是类似`time.Duration`这样的基础类型），但是许多常量并没有一个明确的基础类型。

编译器为这些没有明确的基础类型的数字常量，提供比基础类型更高精度的算数运算。



Go语言有6种未明确类型的常量类型：

- 无类型的布尔型
- 无类型的整数
- 无类型的字符
- 无类型的浮点数
- 无类型的复数
- 无类型的字符串




例如，无类型的浮点数常量math.Pi，可以直接用于任何需要浮点数或复数的地方：

```go
var a float32 = math.Pi
var b float64 = math.Pi
var c complex128 = math.Pi
```



如果math.Pi被确定未特定类型（比如float64），则结果精度可能会不一样。同时在需要float32或complex128类型值得地方，需要对其进行一个明确得强制类型转换：

```go
const Pi64 float64 = math.Pi
var a float32 = float32(Pi64)
var b float64 = Pi64
var c complex128 = complex128(Pi64)
```

对于常量面值，不同的写法会对应不同得类型。例如`0`、`0.0`、`0i`和`\u0000`虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，`true`和`false`也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。







## 4. 运算符

运算符的优先级

表达式如下：

```go
var a, b, c int = 3, 6, 9
d := a + b * c
```


```go
package main

import "fmt"

func main(){
	var x, y = 8, 5
	fmt.Printf("加法运算符：%d\n", x+y)
	fmt.Printf("减法运算符：%d\n", x-y)
	fmt.Printf("乘法运算符：%d\n", x*y)
	fmt.Printf("除法运算符：%d\n", x/y)
	fmt.Printf("取模运算符：%d\n", x%y)
	x++
	fmt.Printf("幂运算符：%d\n", x)
	y--
	fmt.Printf("取整运算符：%d\n", y)

  fmt.Printf("x大于y：%v\n", x > y)
	fmt.Printf("x大于或等于y：%v\n", x >= y)
	fmt.Printf("x小于y：%v\n", x < y)
	fmt.Printf("x小于或等于y：%v\n", x <= y)
	fmt.Printf("x等于y：%v\n", x == y)
	fmt.Printf("x不等于y：%v\n", x != y)

	var a, b, c, d = true, true, false, false
	fmt.Printf("a&&b的值为：%v\n", a && b)
	fmt.Printf("a&&c的值为：%v\n", a && c)
	fmt.Printf("c&&d的值为：%v\n", c && d)
	fmt.Printf("a||b的值为：%v\n", a || b)
	fmt.Printf("a||c的值为：%v\n", a || c)
	fmt.Printf("c||d的值为：%v\n", c || d)
	fmt.Printf("!a的值为：%v\n", !a)
	fmt.Printf("!c的值为：%v\n", !c)
}

```

与其他语言的优先级是一样的，这里不做扩展。




## 5. 流程控制语句

### 5.1.1 if-else

在Go语言中，关键字`if`用于判断某个条件（布尔型或逻辑型）。

如果该条件成立，则会执行`if`后面由大括号`{}`括起来的代码块，否则就忽略该代码块继续执行后续的代码。


```go
if b > 10 {
	return 1
}
```

如果存在第2个分支，则可以在上面代码的基础上添加`else`关键字及另一代码块，见下方代码。

这个代码块中的代码只有在`if`条件不满足时才会执行。

`if{}`和`else{}`中的两个代码块是相互独立的分支，两者只能执行其中一个。

```go
if b > 10 {
	return 1
}else{
	return 2
}
```

如果存在第3分支，则可以使用下面这种3个独立分支的形式：

```go
if b > 10 {
	return 1
}else if b == 10{
	return 2
}else{
	return 3
}
```

一般来说，`else-if`分支的数量是没有限制的。

但是为了代码的可读性，最好不要在`if`后面加入太多的`else-if`结构。

如果必须使用这种形式，则尽可能把先满足的条件放在前面。

关键字`if`和`else`之后的左大括号`{`必须和关键字在同一行。

如果使用了`else-if`结构，则前段代码块的右大括号`}`必须和`else if`语句在同一行。

这两条规则都是被编译器强制规定的，如果不满足，则编译不能通过。






### 5.1.2 for

Go语言种的循环语句只支持`for`关键字，不支持`while`和`do-while`结构。

```go
package main

import "fmt"

func main() {
	// 组合方式一
	for i := 1; i < 10; i++ {
		fmt.Printf("本次循环：%v\n", i)
	}
	// 组合方式二
	for i := 1; i < 10; {
		fmt.Printf("本次循环：%v\n", i)
		i++
	}
	// 组合方式三
	var i int = 1
	for i < 5 {
		fmt.Printf("本次循环：%v\n", i)
		i++
	}
	// 组合方式四
	for {
		fmt.Printf("本次循环：%v\n", i)
		break
	}
}
```


```go
product := 1
for i := 1; i < 5; i++{
	product *= i
}
```


无限循环场景

```go
i := 0
for {
	i++
	if i > 50 {
		break
	}
}
```

在使用循环语句时，需要注意以下几点：

- 左花括号{必须与for处于同一行。

- Go语言种的for循环与C语言一样，都允许在循环条件中定义和初始化变量。唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。

- Go语言的for循环同样支持用continue和break来控制循环，但它提供了一个更高级的break——可以选择中断哪一个循环，如下例：


```go
JumpLoop:
	for j := 0; j < 5; j++{
		for i := 0; i < 5; i++{
			if i > 2{
				break JumpLoop
			}
			fmt.Println(i)
		}
	}
```



在上述代码中，`break`语句终止的是`JumpLoop`标签对应的`for`循环。`for`中的初始语句是在第1次循环前执行的语句。

一般使用初始语句进行变量初始化，但如果变量在`for`循环中被声明，则其作用域只是这个`for`的范围。

初始语句可以被忽略，但是初始语句之后的**分号**必须要写，代码如下：

```go
j := 2
for ; j > 0; j--{
	fmt.Println(j)
}
```

在上面这段代码中，将`j`放在`for`的前面进行初始化，`for`中没有初始语句，此时`j`的作用域比在初始语句中声明的`j`的作用域要大

for中的条件表达式是控制是否循环的开关。

在每次循环开始前，都会判断条件表达式，如果表达式为true，则循环继续；否则结束循环。

条件表达式可以被忽略，忽略条件表达式后默认形成无限循环。


下面代码会忽略条件表达式，但是保留结束语句：


```go
var i int 
JumpLoop:
for ; ; i++{
	if i > 10 {
		// println(i)
		break JumpLoop
	}
}
```


美观的写法

```go
var i int
for {
	if i > 10 {
		break
	}
	i++
}
```

在`for`循环中，如果循环被`break`、`goto`、`return`、`panic`等语句强制退出，则之后的语句不会被执行。


#### continue

```go
import "fmt"

func main() {
	for i := 0; i < 10; i++ {
		if i == 5 {
			continue
		}
		fmt.Println(i)
	}
}
```

#### break

```go
import "fmt"

func main() {
	for i := 0; i < 10; i++ {
		if i == 5 {
			break
		}
		fmt.Println(i)
	}
}
```

#### goto

goto语句可以跳转到指定标签，进行代码间的无条件跳转。

在快速跳出循环，避免重复退出的方面有一定的帮助，goto语句可以简化代码上实现过程。

传统的连续退出两层循环的代码示例：

```go
package main

import "fmt"

func main() {
	var flag = false
	for i := 0; i < 10; i++ {
		for j := 1; j < 10; j++ {
			if j == 2 {
				flag = true
				break
			}
			fmt.Printf("i:%d - j:%d", i, j)
		}
		if flag {
			break
		}
	}
	fmt.Print("结束循环")
}
```

如果使用goto 语句，则简化如下：

```go
package main

import "fmt"

func main() {
	// var flag = false
	for i := 0; i < 10; i++ {
		for j := 1; j < 10; j++ {
			if j == 2 {
				goto breakTag
			}
			fmt.Printf("i:%d - j:%d", i, j)
		}
	}
breakTag:
	fmt.Print("结束循环")
}
```



"goto breakTag" 来跳转到指明的标签处，breakTag 是自定义的标签。


goto在`多错误处理`中优势


```go
func main() {
	err := getUserInfo()
	if err != nil {
		fmt.Println(err)
		exitProcess()
	}

	err = getEmail()
	if err != nil {
		fmt.Println(err)
		exitProcess()
	}
	
	fmt.Println("over")
}
```


```go
func main() {
	err := getUserInfo()
	if err != nil {
		goto doExit
	}

	err = getEmail()
	if err != nil {
		goto doExit
	}
	
	fmt.Println("over")
	return

doExit:
	fmt.Println(err)
	exitProcess()
}
```









### 5.1.3 for-range


`for-range`循环结构是Go语言特有的一种的迭代结构，其引用十分广泛。

`for-range`可以遍历数组、切片、字符串、`map`及通道（`channel`）。



`for-range`的语法结构：

```
for key, val := range 复合变量值 {
	// ...逻辑语句
}
```

需要注意的是，`val`始终为集合中对应索引值的一个复制值。因此，它一般只具有“只读”属性，对它所做的任何修改都不会影响集合中原有的值。一个字符串是`Unicode`编码的字符（或称之为`rune`）集合，因此也可以用它来迭代字符串：

```
for position, char := range str{
	// ...逻辑语句
}
```

每个`rune`字符和索引在`for-range`循环中的值是一一对应的，它能够自动根据`UTF-8`规则识别`Unicode`编码的字符。

通过`for-range`遍历的返回值有一定的规律：

- 数组、切片、字符串返回索引和值。
- `map`返回值和键。
- 通道(`channel`)只返回通道内的值。



#### 1.遍历数组

访问每一个数组元素

```go 

package main

import "fmt"

var arrAge = [5]int{12, 13, 14, 15, 16}
var arrLazy = [...]int{22, 23, 24, 25, 26}
var arrKeyValue = [5]string{3: "hujian", 4: "xiaojian"}

func main() {
    // 遍历方法1
    for _, i2 := range arrAge {
        fmt.Println(i2)
    }
    fmt.Println("----------------------------")


    // 遍历方法2
    for i := 0; i < len(arrAge); i++ {
        fmt.Println(arrAge[i])
    }
}
```

#### 2.遍历切片

使用for和for range的方式遍历切片

```go
package main

import "fmt"

func main() {

    list := []int{1, 2, 3, 4, 5, 6}
    for i, i2 := range list {
        fmt.Printf("index %d is %d\n", i, i2)
    }

    fmt.Println("-----------------------------------------------")
    for index := 0; index < len(list); index++ {
        fmt.Printf("index %d is %d\n", index, list[index])
    }

    fmt.Println("-------------只获取值--------------------")
    for _, value := range list {
        fmt.Printf("value is %d\n",value)
    }
}

```




#### 3.遍历字符串

Go语言和其他语言类似：可以通过`for-range`的组合对字符串进行遍历。在遍历时，`key`和`value`分别代表字符串的索引和字符串中的一个字符。

```go
var str = "hi 加油"
for key, value := range str{
	fmt.Printf("key:%d value:0x%x\n", key, value)
}
```

以上代码的运行结果如下：

```go
key:0 value:0x68
key:1 value:0x69
key:2 value:0x20
key:3 value:0x52a0
key:4 value:0x6cb9
```

代码中的遍历`value`的实际类型是`rune`类型，以十六进制打印出来就是字符的编码。





#### 4.遍历map

对于`map`类型，`for-range`在遍历时，`key`和`value`分别代表`map`的索引键`key`和索引键对应的值。下面的代码演示了如何遍历`map`：

```go
m := map[string]int{
	"go": 100,
	"web": 100,
}
for key, value := range m {
	fmt.Println(key, value)
}
```





#### 5.遍历通道


通道可以通过`for-range`进行遍历。


不同于`slice`和`map`，在遍历通道时只输出一个值，即通道内的类型对应的数据。

下面代码展示了通道的遍历方法：

```go
c := make(chan int)   // 创建了一个整型类型的通道
go func(){            // 启动了一个goroutine
	c <- 7            // 将数据推送进通道
	c <- 8
	c <- 9
}()
for v := range c {
	fmt.Println(v)
}
```


以上代码的逻辑如下：

1. 创建一个整型类型的通道并实例化；

2. 通过关键字go启动了一个goroutine；

3. 将数字传入通道，实现的功能是往通道中推送数据7、8、9；

4. 结束并关闭通道（这段goroutine在声明结束后马上被执行）；

5. 用for-range语句对通道c进行遍历，即不断地从通道中接收数据知道通道被关闭。



在使用`for-range`循环遍历某个对象时，往往不会同时使用`key`和`value`的值，而是只需要其中一个的值。这时可以采用一些技巧让代码变得更简单。


```go
m := map[string]int{
	"shirdon": 100,
	"ronger": 98,
}
for _, value := range m {
	fmt.Println(value)
}
```



### 5.1.4 switch-case

Go语言改进了传统的switch-case语句的语法设计：

case与case之间是独立的代码块。不需要break跳出当前case代码块，以避免执行到下一行。


代码示例如下：

```go
package main

import "fmt"

func main() {
	age := 18
	switch age {
	case 60:
		fmt.Print("老人")
	case 30:
		fmt.Print("中年")
	case 18:
		fmt.Print("青年")
	case 6:
		fmt.Print("少年")
	default:
		fmt.Print("你是一个人才")
	}
}
```

> 注意  ：Go语言规定每个switch只能有一个default分支。


(1) 一个分支多个值

```go
func testSwitch3() {
	switch n := 7; n {
	case 1, 3, 5, 7, 9:
		fmt.Println("奇数")
	case 2, 4, 6, 8:
		fmt.Println("偶数")
	default:
		fmt.Println(n)
	}
}
```



(2) 分支表达式

```go
package main

import "fmt"

func main() {
	age := 18
	switch {
	case age > 22:
		fmt.Print("大学毕业")
	case age > 18 && age <= 22:
		fmt.Print("高中毕业")
	case age > 15 && age <= 18:
		fmt.Print("初中毕业")
	case age > 12 && age <= 15:
		fmt.Print("小学毕业")
	case age > 6 && age <= 12:
		fmt.Print("幼儿园毕业")
	}
}
```



```go
package main

import "fmt"

func main() {
	//// 使用方法1
	//finger := 3
	//switch finger {
	//	// 当变量finger=1的时候
	//	case 1:
	//		fmt.Println("大拇指")
	//	// 当变量finger=2的时候
	//	case 2:
	//		fmt.Println("食指")
	//	// 当变量finger=3的时候
	//	case 3:
	//		fmt.Println("中指")
	//	case 4:
	//		fmt.Println("无名指")
	//	case 5:
	//		fmt.Println("小拇指")
	//	default:
	//		fmt.Println("无效的输入！")
	//}
	//
	//// 使用方法2
	//rand.Seed(time.Now().Unix())
	//num := rand.Intn(100)
	//switch {
	//	// 判断num是否大于20
	//	case num < 20:
	//		fmt.Printf("变量num的值为：%v，小于20\n", num)
	//	default:
	//		fmt.Printf("变量num的值为：%v，大于20\n", num)
	//}
	//
	//// 使用方法3
	//rand.Seed(time.Now().Unix())
	//switch n := rand.Intn(9); n {
	//	// 变量n在（1, 3, 5, 7, 9）区间内
	//	case 1, 3, 5, 7, 9:
	//		fmt.Printf("奇数，值为：%v，小于20\n", n)
	//	// 变量n在（2, 4, 6, 8）区间内
	//	case 2, 4, 6, 8:
	//		fmt.Printf("偶数，值为：%v，小于20\n", n)
	//	default:
	//		fmt.Printf("啥也不是")
	//}
	finger := 1
	switch finger {
	// 当变量finger=1的时候
	case 1:
		fmt.Println("大拇指")
		fallthrough
	// 当变量finger=2的时候
	case 2:
		fmt.Println("食指")
		fallthrough
	// 当变量finger=3的时候
	case 3:
		fmt.Println("中指")
	case 4:
		fmt.Println("无名指")
	case 5:
		fmt.Println("小拇指")
	default:
		fmt.Println("无效的输入！")
	}
}
```




### 5.1.5 实践1-编程实现个人健康评测

```go

package main

import (
	"fmt"
	"strconv"
)

func main() {
	// 定义变量
	var name string
	var weight, height float64
	// 输入名字
	fmt.Printf("请输入你的名字：\n")
	fmt.Scanln(&name)
	// 输入体重
	fmt.Printf("请输入你的体重kg：\n")
	fmt.Scanln(&weight)
	// 输入身高
	fmt.Printf("请输入你的身高cm：\n")
	fmt.Scanln(&height)
	// 输出用户输入信息
	fmt.Printf("%v的体重kg:%v，身高cm:%v\n", name, weight, height)
	// 单位换算，将cm换成m
	height /= 100
	// 计算BMI
	result := weight / (height * height)
	// 将BMI保留两位小数
	BMI, _ := strconv.ParseFloat(fmt.Sprintf("%.2f", result), 64)
	// 根据BMI判断身体状态
	if BMI < 18.5 {
		fmt.Printf("你的BMI为%v，体重过轻", BMI)
	} else if 18.5 <= BMI && BMI < 24.0 {
		fmt.Printf("你的BMI为%v，体重正常", BMI)
	} else if 24 <= BMI && BMI < 27 {
		fmt.Printf("你的BMI为%v，体重过重", BMI)
	} else if 27 <= BMI && BMI < 30 {
		fmt.Printf("你的BMI为%v，体重轻度肥胖", BMI)
	} else if 30 <= BMI && BMI < 35 {
		fmt.Printf("你的BMI为%v，体重中度肥胖", BMI)
	} else {
		fmt.Printf("你的BMI为%v，体重重度肥胖", BMI)
	}
}
```

### 5.1.6 实践2-编程实现简易计算器

```go
package main

import (
	"fmt"
)

func main() {
	// 定义变量action，用于功能选择
	var action string
	// 定义变量data，存储当前输入的数据
	var d1, d2 float64
	// 定义变量opt，存储输入的运算符
	var opt string
	// 定义变量result，存储计算结果
	var result interface{}
	// 设置死循环，执行多次计算
	for {
		// 输出操作提示
		fmt.Printf("请输入选择，按1计算，按2退出：\n")
		// 存储用户输入数据
		fmt.Scanln(&action)
		// 进入计算操作
		if action == "1" {
			for i := 0; i < 2; i++ {
				// 输出操作提示
				fmt.Printf("请输入数字：\n")
				// 存储用户输入数据
				if i == 0 {
					fmt.Scanln(&d1)
				} else {
					fmt.Scanln(&d2)
				}
			}
			// 输出操作提示
			fmt.Printf("请输入运算法则，可选择+-*/：\n")
			// 存储用户输入数据
			fmt.Scanln(&opt)
			// 根据输入运算符执行对应计算
			if opt == "+" {
				result = d1 + d2
			}
			if opt == "-" {
				result = d1 - d2
			}
			if opt == "*" {
				result = d1 * d2
			}
			if opt == "/" {
				if d2 != 0.0 {
					result = d1 / d2
				} else {
					result = "除数为0无法计算"
				}
			}
			// 输出计算结果
			fmt.Printf("%v %v %v = %v\n", d1, opt, d2, result)
		}
		// 退出死循环，终止死循环
		if action == "2" {
			break
		}
	}
}
```


## 6. Go数据类型

| 类型       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 布尔型     | true或false                                                  |
| 数字类型   | uint8、uint16、uint32、uint64、int8、int16、int32、int64 、<br />float32（IEEE-754）、float64（IEEE-754）、complex64、complex128、<br />byte（uint8）、rune（int32）、uint（32或64）、int（32或64）、uintptr（存放指针） |
| 字符串类型 | 一串固定长度的字符连接起来的字符序列，utf-8编码              |
| 复合类型   | 数组、切片、map、结构体                                      |




### 6.1 布尔型

只有两个相同类型的值才能比较：

- 值的类型是接口（interface），两者必须都实现了相同的接口。
- 一个是常量，另一个不是常量，类型必须和常量类型相同。
- 类型不同，必须转换为相同类型，才能比较。

&&优先级高于||，有短路现象。

```go
package main

import (
	"fmt"
)

func bool2int(b bool) int {
	if b {
		return 1
	} else {
		return 0
	}
}

func int2bool(i int) bool { return i != 0 }

func main() {
	fmt.Println(bool2int(true)) //1
	fmt.Println(int2bool(0))	//false
}
```



### 6.2 数字类型


#### 1.整型


整型分为以下两个大类： 

- 按长度分为：int8、int16、int32、int64 

- 对应的无符号整型：uint8、uint16、uint32、uint64


其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。


位运算采用补码。int、uint和uintptr，长度由操作系统类型决定。


|类型|	取值范围|内存占用情况|
|-----|-----------------------------|---------|
|int8	  |有符号 8位整型 (-128 到 127)|8位（1字节）|
|uint8	|无符号 8位整型 (0 到 255)|8位（1字节）|
|int16	|有符号 16位整型 (-32768 到 32767)|16位（2字节）|
|uint16	|无符号 16位整型 (0 到 65535)|16位（2字节）|
|int32	|有符号 32位整型 (-2147483648 到 2147483647)|32位（4字节）|
|uint32	|无符号 32位整型 (0 到 4294967295)|32位（4字节）|
|uint64	|无符号 64位整型 (0 到 18446744073709551615)|64位（8字节）|
|int64	|有符号 64位整型 (-9223372036854775808 到 9223372036854775807)|64位（8字节）|


有符号和无符号的使用场景，例如水杯中的水量不可能为负，所以你可以使用只能表示非负整数的无符号整数类型uint来表示水杯中的水量。


> 记忆方法：
> 
> 有符号就是有个负号。
> 
> 无符号就是正数，无负号。


**特殊整型**

|类型	|描述|
|---------|--------|
|uint	|32位操作系统上就是uint32，64位操作系统上就是uint64|
|int	|32位操作系统上就是int32，64位操作系统上就是int64|
|uintptr	|无符号整型，用于存放一个指针|


#### 2.浮点型
Go语言支持两种浮点型数：float32和float64。

这两种浮点型数据格式遵循IEEE 754标准： 

- float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 
- float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。

打印浮点数时，可以使用fmt包配合动词%f，代码如下：

```go
package main
import (
        "fmt"
        "math"
)
func main() {
        fmt.Printf("%f\n", math.Pi)
        fmt.Printf("%.2f\n", math.Pi)
}
```


### 6.3 字符串类型

由一串固定长度的字符连接起来的字符序列，utf-8编码。值类型，字节的定长数组。

```go
//声明和初始化
str := "string"
```

#### 1.创建字符串

字符串字面量用"或`创建

- "创建可解析的字符串，支持转义，不能引用多行
- `创建原生的字符串字面量，不支持转义，可多行，不能包含反引号字符

```go
str1 := "\"hello\"\nI love you"
str2 := `"hello"
I love you
`
```



```go
//字符串连接
str := "I love" + " Go Web"
str += " programming"
```

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	str := "我喜欢Go Web"
	fmt.Println(len(str))                    //15
	fmt.Println(utf8.RuneCountInString(str)) //9
	fmt.Println(str[9])                      //71
	fmt.Println(string(str[9]))              //G
	fmt.Println(str[:3])                     //我
	fmt.Println(string(str[:3]))             //我
	fmt.Println(str[3:])                     //喜欢Go Web
	fmt.Println([]rune(str))				//[25105 21916 27426 71 111 32 87 101 98]
}
```

```go
package main

import (
	"fmt"
)

func main() {
	str := "我喜欢Go Web"
	chars := []rune(str)
	for ind, char := range chars {
		fmt.Printf("%d: %s\n", ind, string(char))
	}
	for ind, char := range str {
		fmt.Printf("%d: %s\n", ind, string(char))
	}
	for ind, char := range str {
		fmt.Printf("%d: %U %c\n", ind, char, char)
	}
}
```

```go
var buffer bytes.Buffer
for {
	if piece, ok := getNextString(); ok {
		buffer.WriteString(piece)
	} else {
		break
	}
}
fmt.Println(buffer.String())
```


#### 2.字符串的修改

不能通过str[i]方式修改字符串中的字符。
要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。


```go
package main

import (
	"fmt"
)

func main() {
	str := "hi 世界"
	by := []byte(str)
	by[2] = ','
	fmt.Printf("%s\n", str)	//hi 世界		
	fmt.Printf("%s\n", by)	//hi 世界
	fmt.Printf("%s\n", string(by))	//hi 世界
}
```

```go
package main

import "fmt"

func main() {
	s1 := "hello"
	// 1、强制转换
	byteS1 := []byte(s1)
	// 2、进行修改
	byteS1[0] = 'H'
	// 3、强制转换成字符串并打印
	fmt.Println(string(byteS1))

	s2 := "我爱你中国"
	// 1、强制转换
	runeS2 := []rune(s2)
	// 2、修改
	runeS2[3] = '祖'
	// 3、强制转换成字符串并打印
	fmt.Println(string(runeS2))
}
```


#### 3.字符串的常用操作

|方法|	作用|
|--------|------|
|len(s)	|求长度（是字节的长度）|
|+或者fmt.Sprintf|	字符串拼接|
|strings.Split|	字符串切割|
|strings.contains|	判断字符串中是否包含|
|strings.HasPrefix,strings.HasSuffix|	判断字符串的前缀/后缀（布尔类型）|
|strings.Index(),strings.LastIndex()|	输出子串出现的位置（索引）|
|strings.Join(a[]string, sep string)|	join操作|



例子
```go
package main

import "fmt"
import "strings"

func main() {
	s := "Hello World 你好啊！"
	// 求长度
	fmt.Println(len(s))
	// 字符串拼接
	s1 := "Joker"
	s2 := "你好"
	fmt.Println(s1 + s2)
	s12 := fmt.Sprintf("%s%s", s1, s2)
	fmt.Println(s12)
	// 字符串切割
	sSplit := strings.Split(s, " ")
	fmt.Println(sSplit)
	// 判断字符串是否包含
	fmt.Println(strings.Contains(s, "H"))
	fmt.Println(strings.Contains(s, "L"))
	// 判断字符串的前缀
	fmt.Println(strings.HasPrefix(s, "H"))
	// 判断字符串的后缀
	fmt.Println(strings.HasSuffix(s, "啊"))
	// 判断字串出现的位置
	fmt.Println(strings.Index(s, "H"))
	// 判断子串最后出现的位置
	fmt.Println(strings.LastIndex(s, "o"))
	// join操作
	fmt.Println(strings.Join(sSplit, "-"))
}
```

#### 4.类型转换
Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。

强制类型转换的基本语法如下：

```shell
T(表达式)
```
其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.

### 6.4 指针类型

指针类型指存储内存地址的变量类型。

```
var b int = 66
var p * int = &b
```

```go
package main

import (
	"fmt"
)

func main() {
	var score int = 100
	var name string = "barry"
	fmt.Printf("%p %p\n", &score, &name) //0xc0000ac058	0xc000088230
}
```


```go
package main

import (
	"fmt"
)

func main() {
	var address string = "hangzhou, China"
	ptr := &address

	fmt.Printf("address type: %T\n", address)     //address type: string
	fmt.Printf("address value: %v\n", address)    //address value: hangzhou, China
	fmt.Printf("address address: %p\n", &address) //address address: 0xc00003a240

	fmt.Printf("ptr type: %T\n", ptr)             //ptr type: *string
	fmt.Printf("ptr value: %v\n", ptr)            //ptr value: 0xc00003a240
	fmt.Printf("ptr address: %p\n", &ptr)         //ptr address: 0xc000006028
	fmt.Printf("point value of ptr : %v\n", *ptr) //point value of ptr : hangzhou, China
}
```

```go
package main

import (
	"fmt"
)

func exchange1(c, d int) {
	t := c
	c = d
	d = t
}

func exchange2(c, d int) {
	c, d = d, c
}

func exchange3(c, d *int) {
	t := *c
	*c = *d
	*d = t
}

func exchange4(c, d *int) {
	d, c = c, d
}

func exchange5(c, d *int) {
	*d, *c = *c, *d
}

func main() {
	x, y := 6, 8
	x, y = y, x
	fmt.Println(x, y) //8 6

	x, y = 6, 8
	exchange1(x, y)
	fmt.Println(x, y) //6 8

	x, y = 6, 8
	exchange2(x, y)
	fmt.Println(x, y) //6 8

	x, y = 6, 8
	exchange3(&x, &y)
	fmt.Println(x, y) //8 6

	x, y = 6, 8
	exchange4(&x, &y)
	fmt.Println(x, y) //6 8

	x, y = 6, 8
	exchange5(&x, &y)
	fmt.Println(x, y) //8 6
}


```

### 6.5 复合类型

#### 1.数组类型
数组是具有相同类型（整数、字符串、自定义类型等）的一组长度固定的数据项的序列。

```go
var team [3]string
team[0] = "hujianli1"
team[1] = "hujianli2"
team[2] = "hujianli3"
fmt.Println(team)

// 使用符合字面量初始化数组
var numbers = [5]float32{100.0, 8.0, 9.4, 6.8, 30.1}

// 让编译器自动计算数组元素数量
var numbers = [...]float32{100.0, 8.0, 9.4, 6.8, 30.1}


// 示例1
var name_list  = [3]string{"xiaojian01","xiaojian02","xiaojian03"}
fmt.Printf("%s--%s--%s",name_list[0],name_list[1],name_list[2])
//xiaojian01--xiaojian02--xiaojian03

// 示例2 "..."表示让编译器确定数组大小
 var array_list = [...]string{"var1","var2","var3","var4"}
 fmt.Println(array_list[0]) //var1
 fmt.Println(array_list[1]) //var2
 fmt.Println(array_list[2])
 fmt.Println(array_list[3])

```




```go
package main

import (
	"fmt"
)

func main() {
	var arr [6]int
	var i, j int
	for i = 0; i < 6; i++ {
		arr[i] = i + 66
	}
	for j = 0; j < 6; j++ {
		fmt.Printf("arr[%d] = %d\n", j, arr[j])
	}
}

/**
arr[0] = 66
arr[1] = 67
arr[2] = 68
arr[3] = 69
arr[4] = 70
arr[5] = 71
**/
```


```go
package main

import "fmt"

func main() {
	// 定义长度为2的数组并设置每个元素值
	var s = [2]int{100, 200}
	// 输出数组元素
	for i := 0; i < len(s); i++ {
		fmt.Printf("数组s第%v个元素是：%v\n", i+1, s[i])
	}

	// 定义数组并设置每个元素值，数值长度根据元素个数自动设置
	var ss = [...]int{300, 400}
	// 输出数组元素
	for i := 0; i < len(ss); i++ {
		fmt.Printf("数组ss第%v个元素是：%v\n", i+1, ss[i])
	}

	// 定义数组并设置第一个和第四个元素值
	var sss = [...]int{0: 300, 3: 500}
	// 输出数组元素
	for i := 0; i < len(sss); i++ {
		fmt.Printf("数组sss第%v个元素是：%v\n", i+1, sss[i])
	}
}

```

#### 2.结构体类型

结构体是由0或多个任意类型的数据构成的数据集合。
```
type 类型名 struct {
	字段1 类型1
	结构体成员2 类型2
}
```



```go
type Pointer struct {
	A float32
	B float32
}

type Color struct {
	Red, Green, Blue byte
}

variable_name := struct_variable_type {value1, value2, ...}
variable_name := struct_variable_type {key2: value2, key1: value1, ...}

```

```go
package main

import "fmt"

type Books struct {
	title   string
	author  string
	subject string
	press   string
}

func printBook(book Books) {
	fmt.Printf("book.title: %s\n", book.title)
	fmt.Printf("book.author: %s\n", book.author)
	fmt.Printf("book.subject: %s\n", book.subject)
	fmt.Printf("book.press: %s\n", book.press)
}

func printBook2(book *Books) {
	fmt.Printf("book.title: %s\n", book.title)
	fmt.Printf("book.author: %s\n", book.author)
	fmt.Printf("book.subject: %s\n", book.subject)
	fmt.Printf("book.press: %s\n", book.press)
}

func main() {
	fmt.Println(Books{author: "yx", title: "学习 Go Web"})
	fmt.Println()

	var bookGo Books
	bookGo.title = "学习 Go Web"
	bookGo.author = "yx"
	bookGo.subject = "Go"
	bookGo.press = "电力工业出版社"
	fmt.Printf("bookGo.title: %s\n", bookGo.title)
	fmt.Printf("bookGo.author: %s\n", bookGo.author)
	fmt.Printf("bookGo.subject: %s\n", bookGo.subject)
	fmt.Printf("bookGo.press: %s\n", bookGo.press)
	fmt.Println()
	printBook(bookGo)
	fmt.Println()
	printBook2(&bookGo)
}
```
#### 3.切片类型

slice是对数组或切片连续片段的引用。


切片内部结构包含**内存地址pointer、大小len和容量cap**。


```shell
//不含结束位置,左开右闭
slice[开始位置:结束位置]
```

```go
package main

import "fmt"

var sliceBuilder [20]int

func main() {
	for i := 0; i < 20; i++ {
		sliceBuilder[i] = i + 1
	}
	fmt.Println(sliceBuilder)       //[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20]
	fmt.Println(sliceBuilder[5:15]) //[6 7 8 9 10 11 12 13 14 15]
	fmt.Println(sliceBuilder[15:])  //[16 17 18 19 20]
	fmt.Println(sliceBuilder[:2])   //[1 2]
    
    // 复合字面量方法初始化切片
	b := []int{6, 7, 8}
	fmt.Println(b[:])   //[6 7 8]
	fmt.Println(b[0:0]) //[]

	var sliceStr []string
	var sliceNum []int
	var emptySliceNum = []int{}
	fmt.Println(sliceStr, sliceNum, emptySliceNum)                      //[] [] []
	fmt.Println(len(sliceStr), len(sliceNum), (emptySliceNum))          //0 0 []
	fmt.Println(sliceStr == nil, sliceNum == nil, emptySliceNum == nil) //true true false

	slice1 := make([]int, 6)
	slice2 := make([]int, 6, 10)
	fmt.Println(slice1, slice2)           //[0 0 0 0 0 0] [0 0 0 0 0 0]
	fmt.Println(len(slice1), len(slice2)) //6 6
	fmt.Println(cap(slice1), cap(slice2)) //6 10

}
```

```go
package main

import "fmt"

func main() {
	var ss = []int{1, 2, 3, 4, 5, 6, 7}
	// 截取第二个到第五个元素
	s1 := ss[1:4]
	fmt.Printf("截取第二个到第五个元素：%v\n", s1)
	// 截取第三个元素之后的所有元素
	s2 := ss[2:]
	fmt.Printf("截取第三个元素之后的所有元素：%v\n", s2)
	// 截取第三个元素之前的所有元素
	s3 := ss[:2]
	fmt.Printf("截取第三个元素之前的所有元素：%v\n", s3)
	// 如果切片ss没被覆盖，经过截取后不改变原有的切片数据
	fmt.Printf("切片变量ss的值：%v\n", ss)


	//var ss = []int{1, 2, 3, 4, 5, 6, 7}
	//fmt.Printf("切片ss的元素：%v\n", ss)
	//// 删除元素4、5、6
	//ss = append(ss[:2], ss[6:]...)
	//fmt.Printf("切片ss的元素：%v\n", ss)

}

```



#### 4.map类型
关联数组，字典，元素对（pair）的无序集合，引用类型。

```
var name map[key_type]value_type
```



```go
package main

import (
	"fmt"
)

func main() {
	// 只定义
	var m1 = map[string]string{}
	m1["name"] = "Tom"
	fmt.Printf("集合m1：%v\n", m1)
	// 定义并赋值
	var m2 = map[string]string{"name": "Lily"}
	fmt.Printf("集合m2：%v\n", m2)
	// 使用make()函数定义
	m3 := make(map[string]string)
	m3["name"] = "Tim"
	fmt.Printf("集合m3：%v\n", m3)
}

```



```go
package main

import "fmt"

var literalMap map[string]string
var assignedMap map[string]string

func main() {
	// 使用复合字面量为map提供键值对。第一种声明方式
	literalMap = map[string]string{"first": "go", "second": "web"}

	// 使用make函数，可对map预分配地址。第二种声明方式
	createdMap := make(map[string]float32)
	assignedMap = literalMap //引用
	createdMap["k1"] = 99
	createdMap["k2"] = 199
	assignedMap["second"] = "program"

	fmt.Println(literalMap["first"])  //go
	fmt.Println(literalMap["second"]) //program
	// 判断key是否存在
	if value, ok := literalMap["third"]; ok {
		fmt.Printf("key third has exist.value is: %v", value)
	} else {
		fmt.Println("key third has not exist") //key third has not exist
	}
	fmt.Println(createdMap["k1"]) //99
	fmt.Println(createdMap["k2"]) //199

	// 创建一个map
	scenesint := make(map[string]int)
	// 向map中添加映射关系
	scenesint["route"] = 66
	fmt.Println(scenesint["route"]) //66

	v := scenesint["route2"]
	fmt.Println(v) //0

	// 判断键值对
	mydicMaps := make(map[string]string)
	mydicMaps["hujianli1"] = "A1"
	mydicMaps["hujianli2"] = "A2"
	mydicMaps["hujianli3"] = "A3"

	for k, v := range mydicMaps {
		fmt.Printf("%s %s\n", k, v)
	}
	name1, ok := mydicMaps["hu1"]
	if !ok {
		fmt.Println("----------", name1)
	}

	// 或者
	if name2, ok := mydicMaps["hu2"]; !ok {
		fmt.Println("----------", name2)
	}

	// 遍历map中的键值对–访问关联关系
	m := map[string]string{
		"name":   "hujianli",
		"age":    "22",
		"sex":    "man",
		"school": "dianda",
	}
	for i, i2 := range m {
		fmt.Printf("key:%s value:%s\n", i, i2)
	}

	// 只遍历值
	for _, i2 := range m {
		fmt.Printf("%s\n", i2)
	}
	// 只遍历键
	for i := range m {
		fmt.Printf("%s\n", i)
	}

	//delete()函数从map中删除键值对
	scene := make(map[string]int)
	//准备map数据
	scene["route"] = 66
	scene["brazil"] = 4
	scene["china"] = 960
	// 删除一个键
	delete(scene, "brazil")
	fmt.Println(scene) //map[china:960 route:66]
	for i, i2 := range scene {
		fmt.Println(i, i2)
	}
	// Go 语言中没有清空map的方法和函数。清空map的位于方法是重新make一个新的map。 Go中的并行垃圾回收效率比写一个清空函数高效多了。
	scene = make(map[string]int)
	fmt.Println(scene) //map[]
}
```


```go
createdMap := new(map[string]float32)
//错误
//声明了一个未初始化的变量并取了它的地址
```



```go
//map到达容量上限，自动增1
// make(map[key_type]value_type, cap)
map := make(map[string]float32, 100)

// 使用复合字面量为map提供键值对
achievement := map[string]float32{
		"zhang": 99.5, "xiao": 88,
		"wange": 96, "ma": 100,
}
map1 := make(map[int][]int)
map2 := make(map[int]*[]int)
```




##### 4.1 编程实现map与JSON互换


- JSON转换map

```go
package main

import (
	"encoding/json"
	"fmt"
)

func main() {
	// 定义字符串，用于记录JSON数据
	var j string
	j = `{"infos": [{"name": "Tom", "age": 15}, {"name": "Lily", "age": 20}]}`
	// 定义集合，value的数据类型为接口interface类型
	var m1 = map[string]interface{}{}
	// 将JSON字符串转换为集合
	json.Unmarshal([]byte(j), &m1)
	// 遍历输出JSON
	for k, v := range m1 {
		fmt.Printf("集合m1的键为：%v\n", k)
		fmt.Printf("集合m1的值为：%v\n", v)
		// 解析JSON里面的数组
		vv := v.([]interface{})
		for i := 0; i < len(vv); i++ {
			fmt.Printf("数组vv的值为：%v\n", vv[i])
			// 解析数组里面的集合
			vvv := vv[i].(map[string]interface{})
			name := vvv["name"]
			age := vvv["age"]
			fmt.Printf("键为name的数据为：%v\n", name)
			fmt.Printf("键为age的数据为：%v\n", age)
		}
	}
}

```


- map转换JSON

```go
package main

import (
	"encoding/json"
	"fmt"
)

func main() {
	// 定义集合
	var m1 = map[string]interface{}{}
	m1["name"] = "Tom"
	m1["age"] = 10
	fmt.Printf("m1的数据为：%v\n", m1)
	var m2 = map[string]interface{}{}
	m2["name"] = "Lily"
	m2["age"] = 20
	fmt.Printf("m2的数据为：%v\n", m2)
	// 定义切片
	var s1 = []map[string]interface{}{m1, m2}
	fmt.Printf("s1的数据为：%v\n", s1)
	// 定义集合，键为字符串类型，值为接口类型
	var m3 = map[string]interface{}{}
	m3["infos"] = s1
	data, _ := json.Marshal(&m3)
	fmt.Printf("JSON数据为：%v\n", string(data))
}
```




## 7.函数

### 7.1 声明函数
```
func function_name([parameter list]) [return_types] {
	//bunction_body
}
```

```go
package main

import "fmt"

func main() {
	array := []int{6, 8, 10}
	var ret int
	ret = min(array)
	fmt.Printf("最小值是: %d \n", ret)
}

func min(arr []int) (m int) {
	m = arr[0]
	for _, v := range arr {
		if v < m {
			m = v
		}
	}
	return m
}
```


```go
package main

import "fmt"

func compute(x, y int) (int, int) {
	return x + y, x * y
}
func main() {
	a, b := compute(6, 8)
	fmt.Println(a, b) //14 48
}
```



```go
package main

import "fmt"

func change(a, b int) (x, y int) {
	x = a + 100
	y = b + 100
	return
	//return x, y
	//return y, x
}
func main() {
	a := 1
	b := 2
	c, d := change(a, b)
	fmt.Println(c, d) //111 102
}
```

### 7.2 函数参数

#### 1.参数使用

- 形参：定义函数时，用于接收外部传入的数据。
- 实参：调用函数时，传给形参的实际的数据。


#### 2.可变参数
```go
package main

import "fmt"

func myFunc(arg ...string) {
	for _, v := range arg {
		fmt.Printf("the string is: %s\n", v)
	}
}

func main() {
	myFunc("hujianli1", "hujianli2", "hujianli3")
}

```


```go
package main

import (
	"fmt"
)

//func myfun(numbers ...int) {
//	for _, k := range numbers {
//		fmt.Printf("参数值为：%v\n", k)
//	}
//}
func myfun(numbers ...interface{}) {
	for _, k := range numbers {
		fmt.Printf("参数值为：%v\n", k)
	}
}


func main() {
	var s = []string{"Mary", "Tim"}
	var m = map[string]interface{}{"name": "Mary", "age": 10}
	// 调用函数
	myfun(45, "Tom", s, m)
}
```


#### 3.参数传递

- 值传递

```go
package main

import "fmt"

func exchange(a, b int) {
	var tmp int
	tmp = a
	a = b
	b = tmp
}
func main() {
	a := 1
	b := 2
	fmt.Printf("交换前a=%d\n", a)
	fmt.Printf("交换前b=%d\n", b)
	exchange(a, b)
	fmt.Printf("交换后a=%d\n", a)
	fmt.Printf("交换后b=%d\n", b)
}

/* 交换前a=1
交换前b=2
交换后a=1
交换后b=2 */
```


- 引用传递

```go
package main

import "fmt"

func exchange(a, b *int) {
	var tmp int
	tmp = *a
	*a = *b
	*b = tmp
}
func main() {
	a := 1
	b := 2
	fmt.Printf("交换前a=%d\n", a)
	fmt.Printf("交换前b=%d\n", b)
	exchange(&a, &b)
	fmt.Printf("交换后a=%d\n", a)
	fmt.Printf("交换后b=%d\n", b)
}

/* 交换前a=1
交换前b=2
交换后a=2
交换后b=1 */
```


#### 4.函数作为变量

```go
package main

import (
	"fmt"
)

func myfun() {
	// 定义函数
	fmt.Printf("自定义函数")
}


func main() {
	// 定义函数变量
	var m func()
	// 将函数作为变量m的值
	m = myfun
	// 调用函数
	m()
}
```


### 7.3 匿名函数

匿名函数（闭包），一类无须定义标识符（函数名）的函数或子程序。

#### 1.定义
```
func (参数列表) (返回值列表) {
	//函数体
}
```

```go
package main
import (
	"fmt"
)
func main(){

	//res := func(n1 int, n2 int) int {
	//	return n1 + n2
	//}(10, 30)
	//
	//fmt.Printf("函数执行结果为：%v\n", res)
	//


	// 将匿名函数赋给函数变量myfun
	myfun := func (n1 int, n2 int) int {
		return n1 - n2
	}

	// 变量myfun的数据类型是函数类型，可以由该变量完成函数调用
	res2 := myfun(10, 30)
	res3 := myfun(50, 30)
	fmt.Printf("匿名函数调用第一次：%v\n", res2)
	fmt.Printf("匿名函数调用第二次：%v\n", res3)
	fmt.Printf("函数变量myfun的数据类型：%T\n", myfun)
}
```


```go
package main

import "fmt"

func main() {
	x, y := 6, 8
	defer func(a int) {
		fmt.Println("defer x, y = ", a, y) //y为闭包引用
	}(x)
	x += 10
	y += 100
	fmt.Println(x, y)
}
/*
输出
16 108
defer x,y = 6 108
*/
```

#### 2.调用

- 定义时调用

```go
package main

import "fmt"

func main() {
	//定义匿名函数并赋值给f变量
	f := func(data int) {
		fmt.Println("closure", data)
	}
	f(6) //closure 6

	//直接声明并调用
	func(data int) {
		fmt.Println("closure, directly", data)
	}(8) //closure, directly 8
}

```
- 回调函数（call then back）

```go
package main

import "fmt"

func visitPrint(list []int, f func(int)) {
	for _, value := range list {
		f(value)
	}
}

func main() {
	sli := []int{1, 6, 8}
	visitPrint(sli, func(value int) {
		fmt.Println(value)
	})
}

/*
1
6
8 */

```
#### 5.实践-编程实现创建文件后缀名

```go
package main

import (
	"fmt"
	"path"
)

func makeSuffixFunc(suffix string) func(string) string {
	fmt.Printf("参数suffix的内存地址：%v\n", &suffix)
	// 参数suffix是文件后缀名
	return func(name string) string {
		fmt.Printf("参数suffix在匿名函数的内存地址：%v\n", &suffix)
		// 匿名函数使用makeSuffixFunc的参数suffix
		// 参数name是文件名，可能含有后缀名或没有后缀名
		// path.Ext()获取文件后缀名，判断path.Ext()是否为空
		// 判断结果为空，说明参数name没有后缀名，根据suffix创建后缀名
		// 判断结果不为空，说明参数name已有后缀名
		if path.Ext(name) == "" {
			return name + suffix
		} else {
			return "文件已有后缀名：" + name
		}
	}
}

func main() {
	// 定义jpg文件类型的函数变量
	jpgFunc := makeSuffixFunc(".jpg")
	// 定义txt文件类型的函数变量
	txtFunc := makeSuffixFunc(".txt")
	// 判断文件是否已有后缀名
	// 没有后缀名则根据函数变量自动创建
	fmt.Println(jpgFunc("test.png"))
	fmt.Println(txtFunc("test"))
}
```


### 7.4 defer延迟语句
defer用于函数结束（return或panic）前最后执行的动作，便于及时的释放资源（数据库连接、文件句柄、锁等）。

#### 1.defer语句执行逻辑：

1. 函数执行到defer时，将defer后的语句压入专门存储defer语句的栈中，然后继续执行函数下一个语句。
2. 函数执行完毕，从defer栈顶依次取出语句执行（先进后出，后进先出）。
3. defer语句放在defer栈时，相关值会复制入栈中。


```go
package main

import "fmt"

func main() {
	deferCall()
}

func deferCall() {
	defer func1()
	defer func2()
	defer func3()
}

func func1() {
	fmt.Println("A")
}

func func2() {
	fmt.Println("B")
}

func func3() {
	fmt.Println("C")
}

//输出
//C
//B
//A
```

```go
package main

import "fmt"

var name string = "go"

func myfunc() string {
	defer func() {
		name = "python" 			//最后一个动作，修改全局变量name为"python"
	}()

	fmt.Printf("myfunc()函数里的name: %s\n", name) //全局变量name（"go"）未修改
	return name                                //倒数第二个动作，将全局变量name（"go"）赋值给myfunc函数返回值
}

func main() {
	myname := myfunc()
	fmt.Printf("main()函数里的name: %s\n", name)
	fmt.Printf("main()函数里的myname: %s\n", myname)
}

//输出
//myfunc()函数里的name: go
//main()函数里的name: python
//main()函数里的myname: go

```

#### 2.defer常用应用场景：

1. 关闭资源。
创建资源（数据库连接、文件句柄、锁等）语句下一行，defer语句注册关闭资源，避免忘记。

2. 和recover()函数一起使用。
程序宕机或panic时，recover()函数恢复执行，而不报错。

```go
package main

import "fmt"

func f() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("Recovered in f", r)
		}
	}() //func()函数含recover，不可封装成外部函数调用，必须defer func(){}()匿名函数调用
	fmt.Println("Calling g.")
	g(0)
	fmt.Println("Returned normally from g.")
}

func g(i int) {
	if i > 3 {
		fmt.Println("Panicking!")
		panic(fmt.Sprintf("%v", i))
	}
	defer fmt.Println("Defer in g", i)
	fmt.Println("Printing in g", i)
	g(i + 1)
}

func main() {
	f()
}
```


## 8.Go面向对象编程


### 8.1 封装
隐藏对象属性和实现细节，仅公开访问方式。

Go使用结构体封装属性。

```go
type Triangle struct {
	Bottom float32
	Height float32
}
```


方法（Methods）是作用在接收者（receiver）（某种类型的变量）上的函数。


```
func (recv recv_type) methodName(parameter_list) (return_value_list) {...}
```

```go
package main

import "fmt"

type Triangle struct {
	Bottom float32
	Height float32
}

func (t *Triangle) Area() float32 {
	return (t.Bottom * t.Height) / 2
}

func main() {
	/* 	t := Triangle{
	   		Bottom: 6,
	   		Height: 4,
	   	}
	*/
	t := Triangle{6, 4}
	fmt.Println(t.Area()) //12
}
```


**访问权限指类属性是公开还是私有的，Go通过首字母大小写来控制可见性。**

常量、变量、类型、接口、结构体、函数等若是大写字母开头，则能被其他包访问或调用（public）；__非大写开头则只能包内使用（private）__。


```
bubble/
├── go.mod
├── main.go
└── person
    └── person.go
```

`bubble/go.mod`

```
module bubble

go 1.16
```


`bubble/main.go`
```go
package main

import (
        "bubble/person"
        "fmt"
)

func main() {
        s := new(person.Student)
        s.SetName("yx")
        s.Age = 22
        // s.name = "hujianli"                  无法设置私有变量
        fmt.Println(s.GetName())				// yx
}

```
`bubble/person/person.go`
```go
package person

type Student struct {
        name  string
        score float32
        Age   int
}

func (s *Student) GetName() string {
        return s.name
}

func (s *Student) SetName(newName string) {
        s.name = newName
}

```


#### 指针方式的实例化

在实例化结构体的时候，可以使用内置函数方法new()和取地址操作符“&”实现，这两种实例化方法都是由指针方式完成的，在访问成员的时候也是使用实心点，但编译器自动将其转换为(*yyy).xxx形式访问。

```go
package main

import "fmt"

// 定义结构体person
type person struct {
	name string
	age  int
}

func main() {
	// 实例化方法3
	// 使用new()实例化结构体
	var p3 *person = new(person)
	// 对结构体成员进行赋值操作
	(*p3).name = "LiLy"
	(*p3).age = 28
	// 由实例化对象p3访问成员
	fmt.Printf("结构体成员name的值：%v\n", p3.name)
	fmt.Printf("结构体成员age的值：%v\n", p3.age)

	// 实例化方法4
	// 取结构体的地址实例化
	var p4 *person = &person{}
	// 对结构体成员进行赋值操作
	(*p4).name = "Mary"
	(*p4).age = 16
	// 由实例化对象p4访问成员
	fmt.Printf("结构体成员name的值：%v\n", p4.name)
	fmt.Printf("结构体成员age的值：%v\n", p4.age)
}


```



#### 结构体标签

在定义结构体的时候，我们还可以为每个成员添加标签tag，它是一个附属于成员的字符串，代表文档或其他的重要标记。

比如解析JSON需要使用内置包encoding/json，该包为我们提供了一些默认标签；还有一些开源的ORM框架，也广泛使用结构体的标签tag。

结构体标签设置说明如下：

1）标签在成员的数据类型后面设置，以字符串形式表示，并且使用反引号表示字符串。

2）标签内容格式由一个或多个键值对组成，键与值使用冒号分隔，并且不能留有空格，值用双引号引起来，多个键值对之间使用一个空格分隔。

```
    type name struct {
       field1 dataType `key1:"value1" key2:"value2"`
       field2 dataType `key1:"value1" key2:"value2"`
       ...
    }
```


如果将结构体的每个成员首个字母改为大写格式，内置包encoding/json的Marshal()能将结构体转换为JSON数据，但是JSON数据的键(key)一般以小写格式表示，

为了使数据转换成功且转换结果符合格式要求，这时候需要使用结构体标签tag实现，实现代码如下：

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Student struct {
	// `json:"name"`表示json序列化时，结构体成员展示形式为name
	Name  string `json:"name"`
	Age   int `json:"age"`
	Score int `json:"score"`
}

func main() {
	var stu Student = Student{
		Name:  "张三",
		Age:   22,
		Score: 88,
	}

	data, _ := json.Marshal(stu)
	fmt.Println(string(data))
}
```


#### 匿名结构体与匿名成员


- 匿名结构体

```go
package main

import "fmt"

func main() {
	// 定义匿名结构体
	var p struct {
		name string
		age  int
	}
	// 使用匿名结构体并为成员赋值
	p.name = "Tom"
	p.age = 10
	fmt.Printf("匿名结构体的成员name：%v\n", p.name)
	fmt.Printf("匿名结构体的成员age：%v\n", p.age)

	// 定义匿名结构体并赋值
	p1 := struct {
		name string
		age  int
	}{
		name: "Tim",
		age: 20,
	}
	fmt.Printf("匿名结构体的成员name：%v\n", p1.name)
	fmt.Printf("匿名结构体的成员age：%v\n", p1.age)
}

```


- 匿名成员

```go
package main

import "fmt"

type person struct {
	// 定义结构体
	string
	int
	float64
	bool
}

func main() {
	// 实例化结构体
	p := person{"Tim", 20, 171.1, true}
	// 访问匿名成员并输出
	fmt.Printf("结构体的匿名成员string的值：%v\n", p.string)
	fmt.Printf("结构体的匿名成员int的值：%v\n", p.int)
	fmt.Printf("结构体的匿名成员float64的值：%v\n", p.float64)
	fmt.Printf("结构体的匿名成员bool的值：%v\n", p.bool)
}

```




### 8.2 继承
结构体中内嵌匿名类型的方法来实现继承。


#### 结构体嵌套

```go
package main

import "fmt"

func main() {
	type cars struct {
		name  string
		price int
	}

	type person struct {
		name   string
		age    int
		cars   cars
		hourse struct {
			name  string
			price int
		}
	}

	c := cars{name: "BWM", price: 500000}
	p := person{name: "Tim", age: 30, cars: c}
	fmt.Printf("个人名称：%v\n", p.name)
	fmt.Printf("个人年龄：%v\n", p.age)
	fmt.Printf("个人拥有车辆：%v\n", p.cars.name)
	fmt.Printf("车辆价钱为：%v\n", p.cars.price)
}
```


```go
package main

import "fmt"

type Engine interface {
	Run()
	Stop()
}

type Bus struct {
	Engine
}

func (c *Bus) Working() {
	c.Run()
	c.Stop()
}

func (c *Bus) Run() {
	fmt.Println("running...........")
}

func (c *Bus) Stop() {
	fmt.Println("Stopping...........")
}

func main() {
	nEw_Name := new(Bus)
	nEw_Name.Run()
	nEw_Name.Stop()
}

```




### 8.3 多态
多态指不同对象中同种行为的不同实现方法，通过接口实现。

```go
package main

import "fmt"

// 现状接口
type Shape interface {
	Area() float32
}

// 正方形
type Square struct {
	sideLen float32
}

// 三角形
type Triangle struct {
	Bottom float32
	Height float32
}

// 正方形计算面积的方法
func (sq Square) Area() float32 {
	return sq.sideLen * sq.sideLen
}

// 三角形计算面积的方法
func (t Triangle) Area() float32 {
	return t.Bottom * t.Height
}

// 多态函数，传入接口根据接口实现相对于的方法
func Polymorphism(n Shape) float32 {
	return n.Area()
}

func main() {
	t := Triangle{6, 8}
	s := Square{8}

	shapes := []Shape{t, s}
	for n, _ := range shapes {
		fmt.Println("图形数据：", shapes[n])
		fmt.Println("面积：", shapes[n].Area())
	}

	fmt.Println()
	t1 := Polymorphism(t)
	s1 := Polymorphism(s)
	fmt.Println(t1)
	fmt.Println(s1)
}

```


```go

package main

import "fmt"

// 定义接口
type actions interface {
	speak(content string)
}

// 定义结构体
type duck struct {
	name string
}

type cat struct {
	name string
}

// 定义结构体方法
func (d *duck) speak(content string) {
	fmt.Printf("%v在说话：%v\n", d.name, content)
}

func (c *cat) speak(content string) {
	fmt.Printf("%v在说话：%v\n", c.name, content)
}

// 定义函数
func speaking(a actions, content string) {
	a.speak(content)
}

func main() {
	// 实例化结构体
	d := duck{name: "唐老鸭"}
	c := cat{name: "凯蒂猫"}
	// 调用函数
	speaking(&d, "嘎嘎")
	speaking(&c, "喵喵")
}

```

### 8.4 工厂函数

```go

package main

import "fmt"

// 定义接口
type actions interface {
	speak(content string)
}

// 定义结构体
type duck struct {
	name string
}

type cat struct {
	name string
}

// 定义结构体方法
func (d *duck) speak(content string) {
	fmt.Printf("%v在说话：%v\n", d.name, content)
}

func (c *cat) speak(content string) {
	fmt.Printf("%v在说话：%v\n", c.name, content)
}

// 定义工厂函数
func factory(name string) actions {
	switch name {
	case "duck":
		// 返回结构体duck实例化的内存地址
		return &duck{name: "唐老鸭"}
	case "cat":
		// 返回结构体cat实例化的内存地址
		return &cat{name: "凯蒂猫"}
	default:
		// 自主抛出异常
		panic("No such animal")
	}
}

func main() {
	// 调用工厂函数
	f1 := factory("duck")
	// 调用接口方法speak()
	f1.speak("嘎嘎嘎")
	// 调用工厂函数
	f2 := factory("cat")
	// 调用接口方法speak()
	f2.speak("喵喵喵")
}

```



### 8.5 实践-编程实现结构体与JSON互换


- JSON转结构体

```go
package main

import (
	"encoding/json"
	"fmt"
)

type person struct {
	// 定义结构体
	// 成员infos为切片，切片元素为结构体
	Infos []struct{
		Name string `json:"name"`
		Age int `json:"age"`
	} `json:"infos"`
}

func main() {
	// 定义字符串，用于记录JSON数据
	var j string
	j=`{"infos":[{"name":"Tom","age":15},{"name":"Lily","age":20}]}`
	// 实例化结构体
	var p person
	// 将JSON字符串转为结构体p
	json.Unmarshal([]byte(j),&p)
	// 遍历输出结构体成员Infos的值
	// 遍历切片，切片元素为结构体
	for _, value := range p.Infos{
		fmt.Printf("获取Infos的值，名字为：%v\n", value.Name)
		fmt.Printf("获取Infos的值，年龄为：%v\n", value.Age)
	}

}
```

- 结构体转JSON

```go
package main

import (
	"encoding/json"
	"fmt"
)

type person struct {
	// 定义结构体
	// 成员infos为切片，切片元素为结构体
	Infos []struct {
		Name string `json:"name"`
		Age  int    `json:"age"`
	} `json:"infos"`
}

func main() {
	// 定义结构体类型的切片，并赋值
	s := []struct {
		Name string `json:"name"`
		Age  int    `json:"age"`
	}{{Name: "Tom", Age: 15}, {Name: "Lily", Age: 20}}
	// 实例化结构体并赋值
	p := person{Infos: s}
	// 输出结构体p
	fmt.Printf("结构体p为：%v\n", p)
	// 将结构体p转换JSON字符串
	data, _ := json.Marshal(&p)
	// 输出JSON字符串
	fmt.Printf("JSON数据为：%v\n", string(data))
}
```



## 9.接口

### 9.1 接口定义
接口类型是对其他类型行为的概括与抽象，定义了零及以上个方法，但没具体实现这些方法。
接口本质上是指针类型，可以实现多态。



```
//接口定义格式
type 接口名称 interface {
	method1(参数列表) 返回值列表
	method2(参数列表) 返回值列表
	//...
	methodn(参数列表) 返回值列表
}
```


空接口（interface{}），无任何方法声明，类似面向对象中的根类型，c中的void*，默认值nil。

实现接口的类型支持相等运算，才能比较。


```go
var var1, var2 interface{}
fmt.Println(var1 == nil, var1 == var2)

var1, var2 = 66, 88
fmt.Println(var1 == var2)
```

```go
//比较map[string]interface{}
func CompareTwoMapInterface(data1 map[string]interface{}, data2 map[string]interface{}) bool {
	keySlice := make([]string, 0)
	dataSlice1 := make([]interface{}, 0)
	dataSlice2 := make([]interface{}, 0)
	for key, value := range data1 {
		keySlice = append(keySlice, key)
		dataSlice1 = append(dataSlice1, value)
	}
	for _, key := range keySlice {
		if data, ok := data2[key]; ok {
			dataSlice2 = append(dataSlice2, data)
		} else {
			return false
		}
	}
	dataStr1, _ := json.Marshal(dataSlice1)
	dataStr2, _ := json.Marshal(dataSlice2)

	return string(dataStr1) == string(dataStr2)
}
```

### 9.2 接口赋值
接口不支持直接实例化，但支持赋值操作。


#### 1.实现接口的对象实例赋值给接口
要求该对象实例实现了接口的所有方法。
```go
type Num int

func (x Num) Equal(i Num) bool {
	return x == i
}

func (x Num) LessThan(i Num) bool {
	return x < i
}

func (x Num) MoreThan(i Num) bool {
	return x > i
}

func (x *Num) Multiple(i Num) {
	*x = *x * i
}

func (x *Num) Divide(i Num) {
	*x = *x / i
}

type NumI interface {
	Equal(i Num) bool
	LessThan(i Num) bool
	MoreThan(i Num) bool
	Multiple(i Num)
	Divide(i Num)
}

//&Num实现NumI所有方法
//Num未实现NumI所有方法
var x Num = 8
var y NumI = &x

/*
Go语言会根据非指针成员方法，自动生成对应的指针成员方法
func (x Num) Equal(i Num) bool
func (x *Num) Equal(i Num) bool
*/


```



#### 2.一个接口赋值给另一个接口

两个接口拥有相同的方法列表（与顺序无关），则等同，可相互赋值。
```go
package oop1

type NumInterface1 interface {
	Equal(i int) bool
	LessThan(i int) bool
	BiggerThan(i int) bool
}

package oop2

type NumInterface2 interface {
	Equal(i int) bool
	BiggerThan(i int) bool
	LessThan(i int) bool
}

type Num int

//int不能改为Num
func (x Num) Equal(i int) bool {
	return int(x) == i
}

func (x Num) LessThan(i int) bool {
	return int(x) < i
}

func (x Num) BiggerThan(i int) bool {
	return int(x) > i
}

var f1 Num = 6
var f2 oop1.NumInterface1 = f1
var f3 oop2.NumInterface2 = f2

```

若接口A的方法列表是接口B的方法列表的子集，则接口B可以直接赋值给接口A。
```go
type NumInterface1 interface {
	Equal(i int) bool
	LessThan(i int) bool
	BiggerThan(i int) bool
}

type NumInterface2 interface {
	Equal(i int) bool
	BiggerThan(i int) bool
	LessThan(i int) bool
	Sum(i int)
}

type Num int

func (x Num) Equal(i int) bool {
	return int(x) == i
}

func (x Num) LessThan(i int) bool {
	return int(x) < i
}

func (x Num) BiggerThan(i int) bool {
	return int(x) > i
}

func (x *Num) Sum(i int) {
	*x = *x + Num(i)
}

var f1 Num = 6
var f2 NumInterface2 = &f1
var f3 NumInterface1 = f2


```


### 9.3 接口查询
程序运行时，询问接口指向的对象是否时某个类型。
```
var filewriter Write = ...
if filew, ok := filewriter.(*File); ok {
	//...
}

```



```go
slice := make([]int, 0)
slice = append(slice, 6, 7, 8)
var I interface{} = slice
if res, ok := I.([]int); ok {
	fmt.Println(res) //[6 7 8]
	fmt.Println(ok) //true
}

```


```go
func Len(array interface{}) int {
	var length int
	
	switch b := array.(type) {
	case nil:
		length = 0
	case []int:
		length = len(b)
	case []string:
		length = len(b)
	case []float32:
		length = len(b)
	default:
		length = 0
	}
	return length
}

```


### 9.4 接口组合
接口间通过嵌套创造出新接口。
```go
type Interface1 interface {
	Write(p []byte) (n int, err error)
}

type Interface2 interface {
	Close() error
}

type InterfaceCombine interface {
	Interface1
	Interface2
}
```


### 9.5 接口应用

#### 1.类型推断
类型推断可将接口还原为原始类型，或用来判断是否实现了某种更具体的接口类型。

```go
package main

import "fmt"

func main() {
	var a interface{} = func(a int) string {
		rteurn fmt.Sprintf("d:%d", a)
	}
	
	switch b := a.(type) {
	case nil:
		fmt.Println("nil")
	case *int:
		fmt.Println(*b)
	case func(int) string:
		fmt.Println(b(66))
	case fmt.Stringer:
		fmt.Println(b)
	default:
		fmt.Println("unknown")
	}
}

```


#### 2.实现多态功能
```go
package main

import "fmt"

type Message interface {
	sending()
}

type User struct {
	name string
	phone string
}

func (u *User) sending() {
	fmt.Printf("Sending user phone to %s<%s>\n", u.name, u.phone)
}

type admin struct {
	name string
	phone string
}

func (a *admin) sending() {
	fmt.Printf("Sending admin phone to %s<%s>\n", a.name, a.phone)
}

func main() {
	bill := User{"Barry", "barry@gmail.com"}
	sendMessage(&bill)
	
	lisa := admin{"Barry", "barry@gmail.com"}
	sendMessage(&lisa)
}

func sendMessage(n Message) {
	n.sending()
}

```


## 10.反射


### 10.1 反射的定义
反射指，编译时不知道变量的具体类型，运行时（Run time）可以访问、检测和修改状态或行为的能力。

reflect包定义了接口和结构体，获取类型信息。

- reflect.Type接口提供类型信息
- reflect.Value结构体提供值相关信息，可以获取甚至改变类型的值


```
func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value
```


### 10.2 反射的三大法则

#### 1.接口类型变量转换为反射类型对象
```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var x float64 = 3.4
	fmt.Println("type:", reflect.TypeOf(x))
	fmt.Println("value:", reflect.ValueOf(x))
	
	v := reflect.ValueOf(x)
	fmt.Println("type:", v.Type())
	fmt.Println("kind is float64:", v.Kind() == reflect.Float64)
	fmt.Println("value:", v.Float())
}
//输出
//type: float64
//value: 3.4
//kind is float64: true
//type: float64
//value: 3.4

```


#### 2.反射类型对象转换为接口类型变量
```go
func (v Value) Interface() interface{}
y := v.Interface().(float64)
fmt.Println(y)
```


```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var name interface{} = "shirdon"
	fmt.Printf("原始接口变量类型为%T，值为%v\n", name, name)
	
	t := reflect.TypeOf(name)
	v := reflect.ValueOf(name)
	fmt.Printf("Type类型为%T，值为%v\n", t, t)
	fmt.Printf("Value类型为%T，值为%v\n", v, v)
	
	i := v.Interface()
	fmt.Printf("新对象interface{}类型为%T，值为%v\n", i, i)
}
//输出
//原始接口变量类型为string，值为shirdon
//Type类型为*reflect.rtype，值为string
//Value类型为reflect.Value，值为shirdon
//新对象interface{}类型为string，值为shirdon


```


#### 3.修改反射类型对象，其值必须是可写的（settable）

reflect.TypeOf()和reflect.ValueOf()函数中若传递的不是指针，则只是变量复制，对该反射对象修改，不会影响原始变量。
反射对象可写性要点:

- 变量指针创建的反射对象
- CanSet()可判断
- Elem()返回指针指向的数据


```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var name string = "shirdon"
	//var name int = 12
	
	v1 := reflect.ValueOf(&name)
	v2 := v1.Elem()
	fmt.Println("可写性:", v1.CanSet())
	fmt.Println("可写性:", v2.CanSet())
}

//输出
//可写性：false
//可写性：true

```




```
func (v Value) SetBool(x bool)
func (v Value) SetBytes(x []byte)
func (v Value) SetFloat(x float64)
func (v Value) SetInt(x int64)
func (v Value) SetString(x string)
```


```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var name string = "shirdon"
	fmt.Println("name原始值:", name)
	
	v1 := reflect.ValueOf(&name)
	v2 := v1.Elem()
	
	v2.SetString("yx")
	fmt.Println("反射对象修改后，name值:", name)
}

//输出
//name原始值: shirdon
//反射对象修改后，name值: yx


```

## 11.goroutine

在Go语言中，每一个并发执行的活动叫goroutine。使用go 关键字可创建goroutine。形式如下：

```go
go func_name()
```

先将go关键字声明放到一个需要调用的函数之前，然后在相同地址空间调用运行这个函数，这样该函数执行时便会作为一个独立的并发线程。
这种线程在Go语言中则被称为goroutine。


goroutine的使用示例如下：

```go
package main

import (
	"fmt"
	"time"
)

func HelloWorld() {
	fmt.Println("this is a goroutine msg")
}

func main() {
	go HelloWorld()
	time.Sleep(1 * time.Second)
	fmt.Println("end")
}

```
goroutine在多核CPU环境下是并行的。如果代码块在多个goroutine中执行，则实现了代码的并行。

goroutine是Go语言最重要的特性之一，同时也是一个难点。




## 12.单元测试(go test)


Go语言在设计之初就考虑到了代码的可测试性。


Go语言提供了testing库用于单元测试，go test是Go语言的程序测试工具。

在目录下，它以*\_test.go的文件形式存在，且go build不会将其编译成为构建的一部分。




```go
//sum.go
package testexample

func Min(arr []int) (min int) { //获取整型数组中的最小值
	min = arr[0]
	for _, v := range arr {
		if v < min {
			min = v
		}
	}
	return
}

// Hello ...
func Hello() string {
	return "Hello World"
}

// world ...
func world() string {
	return "world"
}


// Add ...
func Add(v1 int, v2 int) int {
	return v1 + v2
}

// FloatToString ...
func FloatToString(f1 float64, f2 float64) string {
	return strconv.FormatFloat(f1/f2*100, 'f', 2, 32) + "%"
}


```

```go
//sum_test.go
package testexample

import (
	"fmt"
	"testing"
)

func TestMin(t *testing.T) {
	array := []int{6, 8, 10}
	ret := Min(array)
	fmt.Println(ret)
}

func TestHello(t *testing.T) {
	result := Hello()
	want := "Hello World"
	if result == want {
		t.Logf("Hello() = %v, want %v", result, want)
	} else {
		t.Errorf("Hello() = %v, want %v", result, want)
	}

	want2 := "Hello World"
	if result == want2 {
		t.Logf("Hello() = %v, want %v", result, want)
	} else {
		t.Errorf("Hello() = %v, want %v", result, want)
	}

}

func testHello(expected string) func(t *testing.T) {
	return func(t *testing.T) {
		if expected == "Hello World" {
			t.Logf("Hello() = %v, want = %v", expected, "Hello World")
		} else {
			t.Errorf("Hello() = %v, want = %v", expected, "Hello World")
		}
	}

}

func TestHello2(t *testing.T) {
	t.Run("test for hello with run", testHello(Hello()))
}



func TestHelloWithTable(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		// TODO: Add test cases.
		{
			name: "test for hello",
			want: "Hello World",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := Hello(); got != tt.want {
				t.Errorf("Hello() = %v, want %v", got, tt.want)
			}
		})
	}

}

func ExampleHello() {
	fmt.Println(Hello())
	// Output:
	// Hello World
}

func TestMain(m *testing.M) {
	fmt.Println("Before ====================")
	code := m.Run()
	fmt.Println("End ====================")
	os.Exit(code)
}

func Test_world(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		// TODO: Add test cases.
		{},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := world(); got != tt.want {
				t.Logf("world() = %v, want %v", got, tt.want)
			}
		})
	}
}


func TestAdd(t *testing.T) {
	type args struct {
		v1 int
		v2 int
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		// TODO: Add test cases.
		{
			name: "Add",
			args: args{1, 2},
			want: 3,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := Add(tt.args.v1, tt.args.v2); got != tt.want {
				t.Errorf("Add() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestFloatToString(t *testing.T) {
	type args struct {
		f1 float64
		f2 float64
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		// TODO: Add test cases.
		{
			name: "float to string",
			args: args{1.0, 3.0},
			want: "33.33%",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := FloatToString(tt.args.f1, tt.args.f2); got != tt.want {
				t.Errorf("FloatToString() = %v, want %v", got, tt.want)
			}
		})
	}
}


func ExampleAdd() {
	fmt.Println(Add(100, 200))
	// Output:
	// 300
}

```


注意，文件名必须是name_test.go格式，测试函数名称必须以Test开头，传入参数必须是*testing.T。

格式如下： 

```go
func TestName(t *testing.T){
  //...
}
```



运行测试程序

```sh
# 执行整个项目测试文件
go test



# 查看详细运行结果
go test -v




# 参数run对应一个正则表达式，匹配的函数才会被"go test"命令运行。

go test -v -run="Test"
```


"go test"命令还可以从主体中分离出来生成独立的测试二进制文件，因为"go test"命令中包含了编译动作，所以它可以接受可用于"go build"命令的所有参数。

"go test"命令常见参数的作用见表1-5。


|参数|	作用|
|-----|-----|
|-v|	打印每个测试函数的名字和运行时间|
|-c|	生成测试可执行文件，但不执行，默认命名pkg.test|
|-i|	重新安装运行测试依赖包，但不编译和运行测试代码|
|-o|	指定生成测试可执行文件的名称|


例如，生成用于测试的二进制可执行文件： 

```bash
go test -c 
```

运行“go test”命令生成指定名字的二进制可执行文件的示例如下。 

```bash
go test -v -o testexample.test
```

运行命令后，会在项目所在目录生成一个名为testexample.test的文件。



## 13. Go编译与工具

### 13.1 编译(go build)

Go语言中"go build"命令主要用于编译代码。

在包的编译过程中，若有必要，则会同时编译与之相关联的包。“go build'”命令有很多种编译方法，如无参数编译、文件列表编译、指定包编译等，使用这些
方法都可以输出可执行文件。


**注意：在windows中，可执行文件后缀为.exe文件，Linux中无后缀。**


#### 1. 无参数编译

```go
//build
//----main.go
//----utils.go

//main.go
package main

import (
	"fmt"
)

func main() {
	printString()
	fmt.Println("go build")
}
```

```go
//utils.go
package main

import "fmt"

func printString() {
	fmt.Println("test")
}

```

```bash
cd build
go build
# 运行以上命令，文件夹会生成一个build的文件，windows中为build.exe

$ ./build 
this is a go build test call!
I love go build!
```




#### 2. 文件列表编译

在编译同一个目录下的多个源码文件时，可以在“go build”命令的后面加上多个文件名。

“go build'”命令会编译这些源码，输出可执行文件。

“go build-+文件列表”的格式如下： 

```bash
go build filel.go file2.go......
```
例如，在代码所在根目录（chapter1/build)中运行“go build'”命令，在“go build”命令后添加要编译的源码的文件名，代码如下：

```bash
go build main.go utils.go
```
在Linux中运行以上命令后，该目录下有如下文件：build、utils.go、main、main.go。

在使用“go buid+文件列表”方式编译时，**可执行文件默认选择文件列表中第1个源码文件将作为可执行文件名输出。**


如果需要指定输出可执行文件名，则需要使用-o参数，示例如下：
```bash
go build main.go utils.go
# 运行以上命令，文件夹会生成一个main的文件，windows中为main.exe

go build -o file main.go utils.go
$ ./file 
this is a go build test call!
I love go build!
```
在上面的示例中，在“go build”和文件列表中，插入了一个-o file参数，表示指定输出文件名为file。


> 注意：
> 使在用“go build+文件列表”.编译方式编译时，文件列表中的每个文件必须是同一个包的Go源码。即不能像C++那样将所有工程的Go源码使用文件列表方式进行编译。
> 在编译复杂工程时需要采用“指定包编译”的方式


#### 3. 指定包编译 
“go build + 文件列表”的方式适合编译少量文件的情景。

而"go build + 包"在设置GOPATH之后，可以直接根据包名进行编译，即使包内文件被增加或者删除也不影响编译指令。


新建一个项目，代码目录结构关系如下：
```bash
├── build
  ├── pkg
  │   ├── buildpkg.go
  │   ├── mainpkg.go
  │   └── pkg
```


```go
//pkg
//----mainpkg.go
//----buildpkg.go

//mainpkg.go
package main

import (
	"fmt"
	"pkg"
)

func main() {
	pkg.CallFunc()
	fmt.Println("go build")
}

//buildpkg.go
package pkg

import "fmt"

func CallFunc() {
	fmt.Println("test")
}
//go build .../pkg
```



#### 4. 交叉编译

(1) 创建一个名为compole.go的文件
```go
//compile.go
package main

import (
	"fmt"
)

func main() {
	fmt.Println("go build")
}

```


(2) 如果Mac OS X系统中编译64位的可执行文件，为了让它能够在Linux系统中也可以执行，则编译命令如下：


```sh
CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build compile.go
```

通过上面的这段代码可以生成64位的，能够在Linux系统中可执行的文件，这里用到了2个变量。

- CGO_ENABLED: 是否使用C语言的Go编译器；0关闭，1开启
- GOOS：目标操作系统
- GOARCH：目标操作系统的架构




如果要编译其他平台中可执行的文件，  根据如下表执行编译即可。

|系统编译参数|	架构 |
|----------|--------|
|linux(>=Linux 2.6)|	386/amd64/arm|
|darwin(OS X(Snow Lepoard + Lion))|	386/amd64|
|freebsd(>=FreeBSD 7)|	386/amd64|
|windows(>=Windows 2000)|386/amd64|


通过下面的编译命令，可以生成在windows系统中可以执行的文件：
```sh
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build compile.go
```

> 提示：
> 
1.5版本之后，Go语言就开始使用“用Go语言编写的编译器”进行编译。
**在Go语言1.9及以后的版本中，如果不使用CGO ENABLED参数，依然可以正常编译。**
当然使用了也可以正常编译。比如把CGO ENABLED参数设置成1（即在编译的过程当中使用CGO编译器），依然是可以正常编译的。


实际上，如果在Go中使用了C语言的库，则默认在使用“go build'”命令时就会启动CGO编译器。当然，也可以使用CGO_ENABLED来控制“go build”命令是否使用CGO编译器。


#### 5. 编译时的附加参数

|附加参数	|作用|
|------|------|
|-v	|编译时显示包名|
|-p n	|开启并发编译，默认值为CPU逻辑核数|
|-a	|强制重新构建|
|-n	|打印编译时会用到的所有命令，但不真正执行|
|-x	|打印编译时会用到的所有命令|
|-race	|开启竞态检测|



### 13.2 编译后运行(go run)

Go语言虽然不使用虚拟机，但可以使用"go run"命令达到同样的效果，

编译后直接运行main()函数，且不保留可执行文件。

```go
//hello.go
package main

import (
	"fmt"
)

func main() {
	fmt.Println("go run")
}

//go run hello.go
```


"go run"命令不会在运行目录下生成任何文件，可执行文件被放在临时文件中被执行，工作目录被设置为当前目录，"go run"命令后边可以添加参数，这部分参数可以
作为代码可以接受的命令行输入提供给程序。


"go run"命令不能采用"go run+包"的方式进行编译。

如果需快速编译运行包，则应采用如下步骤来代替：


1. 使用"go build"命令生成可执行文件。
2. 运行可执行文件。




### 13.3 编译并安装(go install)

类似go build，只是编译中间文件放在$GOPATH/pkg目录下，编译结果放在$GOPATH/bin目录下。


"go install"命令的输出目录始终为$GOPATH下的bin目录，无法使用-o附加参数进行自定义。$GOPATH下的pkg目录放置的是编译期间的中间文件。



项目代码相对于项目的根目录层级关系如下：

```sh
install
|----main.go
|----pkg
    |----installpkg.go
```

```go
//main.go
package main

import (
	"fmt"
	"pkg"
)

func main() {
	pkg.CallFunc()
	fmt.Println("go build")
}

//installpkg.go
package pkg

import "fmt"

func CallFunc() {
	fmt.Println("test")
}
//go install
```




### 13.4 获取代码(go get)

动态远程拉取或更新代码包及其依赖包，自动完成编译和安装。整个过程就行手机中安装一个APP一样简单。

需要安装Git，SVN，HG等。


|标记名称|	标记描述|
|-------|---------|
|-d	|只下载，不安装|
|-f	|使用-u时才有效，忽略对已下载代码包导入路径的检查。适用于从别人处Fork代码包|
|-fix	|下载代码包后先修正，然后编译和安装|
|-insecure	|运行非安全scheme(如HTTP)下载代码包。|
|-t	|同时下载测试源码文件中的依赖代码包|
|-u	|更新已有代码包及其依赖包|


"go get"命令的使用方法如下：


```sh
go get -u github.com/shirdon1/TP-Link-HS110
```

运行完成后即可下载并进行编译和安装。


使用go get xxx指令下载第三方包，比如下载MySQL数据库操作包，输入

```sh
go get github.com/go-sql-driver/mysql
```
即可下载，第三方包下载后将会存放在GOPATH的pkg文件夹。


在项目中执行go get命令可以下载依赖包，并且还可以指定下载的版本。

- 运行go get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)
- 运行go get -u=patch将会升级到最新的修订版本
- 运行go get package@version将会升级到指定的版本号version


**如果下载所有依赖可以使用go mod download命令。**




## 14. 包

### 1. 代码
项目代码相对于项目的根目录层级关系如下：

```go
tree
.
├── go.mod
├── main.go
└── mathop
    └── multi.go
```

mathop/multi.go

```go
package mathop

// 此处Multi函数，开头M要大写，否则外部不可访问它
func Multi(num1 int, num2 int) int {
	return num1 * num2
}
```



main.go

```go
package main

import "fmt"

// 注意在引用本地包的定位格式
import "pkg/mathop"

func main() {
	fmt.Println(mathop.Multi(8, 9)) // 72
}
```

### 2. 输出

```sh
$ go run main.go
72
```



### 3. 解释

Go语言用包来组织源代码的，实现命名空间管理，任何一个Go语言的程序必须属于一个包，即每个Go语言程序的开头必须写上package <包名>。

Go语言的包一般需要满足3个条件：

1. 同一个目录下同级的所有Go语言文件应该属于同一个包。
2. 包的名称可以跟目录不同，不过建议同名。
3. 一个Go语言程序有且只有一个main函数，它是Go语言的入口函数，且必须属于main包，没有或者多余一个Go语言编译时都会报错。


如果要在一个包里面引用另外一个包的标识符(如变量、常量、类型或函数等)，该标识符必须是对外可见的(public)。在Go语言中只需要将标识符首字母大写就能
让标识符对外可见了。


要在代码中引用其他包的内容，需要使用import关键字导入使用的包，具体方法如下：


```go
import "包的路径"
```


## 15. Go项目结构


参考：https://github.com/golang-standards/project-layout


[Go项目结构](https://www.yuque.com/jw-go/rieow9/tecvmk)

